/* eslint-disable */
/*
 @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */
!(function (a, b) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = b())
    : 'function' == typeof define && define.amd
    ? define(b)
    : ((a = 'undefined' != typeof globalThis ? globalThis : a || self).DOMPurify = b());
})(this, function () {
  function a(b) {
    return (a =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
        ? function (a) {
            return typeof a;
          }
        : function (a) {
            return a && 'function' == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype
              ? 'symbol'
              : typeof a;
          })(b);
  }
  function b(a, c) {
    return (b =
      Object.setPrototypeOf ||
      function (a, b) {
        return (a.__proto__ = b), a;
      })(a, c);
  }
  function c() {
    if ('undefined' == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
    if ('function' == typeof Proxy) return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
    } catch (Ca) {
      return !1;
    }
  }
  function d(a, e, f) {
    return (d = c()
      ? Reflect.construct
      : function (a, c, d) {
          var e = [null];
          e.push.apply(e, c);
          a = new (Function.bind.apply(a, e))();
          return d && b(a, d.prototype), a;
        }).apply(null, arguments);
  }
  function e(a) {
    var b;
    (b = (function (a) {
      if (Array.isArray(a)) return f(a);
    })(a)) ||
      (b =
        ('undefined' != typeof Symbol && null != a[Symbol.iterator]) || null != a['@@iterator']
          ? Array.from(a)
          : void 0);
    if (
      !(a =
        b ||
        (function (a, b) {
          if (a) {
            if ('string' == typeof a) return f(a, b);
            var c = Object.prototype.toString.call(a).slice(8, -1);
            'Object' === c && a.constructor && (c = a.constructor.name);
            if ('Map' === c || 'Set' === c) return Array.from(a);
            if ('Arguments' === c || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return f(a, b);
          }
        })(a))
    )
      throw new TypeError(
        'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
      );
    return a;
  }
  function f(a, b) {
    (null == b || b > a.length) && (b = a.length);
    for (var c = 0, d = Array(b); c < b; c++) d[c] = a[c];
    return d;
  }
  function g(a) {
    return function (b) {
      for (var c = arguments.length, d = Array(1 < c ? c - 1 : 0), e = 1; e < c; e++) d[e - 1] = arguments[e];
      return B(a, b, d);
    };
  }
  function k(a, b) {
    n && n(a, null);
    for (var c = b.length; c--; ) {
      var d = b[c];
      if ('string' == typeof d) {
        var e = T(d);
        e !== d && (p(b) || (b[c] = e), (d = e));
      }
      a[d] = !0;
    }
    return a;
  }
  function h(a) {
    var b,
      c = z(null);
    for (b in a) B(m, a, [b]) && (c[b] = a[b]);
    return c;
  }
  function l(a, b) {
    for (; null !== a; ) {
      var c = t(a, b);
      if (c) {
        if (c.get) return g(c.get);
        if ('function' == typeof c.value) return g(c.value);
      }
      a = r(a);
    }
    return function (a) {
      return console.warn('fallback value for', a), null;
    };
  }
  var m = Object.hasOwnProperty,
    n = Object.setPrototypeOf,
    p = Object.isFrozen,
    r = Object.getPrototypeOf,
    t = Object.getOwnPropertyDescriptor,
    u = Object.freeze,
    x = Object.seal,
    z = Object.create,
    D = 'undefined' != typeof Reflect && Reflect,
    B = D.apply,
    C = D.construct;
  B ||
    (B = function (a, b, c) {
      return a.apply(b, c);
    });
  u ||
    (u = function (a) {
      return a;
    });
  x ||
    (x = function (a) {
      return a;
    });
  C ||
    (C = function (a, b) {
      return d(a, e(b));
    });
  var J,
    v = g(Array.prototype.forEach),
    K = g(Array.prototype.pop),
    O = g(Array.prototype.push),
    T = g(String.prototype.toLowerCase),
    M = g(String.prototype.match),
    U = g(String.prototype.replace),
    da = g(String.prototype.indexOf),
    ha = g(String.prototype.trim),
    Y = g(RegExp.prototype.test),
    P =
      ((J = TypeError),
      function () {
        for (var a = arguments.length, b = Array(a), c = 0; c < a; c++) b[c] = arguments[c];
        return C(J, b);
      }),
    Oa = u(
      'a abbr acronym address area article aside audio b bdi bdo big blink blockquote body br button canvas caption center cite code col colgroup content data datalist dd decorator del details dfn dialog dir div dl dt element em fieldset figcaption figure font footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i img input ins kbd label legend li main map mark marquee menu menuitem meter nav nobr ol optgroup option output p picture pre progress q rp rt ruby s samp section select shadow small source spacer span strike strong style sub summary sup table tbody td template textarea tfoot th thead time tr track tt u ul var video wbr'.split(
        ' '
      )
    ),
    Da = u(
      'svg a altglyph altglyphdef altglyphitem animatecolor animatemotion animatetransform circle clippath defs desc ellipse filter font g glyph glyphref hkern image line lineargradient marker mask metadata mpath path pattern polygon polyline radialgradient rect stop style switch symbol text textpath title tref tspan view vkern'.split(
        ' '
      )
    ),
    Pa = u(
      'feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence'.split(
        ' '
      )
    ),
    Wa = u(
      'animate color-profile cursor discard fedropshadow font-face font-face-format font-face-name font-face-src font-face-uri foreignobject hatch hatchpath mesh meshgradient meshpatch meshrow missing-glyph script set solidcolor unknown use'.split(
        ' '
      )
    ),
    Ea = u(
      'math menclose merror mfenced mfrac mglyph mi mlabeledtr mmultiscripts mn mo mover mpadded mphantom mroot mrow ms mspace msqrt mstyle msub msup msubsup mtable mtd mtext mtr munder munderover'.split(
        ' '
      )
    ),
    qa = u(
      'maction maligngroup malignmark mlongdiv mscarries mscarry msgroup mstack msline msrow semantics annotation annotation-xml mprescripts none'.split(
        ' '
      )
    ),
    ia = u(['#text']),
    Ka = u(
      'accept action align alt autocapitalize autocomplete autopictureinpicture autoplay background bgcolor border capture cellpadding cellspacing checked cite class clear color cols colspan controls controlslist coords crossorigin datetime decoding default dir disabled disablepictureinpicture disableremoteplayback download draggable enctype enterkeyhint face for headers height hidden high href hreflang id inputmode integrity ismap kind label lang list loading loop low max maxlength media method min minlength multiple muted name nonce noshade novalidate nowrap open optimum pattern placeholder playsinline poster preload pubdate radiogroup readonly rel required rev reversed role rows rowspan spellcheck scope selected shape size sizes span srclang start src srcset step style summary tabindex title translate type usemap valign value width xmlns slot'.split(
        ' '
      )
    ),
    ua = u(
      'accent-height accumulate additive alignment-baseline ascent attributename attributetype azimuth basefrequency baseline-shift begin bias by class clip clippathunits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering cx cy d dx dy diffuseconstant direction display divisor dur edgemode elevation end fill fill-opacity fill-rule filter filterunits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight fx fy g1 g2 glyph-name glyphref gradientunits gradienttransform height href id image-rendering in in2 k k1 k2 k3 k4 kerning keypoints keysplines keytimes lang lengthadjust letter-spacing kernelmatrix kernelunitlength lighting-color local marker-end marker-mid marker-start markerheight markerunits markerwidth maskcontentunits maskunits max mask media method mode min name numoctaves offset operator opacity order orient orientation origin overflow paint-order path pathlength patterncontentunits patterntransform patternunits points preservealpha preserveaspectratio primitiveunits r rx ry radius refx refy repeatcount repeatdur restart result rotate scale seed shape-rendering specularconstant specularexponent spreadmethod startoffset stddeviation stitchtiles stop-color stop-opacity stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke stroke-width style surfacescale systemlanguage tabindex targetx targety transform transform-origin text-anchor text-decoration text-rendering textlength type u1 u2 unicode values viewbox visibility version vert-adv-y vert-origin-x vert-origin-y width word-spacing wrap writing-mode xchannelselector ychannelselector x x1 x2 xmlns y y1 y2 z zoomandpan'.split(
        ' '
      )
    ),
    Xa = u(
      'accent accentunder align bevelled close columnsalign columnlines columnspan denomalign depth dir display displaystyle encoding fence frame height href id largeop length linethickness lspace lquote mathbackground mathcolor mathsize mathvariant maxsize minsize movablelimits notation numalign open rowalign rowlines rowspacing rowspan rspace rquote scriptlevel scriptminsize scriptsizemultiplier selection separator separators stretchy subscriptshift supscriptshift symmetric voffset width xmlns'.split(
        ' '
      )
    ),
    Z = u(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']),
    ea = x(/\{\{[\s\S]*|[\s\S]*\}\}/gm),
    L = x(/<%[\s\S]*|[\s\S]*%>/gm),
    db = x(/^data-[\-\w.\u00B7-\uFFFF]/),
    sa = x(/^aria-[\-\w]+$/),
    eb = x(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
    ta = x(/^(?:\w+script|data):/i),
    Fa = x(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
    La = x(/^html$/i),
    la = function (b, c) {
      if ('object' !== a(b) || 'function' != typeof b.createPolicy) return null;
      var d = null;
      c.currentScript &&
        c.currentScript.hasAttribute('data-tt-policy-suffix') &&
        (d = c.currentScript.getAttribute('data-tt-policy-suffix'));
      d = 'dompurify' + (d ? '#' + d : '');
      try {
        return b.createPolicy(d, {
          createHTML: function (a) {
            return a;
          },
        });
      } catch (ba) {
        return console.warn('TrustedTypes policy ' + d + ' could not be created.'), null;
      }
    };
  return (function pa() {
    var b =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 'undefined' == typeof window ? null : window,
      c = function (a) {
        return pa(a);
      };
    if (((c.version = '2.3.6'), (c.removed = []), !b || !b.document || 9 !== b.document.nodeType))
      return (c.isSupported = !1), c;
    var d = b.document,
      f = b.document,
      g = b.DocumentFragment,
      m = b.HTMLTemplateElement,
      n = b.Node,
      p = b.Element,
      r = b.NodeFilter,
      t = b.NamedNodeMap,
      x = void 0 === t ? b.NamedNodeMap || b.MozNamedAttrMap : t,
      C = b.HTMLFormElement,
      z = b.DOMParser,
      t = b.trustedTypes,
      B = p.prototype,
      D = l(B, 'cloneNode'),
      J = l(B, 'nextSibling'),
      fa = l(B, 'childNodes'),
      S = l(B, 'parentNode');
    'function' == typeof m &&
      ((m = f.createElement('template')), m.content && m.content.ownerDocument && (f = m.content.ownerDocument));
    var ma = la(t, d),
      R = ma ? ma.createHTML('') : '',
      m = f,
      ra = m.implementation,
      ib = m.createNodeIterator,
      Ta = m.createDocumentFragment,
      za = m.getElementsByTagName,
      tb = d.importNode,
      m = {};
    try {
      m = h(f).documentMode ? f.documentMode : {};
    } catch (Jb) {}
    var Aa = {};
    c.isSupported = 'function' == typeof S && ra && void 0 !== ra.createHTMLDocument && 9 !== m;
    var ab,
      Ba,
      jb = eb,
      ga = null,
      kb = k({}, [].concat(e(Oa), e(Da), e(Pa), e(Ea), e(ia))),
      aa = null,
      Ha = k({}, [].concat(e(Ka), e(ua), e(Xa), e(Z))),
      ca = Object.seal(
        Object.create(null, {
          tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 },
        })
      ),
      Ua = null,
      Ya = null,
      pb = !0,
      Za = !0,
      Ia = !1,
      W = !1,
      va = !1,
      qb = !1,
      bb = !1,
      Na = !1,
      fb = !1,
      gb = !1,
      ub = !0,
      q = !0,
      w = !1,
      y = {},
      A = null,
      G = k(
        {},
        'annotation-xml audio colgroup desc foreignobject head iframe math mi mn mo ms mtext noembed noframes noscript plaintext script style svg template thead title video xmp'.split(
          ' '
        )
      ),
      H = null,
      oa = k({}, 'audio video img source image track'.split(' ')),
      xa = null,
      ka = k({}, 'alt class for id label name pattern placeholder role summary title value style xmlns'.split(' ')),
      wa = 'http://www.w3.org/1999/xhtml',
      lb = !1,
      Db = ['application/xhtml+xml', 'text/html'],
      mb = null,
      Eb = f.createElement('form'),
      yb = function (a) {
        return a instanceof RegExp || a instanceof Function;
      },
      rb = function (b) {
        (mb && mb === b) ||
          ((b && 'object' === a(b)) || (b = {}),
          (b = h(b)),
          (ga = 'ALLOWED_TAGS' in b ? k({}, b.ALLOWED_TAGS) : kb),
          (aa = 'ALLOWED_ATTR' in b ? k({}, b.ALLOWED_ATTR) : Ha),
          (xa = 'ADD_URI_SAFE_ATTR' in b ? k(h(ka), b.ADD_URI_SAFE_ATTR) : ka),
          (H = 'ADD_DATA_URI_TAGS' in b ? k(h(oa), b.ADD_DATA_URI_TAGS) : oa),
          (A = 'FORBID_CONTENTS' in b ? k({}, b.FORBID_CONTENTS) : G),
          (Ua = 'FORBID_TAGS' in b ? k({}, b.FORBID_TAGS) : {}),
          (Ya = 'FORBID_ATTR' in b ? k({}, b.FORBID_ATTR) : {}),
          (y = 'USE_PROFILES' in b && b.USE_PROFILES),
          (pb = !1 !== b.ALLOW_ARIA_ATTR),
          (Za = !1 !== b.ALLOW_DATA_ATTR),
          (Ia = b.ALLOW_UNKNOWN_PROTOCOLS || !1),
          (W = b.SAFE_FOR_TEMPLATES || !1),
          (va = b.WHOLE_DOCUMENT || !1),
          (Na = b.RETURN_DOM || !1),
          (fb = b.RETURN_DOM_FRAGMENT || !1),
          (gb = b.RETURN_TRUSTED_TYPE || !1),
          (bb = b.FORCE_BODY || !1),
          (ub = !1 !== b.SANITIZE_DOM),
          (q = !1 !== b.KEEP_CONTENT),
          (w = b.IN_PLACE || !1),
          (jb = b.ALLOWED_URI_REGEXP || jb),
          (wa = b.NAMESPACE || 'http://www.w3.org/1999/xhtml'),
          b.CUSTOM_ELEMENT_HANDLING &&
            yb(b.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
            (ca.tagNameCheck = b.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
          b.CUSTOM_ELEMENT_HANDLING &&
            yb(b.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
            (ca.attributeNameCheck = b.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
          b.CUSTOM_ELEMENT_HANDLING &&
            'boolean' == typeof b.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&
            (ca.allowCustomizedBuiltInElements = b.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
          (ab = ab = -1 === Db.indexOf(b.PARSER_MEDIA_TYPE) ? 'text/html' : b.PARSER_MEDIA_TYPE),
          (Ba =
            'application/xhtml+xml' === ab
              ? function (a) {
                  return a;
                }
              : T),
          W && (Za = !1),
          fb && (Na = !0),
          y &&
            ((ga = k({}, e(ia))),
            (aa = []),
            !0 === y.html && (k(ga, Oa), k(aa, Ka)),
            !0 === y.svg && (k(ga, Da), k(aa, ua), k(aa, Z)),
            !0 === y.svgFilters && (k(ga, Pa), k(aa, ua), k(aa, Z)),
            !0 === y.mathMl && (k(ga, Ea), k(aa, Xa), k(aa, Z))),
          b.ADD_TAGS && (ga === kb && (ga = h(ga)), k(ga, b.ADD_TAGS)),
          b.ADD_ATTR && (aa === Ha && (aa = h(aa)), k(aa, b.ADD_ATTR)),
          b.ADD_URI_SAFE_ATTR && k(xa, b.ADD_URI_SAFE_ATTR),
          b.FORBID_CONTENTS && (A === G && (A = h(A)), k(A, b.FORBID_CONTENTS)),
          q && (ga['#text'] = !0),
          va && k(ga, ['html', 'head', 'body']),
          ga.table && (k(ga, ['tbody']), delete Ua.tbody),
          u && u(b),
          (mb = b));
      },
      vb = k({}, ['mi', 'mo', 'mn', 'ms', 'mtext']),
      na = k({}, ['foreignobject', 'desc', 'title', 'annotation-xml']),
      sb = k({}, Da);
    k(sb, Pa);
    k(sb, Wa);
    var wb = k({}, Ea);
    k(wb, qa);
    var Fb = function (a) {
        var b = S(a);
        (b && b.tagName) || (b = { namespaceURI: 'http://www.w3.org/1999/xhtml', tagName: 'template' });
        var c = T(a.tagName),
          d = T(b.tagName);
        if ('http://www.w3.org/2000/svg' === a.namespaceURI)
          return 'http://www.w3.org/1999/xhtml' === b.namespaceURI
            ? 'svg' === c
            : 'http://www.w3.org/1998/Math/MathML' === b.namespaceURI
            ? 'svg' === c && ('annotation-xml' === d || vb[d])
            : !!sb[c];
        if ('http://www.w3.org/1998/Math/MathML' === a.namespaceURI)
          return 'http://www.w3.org/1999/xhtml' === b.namespaceURI
            ? 'math' === c
            : 'http://www.w3.org/2000/svg' === b.namespaceURI
            ? 'math' === c && na[d]
            : !!wb[c];
        if ('http://www.w3.org/1999/xhtml' === a.namespaceURI) {
          if (
            ('http://www.w3.org/2000/svg' === b.namespaceURI && !na[d]) ||
            ('http://www.w3.org/1998/Math/MathML' === b.namespaceURI && !vb[d])
          )
            return !1;
          a = k({}, ['title', 'style', 'font', 'a', 'script']);
          return !wb[c] && (a[c] || !sb[c]);
        }
        return !1;
      },
      cb = function (a) {
        O(c.removed, { element: a });
        try {
          a.parentNode.removeChild(a);
        } catch (zb) {
          try {
            a.outerHTML = R;
          } catch (Ab) {
            a.remove();
          }
        }
      },
      Bb = function (a, b) {
        try {
          O(c.removed, { attribute: b.getAttributeNode(a), from: b });
        } catch (Ab) {
          O(c.removed, { attribute: null, from: b });
        }
        if ((b.removeAttribute(a), 'is' === a && !aa[a]))
          if (Na || fb)
            try {
              cb(b);
            } catch (Ab) {}
          else
            try {
              b.setAttribute(a, '');
            } catch (Ab) {}
      },
      Va = function (a) {
        var b, c;
        bb ? (a = '<remove></remove>' + a) : (c = (c = M(a, /^[\r\n\t ]+/)) && c[0]);
        'application/xhtml+xml' === ab &&
          (a = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + a + '</body></html>');
        var d = ma ? ma.createHTML(a) : a;
        if ('http://www.w3.org/1999/xhtml' === wa)
          try {
            b = new z().parseFromString(d, ab);
          } catch (Gb) {}
        if (!b || !b.documentElement) {
          b = ra.createDocument(wa, 'template', null);
          try {
            b.documentElement.innerHTML = lb ? '' : d;
          } catch (Gb) {}
        }
        d = b.body || b.documentElement;
        return (
          a && c && d.insertBefore(f.createTextNode(c), d.childNodes[0] || null),
          'http://www.w3.org/1999/xhtml' === wa ? za.call(b, va ? 'html' : 'body')[0] : va ? b.documentElement : d
        );
      },
      Hb = function (a) {
        return ib.call(a.ownerDocument || a, a, r.SHOW_ELEMENT | r.SHOW_COMMENT | r.SHOW_TEXT, null, !1);
      },
      nb = function (b) {
        return 'object' === a(n)
          ? b instanceof n
          : b && 'object' === a(b) && 'number' == typeof b.nodeType && 'string' == typeof b.nodeName;
      },
      $a = function (a, b, d) {
        Aa[a] &&
          v(Aa[a], function (a) {
            a.call(c, b, d, mb);
          });
      },
      Ib = function (a) {
        var b;
        if (
          ($a('beforeSanitizeElements', a, null),
          a instanceof C &&
            ('string' != typeof a.nodeName ||
              'string' != typeof a.textContent ||
              'function' != typeof a.removeChild ||
              !(a.attributes instanceof x) ||
              'function' != typeof a.removeAttribute ||
              'function' != typeof a.setAttribute ||
              'string' != typeof a.namespaceURI ||
              'function' != typeof a.insertBefore)) ||
          M(a.nodeName, /[\u0080-\uFFFF]/)
        )
          return cb(a), !0;
        var d = Ba(a.nodeName);
        if (
          ($a('uponSanitizeElement', a, { tagName: d, allowedTags: ga }),
          !(nb(a.firstElementChild) || (nb(a.content) && nb(a.content.firstElementChild))) &&
            Y(/<[/\w]/g, a.innerHTML) &&
            Y(/<[/\w]/g, a.textContent)) ||
          ('select' === d && Y(/<template/i, a.innerHTML))
        )
          return cb(a), !0;
        if (!ga[d] || Ua[d]) {
          if (
            !Ua[d] &&
            0 < d.indexOf('-') &&
            ((ca.tagNameCheck instanceof RegExp && Y(ca.tagNameCheck, d)) ||
              (ca.tagNameCheck instanceof Function && ca.tagNameCheck(d)))
          )
            return !1;
          if (q && !A[d] && ((b = S(a) || a.parentNode), (d = fa(a) || a.childNodes) && b))
            for (var e = d.length - 1; 0 <= e; --e) b.insertBefore(D(d[e], !0), J(a));
          return cb(a), !0;
        }
        return a instanceof p && !Fb(a)
          ? (cb(a), !0)
          : ('noscript' !== d && 'noembed' !== d) || !Y(/<\/no(script|embed)/i, a.innerHTML)
          ? (W &&
              3 === a.nodeType &&
              ((b = a.textContent),
              (b = U(b, ea, ' ')),
              (b = U(b, L, ' ')),
              a.textContent !== b && (O(c.removed, { element: a.cloneNode() }), (a.textContent = b))),
            $a('afterSanitizeElements', a, null),
            !1)
          : (cb(a), !0);
      },
      ob = function (a, b, c) {
        if (ub && ('id' === b || 'name' === b) && (c in f || c in Eb)) return !1;
        if (!Za || Ya[b] || !Y(db, b))
          if (!pb || !Y(sa, b))
            if (!aa[b] || Ya[b]) {
              if (
                !(
                  (0 < a.indexOf('-') &&
                    ((ca.tagNameCheck instanceof RegExp && Y(ca.tagNameCheck, a)) ||
                      (ca.tagNameCheck instanceof Function && ca.tagNameCheck(a))) &&
                    ((ca.attributeNameCheck instanceof RegExp && Y(ca.attributeNameCheck, b)) ||
                      (ca.attributeNameCheck instanceof Function && ca.attributeNameCheck(b)))) ||
                  ('is' === b &&
                    ca.allowCustomizedBuiltInElements &&
                    ((ca.tagNameCheck instanceof RegExp && Y(ca.tagNameCheck, c)) ||
                      (ca.tagNameCheck instanceof Function && ca.tagNameCheck(c))))
                )
              )
                return !1;
            } else if (
              !(
                xa[b] ||
                Y(jb, U(c, Fa, '')) ||
                (('src' === b || 'xlink:href' === b || 'href' === b) &&
                  'script' !== a &&
                  0 === da(c, 'data:') &&
                  H[a]) ||
                (Ia && !Y(ta, U(c, Fa, '')))
              ) &&
              c
            )
              return !1;
        return !0;
      },
      xb = function (a) {
        var b, d, e, f;
        $a('beforeSanitizeAttributes', a, null);
        var g = a.attributes;
        if (g) {
          var q = { attrName: '', attrValue: '', keepAttr: !0, allowedAttributes: aa };
          for (f = g.length; f--; ) {
            var k = (b = g[f]),
              h = k.name,
              k = k.namespaceURI;
            if (
              ((d = 'value' === h ? b.value : ha(b.value)),
              (e = Ba(h)),
              (q.attrName = e),
              (q.attrValue = d),
              (q.keepAttr = !0),
              (q.forceKeepAttr = void 0),
              $a('uponSanitizeAttribute', a, q),
              (d = q.attrValue),
              !q.forceKeepAttr && (Bb(h, a), q.keepAttr))
            )
              if (Y(/\/>/i, d)) Bb(h, a);
              else if ((W && ((d = U(d, ea, ' ')), (d = U(d, L, ' '))), (b = Ba(a.nodeName)), ob(b, e, d)))
                try {
                  k ? a.setAttributeNS(k, h, d) : a.setAttribute(h, d), K(c.removed);
                } catch (hb) {}
          }
          $a('afterSanitizeAttributes', a, null);
        }
      },
      Cb = function zb(a) {
        var b,
          c = Hb(a);
        for ($a('beforeSanitizeShadowDOM', a, null); (b = c.nextNode()); )
          $a('uponSanitizeShadowNode', b, null), Ib(b) || (b.content instanceof g && zb(b.content), xb(b));
        $a('afterSanitizeShadowDOM', a, null);
      };
    return (
      (c.sanitize = function (e, f) {
        var q, k, h;
        if (((lb = !e) && (e = '\x3c!--\x3e'), 'string' != typeof e && !nb(e))) {
          if ('function' != typeof e.toString) throw P('toString is not a function');
          if ('string' != typeof (e = e.toString())) throw P('dirty is not a string, aborting');
        }
        if (!c.isSupported) {
          if ('object' === a(b.toStaticHTML) || 'function' == typeof b.toStaticHTML) {
            if ('string' == typeof e) return b.toStaticHTML(e);
            if (nb(e)) return b.toStaticHTML(e.outerHTML);
          }
          return e;
        }
        if ((qb || rb(f), (c.removed = []), 'string' == typeof e && (w = !1), w)) {
          if (e.nodeName && ((k = Ba(e.nodeName)), !ga[k] || Ua[k]))
            throw P('root node is forbidden and cannot be sanitized in-place');
        } else if (e instanceof n)
          (1 === (k = (q = Va('\x3c!----\x3e')).ownerDocument.importNode(e, !0)).nodeType && 'BODY' === k.nodeName) ||
          'HTML' === k.nodeName
            ? (q = k)
            : q.appendChild(k);
        else {
          if (!Na && !W && !va && -1 === e.indexOf('<')) return ma && gb ? ma.createHTML(e) : e;
          if (!(q = Va(e))) return Na ? null : gb ? R : '';
        }
        q && bb && cb(q.firstChild);
        for (var A = Hb(w ? e : q); (k = A.nextNode()); )
          (3 === k.nodeType && k === h) || Ib(k) || (k.content instanceof g && Cb(k.content), xb(k), (h = k));
        if (w) return e;
        if (Na) {
          if (fb) for (h = Ta.call(q.ownerDocument); q.firstChild; ) h.appendChild(q.firstChild);
          else h = q;
          return aa.shadowroot && (h = tb.call(d, h, !0)), h;
        }
        h = va ? q.outerHTML : q.innerHTML;
        return (
          va &&
            ga['!doctype'] &&
            q.ownerDocument &&
            q.ownerDocument.doctype &&
            q.ownerDocument.doctype.name &&
            Y(La, q.ownerDocument.doctype.name) &&
            (h = '<!DOCTYPE ' + q.ownerDocument.doctype.name + '>\n' + h),
          W && ((h = U(h, ea, ' ')), (h = U(h, L, ' '))),
          ma && gb ? ma.createHTML(h) : h
        );
      }),
      (c.setConfig = function (a) {
        rb(a);
        qb = !0;
      }),
      (c.clearConfig = function () {
        mb = null;
        qb = !1;
      }),
      (c.isValidAttribute = function (a, b, c) {
        mb || rb({});
        a = Ba(a);
        b = Ba(b);
        return ob(a, b, c);
      }),
      (c.addHook = function (a, b) {
        'function' == typeof b && ((Aa[a] = Aa[a] || []), O(Aa[a], b));
      }),
      (c.removeHook = function (a) {
        if (Aa[a]) return K(Aa[a]);
      }),
      (c.removeHooks = function (a) {
        Aa[a] && (Aa[a] = []);
      }),
      (c.removeAllHooks = function () {
        Aa = {};
      }),
      c
    );
  })();
});
var Base64 = {
  _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  encode: function (a, b) {
    var c = '',
      d,
      e,
      f,
      g,
      k,
      h,
      l = 0;
    for ((null != b && b) || (a = Base64._utf8_encode(a)); l < a.length; )
      (d = a.charCodeAt(l++)),
        (e = a.charCodeAt(l++)),
        (f = a.charCodeAt(l++)),
        (g = d >> 2),
        (d = ((d & 3) << 4) | (e >> 4)),
        (k = ((e & 15) << 2) | (f >> 6)),
        (h = f & 63),
        isNaN(e) ? (k = h = 64) : isNaN(f) && (h = 64),
        (c = c + this._keyStr.charAt(g) + this._keyStr.charAt(d) + this._keyStr.charAt(k) + this._keyStr.charAt(h));
    return c;
  },
  decode: function (a, b) {
    b = null != b ? b : !1;
    var c = '',
      d,
      e,
      f,
      g,
      k,
      h = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ''); h < a.length; )
      (d = this._keyStr.indexOf(a.charAt(h++))),
        (e = this._keyStr.indexOf(a.charAt(h++))),
        (g = this._keyStr.indexOf(a.charAt(h++))),
        (k = this._keyStr.indexOf(a.charAt(h++))),
        (d = (d << 2) | (e >> 4)),
        (e = ((e & 15) << 4) | (g >> 2)),
        (f = ((g & 3) << 6) | k),
        (c += String.fromCharCode(d)),
        64 != g && (c += String.fromCharCode(e)),
        64 != k && (c += String.fromCharCode(f));
    b || (c = Base64._utf8_decode(c));
    return c;
  },
  _utf8_encode: function (a) {
    a = a.replace(/\r\n/g, '\n');
    for (var b = '', c = 0; c < a.length; c++) {
      var d = a.charCodeAt(c);
      128 > d
        ? (b += String.fromCharCode(d))
        : (127 < d && 2048 > d
            ? (b += String.fromCharCode((d >> 6) | 192))
            : ((b += String.fromCharCode((d >> 12) | 224)), (b += String.fromCharCode(((d >> 6) & 63) | 128))),
          (b += String.fromCharCode((d & 63) | 128)));
    }
    return b;
  },
  _utf8_decode: function (a) {
    var b = '',
      c = 0,
      d;
    for (c1 = c2 = 0; c < a.length; )
      (d = a.charCodeAt(c)),
        128 > d
          ? ((b += String.fromCharCode(d)), c++)
          : 191 < d && 224 > d
          ? ((c2 = a.charCodeAt(c + 1)), (b += String.fromCharCode(((d & 31) << 6) | (c2 & 63))), (c += 2))
          : ((c2 = a.charCodeAt(c + 1)),
            (c3 = a.charCodeAt(c + 2)),
            (b += String.fromCharCode(((d & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))),
            (c += 3));
    return b;
  },
}; /*
 pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
!(function (a, b) {
  'object' == typeof exports && 'undefined' != typeof module
    ? b(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], b)
    : b(((a = 'undefined' != typeof globalThis ? globalThis : a || self).pako = {}));
})(this, function (a) {
  function b(a) {
    for (var b = a.length; 0 <= --b; ) a[b] = 0;
  }
  function c(a, b, c, d, e) {
    this.static_tree = a;
    this.extra_bits = b;
    this.extra_base = c;
    this.elems = d;
    this.max_length = e;
    this.has_stree = a && a.length;
  }
  function d(a, b) {
    this.dyn_tree = a;
    this.max_code = 0;
    this.stat_desc = b;
  }
  function e(a, b, c, d, e) {
    this.good_length = a;
    this.max_lazy = b;
    this.nice_length = c;
    this.max_chain = d;
    this.func = e;
  }
  function f() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.wrap = this.pending = this.pending_out = this.pending_buf_size = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Ga;
    this.last_flush = -1;
    this.w_mask = this.w_bits = this.w_size = 0;
    this.window = null;
    this.window_size = 0;
    this.head = this.prev = null;
    this.nice_match =
      this.good_match =
      this.strategy =
      this.level =
      this.max_lazy_match =
      this.max_chain_length =
      this.prev_length =
      this.lookahead =
      this.match_start =
      this.strstart =
      this.match_available =
      this.prev_match =
      this.match_length =
      this.block_start =
      this.hash_shift =
      this.hash_mask =
      this.hash_bits =
      this.hash_size =
      this.ins_h =
        0;
    this.dyn_ltree = new Uint16Array(1146);
    this.dyn_dtree = new Uint16Array(122);
    this.bl_tree = new Uint16Array(78);
    Sa(this.dyn_ltree);
    Sa(this.dyn_dtree);
    Sa(this.bl_tree);
    this.bl_desc = this.d_desc = this.l_desc = null;
    this.bl_count = new Uint16Array(16);
    this.heap = new Uint16Array(573);
    Sa(this.heap);
    this.heap_max = this.heap_len = 0;
    this.depth = new Uint16Array(573);
    Sa(this.depth);
    this.bi_valid =
      this.bi_buf =
      this.insert =
      this.matches =
      this.static_len =
      this.opt_len =
      this.d_buf =
      this.last_lit =
      this.lit_bufsize =
      this.l_buf =
        0;
  }
  function g(a) {
    return (g =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
        ? function (a) {
            return typeof a;
          }
        : function (a) {
            return a && 'function' == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype
              ? 'symbol'
              : typeof a;
          })(a);
  }
  function k(a) {
    a = this.options = jb(
      { level: bb, method: fb, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Na },
      a || {}
    );
    a.raw && 0 < a.windowBits
      ? (a.windowBits = -a.windowBits)
      : a.gzip && 0 < a.windowBits && 16 > a.windowBits && (a.windowBits += 16);
    this.err = 0;
    this.msg = '';
    this.ended = !1;
    this.chunks = [];
    this.strm = new Ua();
    this.strm.avail_out = 0;
    var b = Ba.deflateInit2(this.strm, a.level, a.method, a.windowBits, a.memLevel, a.strategy);
    if (b !== va) throw Error(ea[b]);
    if ((a.header && Ba.deflateSetHeader(this.strm, a.header), a.dictionary)) {
      var c;
      if (
        ((c =
          'string' == typeof a.dictionary
            ? ca(a.dictionary)
            : '[object ArrayBuffer]' === Ya.call(a.dictionary)
            ? new Uint8Array(a.dictionary)
            : a.dictionary),
        (b = Ba.deflateSetDictionary(this.strm, c)) !== va)
      )
        throw Error(ea[b]);
      this._dict_set = !0;
    }
  }
  function h(a, b) {
    var c = new k(b);
    if ((c.push(a, !0), c.err)) throw c.msg || ea[c.err];
    return c.result;
  }
  function l() {
    this.mode = 0;
    this.last = !1;
    this.wrap = 0;
    this.havedict = !1;
    this.total = this.check = this.dmax = this.flags = 0;
    this.head = null;
    this.wnext = this.whave = this.wsize = this.wbits = 0;
    this.window = null;
    this.extra = this.offset = this.length = this.bits = this.hold = 0;
    this.distcode = this.lencode = null;
    this.have = this.ndist = this.nlen = this.ncode = this.distbits = this.lenbits = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.distdyn = this.lendyn = null;
    this.was = this.back = this.sane = 0;
  }
  function m(a) {
    var b = (this.options = jb({ chunkSize: 65536, windowBits: 15, to: '' }, a || {}));
    b.raw &&
      0 <= b.windowBits &&
      16 > b.windowBits &&
      ((b.windowBits = -b.windowBits), 0 === b.windowBits && (b.windowBits = -15));
    !(0 <= b.windowBits && 16 > b.windowBits) || (a && a.windowBits) || (b.windowBits += 32);
    15 < b.windowBits && 48 > b.windowBits && 0 == (15 & b.windowBits) && (b.windowBits |= 15);
    this.err = 0;
    this.msg = '';
    this.ended = !1;
    this.chunks = [];
    this.strm = new Ua();
    this.strm.avail_out = 0;
    a = Va.inflateInit2(this.strm, b.windowBits);
    if (a !== ob) throw Error(ea[a]);
    if (
      ((this.header = new Hb()),
      Va.inflateGetHeader(this.strm, this.header),
      b.dictionary &&
        ('string' == typeof b.dictionary
          ? (b.dictionary = ca(b.dictionary))
          : '[object ArrayBuffer]' === nb.call(b.dictionary) && (b.dictionary = new Uint8Array(b.dictionary)),
        b.raw && (a = Va.inflateSetDictionary(this.strm, b.dictionary)) !== ob))
    )
      throw Error(ea[a]);
  }
  function n(a, b) {
    var c = new m(b);
    if ((c.push(a), c.err)) throw c.msg || ea[c.err];
    return c.result;
  }
  var p = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
    r = new Uint8Array([
      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
    ]),
    t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
    u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    x = Array(576);
  b(x);
  var z = Array(60);
  b(z);
  var D = Array(512);
  b(D);
  var B = Array(256);
  b(B);
  var C = Array(29);
  b(C);
  var J,
    v,
    K,
    O = Array(30);
  b(O);
  var T = function (a, b) {
      a.pending_buf[a.pending++] = 255 & b;
      a.pending_buf[a.pending++] = (b >>> 8) & 255;
    },
    M = function (a, b, c) {
      a.bi_valid > 16 - c
        ? ((a.bi_buf |= (b << a.bi_valid) & 65535),
          T(a, a.bi_buf),
          (a.bi_buf = b >> (16 - a.bi_valid)),
          (a.bi_valid += c - 16))
        : ((a.bi_buf |= (b << a.bi_valid) & 65535), (a.bi_valid += c));
    },
    U = function (a, b, c) {
      M(a, c[2 * b], c[2 * b + 1]);
    },
    da = function (a, b) {
      var c = 0;
      do (c |= 1 & a), (a >>>= 1), (c <<= 1);
      while (0 < --b);
      return c >>> 1;
    },
    ha = function (a, b, c) {
      var d,
        e = Array(16),
        f = 0;
      for (d = 1; 15 >= d; d++) e[d] = f = (f + c[d - 1]) << 1;
      for (c = 0; c <= b; c++) (d = a[2 * c + 1]), 0 !== d && (a[2 * c] = da(e[d]++, d));
    },
    Y = function (a) {
      var b;
      for (b = 0; 286 > b; b++) a.dyn_ltree[2 * b] = 0;
      for (b = 0; 30 > b; b++) a.dyn_dtree[2 * b] = 0;
      for (b = 0; 19 > b; b++) a.bl_tree[2 * b] = 0;
      a.dyn_ltree[512] = 1;
      a.opt_len = a.static_len = 0;
      a.last_lit = a.matches = 0;
    },
    P = function (a) {
      8 < a.bi_valid ? T(a, a.bi_buf) : 0 < a.bi_valid && (a.pending_buf[a.pending++] = a.bi_buf);
      a.bi_buf = 0;
      a.bi_valid = 0;
    },
    Oa = function (a, b, c, d) {
      var e = 2 * b,
        f = 2 * c;
      return a[e] < a[f] || (a[e] === a[f] && d[b] <= d[c]);
    },
    Da = function (a, b, c) {
      for (
        var d = a.heap[c], e = c << 1;
        e <= a.heap_len &&
        (e < a.heap_len && Oa(b, a.heap[e + 1], a.heap[e], a.depth) && e++, !Oa(b, d, a.heap[e], a.depth));

      )
        (a.heap[c] = a.heap[e]), (c = e), (e <<= 1);
      a.heap[c] = d;
    },
    Pa = function (a, b, c) {
      var d,
        e,
        f,
        g,
        q = 0;
      if (0 !== a.last_lit) {
        do
          (d = (a.pending_buf[a.d_buf + 2 * q] << 8) | a.pending_buf[a.d_buf + 2 * q + 1]),
            (e = a.pending_buf[a.l_buf + q]),
            q++,
            0 === d
              ? U(a, e, b)
              : ((f = B[e]),
                U(a, f + 256 + 1, b),
                0 !== (g = p[f]) && ((e -= C[f]), M(a, e, g)),
                d--,
                (f = 256 > d ? D[d] : D[256 + (d >>> 7)]),
                U(a, f, c),
                0 !== (g = r[f]) && ((d -= O[f]), M(a, d, g)));
        while (q < a.last_lit);
      }
      U(a, 256, b);
    },
    Wa = function (a, b) {
      var c,
        d,
        e,
        f = b.dyn_tree;
      d = b.stat_desc.static_tree;
      var g = b.stat_desc.has_stree,
        q = b.stat_desc.elems,
        k = -1;
      a.heap_len = 0;
      a.heap_max = 573;
      for (c = 0; c < q; c++) 0 !== f[2 * c] ? ((a.heap[++a.heap_len] = k = c), (a.depth[c] = 0)) : (f[2 * c + 1] = 0);
      for (; 2 > a.heap_len; )
        (f[2 * (e = a.heap[++a.heap_len] = 2 > k ? ++k : 0)] = 1),
          (a.depth[e] = 0),
          a.opt_len--,
          g && (a.static_len -= d[2 * e + 1]);
      b.max_code = k;
      for (c = a.heap_len >> 1; 1 <= c; c--) Da(a, f, c);
      e = q;
      do
        (c = a.heap[1]),
          (a.heap[1] = a.heap[a.heap_len--]),
          Da(a, f, 1),
          (d = a.heap[1]),
          (a.heap[--a.heap_max] = c),
          (a.heap[--a.heap_max] = d),
          (f[2 * e] = f[2 * c] + f[2 * d]),
          (a.depth[e] = (a.depth[c] >= a.depth[d] ? a.depth[c] : a.depth[d]) + 1),
          (f[2 * c + 1] = f[2 * d + 1] = e),
          (a.heap[1] = e++),
          Da(a, f, 1);
      while (2 <= a.heap_len);
      a.heap[--a.heap_max] = a.heap[1];
      var h,
        w,
        A,
        g = b.dyn_tree,
        q = b.max_code,
        G = b.stat_desc.static_tree,
        y = b.stat_desc.has_stree,
        l = b.stat_desc.extra_bits,
        H = b.stat_desc.extra_base,
        m = b.stat_desc.max_length,
        oa = 0;
      for (d = 0; 15 >= d; d++) a.bl_count[d] = 0;
      g[2 * a.heap[a.heap_max] + 1] = 0;
      for (c = a.heap_max + 1; 573 > c; c++)
        (d = g[2 * g[2 * (e = a.heap[c]) + 1] + 1] + 1) > m && ((d = m), oa++),
          (g[2 * e + 1] = d),
          e > q ||
            (a.bl_count[d]++,
            (w = 0),
            e >= H && (w = l[e - H]),
            (A = g[2 * e]),
            (a.opt_len += A * (d + w)),
            y && (a.static_len += A * (G[2 * e + 1] + w)));
      if (0 !== oa) {
        do {
          for (d = m - 1; 0 === a.bl_count[d]; ) d--;
          a.bl_count[d]--;
          a.bl_count[d + 1] += 2;
          a.bl_count[m]--;
          oa -= 2;
        } while (0 < oa);
        for (d = m; 0 !== d; d--)
          for (e = a.bl_count[d]; 0 !== e; )
            (h = a.heap[--c]) > q ||
              (g[2 * h + 1] !== d && ((a.opt_len += (d - g[2 * h + 1]) * g[2 * h]), (g[2 * h + 1] = d)), e--);
      }
      ha(f, k, a.bl_count);
    },
    Ea = function (a, b, c) {
      var d,
        e,
        f = -1,
        g = b[1],
        q = 0,
        k = 7,
        h = 4;
      0 === g && ((k = 138), (h = 3));
      b[2 * (c + 1) + 1] = 65535;
      for (d = 0; d <= c; d++)
        (e = g),
          (g = b[2 * (d + 1) + 1]),
          (++q < k && e === g) ||
            (q < h
              ? (a.bl_tree[2 * e] += q)
              : 0 !== e
              ? (e !== f && a.bl_tree[2 * e]++, a.bl_tree[32]++)
              : 10 >= q
              ? a.bl_tree[34]++
              : a.bl_tree[36]++,
            (q = 0),
            (f = e),
            0 === g ? ((k = 138), (h = 3)) : e === g ? ((k = 6), (h = 3)) : ((k = 7), (h = 4)));
    },
    qa = function (a, b, c) {
      var d,
        e,
        f = -1,
        g = b[1],
        q = 0,
        k = 7,
        h = 4;
      0 === g && ((k = 138), (h = 3));
      for (d = 0; d <= c; d++)
        if (((e = g), (g = b[2 * (d + 1) + 1]), !(++q < k && e === g))) {
          if (q < h) {
            do U(a, e, a.bl_tree);
            while (0 != --q);
          } else
            0 !== e
              ? (e !== f && (U(a, e, a.bl_tree), q--), U(a, 16, a.bl_tree), M(a, q - 3, 2))
              : 10 >= q
              ? (U(a, 17, a.bl_tree), M(a, q - 3, 3))
              : (U(a, 18, a.bl_tree), M(a, q - 11, 7));
          q = 0;
          f = e;
          0 === g ? ((k = 138), (h = 3)) : e === g ? ((k = 6), (h = 3)) : ((k = 7), (h = 4));
        }
    },
    ia = !1,
    Ka = function (a, b, c, d) {
      M(a, 0 + (d ? 1 : 0), 3);
      P(a);
      T(a, c);
      T(a, ~c);
      a.pending_buf.set(a.window.subarray(b, b + c), a.pending);
      a.pending += c;
    },
    ua = function (a, b, c, d) {
      var e = (65535 & a) | 0;
      a = ((a >>> 16) & 65535) | 0;
      for (var f; 0 !== c; ) {
        c -= f = 2e3 < c ? 2e3 : c;
        do a = (a + (e = (e + b[d++]) | 0)) | 0;
        while (--f);
        e %= 65521;
        a %= 65521;
      }
      return e | (a << 16) | 0;
    },
    Xa = new Uint32Array(
      (function () {
        for (var a, b = [], c = 0; 256 > c; c++) {
          a = c;
          for (var d = 0; 8 > d; d++) a = 1 & a ? 3988292384 ^ (a >>> 1) : a >>> 1;
          b[c] = a;
        }
        return b;
      })()
    ),
    Z = function (a, b, c, d) {
      c = d + c;
      for (a ^= -1; d < c; d++) a = (a >>> 8) ^ Xa[255 & (a ^ b[d])];
      return -1 ^ a;
    },
    ea = {
      '2': 'need dictionary',
      '1': 'stream end',
      '0': '',
      '-1': 'file error',
      '-2': 'stream error',
      '-3': 'data error',
      '-4': 'insufficient memory',
      '-5': 'buffer error',
      '-6': 'incompatible version',
    },
    L = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8,
    },
    db = function (a, b, c, d) {
      var e,
        f,
        g = 0;
      0 < a.level
        ? (2 === a.strm.data_type &&
            (a.strm.data_type = (function (a) {
              var b,
                c = 4093624447;
              for (b = 0; 31 >= b; b++, c >>>= 1) if (1 & c && 0 !== a.dyn_ltree[2 * b]) return 0;
              if (0 !== a.dyn_ltree[18] || 0 !== a.dyn_ltree[20] || 0 !== a.dyn_ltree[26]) return 1;
              for (b = 32; 256 > b; b++) if (0 !== a.dyn_ltree[2 * b]) return 1;
              return 0;
            })(a)),
          Wa(a, a.l_desc),
          Wa(a, a.d_desc),
          (g = (function (a) {
            var b;
            Ea(a, a.dyn_ltree, a.l_desc.max_code);
            Ea(a, a.dyn_dtree, a.d_desc.max_code);
            Wa(a, a.bl_desc);
            for (b = 18; 3 <= b && 0 === a.bl_tree[2 * u[b] + 1]; b--);
            return (a.opt_len += 3 * (b + 1) + 14), b;
          })(a)),
          (e = (a.opt_len + 3 + 7) >>> 3),
          (f = (a.static_len + 3 + 7) >>> 3) <= e && (e = f))
        : (e = f = c + 5);
      c + 4 <= e && -1 !== b
        ? Ka(a, b, c, d)
        : 4 === a.strategy || f === e
        ? (M(a, 2 + (d ? 1 : 0), 3), Pa(a, x, z))
        : (M(a, 4 + (d ? 1 : 0), 3),
          (function (a, b, c, d) {
            var e;
            M(a, b - 257, 5);
            M(a, c - 1, 5);
            M(a, d - 4, 4);
            for (e = 0; e < d; e++) M(a, a.bl_tree[2 * u[e] + 1], 3);
            qa(a, a.dyn_ltree, b - 1);
            qa(a, a.dyn_dtree, c - 1);
          })(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, g + 1),
          Pa(a, a.dyn_ltree, a.dyn_dtree));
      Y(a);
      d && P(a);
    },
    sa = function (a, b, c) {
      return (
        (a.pending_buf[a.d_buf + 2 * a.last_lit] = (b >>> 8) & 255),
        (a.pending_buf[a.d_buf + 2 * a.last_lit + 1] = 255 & b),
        (a.pending_buf[a.l_buf + a.last_lit] = 255 & c),
        a.last_lit++,
        0 === b
          ? a.dyn_ltree[2 * c]++
          : (a.matches++,
            b--,
            a.dyn_ltree[2 * (B[c] + 256 + 1)]++,
            a.dyn_dtree[2 * (256 > b ? D[b] : D[256 + (b >>> 7)])]++),
        a.last_lit === a.lit_bufsize - 1
      );
    },
    eb = function (a) {
      M(a, 2, 3);
      U(a, 256, x);
      16 === a.bi_valid
        ? (T(a, a.bi_buf), (a.bi_buf = 0), (a.bi_valid = 0))
        : 8 <= a.bi_valid && ((a.pending_buf[a.pending++] = 255 & a.bi_buf), (a.bi_buf >>= 8), (a.bi_valid -= 8));
    },
    ta = L.Z_NO_FLUSH,
    Fa = L.Z_PARTIAL_FLUSH,
    La = L.Z_FULL_FLUSH,
    la = L.Z_FINISH,
    Ca = L.Z_BLOCK,
    pa = L.Z_OK,
    Ja = L.Z_STREAM_END,
    ba = L.Z_STREAM_ERROR,
    E = L.Z_DATA_ERROR,
    I = L.Z_BUF_ERROR,
    F = L.Z_DEFAULT_COMPRESSION,
    N = L.Z_FILTERED,
    V = L.Z_HUFFMAN_ONLY,
    Q = L.Z_RLE,
    X = L.Z_FIXED,
    ja = L.Z_DEFAULT_STRATEGY,
    Qa = L.Z_UNKNOWN,
    Ga = L.Z_DEFLATED,
    Ra = function (a, b) {
      return (a.msg = ea[b]), b;
    },
    Sa = function (a) {
      for (var b = a.length; 0 <= --b; ) a[b] = 0;
    },
    ya = function (a, b, c) {
      return ((b << a.hash_shift) ^ c) & a.hash_mask;
    },
    Ma = function (a) {
      var b = a.state,
        c = b.pending;
      c > a.avail_out && (c = a.avail_out);
      0 !== c &&
        (a.output.set(b.pending_buf.subarray(b.pending_out, b.pending_out + c), a.next_out),
        (a.next_out += c),
        (b.pending_out += c),
        (a.total_out += c),
        (a.avail_out -= c),
        (b.pending -= c),
        0 === b.pending && (b.pending_out = 0));
    },
    fa = function (a, b) {
      db(a, 0 <= a.block_start ? a.block_start : -1, a.strstart - a.block_start, b);
      a.block_start = a.strstart;
      Ma(a.strm);
    },
    S = function (a, b) {
      a.pending_buf[a.pending++] = b;
    },
    ma = function (a, b) {
      a.pending_buf[a.pending++] = (b >>> 8) & 255;
      a.pending_buf[a.pending++] = 255 & b;
    },
    R = function (a, b) {
      var c,
        d,
        e = a.max_chain_length,
        f = a.strstart,
        g = a.prev_length,
        q = a.nice_match,
        k = a.strstart > a.w_size - 262 ? a.strstart - (a.w_size - 262) : 0,
        h = a.window,
        w = a.w_mask,
        A = a.prev,
        G = a.strstart + 258,
        y = h[f + g - 1],
        l = h[f + g];
      a.prev_length >= a.good_match && (e >>= 2);
      q > a.lookahead && (q = a.lookahead);
      do
        if (h[(c = b) + g] === l && h[c + g - 1] === y && h[c] === h[f] && h[++c] === h[f + 1]) {
          f += 2;
          for (
            c++;
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            h[++f] === h[++c] &&
            f < G;

          );
          if (((d = 258 - (G - f)), (f = G - 258), d > g)) {
            if (((a.match_start = b), (g = d), d >= q)) break;
            y = h[f + g - 1];
            l = h[f + g];
          }
        }
      while ((b = A[b & w]) > k && 0 != --e);
      return g <= a.lookahead ? g : a.lookahead;
    },
    ra = function (a) {
      var b,
        c,
        d,
        e,
        f,
        g,
        q,
        k,
        h,
        w = a.w_size;
      do {
        if (((e = a.window_size - a.lookahead - a.strstart), a.strstart >= w + (w - 262))) {
          a.window.set(a.window.subarray(w, w + w), 0);
          a.match_start -= w;
          a.strstart -= w;
          a.block_start -= w;
          b = c = a.hash_size;
          do (d = a.head[--b]), (a.head[b] = d >= w ? d - w : 0);
          while (--c);
          b = c = w;
          do (d = a.prev[--b]), (a.prev[b] = d >= w ? d - w : 0);
          while (--c);
          e += w;
        }
        if (0 === a.strm.avail_in) break;
        if (
          ((f = a.strm),
          (g = a.window),
          (q = a.strstart + a.lookahead),
          (k = e),
          (h = void 0),
          (h = f.avail_in) > k && (h = k),
          (c =
            0 === h
              ? 0
              : ((f.avail_in -= h),
                g.set(f.input.subarray(f.next_in, f.next_in + h), q),
                1 === f.state.wrap
                  ? (f.adler = ua(f.adler, g, h, q))
                  : 2 === f.state.wrap && (f.adler = Z(f.adler, g, h, q)),
                (f.next_in += h),
                (f.total_in += h),
                h)),
          (a.lookahead += c),
          3 <= a.lookahead + a.insert)
        )
          for (
            b = a.strstart - a.insert, a.ins_h = a.window[b], a.ins_h = ya(a, a.ins_h, a.window[b + 1]);
            a.insert &&
            ((a.ins_h = ya(a, a.ins_h, a.window[b + 3 - 1])),
            (a.prev[b & a.w_mask] = a.head[a.ins_h]),
            (a.head[a.ins_h] = b),
            b++,
            a.insert--,
            !(3 > a.lookahead + a.insert));

          );
      } while (262 > a.lookahead && 0 !== a.strm.avail_in);
    },
    ib = function (a, b) {
      for (var c, d; ; ) {
        if (262 > a.lookahead) {
          if ((ra(a), 262 > a.lookahead && b === ta)) return 1;
          if (0 === a.lookahead) break;
        }
        if (
          ((c = 0),
          3 <= a.lookahead &&
            ((a.ins_h = ya(a, a.ins_h, a.window[a.strstart + 3 - 1])),
            (c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h]),
            (a.head[a.ins_h] = a.strstart)),
          0 !== c && a.strstart - c <= a.w_size - 262 && (a.match_length = R(a, c)),
          3 <= a.match_length)
        )
          if (
            ((d = sa(a, a.strstart - a.match_start, a.match_length - 3)),
            (a.lookahead -= a.match_length),
            a.match_length <= a.max_lazy_match && 3 <= a.lookahead)
          ) {
            a.match_length--;
            do
              a.strstart++,
                (a.ins_h = ya(a, a.ins_h, a.window[a.strstart + 3 - 1])),
                (c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h]),
                (a.head[a.ins_h] = a.strstart);
            while (0 != --a.match_length);
            a.strstart++;
          } else
            (a.strstart += a.match_length),
              (a.match_length = 0),
              (a.ins_h = a.window[a.strstart]),
              (a.ins_h = ya(a, a.ins_h, a.window[a.strstart + 1]));
        else (d = sa(a, 0, a.window[a.strstart])), a.lookahead--, a.strstart++;
        if (d && (fa(a, !1), 0 === a.strm.avail_out)) return 1;
      }
      return (
        (a.insert = 2 > a.strstart ? a.strstart : 2),
        b === la
          ? (fa(a, !0), 0 === a.strm.avail_out ? 3 : 4)
          : a.last_lit && (fa(a, !1), 0 === a.strm.avail_out)
          ? 1
          : 2
      );
    },
    Ta = function (a, b) {
      for (var c, d, e; ; ) {
        if (262 > a.lookahead) {
          if ((ra(a), 262 > a.lookahead && b === ta)) return 1;
          if (0 === a.lookahead) break;
        }
        if (
          ((c = 0),
          3 <= a.lookahead &&
            ((a.ins_h = ya(a, a.ins_h, a.window[a.strstart + 3 - 1])),
            (c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h]),
            (a.head[a.ins_h] = a.strstart)),
          (a.prev_length = a.match_length),
          (a.prev_match = a.match_start),
          (a.match_length = 2),
          0 !== c &&
            a.prev_length < a.max_lazy_match &&
            a.strstart - c <= a.w_size - 262 &&
            ((a.match_length = R(a, c)),
            5 >= a.match_length &&
              (a.strategy === N || (3 === a.match_length && 4096 < a.strstart - a.match_start)) &&
              (a.match_length = 2)),
          3 <= a.prev_length && a.match_length <= a.prev_length)
        ) {
          e = a.strstart + a.lookahead - 3;
          d = sa(a, a.strstart - 1 - a.prev_match, a.prev_length - 3);
          a.lookahead -= a.prev_length - 1;
          a.prev_length -= 2;
          do
            ++a.strstart <= e &&
              ((a.ins_h = ya(a, a.ins_h, a.window[a.strstart + 3 - 1])),
              (c = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h]),
              (a.head[a.ins_h] = a.strstart));
          while (0 != --a.prev_length);
          if (((a.match_available = 0), (a.match_length = 2), a.strstart++, d && (fa(a, !1), 0 === a.strm.avail_out)))
            return 1;
        } else if (a.match_available) {
          if ((sa(a, 0, a.window[a.strstart - 1]) && fa(a, !1), a.strstart++, a.lookahead--, 0 === a.strm.avail_out))
            return 1;
        } else (a.match_available = 1), a.strstart++, a.lookahead--;
      }
      return (
        a.match_available && (sa(a, 0, a.window[a.strstart - 1]), (a.match_available = 0)),
        (a.insert = 2 > a.strstart ? a.strstart : 2),
        b === la
          ? (fa(a, !0), 0 === a.strm.avail_out ? 3 : 4)
          : a.last_lit && (fa(a, !1), 0 === a.strm.avail_out)
          ? 1
          : 2
      );
    },
    za = [
      new e(0, 0, 0, 0, function (a, b) {
        var c = 65535;
        for (c > a.pending_buf_size - 5 && (c = a.pending_buf_size - 5); ; ) {
          if (1 >= a.lookahead) {
            if ((ra(a), 0 === a.lookahead && b === ta)) return 1;
            if (0 === a.lookahead) break;
          }
          a.strstart += a.lookahead;
          a.lookahead = 0;
          var d = a.block_start + c;
          if (
            ((0 === a.strstart || a.strstart >= d) &&
              ((a.lookahead = a.strstart - d), (a.strstart = d), fa(a, !1), 0 === a.strm.avail_out)) ||
            (a.strstart - a.block_start >= a.w_size - 262 && (fa(a, !1), 0 === a.strm.avail_out))
          )
            return 1;
        }
        return (
          (a.insert = 0),
          b === la
            ? (fa(a, !0), 0 === a.strm.avail_out ? 3 : 4)
            : (a.strstart > a.block_start && (fa(a, !1), a.strm.avail_out), 1)
        );
      }),
      new e(4, 4, 8, 4, ib),
      new e(4, 5, 16, 8, ib),
      new e(4, 6, 32, 32, ib),
      new e(4, 4, 16, 16, Ta),
      new e(8, 16, 32, 32, Ta),
      new e(8, 16, 128, 128, Ta),
      new e(8, 32, 128, 256, Ta),
      new e(32, 128, 258, 1024, Ta),
      new e(32, 258, 258, 4096, Ta),
    ],
    tb = function (a) {
      if (!a || !a.state) return Ra(a, ba);
      a.total_in = a.total_out = 0;
      a.data_type = Qa;
      var b = a.state;
      b.pending = 0;
      b.pending_out = 0;
      0 > b.wrap && (b.wrap = -b.wrap);
      b.status = b.wrap ? 42 : 113;
      a.adler = 2 === b.wrap ? 0 : 1;
      b.last_flush = ta;
      if (!ia) {
        var e, f, g;
        a = Array(16);
        for (g = f = 0; 28 > g; g++) for (C[g] = f, e = 0; e < 1 << p[g]; e++) B[f++] = g;
        B[f - 1] = g;
        for (g = f = 0; 16 > g; g++) for (O[g] = f, e = 0; e < 1 << r[g]; e++) D[f++] = g;
        for (f >>= 7; 30 > g; g++) for (O[g] = f << 7, e = 0; e < 1 << (r[g] - 7); e++) D[256 + f++] = g;
        for (e = 0; 15 >= e; e++) a[e] = 0;
        for (e = 0; 143 >= e; ) (x[2 * e + 1] = 8), e++, a[8]++;
        for (; 255 >= e; ) (x[2 * e + 1] = 9), e++, a[9]++;
        for (; 279 >= e; ) (x[2 * e + 1] = 7), e++, a[7]++;
        for (; 287 >= e; ) (x[2 * e + 1] = 8), e++, a[8]++;
        ha(x, 287, a);
        for (e = 0; 30 > e; e++) (z[2 * e + 1] = 5), (z[2 * e] = da(e, 5));
        J = new c(x, p, 257, 286, 15);
        v = new c(z, r, 0, 30, 15);
        K = new c([], t, 0, 19, 7);
        !0;
        ia = !0;
      }
      b.l_desc = new d(b.dyn_ltree, J);
      b.d_desc = new d(b.dyn_dtree, v);
      b.bl_desc = new d(b.bl_tree, K);
      b.bi_buf = 0;
      b.bi_valid = 0;
      Y(b);
      return pa;
    },
    Aa = function (a) {
      var b,
        c = tb(a);
      return (
        c === pa &&
          (((b = a.state).window_size = 2 * b.w_size),
          Sa(b.head),
          (b.max_lazy_match = za[b.level].max_lazy),
          (b.good_match = za[b.level].good_length),
          (b.nice_match = za[b.level].nice_length),
          (b.max_chain_length = za[b.level].max_chain),
          (b.strstart = 0),
          (b.block_start = 0),
          (b.lookahead = 0),
          (b.insert = 0),
          (b.match_length = b.prev_length = 2),
          (b.match_available = 0),
          (b.ins_h = 0)),
        c
      );
    },
    ab = function (a, b, c, d, e, g) {
      if (!a) return ba;
      var q = 1;
      if (
        (b === F && (b = 6),
        0 > d ? ((q = 0), (d = -d)) : 15 < d && ((q = 2), (d -= 16)),
        1 > e || 9 < e || c !== Ga || 8 > d || 15 < d || 0 > b || 9 < b || 0 > g || g > X)
      )
        return Ra(a, ba);
      8 === d && (d = 9);
      var k = new f();
      return (
        (a.state = k),
        (k.strm = a),
        (k.wrap = q),
        (k.gzhead = null),
        (k.w_bits = d),
        (k.w_size = 1 << k.w_bits),
        (k.w_mask = k.w_size - 1),
        (k.hash_bits = e + 7),
        (k.hash_size = 1 << k.hash_bits),
        (k.hash_mask = k.hash_size - 1),
        (k.hash_shift = ~~((k.hash_bits + 3 - 1) / 3)),
        (k.window = new Uint8Array(2 * k.w_size)),
        (k.head = new Uint16Array(k.hash_size)),
        (k.prev = new Uint16Array(k.w_size)),
        (k.lit_bufsize = 1 << (e + 6)),
        (k.pending_buf_size = 4 * k.lit_bufsize),
        (k.pending_buf = new Uint8Array(k.pending_buf_size)),
        (k.d_buf = 1 * k.lit_bufsize),
        (k.l_buf = 3 * k.lit_bufsize),
        (k.level = b),
        (k.strategy = g),
        (k.method = c),
        Aa(a)
      );
    },
    Ba = {
      deflateInit: function (a, b) {
        return ab(a, b, Ga, 15, 8, ja);
      },
      deflateInit2: ab,
      deflateReset: Aa,
      deflateResetKeep: tb,
      deflateSetHeader: function (a, b) {
        return a && a.state ? (2 !== a.state.wrap ? ba : ((a.state.gzhead = b), pa)) : ba;
      },
      deflate: function (a, b) {
        var c, d;
        if (!a || !a.state || b > Ca || 0 > b) return a ? Ra(a, ba) : ba;
        var e = a.state;
        if (!a.output || (!a.input && 0 !== a.avail_in) || (666 === e.status && b !== la))
          return Ra(a, 0 === a.avail_out ? I : ba);
        e.strm = a;
        var f = e.last_flush;
        if (((e.last_flush = b), 42 === e.status))
          2 === e.wrap
            ? ((a.adler = 0),
              S(e, 31),
              S(e, 139),
              S(e, 8),
              e.gzhead
                ? (S(
                    e,
                    (e.gzhead.text ? 1 : 0) +
                      (e.gzhead.hcrc ? 2 : 0) +
                      (e.gzhead.extra ? 4 : 0) +
                      (e.gzhead.name ? 8 : 0) +
                      (e.gzhead.comment ? 16 : 0)
                  ),
                  S(e, 255 & e.gzhead.time),
                  S(e, (e.gzhead.time >> 8) & 255),
                  S(e, (e.gzhead.time >> 16) & 255),
                  S(e, (e.gzhead.time >> 24) & 255),
                  S(e, 9 === e.level ? 2 : e.strategy >= V || 2 > e.level ? 4 : 0),
                  S(e, 255 & e.gzhead.os),
                  e.gzhead.extra &&
                    e.gzhead.extra.length &&
                    (S(e, 255 & e.gzhead.extra.length), S(e, (e.gzhead.extra.length >> 8) & 255)),
                  e.gzhead.hcrc && (a.adler = Z(a.adler, e.pending_buf, e.pending, 0)),
                  (e.gzindex = 0),
                  (e.status = 69))
                : (S(e, 0),
                  S(e, 0),
                  S(e, 0),
                  S(e, 0),
                  S(e, 0),
                  S(e, 9 === e.level ? 2 : e.strategy >= V || 2 > e.level ? 4 : 0),
                  S(e, 3),
                  (e.status = 113)))
            : ((c = (Ga + ((e.w_bits - 8) << 4)) << 8),
              (c |= (e.strategy >= V || 2 > e.level ? 0 : 6 > e.level ? 1 : 6 === e.level ? 2 : 3) << 6),
              0 !== e.strstart && (c |= 32),
              (e.status = 113),
              ma(e, c + (31 - (c % 31))),
              0 !== e.strstart && (ma(e, a.adler >>> 16), ma(e, 65535 & a.adler)),
              (a.adler = 1));
        if (69 === e.status)
          if (e.gzhead.extra) {
            for (
              c = e.pending;
              e.gzindex < (65535 & e.gzhead.extra.length) &&
              (e.pending !== e.pending_buf_size ||
                (e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c)),
                Ma(a),
                (c = e.pending),
                e.pending !== e.pending_buf_size));

            )
              S(e, 255 & e.gzhead.extra[e.gzindex]), e.gzindex++;
            e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c));
            e.gzindex === e.gzhead.extra.length && ((e.gzindex = 0), (e.status = 73));
          } else e.status = 73;
        if (73 === e.status)
          if (e.gzhead.name) {
            c = e.pending;
            do {
              if (
                e.pending === e.pending_buf_size &&
                (e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c)),
                Ma(a),
                (c = e.pending),
                e.pending === e.pending_buf_size)
              ) {
                d = 1;
                break;
              }
              d = e.gzindex < e.gzhead.name.length ? 255 & e.gzhead.name.charCodeAt(e.gzindex++) : 0;
              S(e, d);
            } while (0 !== d);
            e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c));
            0 === d && ((e.gzindex = 0), (e.status = 91));
          } else e.status = 91;
        if (91 === e.status)
          if (e.gzhead.comment) {
            c = e.pending;
            do {
              if (
                e.pending === e.pending_buf_size &&
                (e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c)),
                Ma(a),
                (c = e.pending),
                e.pending === e.pending_buf_size)
              ) {
                d = 1;
                break;
              }
              d = e.gzindex < e.gzhead.comment.length ? 255 & e.gzhead.comment.charCodeAt(e.gzindex++) : 0;
              S(e, d);
            } while (0 !== d);
            e.gzhead.hcrc && e.pending > c && (a.adler = Z(a.adler, e.pending_buf, e.pending - c, c));
            0 === d && (e.status = 103);
          } else e.status = 103;
        if (
          (103 === e.status &&
            (e.gzhead.hcrc
              ? (e.pending + 2 > e.pending_buf_size && Ma(a),
                e.pending + 2 <= e.pending_buf_size &&
                  (S(e, 255 & a.adler), S(e, (a.adler >> 8) & 255), (a.adler = 0), (e.status = 113)))
              : (e.status = 113)),
          0 !== e.pending)
        ) {
          if ((Ma(a), 0 === a.avail_out)) return (e.last_flush = -1), pa;
        } else if (0 === a.avail_in && (b << 1) - (4 < b ? 9 : 0) <= (f << 1) - (4 < f ? 9 : 0) && b !== la)
          return Ra(a, I);
        if (666 === e.status && 0 !== a.avail_in) return Ra(a, I);
        if (0 !== a.avail_in || 0 !== e.lookahead || (b !== ta && 666 !== e.status)) {
          f =
            e.strategy === V
              ? (function (a, b) {
                  for (var c; ; ) {
                    if (0 === a.lookahead && (ra(a), 0 === a.lookahead)) {
                      if (b === ta) return 1;
                      break;
                    }
                    if (
                      ((a.match_length = 0),
                      (c = sa(a, 0, a.window[a.strstart])),
                      a.lookahead--,
                      a.strstart++,
                      c && (fa(a, !1), 0 === a.strm.avail_out))
                    )
                      return 1;
                  }
                  return (
                    (a.insert = 0),
                    b === la
                      ? (fa(a, !0), 0 === a.strm.avail_out ? 3 : 4)
                      : a.last_lit && (fa(a, !1), 0 === a.strm.avail_out)
                      ? 1
                      : 2
                  );
                })(e, b)
              : e.strategy === Q
              ? (function (a, b) {
                  for (var c, d, e, f, g = a.window; ; ) {
                    if (258 >= a.lookahead) {
                      if ((ra(a), 258 >= a.lookahead && b === ta)) return 1;
                      if (0 === a.lookahead) break;
                    }
                    if (
                      ((a.match_length = 0),
                      3 <= a.lookahead &&
                        0 < a.strstart &&
                        (d = g[(e = a.strstart - 1)]) === g[++e] &&
                        d === g[++e] &&
                        d === g[++e])
                    ) {
                      for (
                        f = a.strstart + 258;
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        d === g[++e] &&
                        e < f;

                      );
                      a.match_length = 258 - (f - e);
                      a.match_length > a.lookahead && (a.match_length = a.lookahead);
                    }
                    if (
                      (3 <= a.match_length
                        ? ((c = sa(a, 1, a.match_length - 3)),
                          (a.lookahead -= a.match_length),
                          (a.strstart += a.match_length),
                          (a.match_length = 0))
                        : ((c = sa(a, 0, a.window[a.strstart])), a.lookahead--, a.strstart++),
                      c && (fa(a, !1), 0 === a.strm.avail_out))
                    )
                      return 1;
                  }
                  return (
                    (a.insert = 0),
                    b === la
                      ? (fa(a, !0), 0 === a.strm.avail_out ? 3 : 4)
                      : a.last_lit && (fa(a, !1), 0 === a.strm.avail_out)
                      ? 1
                      : 2
                  );
                })(e, b)
              : za[e.level].func(e, b);
          if (((3 !== f && 4 !== f) || (e.status = 666), 1 === f || 3 === f))
            return 0 === a.avail_out && (e.last_flush = -1), pa;
          if (
            2 === f &&
            (b === Fa
              ? eb(e)
              : b !== Ca &&
                (Ka(e, 0, 0, !1),
                b === La && (Sa(e.head), 0 === e.lookahead && ((e.strstart = 0), (e.block_start = 0), (e.insert = 0)))),
            Ma(a),
            0 === a.avail_out)
          )
            return (e.last_flush = -1), pa;
        }
        return b !== la
          ? pa
          : 0 >= e.wrap
          ? Ja
          : (2 === e.wrap
              ? (S(e, 255 & a.adler),
                S(e, (a.adler >> 8) & 255),
                S(e, (a.adler >> 16) & 255),
                S(e, (a.adler >> 24) & 255),
                S(e, 255 & a.total_in),
                S(e, (a.total_in >> 8) & 255),
                S(e, (a.total_in >> 16) & 255),
                S(e, (a.total_in >> 24) & 255))
              : (ma(e, a.adler >>> 16), ma(e, 65535 & a.adler)),
            Ma(a),
            0 < e.wrap && (e.wrap = -e.wrap),
            0 !== e.pending ? pa : Ja);
      },
      deflateEnd: function (a) {
        if (!a || !a.state) return ba;
        var b = a.state.status;
        return 42 !== b && 69 !== b && 73 !== b && 91 !== b && 103 !== b && 113 !== b && 666 !== b
          ? Ra(a, ba)
          : ((a.state = null), 113 === b ? Ra(a, E) : pa);
      },
      deflateSetDictionary: function (a, b) {
        var c = b.length;
        if (!a || !a.state) return ba;
        var d = a.state,
          e = d.wrap;
        if (2 === e || (1 === e && 42 !== d.status) || d.lookahead) return ba;
        if ((1 === e && (a.adler = ua(a.adler, b, c, 0)), (d.wrap = 0), c >= d.w_size)) {
          0 === e && (Sa(d.head), (d.strstart = 0), (d.block_start = 0), (d.insert = 0));
          var f = new Uint8Array(d.w_size);
          f.set(b.subarray(c - d.w_size, c), 0);
          b = f;
          c = d.w_size;
        }
        var f = a.avail_in,
          g = a.next_in,
          q = a.input;
        a.avail_in = c;
        a.next_in = 0;
        a.input = b;
        for (ra(d); 3 <= d.lookahead; ) {
          var c = d.strstart,
            k = d.lookahead - 2;
          do
            (d.ins_h = ya(d, d.ins_h, d.window[c + 3 - 1])),
              (d.prev[c & d.w_mask] = d.head[d.ins_h]),
              (d.head[d.ins_h] = c),
              c++;
          while (--k);
          d.strstart = c;
          d.lookahead = 2;
          ra(d);
        }
        return (
          (d.strstart += d.lookahead),
          (d.block_start = d.strstart),
          (d.insert = d.lookahead),
          (d.lookahead = 0),
          (d.match_length = d.prev_length = 2),
          (d.match_available = 0),
          (a.next_in = g),
          (a.input = q),
          (a.avail_in = f),
          (d.wrap = e),
          pa
        );
      },
      deflateInfo: 'pako deflate (from Nodeca project)',
    },
    jb = function (a) {
      for (var b = Array.prototype.slice.call(arguments, 1); b.length; ) {
        var c = b.shift();
        if (c) {
          if ('object' !== g(c)) throw new TypeError(c + 'must be non-object');
          for (var d in c) Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);
        }
      }
      return a;
    },
    ga = function (a) {
      for (var b = 0, c = 0, d = a.length; c < d; c++) b += a[c].length;
      for (var b = new Uint8Array(b), d = (c = 0), e = a.length; c < e; c++) {
        var f = a[c];
        b.set(f, d);
        d += f.length;
      }
      return b;
    },
    kb = !0;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (Nb) {
    kb = !1;
  }
  for (var aa = new Uint8Array(256), Ha = 0; 256 > Ha; Ha++)
    aa[Ha] = 252 <= Ha ? 6 : 248 <= Ha ? 5 : 240 <= Ha ? 4 : 224 <= Ha ? 3 : 192 <= Ha ? 2 : 1;
  aa[254] = aa[254] = 1;
  var ca = function (a) {
      var b,
        c,
        d,
        e,
        f,
        g = a.length,
        q = 0;
      for (e = 0; e < g; e++)
        55296 == (64512 & (c = a.charCodeAt(e))) &&
          e + 1 < g &&
          56320 == (64512 & (d = a.charCodeAt(e + 1))) &&
          ((c = 65536 + ((c - 55296) << 10) + (d - 56320)), e++),
          (q += 128 > c ? 1 : 2048 > c ? 2 : 65536 > c ? 3 : 4);
      b = new Uint8Array(q);
      for (e = f = 0; f < q; e++)
        55296 == (64512 & (c = a.charCodeAt(e))) &&
          e + 1 < g &&
          56320 == (64512 & (d = a.charCodeAt(e + 1))) &&
          ((c = 65536 + ((c - 55296) << 10) + (d - 56320)), e++),
          128 > c
            ? (b[f++] = c)
            : 2048 > c
            ? ((b[f++] = 192 | (c >>> 6)), (b[f++] = 128 | (63 & c)))
            : 65536 > c
            ? ((b[f++] = 224 | (c >>> 12)), (b[f++] = 128 | ((c >>> 6) & 63)), (b[f++] = 128 | (63 & c)))
            : ((b[f++] = 240 | (c >>> 18)),
              (b[f++] = 128 | ((c >>> 12) & 63)),
              (b[f++] = 128 | ((c >>> 6) & 63)),
              (b[f++] = 128 | (63 & c)));
      return b;
    },
    Ua = function () {
      this.input = null;
      this.total_in = this.avail_in = this.next_in = 0;
      this.output = null;
      this.total_out = this.avail_out = this.next_out = 0;
      this.msg = '';
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    },
    Ya = Object.prototype.toString,
    pb = L.Z_NO_FLUSH,
    Za = L.Z_SYNC_FLUSH,
    Ia = L.Z_FULL_FLUSH,
    W = L.Z_FINISH,
    va = L.Z_OK,
    qb = L.Z_STREAM_END,
    bb = L.Z_DEFAULT_COMPRESSION,
    Na = L.Z_DEFAULT_STRATEGY,
    fb = L.Z_DEFLATED;
  k.prototype.push = function (a, b) {
    var c,
      d,
      e = this.strm,
      f = this.options.chunkSize;
    if (this.ended) return !1;
    d = b === ~~b ? b : !0 === b ? W : pb;
    'string' == typeof a
      ? (e.input = ca(a))
      : '[object ArrayBuffer]' === Ya.call(a)
      ? (e.input = new Uint8Array(a))
      : (e.input = a);
    e.next_in = 0;
    for (e.avail_in = e.input.length; ; )
      if (
        (0 === e.avail_out && ((e.output = new Uint8Array(f)), (e.next_out = 0), (e.avail_out = f)),
        (d === Za || d === Ia) && 6 >= e.avail_out)
      )
        this.onData(e.output.subarray(0, e.next_out)), (e.avail_out = 0);
      else {
        if ((c = Ba.deflate(e, d)) === qb)
          return (
            0 < e.next_out && this.onData(e.output.subarray(0, e.next_out)),
            (c = Ba.deflateEnd(this.strm)),
            this.onEnd(c),
            (this.ended = !0),
            c === va
          );
        if (0 !== e.avail_out)
          if (0 < d && 0 < e.next_out) this.onData(e.output.subarray(0, e.next_out)), (e.avail_out = 0);
          else {
            if (0 === e.avail_in) break;
          }
        else this.onData(e.output);
      }
    return !0;
  };
  k.prototype.onData = function (a) {
    this.chunks.push(a);
  };
  k.prototype.onEnd = function (a) {
    a === va && (this.result = ga(this.chunks));
    this.chunks = [];
    this.err = a;
    this.msg = this.strm.msg;
  };
  var gb = new Uint16Array([
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,
      0, 0,
    ]),
    ub = new Uint8Array([
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,
      16, 72, 78,
    ]),
    q = new Uint16Array([
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
      8193, 12289, 16385, 24577, 0, 0,
    ]),
    w = new Uint8Array([
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
      29, 29, 64, 64,
    ]),
    y = function (a, b, c, d, e, f, g, k) {
      var h,
        A,
        G,
        y,
        l,
        H,
        m,
        oa,
        E = k.bits,
        n,
        ka,
        I,
        F,
        p,
        N,
        r = 0,
        xa,
        V = null,
        t = 0,
        hb = new Uint16Array(16);
      y = new Uint16Array(16);
      var Q = null,
        lb = 0;
      for (n = 0; 15 >= n; n++) hb[n] = 0;
      for (ka = 0; ka < d; ka++) hb[b[c + ka]]++;
      F = E;
      for (I = 15; 1 <= I && 0 === hb[I]; I--);
      if ((F > I && (F = I), 0 === I)) return (e[f++] = 20971520), (e[f++] = 20971520), (k.bits = 1), 0;
      for (E = 1; E < I && 0 === hb[E]; E++);
      F < E && (F = E);
      for (n = h = 1; 15 >= n; n++) if (((h <<= 1), 0 > (h -= hb[n]))) return -1;
      if (0 < h && (0 === a || 1 !== I)) return -1;
      y[1] = 0;
      for (n = 1; 15 > n; n++) y[n + 1] = y[n] + hb[n];
      for (ka = 0; ka < d; ka++) 0 !== b[c + ka] && (g[y[b[c + ka]]++] = ka);
      if (
        (0 === a
          ? ((V = Q = g), (l = 19))
          : 1 === a
          ? ((V = gb), (t -= 257), (Q = ub), (lb -= 257), (l = 256))
          : ((V = q), (Q = w), (l = -1)),
        (xa = 0),
        (ka = 0),
        (n = E),
        (y = f),
        (p = F),
        (N = 0),
        (G = -1),
        (d = (r = 1 << F) - 1),
        (1 === a && 852 < r) || (2 === a && 592 < r))
      )
        return 1;
      for (;;) {
        H = n - N;
        g[ka] < l
          ? ((m = 0), (oa = g[ka]))
          : g[ka] > l
          ? ((m = Q[lb + g[ka]]), (oa = V[t + g[ka]]))
          : ((m = 96), (oa = 0));
        h = 1 << (n - N);
        E = A = 1 << p;
        do e[y + (xa >> N) + (A -= h)] = (H << 24) | (m << 16) | oa | 0;
        while (0 !== A);
        for (h = 1 << (n - 1); xa & h; ) h >>= 1;
        if ((0 !== h ? ((xa &= h - 1), (xa += h)) : (xa = 0), ka++, 0 == --hb[n])) {
          if (n === I) break;
          n = b[c + g[ka]];
        }
        if (n > F && (xa & d) !== G) {
          0 === N && (N = F);
          y += E;
          for (h = 1 << (p = n - N); p + N < I && !(0 >= (h -= hb[p + N])); ) p++, (h <<= 1);
          if (((r += 1 << p), (1 === a && 852 < r) || (2 === a && 592 < r))) return 1;
          e[(G = xa & d)] = (F << 24) | (p << 16) | (y - f) | 0;
        }
      }
      return 0 !== xa && (e[y + xa] = ((n - N) << 24) | 4194304), (k.bits = F), 0;
    },
    A = L.Z_FINISH,
    G = L.Z_BLOCK,
    H = L.Z_TREES,
    oa = L.Z_OK,
    xa = L.Z_STREAM_END,
    ka = L.Z_NEED_DICT,
    wa = L.Z_STREAM_ERROR,
    lb = L.Z_DATA_ERROR,
    Db = L.Z_MEM_ERROR,
    mb = L.Z_BUF_ERROR,
    Eb = L.Z_DEFLATED,
    yb = function (a) {
      return ((a >>> 24) & 255) + ((a >>> 8) & 65280) + ((65280 & a) << 8) + ((255 & a) << 24);
    },
    rb,
    vb,
    na = function (a) {
      if (!a || !a.state) return wa;
      var b = a.state;
      return (
        (a.total_in = a.total_out = b.total = 0),
        (a.msg = ''),
        b.wrap && (a.adler = 1 & b.wrap),
        (b.mode = 1),
        (b.last = 0),
        (b.havedict = 0),
        (b.dmax = 32768),
        (b.head = null),
        (b.hold = 0),
        (b.bits = 0),
        (b.lencode = b.lendyn = new Int32Array(852)),
        (b.distcode = b.distdyn = new Int32Array(592)),
        (b.sane = 1),
        (b.back = -1),
        oa
      );
    },
    sb = function (a) {
      if (!a || !a.state) return wa;
      var b = a.state;
      return (b.wsize = 0), (b.whave = 0), (b.wnext = 0), na(a);
    },
    wb = function (a, b) {
      var c;
      if (!a || !a.state) return wa;
      var d = a.state;
      return (
        0 > b ? ((c = 0), (b = -b)) : ((c = 1 + (b >> 4)), 48 > b && (b &= 15)),
        b && (8 > b || 15 < b)
          ? wa
          : (null !== d.window && d.wbits !== b && (d.window = null), (d.wrap = c), (d.wbits = b), sb(a))
      );
    },
    Fb = function (a, b) {
      if (!a) return wa;
      var c = new l();
      a.state = c;
      c.window = null;
      c = wb(a, b);
      return c !== oa && (a.state = null), c;
    },
    cb = !0,
    Bb = function (a, b, c, d) {
      var e;
      a = a.state;
      return (
        null === a.window &&
          ((a.wsize = 1 << a.wbits), (a.wnext = 0), (a.whave = 0), (a.window = new Uint8Array(a.wsize))),
        d >= a.wsize
          ? (a.window.set(b.subarray(c - a.wsize, c), 0), (a.wnext = 0), (a.whave = a.wsize))
          : ((e = a.wsize - a.wnext) > d && (e = d),
            a.window.set(b.subarray(c - d, c - d + e), a.wnext),
            (d -= e)
              ? (a.window.set(b.subarray(c - d, c), 0), (a.wnext = d), (a.whave = a.wsize))
              : ((a.wnext += e), a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += e))),
        0
      );
    },
    Va = {
      inflateReset: sb,
      inflateReset2: wb,
      inflateResetKeep: na,
      inflateInit: function (a) {
        return Fb(a, 15);
      },
      inflateInit2: Fb,
      inflate: function (a, b) {
        var c,
          d,
          e,
          f,
          g,
          q,
          k,
          h,
          w,
          l,
          m,
          E,
          n,
          I,
          F,
          p,
          N,
          r,
          V,
          t,
          Q,
          u,
          v = 0,
          X = new Uint8Array(4),
          x = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (!a || !a.state || !a.output || (!a.input && 0 !== a.avail_in)) return wa;
        12 === (c = a.state).mode && (c.mode = 13);
        g = a.next_out;
        e = a.output;
        k = a.avail_out;
        f = a.next_in;
        d = a.input;
        q = a.avail_in;
        h = c.hold;
        w = c.bits;
        l = q;
        m = k;
        Q = oa;
        a: for (;;)
          switch (c.mode) {
            case 1:
              if (0 === c.wrap) {
                c.mode = 13;
                break;
              }
              for (; 16 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if (2 & c.wrap && 35615 === h) {
                c.check = 0;
                X[0] = 255 & h;
                X[1] = (h >>> 8) & 255;
                c.check = Z(c.check, X, 2, 0);
                w = h = 0;
                c.mode = 2;
                break;
              }
              if (((c.flags = 0), c.head && (c.head.done = !1), !(1 & c.wrap) || (((255 & h) << 8) + (h >> 8)) % 31)) {
                a.msg = 'incorrect header check';
                c.mode = 30;
                break;
              }
              if ((15 & h) !== Eb) {
                a.msg = 'unknown compression method';
                c.mode = 30;
                break;
              }
              if (((w -= 4), (t = 8 + (15 & (h >>>= 4))), 0 === c.wbits)) c.wbits = t;
              else if (t > c.wbits) {
                a.msg = 'invalid window size';
                c.mode = 30;
                break;
              }
              c.dmax = 1 << c.wbits;
              a.adler = c.check = 1;
              c.mode = 512 & h ? 10 : 12;
              w = h = 0;
              break;
            case 2:
              for (; 16 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if (((c.flags = h), (255 & c.flags) !== Eb)) {
                a.msg = 'unknown compression method';
                c.mode = 30;
                break;
              }
              if (57344 & c.flags) {
                a.msg = 'unknown header flags set';
                c.mode = 30;
                break;
              }
              c.head && (c.head.text = (h >> 8) & 1);
              512 & c.flags && ((X[0] = 255 & h), (X[1] = (h >>> 8) & 255), (c.check = Z(c.check, X, 2, 0)));
              w = h = 0;
              c.mode = 3;
            case 3:
              for (; 32 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              c.head && (c.head.time = h);
              512 & c.flags &&
                ((X[0] = 255 & h),
                (X[1] = (h >>> 8) & 255),
                (X[2] = (h >>> 16) & 255),
                (X[3] = (h >>> 24) & 255),
                (c.check = Z(c.check, X, 4, 0)));
              w = h = 0;
              c.mode = 4;
            case 4:
              for (; 16 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              c.head && ((c.head.xflags = 255 & h), (c.head.os = h >> 8));
              512 & c.flags && ((X[0] = 255 & h), (X[1] = (h >>> 8) & 255), (c.check = Z(c.check, X, 2, 0)));
              w = h = 0;
              c.mode = 5;
            case 5:
              if (1024 & c.flags) {
                for (; 16 > w; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                c.length = h;
                c.head && (c.head.extra_len = h);
                512 & c.flags && ((X[0] = 255 & h), (X[1] = (h >>> 8) & 255), (c.check = Z(c.check, X, 2, 0)));
                w = h = 0;
              } else c.head && (c.head.extra = null);
              c.mode = 6;
            case 6:
              if (
                1024 & c.flags &&
                ((E = c.length) > q && (E = q),
                E &&
                  (c.head &&
                    ((t = c.head.extra_len - c.length),
                    c.head.extra || (c.head.extra = new Uint8Array(c.head.extra_len)),
                    c.head.extra.set(d.subarray(f, f + E), t)),
                  512 & c.flags && (c.check = Z(c.check, d, E, f)),
                  (q -= E),
                  (f += E),
                  (c.length -= E)),
                c.length)
              )
                break a;
              c.length = 0;
              c.mode = 7;
            case 7:
              if (2048 & c.flags) {
                if (0 === q) break a;
                E = 0;
                do (t = d[f + E++]), c.head && t && 65536 > c.length && (c.head.name += String.fromCharCode(t));
                while (t && E < q);
                if ((512 & c.flags && (c.check = Z(c.check, d, E, f)), (q -= E), (f += E), t)) break a;
              } else c.head && (c.head.name = null);
              c.length = 0;
              c.mode = 8;
            case 8:
              if (4096 & c.flags) {
                if (0 === q) break a;
                E = 0;
                do (t = d[f + E++]), c.head && t && 65536 > c.length && (c.head.comment += String.fromCharCode(t));
                while (t && E < q);
                if ((512 & c.flags && (c.check = Z(c.check, d, E, f)), (q -= E), (f += E), t)) break a;
              } else c.head && (c.head.comment = null);
              c.mode = 9;
            case 9:
              if (512 & c.flags) {
                for (; 16 > w; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                if (h !== (65535 & c.check)) {
                  a.msg = 'header crc mismatch';
                  c.mode = 30;
                  break;
                }
                w = h = 0;
              }
              c.head && ((c.head.hcrc = (c.flags >> 9) & 1), (c.head.done = !0));
              a.adler = c.check = 0;
              c.mode = 12;
              break;
            case 10:
              for (; 32 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              a.adler = c.check = yb(h);
              w = h = 0;
              c.mode = 11;
            case 11:
              if (0 === c.havedict)
                return (
                  (a.next_out = g), (a.avail_out = k), (a.next_in = f), (a.avail_in = q), (c.hold = h), (c.bits = w), ka
                );
              a.adler = c.check = 1;
              c.mode = 12;
            case 12:
              if (b === G || b === H) break a;
            case 13:
              if (c.last) {
                h >>>= 7 & w;
                w -= 7 & w;
                c.mode = 27;
                break;
              }
              for (; 3 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              switch (((c.last = 1 & h), --w, 3 & (h >>>= 1))) {
                case 0:
                  c.mode = 14;
                  break;
                case 1:
                  I = c;
                  if (cb) {
                    rb = new Int32Array(512);
                    vb = new Int32Array(32);
                    for (F = 0; 144 > F; ) I.lens[F++] = 8;
                    for (; 256 > F; ) I.lens[F++] = 9;
                    for (; 280 > F; ) I.lens[F++] = 7;
                    for (; 288 > F; ) I.lens[F++] = 8;
                    y(1, I.lens, 0, 288, rb, 0, I.work, { bits: 9 });
                    for (F = 0; 32 > F; ) I.lens[F++] = 5;
                    y(2, I.lens, 0, 32, vb, 0, I.work, { bits: 5 });
                    cb = !1;
                  }
                  I.lencode = rb;
                  I.lenbits = 9;
                  I.distcode = vb;
                  I.distbits = 5;
                  if (((c.mode = 20), b === H)) {
                    h >>>= 2;
                    w -= 2;
                    break a;
                  }
                  break;
                case 2:
                  c.mode = 17;
                  break;
                case 3:
                  (a.msg = 'invalid block type'), (c.mode = 30);
              }
              h >>>= 2;
              w -= 2;
              break;
            case 14:
              h >>>= 7 & w;
              for (w -= 7 & w; 32 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if ((65535 & h) != ((h >>> 16) ^ 65535)) {
                a.msg = 'invalid stored block lengths';
                c.mode = 30;
                break;
              }
              if (((c.length = 65535 & h), (h = 0), (w = 0), (c.mode = 15), b === H)) break a;
            case 15:
              c.mode = 16;
            case 16:
              if ((E = c.length)) {
                if ((E > q && (E = q), E > k && (E = k), 0 === E)) break a;
                e.set(d.subarray(f, f + E), g);
                q -= E;
                f += E;
                k -= E;
                g += E;
                c.length -= E;
                break;
              }
              c.mode = 12;
              break;
            case 17:
              for (; 14 > w; ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if (
                ((c.nlen = 257 + (31 & h)),
                (h >>>= 5),
                (w -= 5),
                (c.ndist = 1 + (31 & h)),
                (h >>>= 5),
                (w -= 5),
                (c.ncode = 4 + (15 & h)),
                (h >>>= 4),
                (w -= 4),
                286 < c.nlen || 30 < c.ndist)
              ) {
                a.msg = 'too many length or distance symbols';
                c.mode = 30;
                break;
              }
              c.have = 0;
              c.mode = 18;
            case 18:
              for (; c.have < c.ncode; ) {
                for (; 3 > w; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                c.lens[x[c.have++]] = 7 & h;
                h >>>= 3;
                w -= 3;
              }
              for (; 19 > c.have; ) c.lens[x[c.have++]] = 0;
              if (
                ((c.lencode = c.lendyn),
                (c.lenbits = 7),
                (u = { bits: c.lenbits }),
                (Q = y(0, c.lens, 0, 19, c.lencode, 0, c.work, u)),
                (c.lenbits = u.bits),
                Q)
              ) {
                a.msg = 'invalid code lengths set';
                c.mode = 30;
                break;
              }
              c.have = 0;
              c.mode = 19;
            case 19:
              for (; c.have < c.nlen + c.ndist; ) {
                for (; (v = c.lencode[h & ((1 << c.lenbits) - 1)]), (p = 65535 & v), !((I = v >>> 24) <= w); ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                if (16 > p) (h >>>= I), (w -= I), (c.lens[c.have++] = p);
                else {
                  if (16 === p) {
                    for (F = I + 2; w < F; ) {
                      if (0 === q) break a;
                      q--;
                      h += d[f++] << w;
                      w += 8;
                    }
                    if (((h >>>= I), (w -= I), 0 === c.have)) {
                      a.msg = 'invalid bit length repeat';
                      c.mode = 30;
                      break;
                    }
                    t = c.lens[c.have - 1];
                    E = 3 + (3 & h);
                    h >>>= 2;
                    w -= 2;
                  } else if (17 === p) {
                    for (F = I + 3; w < F; ) {
                      if (0 === q) break a;
                      q--;
                      h += d[f++] << w;
                      w += 8;
                    }
                    w -= I;
                    t = 0;
                    E = 3 + (7 & (h >>>= I));
                    h >>>= 3;
                    w -= 3;
                  } else {
                    for (F = I + 7; w < F; ) {
                      if (0 === q) break a;
                      q--;
                      h += d[f++] << w;
                      w += 8;
                    }
                    w -= I;
                    t = 0;
                    E = 11 + (127 & (h >>>= I));
                    h >>>= 7;
                    w -= 7;
                  }
                  if (c.have + E > c.nlen + c.ndist) {
                    a.msg = 'invalid bit length repeat';
                    c.mode = 30;
                    break;
                  }
                  for (; E--; ) c.lens[c.have++] = t;
                }
              }
              if (30 === c.mode) break;
              if (0 === c.lens[256]) {
                a.msg = 'invalid code -- missing end-of-block';
                c.mode = 30;
                break;
              }
              if (
                ((c.lenbits = 9),
                (u = { bits: c.lenbits }),
                (Q = y(1, c.lens, 0, c.nlen, c.lencode, 0, c.work, u)),
                (c.lenbits = u.bits),
                Q)
              ) {
                a.msg = 'invalid literal/lengths set';
                c.mode = 30;
                break;
              }
              if (
                ((c.distbits = 6),
                (c.distcode = c.distdyn),
                (u = { bits: c.distbits }),
                (Q = y(2, c.lens, c.nlen, c.ndist, c.distcode, 0, c.work, u)),
                (c.distbits = u.bits),
                Q)
              ) {
                a.msg = 'invalid distances set';
                c.mode = 30;
                break;
              }
              if (((c.mode = 20), b === H)) break a;
            case 20:
              c.mode = 21;
            case 21:
              if (6 <= q && 258 <= k) {
                a.next_out = g;
                a.avail_out = k;
                a.next_in = f;
                a.avail_in = q;
                c.hold = h;
                c.bits = w;
                var C, z;
                q = f = void 0;
                var B,
                  Y,
                  Qa,
                  da,
                  P,
                  Ga,
                  na,
                  ja = a,
                  D = ja.state;
                na = ja.next_in;
                e = ja.input;
                Ga = na + (ja.avail_in - 5);
                P = ja.next_out;
                d = ja.output;
                da = P - (m - ja.avail_out);
                Qa = P + (ja.avail_out - 257);
                Y = D.dmax;
                B = D.wsize;
                V = D.whave;
                r = D.wnext;
                N = D.window;
                p = D.hold;
                F = D.bits;
                I = D.lencode;
                w = D.distcode;
                h = (1 << D.lenbits) - 1;
                k = (1 << D.distbits) - 1;
                b: do
                  c: for (15 > F && ((p += e[na++] << F), (F += 8), (p += e[na++] << F), (F += 8)), C = I[p & h]; ; ) {
                    if (((p >>>= q = C >>> 24), (F -= q), 0 === (q = (C >>> 16) & 255))) d[P++] = 65535 & C;
                    else {
                      if (!(16 & q)) {
                        if (0 == (64 & q)) {
                          C = I[(65535 & C) + (p & ((1 << q) - 1))];
                          continue c;
                        }
                        if (32 & q) {
                          D.mode = 12;
                          break b;
                        }
                        ja.msg = 'invalid literal/length code';
                        D.mode = 30;
                        break b;
                      }
                      g = 65535 & C;
                      (q &= 15) &&
                        (F < q && ((p += e[na++] << F), (F += 8)), (g += p & ((1 << q) - 1)), (p >>>= q), (F -= q));
                      15 > F && ((p += e[na++] << F), (F += 8), (p += e[na++] << F), (F += 8));
                      C = w[p & k];
                      d: for (;;) {
                        if (((p >>>= q = C >>> 24), (F -= q), !(16 & (q = (C >>> 16) & 255)))) {
                          if (0 == (64 & q)) {
                            C = w[(65535 & C) + (p & ((1 << q) - 1))];
                            continue d;
                          }
                          ja.msg = 'invalid distance code';
                          D.mode = 30;
                          break b;
                        }
                        if (
                          ((f = 65535 & C),
                          F < (q &= 15) && ((p += e[na++] << F), (F += 8) < q && ((p += e[na++] << F), (F += 8))),
                          (f += p & ((1 << q) - 1)) > Y)
                        ) {
                          ja.msg = 'invalid distance too far back';
                          D.mode = 30;
                          break b;
                        }
                        if (((p >>>= q), (F -= q), f > (q = P - da))) {
                          if ((q = f - q) > V && D.sane) {
                            ja.msg = 'invalid distance too far back';
                            D.mode = 30;
                            break b;
                          }
                          if (((z = 0), (C = N), 0 === r)) {
                            if (((z += B - q), q < g)) {
                              g -= q;
                              do d[P++] = N[z++];
                              while (--q);
                              z = P - f;
                              C = d;
                            }
                          } else if (r < q) {
                            if (((z += B + r - q), (q -= r) < g)) {
                              g -= q;
                              do d[P++] = N[z++];
                              while (--q);
                              if (((z = 0), r < g)) {
                                g -= q = r;
                                do d[P++] = N[z++];
                                while (--q);
                                z = P - f;
                                C = d;
                              }
                            }
                          } else if (((z += r - q), q < g)) {
                            g -= q;
                            do d[P++] = N[z++];
                            while (--q);
                            z = P - f;
                            C = d;
                          }
                          for (; 2 < g; ) (d[P++] = C[z++]), (d[P++] = C[z++]), (d[P++] = C[z++]), (g -= 3);
                          g && ((d[P++] = C[z++]), 1 < g && (d[P++] = C[z++]));
                        } else {
                          z = P - f;
                          do (d[P++] = d[z++]), (d[P++] = d[z++]), (d[P++] = d[z++]), (g -= 3);
                          while (2 < g);
                          g && ((d[P++] = d[z++]), 1 < g && (d[P++] = d[z++]));
                        }
                        break;
                      }
                    }
                    break;
                  }
                while (na < Ga && P < Qa);
                na -= g = F >> 3;
                p &= (1 << (F -= g << 3)) - 1;
                ja.next_in = na;
                ja.next_out = P;
                ja.avail_in = na < Ga ? Ga - na + 5 : 5 - (na - Ga);
                ja.avail_out = P < Qa ? Qa - P + 257 : 257 - (P - Qa);
                D.hold = p;
                D.bits = F;
                g = a.next_out;
                e = a.output;
                k = a.avail_out;
                f = a.next_in;
                d = a.input;
                q = a.avail_in;
                h = c.hold;
                w = c.bits;
                12 === c.mode && (c.back = -1);
                break;
              }
              for (
                c.back = 0;
                (F = ((v = c.lencode[h & ((1 << c.lenbits) - 1)]) >>> 16) & 255),
                  (p = 65535 & v),
                  !((I = v >>> 24) <= w);

              ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if (F && 0 == (240 & F)) {
                N = I;
                r = F;
                for (
                  V = p;
                  (F = ((v = c.lencode[V + ((h & ((1 << (N + r)) - 1)) >> N)]) >>> 16) & 255),
                    (p = 65535 & v),
                    !(N + (I = v >>> 24) <= w);

                ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                h >>>= N;
                w -= N;
                c.back += N;
              }
              if (((h >>>= I), (w -= I), (c.back += I), (c.length = p), 0 === F)) {
                c.mode = 26;
                break;
              }
              if (32 & F) {
                c.back = -1;
                c.mode = 12;
                break;
              }
              if (64 & F) {
                a.msg = 'invalid literal/length code';
                c.mode = 30;
                break;
              }
              c.extra = 15 & F;
              c.mode = 22;
            case 22:
              if (c.extra) {
                for (F = c.extra; w < F; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                c.length += h & ((1 << c.extra) - 1);
                h >>>= c.extra;
                w -= c.extra;
                c.back += c.extra;
              }
              c.was = c.length;
              c.mode = 23;
            case 23:
              for (
                ;
                (F = ((v = c.distcode[h & ((1 << c.distbits) - 1)]) >>> 16) & 255),
                  (p = 65535 & v),
                  !((I = v >>> 24) <= w);

              ) {
                if (0 === q) break a;
                q--;
                h += d[f++] << w;
                w += 8;
              }
              if (0 == (240 & F)) {
                N = I;
                r = F;
                for (
                  V = p;
                  (F = ((v = c.distcode[V + ((h & ((1 << (N + r)) - 1)) >> N)]) >>> 16) & 255),
                    (p = 65535 & v),
                    !(N + (I = v >>> 24) <= w);

                ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                h >>>= N;
                w -= N;
                c.back += N;
              }
              if (((h >>>= I), (w -= I), (c.back += I), 64 & F)) {
                a.msg = 'invalid distance code';
                c.mode = 30;
                break;
              }
              c.offset = p;
              c.extra = 15 & F;
              c.mode = 24;
            case 24:
              if (c.extra) {
                for (F = c.extra; w < F; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                c.offset += h & ((1 << c.extra) - 1);
                h >>>= c.extra;
                w -= c.extra;
                c.back += c.extra;
              }
              if (c.offset > c.dmax) {
                a.msg = 'invalid distance too far back';
                c.mode = 30;
                break;
              }
              c.mode = 25;
            case 25:
              if (0 === k) break a;
              if (((E = m - k), c.offset > E)) {
                if ((E = c.offset - E) > c.whave && c.sane) {
                  a.msg = 'invalid distance too far back';
                  c.mode = 30;
                  break;
                }
                E > c.wnext ? ((E -= c.wnext), (n = c.wsize - E)) : (n = c.wnext - E);
                E > c.length && (E = c.length);
                I = c.window;
              } else (I = e), (n = g - c.offset), (E = c.length);
              E > k && (E = k);
              k -= E;
              c.length -= E;
              do e[g++] = I[n++];
              while (--E);
              0 === c.length && (c.mode = 21);
              break;
            case 26:
              if (0 === k) break a;
              e[g++] = c.length;
              k--;
              c.mode = 21;
              break;
            case 27:
              if (c.wrap) {
                for (; 32 > w; ) {
                  if (0 === q) break a;
                  q--;
                  h |= d[f++] << w;
                  w += 8;
                }
                if (
                  ((m -= k),
                  (a.total_out += m),
                  (c.total += m),
                  m && (a.adler = c.check = c.flags ? Z(c.check, e, m, g - m) : ua(c.check, e, m, g - m)),
                  (m = k),
                  (c.flags ? h : yb(h)) !== c.check)
                ) {
                  a.msg = 'incorrect data check';
                  c.mode = 30;
                  break;
                }
                w = h = 0;
              }
              c.mode = 28;
            case 28:
              if (c.wrap && c.flags) {
                for (; 32 > w; ) {
                  if (0 === q) break a;
                  q--;
                  h += d[f++] << w;
                  w += 8;
                }
                if (h !== (4294967295 & c.total)) {
                  a.msg = 'incorrect length check';
                  c.mode = 30;
                  break;
                }
                w = h = 0;
              }
              c.mode = 29;
            case 29:
              Q = xa;
              break a;
            case 30:
              Q = lb;
              break a;
            case 31:
              return Db;
            default:
              return wa;
          }
        return (
          (a.next_out = g),
          (a.avail_out = k),
          (a.next_in = f),
          (a.avail_in = q),
          (c.hold = h),
          (c.bits = w),
          (c.wsize || (m !== a.avail_out && 30 > c.mode && (27 > c.mode || b !== A))) &&
            Bb(a, a.output, a.next_out, m - a.avail_out),
          (l -= a.avail_in),
          (m -= a.avail_out),
          (a.total_in += l),
          (a.total_out += m),
          (c.total += m),
          c.wrap &&
            m &&
            (a.adler = c.check = c.flags ? Z(c.check, e, m, a.next_out - m) : ua(c.check, e, m, a.next_out - m)),
          (a.data_type =
            c.bits + (c.last ? 64 : 0) + (12 === c.mode ? 128 : 0) + (20 === c.mode || 15 === c.mode ? 256 : 0)),
          ((0 === l && 0 === m) || b === A) && Q === oa && (Q = mb),
          Q
        );
      },
      inflateEnd: function (a) {
        if (!a || !a.state) return wa;
        var b = a.state;
        return b.window && (b.window = null), (a.state = null), oa;
      },
      inflateGetHeader: function (a, b) {
        if (!a || !a.state) return wa;
        var c = a.state;
        return 0 == (2 & c.wrap) ? wa : ((c.head = b), (b.done = !1), oa);
      },
      inflateSetDictionary: function (a, b) {
        var c,
          d = b.length;
        return a && a.state
          ? 0 !== (c = a.state).wrap && 11 !== c.mode
            ? wa
            : 11 === c.mode && ua(1, b, d, 0) !== c.check
            ? lb
            : Bb(a, b, d, d)
            ? ((c.mode = 31), Db)
            : ((c.havedict = 1), oa)
          : wa;
      },
      inflateInfo: 'pako inflate (from Nodeca project)',
    },
    Hb = function () {
      this.os = this.xflags = this.time = this.text = 0;
      this.extra = null;
      this.extra_len = 0;
      this.comment = this.name = '';
      this.hcrc = 0;
      this.done = !1;
    },
    nb = Object.prototype.toString,
    $a = L.Z_NO_FLUSH,
    Ib = L.Z_FINISH,
    ob = L.Z_OK,
    xb = L.Z_STREAM_END,
    Cb = L.Z_NEED_DICT,
    Jb = L.Z_STREAM_ERROR,
    zb = L.Z_DATA_ERROR,
    Ab = L.Z_MEM_ERROR;
  m.prototype.push = function (a, b) {
    var c,
      d,
      e,
      f = this.strm,
      g = this.options.chunkSize,
      q = this.options.dictionary;
    if (this.ended) return !1;
    d = b === ~~b ? b : !0 === b ? Ib : $a;
    '[object ArrayBuffer]' === nb.call(a) ? (f.input = new Uint8Array(a)) : (f.input = a);
    f.next_in = 0;
    for (f.avail_in = f.input.length; ; ) {
      0 === f.avail_out && ((f.output = new Uint8Array(g)), (f.next_out = 0), (f.avail_out = g));
      for (
        (c = Va.inflate(f, d)) === Cb &&
        q &&
        ((c = Va.inflateSetDictionary(f, q)) === ob ? (c = Va.inflate(f, d)) : c === zb && (c = Cb));
        0 < f.avail_in && c === xb && 0 < f.state.wrap && 0 !== a[f.next_in];

      )
        Va.inflateReset(f), (c = Va.inflate(f, d));
      switch (c) {
        case Jb:
        case zb:
        case Cb:
        case Ab:
          return this.onEnd(c), (this.ended = !0), !1;
      }
      if (((e = f.avail_out), f.next_out && (0 === f.avail_out || c === xb)))
        if ('string' === this.options.to) {
          var k;
          k = f.output;
          var h = f.next_out;
          (h = h || k.length) > k.length && (h = k.length);
          for (var w = h - 1; 0 <= w && 128 == (192 & k[w]); ) w--;
          k = 0 > w || 0 === w ? h : w + aa[k[w]] > h ? w : h;
          var h = f.next_out - k,
            A,
            G,
            y = f.output,
            l = k || y.length,
            w = Array(2 * l);
          for (G = A = 0; G < l; ) {
            var H = y[G++];
            if (128 > H) w[A++] = H;
            else {
              var m = aa[H];
              if (4 < m) (w[A++] = 65533), (G += m - 1);
              else {
                for (H &= 2 === m ? 31 : 3 === m ? 15 : 7; 1 < m && G < l; ) (H = (H << 6) | (63 & y[G++])), m--;
                1 < m
                  ? (w[A++] = 65533)
                  : 65536 > H
                  ? (w[A++] = H)
                  : ((H -= 65536), (w[A++] = 55296 | ((H >> 10) & 1023)), (w[A++] = 56320 | (1023 & H)));
              }
            }
          }
          if (65534 > A && w.subarray && kb) w = String.fromCharCode.apply(null, w.length === A ? w : w.subarray(0, A));
          else {
            G = '';
            for (y = 0; y < A; y++) G += String.fromCharCode(w[y]);
            w = G;
          }
          f.next_out = h;
          f.avail_out = g - h;
          h && f.output.set(f.output.subarray(k, k + h), 0);
          this.onData(w);
        } else this.onData(f.output.length === f.next_out ? f.output : f.output.subarray(0, f.next_out));
      if (c !== ob || 0 !== e) {
        if (c === xb) return (c = Va.inflateEnd(this.strm)), this.onEnd(c), (this.ended = !0), !0;
        if (0 === f.avail_in) break;
      }
    }
    return !0;
  };
  m.prototype.onData = function (a) {
    this.chunks.push(a);
  };
  m.prototype.onEnd = function (a) {
    a === ob && ('string' === this.options.to ? (this.result = this.chunks.join('')) : (this.result = ga(this.chunks)));
    this.chunks = [];
    this.err = a;
    this.msg = this.strm.msg;
  };
  var Kb = function (a, b) {
      return ((b = b || {}).raw = !0), h(a, b);
    },
    Gb = function (a, b) {
      return ((b = b || {}).gzip = !0), h(a, b);
    },
    Lb = function (a, b) {
      return ((b = b || {}).raw = !0), n(a, b);
    },
    Mb = {
      Deflate: k,
      deflate: h,
      deflateRaw: Kb,
      gzip: Gb,
      Inflate: m,
      inflate: n,
      inflateRaw: Lb,
      ungzip: n,
      constants: L,
    };
  a.Deflate = k;
  a.Inflate = m;
  a.constants = L;
  a['default'] = Mb;
  a.deflate = h;
  a.deflateRaw = Kb;
  a.gzip = Gb;
  a.inflate = n;
  a.inflateRaw = Lb;
  a.ungzip = n;
  Object.defineProperty(a, '__esModule', { value: !0 });
});
'undefined' === typeof window.mxBasePath &&
  ((window.mxBasePath = 'https://viewer.diagrams.net/mxgraph/'),
  (window.mxImageBasePath = 'https://viewer.diagrams.net/mxgraph/images'));
window.mxLoadStylesheets = window.mxLoadStylesheets || !1;
window.mxLoadResources = window.mxLoadResources || !1;
window.mxLanguage = window.mxLanguage || 'en';
window.urlParams = window.urlParams || {};
window.MAX_REQUEST_SIZE = window.MAX_REQUEST_SIZE || 10485760;
window.MAX_AREA = window.MAX_AREA || 225e6;
window.EXPORT_URL = window.EXPORT_URL || '/export';
window.SAVE_URL = window.SAVE_URL || '/save';
window.OPEN_URL = window.OPEN_URL || '/open';
window.RESOURCES_PATH = window.RESOURCES_PATH || 'resources';
window.RESOURCE_BASE = window.RESOURCE_BASE || window.RESOURCES_PATH + '/grapheditor';
window.STENCIL_PATH = window.STENCIL_PATH || 'stencils';
window.IMAGE_PATH = window.IMAGE_PATH || 'images';
window.STYLE_PATH = window.STYLE_PATH || 'styles';
window.CSS_PATH = window.CSS_PATH || 'styles';
window.OPEN_FORM = window.OPEN_FORM || 'open.html';
window.mxBasePath = window.mxBasePath || 'mxgraph';
window.mxImageBasePath = window.mxImageBasePath || 'mxgraph/images';
window.mxLanguage = window.mxLanguage || urlParams.lang;
window.mxLanguages = window.mxLanguages || ['de', 'se'];
var mxClient = {
  VERSION: '18.0.2',
  IS_IE: null != navigator.userAgent && 0 <= navigator.userAgent.indexOf('MSIE'),
  IS_IE11: null != navigator.userAgent && !!navigator.userAgent.match(/Trident\/7\./),
  IS_EDGE: null != navigator.userAgent && !!navigator.userAgent.match(/Edge\//),
  IS_EM: 'spellcheck' in document.createElement('textarea') && 8 == document.documentMode,
  VML_PREFIX: 'v',
  OFFICE_PREFIX: 'o',
  IS_NS:
    null != navigator.userAgent &&
    0 <= navigator.userAgent.indexOf('Mozilla/') &&
    0 > navigator.userAgent.indexOf('MSIE') &&
    0 > navigator.userAgent.indexOf('Edge/'),
  IS_OP:
    null != navigator.userAgent &&
    (0 <= navigator.userAgent.indexOf('Opera/') || 0 <= navigator.userAgent.indexOf('OPR/')),
  IS_OT:
    null != navigator.userAgent &&
    0 <= navigator.userAgent.indexOf('Presto/') &&
    0 > navigator.userAgent.indexOf('Presto/2.4.') &&
    0 > navigator.userAgent.indexOf('Presto/2.3.') &&
    0 > navigator.userAgent.indexOf('Presto/2.2.') &&
    0 > navigator.userAgent.indexOf('Presto/2.1.') &&
    0 > navigator.userAgent.indexOf('Presto/2.0.') &&
    0 > navigator.userAgent.indexOf('Presto/1.'),
  IS_SF: /Apple Computer, Inc/.test(navigator.vendor),
  IS_ANDROID: 0 <= navigator.appVersion.indexOf('Android'),
  IS_IOS:
    /iP(hone|od|ad)/.test(navigator.platform) ||
    (navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints),
  IS_WEBVIEW: /((iPhone|iPod|iPad).*AppleWebKit(?!.*Version)|; wv)/i.test(navigator.userAgent),
  IS_GC: /Google Inc/.test(navigator.vendor),
  IS_CHROMEAPP: null != window.chrome && null != chrome.app && null != chrome.app.runtime,
  IS_FF: 'undefined' !== typeof InstallTrigger,
  IS_MT:
    (0 <= navigator.userAgent.indexOf('Firefox/') &&
      0 > navigator.userAgent.indexOf('Firefox/1.') &&
      0 > navigator.userAgent.indexOf('Firefox/2.')) ||
    (0 <= navigator.userAgent.indexOf('Iceweasel/') &&
      0 > navigator.userAgent.indexOf('Iceweasel/1.') &&
      0 > navigator.userAgent.indexOf('Iceweasel/2.')) ||
    (0 <= navigator.userAgent.indexOf('SeaMonkey/') && 0 > navigator.userAgent.indexOf('SeaMonkey/1.')) ||
    (0 <= navigator.userAgent.indexOf('Iceape/') && 0 > navigator.userAgent.indexOf('Iceape/1.')),
  IS_SVG: 'MICROSOFT INTERNET EXPLORER' != navigator.appName.toUpperCase(),
  NO_FO:
    !document.createElementNS ||
    '[object SVGForeignObjectElement]' !==
      document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject').toString() ||
    0 <= navigator.userAgent.indexOf('Opera/'),
  IS_WIN: 0 < navigator.appVersion.indexOf('Win'),
  IS_MAC: 0 < navigator.appVersion.indexOf('Mac'),
  IS_CHROMEOS: /\bCrOS\b/.test(navigator.appVersion),
  IS_LINUX: /\bLinux\b/.test(navigator.appVersion),
  IS_TOUCH: 'ontouchstart' in document.documentElement,
  IS_POINTER: null != window.PointerEvent && !(0 < navigator.appVersion.indexOf('Mac')),
  IS_LOCAL: 0 > document.location.href.indexOf('http://') && 0 > document.location.href.indexOf('https://'),
  defaultBundles: [],
  isBrowserSupported: function () {
    return mxClient.IS_SVG;
  },
  link: function (a, b, c, d) {
    c = c || document;
    var e = c.createElement('link');
    e.setAttribute('rel', a);
    e.setAttribute('href', b);
    e.setAttribute('charset', 'UTF-8');
    e.setAttribute('type', 'text/css');
    d && e.setAttribute('id', d);
    c.getElementsByTagName('head')[0].appendChild(e);
  },
  loadResources: function (a, b) {
    function c() {
      0 == --d && a();
    }
    for (var d = mxClient.defaultBundles.length, e = 0; e < mxClient.defaultBundles.length; e++)
      mxResources.add(mxClient.defaultBundles[e], b, c);
  },
  include: function (a) {
    document.write('<script src="' + a + '">\x3c/script>');
  },
};
'undefined' == typeof mxLoadResources && (mxLoadResources = !0);
'undefined' == typeof mxForceIncludes && (mxForceIncludes = !1);
'undefined' == typeof mxResourceExtension && (mxResourceExtension = '.txt');
'undefined' == typeof mxLoadStylesheets && (mxLoadStylesheets = !0);
'undefined' != typeof mxBasePath && 0 < mxBasePath.length
  ? ('/' == mxBasePath.substring(mxBasePath.length - 1) &&
      (mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1)),
    (mxClient.basePath = mxBasePath))
  : (mxClient.basePath = '.');
'undefined' != typeof mxImageBasePath && 0 < mxImageBasePath.length
  ? ('/' == mxImageBasePath.substring(mxImageBasePath.length - 1) &&
      (mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1)),
    (mxClient.imageBasePath = mxImageBasePath))
  : (mxClient.imageBasePath = 'images');
mxClient.language =
  'undefined' != typeof mxLanguage && null != mxLanguage
    ? mxLanguage
    : mxClient.IS_IE
    ? navigator.userLanguage
    : navigator.language;
mxClient.defaultLanguage =
  'undefined' != typeof mxDefaultLanguage && null != mxDefaultLanguage ? mxDefaultLanguage : 'en';
mxLoadStylesheets && mxClient.link('stylesheet', 'mxgraph/css/common.css');
'undefined' != typeof mxLanguages && null != mxLanguages && (mxClient.languages = mxLanguages);
var mxLog = {
    consoleName: 'Console',
    TRACE: !1,
    DEBUG: !0,
    WARN: !0,
    buffer: '',
    init: function () {
      if (null == mxLog.window && null != document.body) {
        var a = mxLog.consoleName + ' - mxGraph ' + mxClient.VERSION,
          b = document.createElement('table');
        b.setAttribute('width', '100%');
        b.setAttribute('height', '100%');
        var c = document.createElement('tbody'),
          d = document.createElement('tr'),
          e = document.createElement('td');
        e.style.verticalAlign = 'top';
        mxLog.textarea = document.createElement('textarea');
        mxLog.textarea.setAttribute('wrap', 'off');
        mxLog.textarea.setAttribute('readOnly', 'true');
        mxLog.textarea.style.height = '100%';
        mxLog.textarea.style.resize = 'none';
        mxLog.textarea.value = mxLog.buffer;
        mxLog.textarea.style.width = mxClient.IS_NS && 'BackCompat' != document.compatMode ? '99%' : '100%';
        e.appendChild(mxLog.textarea);
        d.appendChild(e);
        c.appendChild(d);
        d = document.createElement('tr');
        mxLog.td = document.createElement('td');
        mxLog.td.style.verticalAlign = 'top';
        mxLog.td.setAttribute('height', '30px');
        d.appendChild(mxLog.td);
        c.appendChild(d);
        b.appendChild(c);
        mxLog.addButton('Info', function (a) {
          mxLog.info();
        });
        mxLog.addButton('DOM', function (a) {
          a = mxUtils.getInnerHtml(document.body);
          mxLog.debug(a);
        });
        mxLog.addButton('Trace', function (a) {
          mxLog.TRACE = !mxLog.TRACE;
          mxLog.TRACE ? mxLog.debug('Tracing enabled') : mxLog.debug('Tracing disabled');
        });
        mxLog.addButton('Copy', function (a) {
          try {
            mxUtils.copy(mxLog.textarea.value);
          } catch (k) {
            mxUtils.alert(k);
          }
        });
        mxLog.addButton('Show', function (a) {
          try {
            mxUtils.popup(mxLog.textarea.value);
          } catch (k) {
            mxUtils.alert(k);
          }
        });
        mxLog.addButton('Clear', function (a) {
          mxLog.textarea.value = '';
        });
        d = c = 0;
        'number' === typeof window.innerWidth
          ? ((c = window.innerHeight), (d = window.innerWidth))
          : ((c = document.documentElement.clientHeight || document.body.clientHeight),
            (d = document.body.clientWidth));
        mxLog.window = new mxWindow(a, b, Math.max(0, d - 320), Math.max(0, c - 210), 300, 160);
        mxLog.window.setMaximizable(!0);
        mxLog.window.setScrollable(!1);
        mxLog.window.setResizable(!0);
        mxLog.window.setClosable(!0);
        mxLog.window.destroyOnClose = !1;
        if (
          ((mxClient.IS_NS || mxClient.IS_IE) &&
            !mxClient.IS_GC &&
            !mxClient.IS_SF &&
            'BackCompat' != document.compatMode) ||
          11 == document.documentMode
        ) {
          var f = mxLog.window.getElement(),
            a = function (a, b) {
              mxLog.textarea.style.height = Math.max(0, f.offsetHeight - 70) + 'px';
            };
          mxLog.window.addListener(mxEvent.RESIZE_END, a);
          mxLog.window.addListener(mxEvent.MAXIMIZE, a);
          mxLog.window.addListener(mxEvent.NORMALIZE, a);
          mxLog.textarea.style.height = '92px';
        }
      }
    },
    info: function () {
      mxLog.writeln(mxUtils.toString(navigator));
    },
    addButton: function (a, b) {
      var c = document.createElement('button');
      mxUtils.write(c, a);
      mxEvent.addListener(c, 'click', b);
      mxLog.td.appendChild(c);
    },
    isVisible: function () {
      return null != mxLog.window ? mxLog.window.isVisible() : !1;
    },
    show: function () {
      mxLog.setVisible(!0);
    },
    setVisible: function (a) {
      null == mxLog.window && mxLog.init();
      null != mxLog.window && mxLog.window.setVisible(a);
    },
    enter: function (a) {
      if (mxLog.TRACE) return mxLog.writeln('Entering ' + a), new Date().getTime();
    },
    leave: function (a, b) {
      if (mxLog.TRACE) {
        var c = 0 != b ? ' (' + (new Date().getTime() - b) + ' ms)' : '';
        mxLog.writeln('Leaving ' + a + c);
      }
    },
    debug: function () {
      mxLog.DEBUG && mxLog.writeln.apply(this, arguments);
    },
    warn: function () {
      mxLog.WARN && mxLog.writeln.apply(this, arguments);
    },
    write: function () {
      for (var a = '', b = 0; b < arguments.length; b++) (a += arguments[b]), b < arguments.length - 1 && (a += ' ');
      null != mxLog.textarea
        ? ((mxLog.textarea.value += a),
          null != navigator.userAgent &&
            0 <= navigator.userAgent.indexOf('Presto/2.5') &&
            ((mxLog.textarea.style.visibility = 'hidden'), (mxLog.textarea.style.visibility = 'visible')),
          (mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight))
        : (mxLog.buffer += a);
    },
    writeln: function () {
      for (var a = '', b = 0; b < arguments.length; b++) (a += arguments[b]), b < arguments.length - 1 && (a += ' ');
      mxLog.write(a + '\n');
    },
  },
  mxObjectIdentity = {
    FIELD_NAME: 'mxObjectId',
    counter: 0,
    get: function (a) {
      if (null != a) {
        if (null == a[mxObjectIdentity.FIELD_NAME])
          if ('object' === typeof a) {
            var b = mxUtils.getFunctionName(a.constructor);
            a[mxObjectIdentity.FIELD_NAME] = b + '#' + mxObjectIdentity.counter++;
          } else 'function' === typeof a && (a[mxObjectIdentity.FIELD_NAME] = 'Function#' + mxObjectIdentity.counter++);
        return a[mxObjectIdentity.FIELD_NAME];
      }
      return null;
    },
    clear: function (a) {
      ('object' !== typeof a && 'function' !== typeof a) || delete a[mxObjectIdentity.FIELD_NAME];
    },
  };
function mxDictionary() {
  this.clear();
}
mxDictionary.prototype.map = null;
mxDictionary.prototype.clear = function () {
  this.map = {};
};
mxDictionary.prototype.get = function (a) {
  a = mxObjectIdentity.get(a);
  return this.map[a];
};
mxDictionary.prototype.put = function (a, b) {
  var c = mxObjectIdentity.get(a),
    d = this.map[c];
  this.map[c] = b;
  return d;
};
mxDictionary.prototype.remove = function (a) {
  a = mxObjectIdentity.get(a);
  var b = this.map[a];
  delete this.map[a];
  return b;
};
mxDictionary.prototype.getKeys = function () {
  var a = [],
    b;
  for (b in this.map) a.push(b);
  return a;
};
mxDictionary.prototype.getValues = function () {
  var a = [],
    b;
  for (b in this.map) a.push(this.map[b]);
  return a;
};
mxDictionary.prototype.visit = function (a) {
  for (var b in this.map) a(b, this.map[b]);
};
var mxResources = {
  resources: {},
  extension: mxResourceExtension,
  resourcesEncoded: !1,
  loadDefaultBundle: !0,
  loadSpecialBundle: !0,
  isLanguageSupported: function (a) {
    return null != mxClient.languages ? 0 <= mxUtils.indexOf(mxClient.languages, a) : !0;
  },
  getDefaultBundle: function (a, b) {
    return mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(b) ? a + mxResources.extension : null;
  },
  getSpecialBundle: function (a, b) {
    if (null == mxClient.languages || !this.isLanguageSupported(b)) {
      var c = b.indexOf('-');
      0 < c && (b = b.substring(0, c));
    }
    return mxResources.loadSpecialBundle && mxResources.isLanguageSupported(b) && b != mxClient.defaultLanguage
      ? a + '_' + b + mxResources.extension
      : null;
  },
  add: function (a, b, c) {
    b = null != b ? b : null != mxClient.language ? mxClient.language.toLowerCase() : mxConstants.NONE;
    if (b != mxConstants.NONE) {
      var d = mxResources.getDefaultBundle(a, b),
        e = mxResources.getSpecialBundle(a, b),
        f = function () {
          if (null != e)
            if (c)
              mxUtils.get(
                e,
                function (a) {
                  mxResources.parse(a.getText());
                  c();
                },
                function () {
                  c();
                }
              );
            else
              try {
                var a = mxUtils.load(e);
                a.isReady() && mxResources.parse(a.getText());
              } catch (h) {}
          else null != c && c();
        };
      if (null != d)
        if (c)
          mxUtils.get(
            d,
            function (a) {
              mxResources.parse(a.getText());
              f();
            },
            function () {
              f();
            }
          );
        else
          try {
            var g = mxUtils.load(d);
            g.isReady() && mxResources.parse(g.getText());
            f();
          } catch (k) {}
      else f();
    }
  },
  parse: function (a) {
    if (null != a) {
      a = a.split('\n');
      for (var b = 0; b < a.length; b++)
        if ('#' != a[b].charAt(0)) {
          var c = a[b].indexOf('=');
          if (0 < c) {
            var d = a[b].substring(0, c),
              e = a[b].length;
            13 == a[b].charCodeAt(e - 1) && e--;
            c = a[b].substring(c + 1, e);
            this.resourcesEncoded
              ? ((c = c.replace(/\\(?=u[a-fA-F\d]{4})/g, '%')), (mxResources.resources[d] = unescape(c)))
              : (mxResources.resources[d] = c);
          }
        }
    }
  },
  get: function (a, b, c) {
    a = mxResources.resources[a];
    null == a && (a = c);
    null != a && null != b && (a = mxResources.replacePlaceholders(a, b));
    return a;
  },
  replacePlaceholders: function (a, b) {
    for (var c = [], d = null, e = 0; e < a.length; e++) {
      var f = a.charAt(e);
      '{' == f
        ? (d = '')
        : null != d && '}' == f
        ? ((d = parseInt(d) - 1), 0 <= d && d < b.length && c.push(b[d]), (d = null))
        : null != d
        ? (d += f)
        : c.push(f);
    }
    return c.join('');
  },
  loadResources: function (a) {
    mxResources.add(mxClient.basePath + '/resources/editor', null, function () {
      mxResources.add(mxClient.basePath + '/resources/graph', null, a);
    });
  },
};
function mxPoint(a, b) {
  this.x = null != a ? a : 0;
  this.y = null != b ? b : 0;
}
mxPoint.prototype.x = null;
mxPoint.prototype.y = null;
mxPoint.prototype.equals = function (a) {
  return null != a && a.x == this.x && a.y == this.y;
};
mxPoint.prototype.clone = function () {
  return mxUtils.clone(this);
};
function mxRectangle(a, b, c, d) {
  mxPoint.call(this, a, b);
  this.width = null != c ? c : 0;
  this.height = null != d ? d : 0;
}
mxRectangle.prototype = new mxPoint();
mxRectangle.prototype.constructor = mxRectangle;
mxRectangle.prototype.width = null;
mxRectangle.prototype.height = null;
mxRectangle.prototype.setRect = function (a, b, c, d) {
  this.x = a;
  this.y = b;
  this.width = c;
  this.height = d;
};
mxRectangle.prototype.getCenterX = function () {
  return this.x + this.width / 2;
};
mxRectangle.prototype.getCenterY = function () {
  return this.y + this.height / 2;
};
mxRectangle.prototype.add = function (a) {
  if (null != a) {
    var b = Math.min(this.x, a.x),
      c = Math.min(this.y, a.y),
      d = Math.max(this.x + this.width, a.x + a.width);
    a = Math.max(this.y + this.height, a.y + a.height);
    this.x = b;
    this.y = c;
    this.width = d - b;
    this.height = a - c;
  }
};
mxRectangle.prototype.intersect = function (a) {
  if (null != a) {
    var b = this.x + this.width,
      c = a.x + a.width,
      d = this.y + this.height,
      e = a.y + a.height;
    this.x = Math.max(this.x, a.x);
    this.y = Math.max(this.y, a.y);
    this.width = Math.min(b, c) - this.x;
    this.height = Math.min(d, e) - this.y;
  }
};
mxRectangle.prototype.grow = function (a) {
  this.x -= a;
  this.y -= a;
  this.width += 2 * a;
  this.height += 2 * a;
  return this;
};
mxRectangle.prototype.getPoint = function () {
  return new mxPoint(this.x, this.y);
};
mxRectangle.prototype.rotate90 = function () {
  var a = (this.width - this.height) / 2;
  this.x += a;
  this.y -= a;
  a = this.width;
  this.width = this.height;
  this.height = a;
};
mxRectangle.prototype.equals = function (a) {
  return null != a && a.x == this.x && a.y == this.y && a.width == this.width && a.height == this.height;
};
mxRectangle.fromPoint = function (a) {
  return new mxRectangle(a.x, a.y, 0, 0);
};
mxRectangle.fromRectangle = function (a) {
  return new mxRectangle(a.x, a.y, a.width, a.height);
};
var mxUtils = {
    errorResource: 'none' != mxClient.language ? 'error' : '',
    closeResource: 'none' != mxClient.language ? 'close' : '',
    errorImage: mxClient.imageBasePath + '/error.gif',
    removeCursors: function (a) {
      null != a.style && (a.style.cursor = '');
      a = a.childNodes;
      if (null != a) for (var b = a.length, c = 0; c < b; c += 1) mxUtils.removeCursors(a[c]);
    },
    getCurrentStyle: (function () {
      return mxClient.IS_IE && (null == document.documentMode || 9 > document.documentMode)
        ? function (a) {
            return null != a ? a.currentStyle : null;
          }
        : function (a) {
            return null != a ? window.getComputedStyle(a, '') : null;
          };
    })(),
    parseCssNumber: function (a) {
      'thin' == a ? (a = '2') : 'medium' == a ? (a = '4') : 'thick' == a && (a = '6');
      a = parseFloat(a);
      isNaN(a) && (a = 0);
      return a;
    },
    setPrefixedStyle: (function () {
      var a = null;
      mxClient.IS_OT
        ? (a = 'O')
        : mxClient.IS_SF || mxClient.IS_GC
        ? (a = 'Webkit')
        : mxClient.IS_MT
        ? (a = 'Moz')
        : mxClient.IS_IE && 9 <= document.documentMode && 10 > document.documentMode && (a = 'ms');
      return function (b, c, d) {
        b[c] = d;
        null != a && 0 < c.length && ((c = a + c.substring(0, 1).toUpperCase() + c.substring(1)), (b[c] = d));
      };
    })(),
    hasScrollbars: function (a) {
      a = mxUtils.getCurrentStyle(a);
      return null != a && ('scroll' == a.overflow || 'auto' == a.overflow);
    },
    bind: function (a, b) {
      return function () {
        return b.apply(a, arguments);
      };
    },
    eval: function (a) {
      var b = null;
      if (0 <= a.indexOf('function'))
        try {
          eval('var _mxJavaScriptExpression=' + a), (b = _mxJavaScriptExpression), (_mxJavaScriptExpression = null);
        } catch (c) {
          mxLog.warn(c.message + ' while evaluating ' + a);
        }
      else
        try {
          b = eval(a);
        } catch (c) {
          mxLog.warn(c.message + ' while evaluating ' + a);
        }
      return b;
    },
    findNode: function (a, b, c) {
      if (a.nodeType == mxConstants.NODETYPE_ELEMENT) {
        var d = a.getAttribute(b);
        if (null != d && d == c) return a;
      }
      for (a = a.firstChild; null != a; ) {
        d = mxUtils.findNode(a, b, c);
        if (null != d) return d;
        a = a.nextSibling;
      }
      return null;
    },
    getFunctionName: function (a) {
      var b = null;
      null != a &&
        (null != a.name
          ? (b = a.name)
          : ((b = mxUtils.trim(a.toString())),
            /^function\s/.test(b) &&
              ((b = mxUtils.ltrim(b.substring(9))), (a = b.indexOf('(')), 0 < a && (b = b.substring(0, a)))));
      return b;
    },
    indexOf: function (a, b) {
      if (null != a && null != b) for (var c = 0; c < a.length; c++) if (a[c] == b) return c;
      return -1;
    },
    forEach: function (a, b) {
      if (null != a && null != b) for (var c = 0; c < a.length; c++) b(a[c]);
      return a;
    },
    remove: function (a, b) {
      var c = null;
      if ('object' == typeof b)
        for (var d = mxUtils.indexOf(b, a); 0 <= d; ) b.splice(d, 1), (c = a), (d = mxUtils.indexOf(b, a));
      for (var e in b) b[e] == a && (delete b[e], (c = a));
      return c;
    },
    isNode: function (a, b, c, d) {
      return null == a || isNaN(a.nodeType) || (null != b && a.nodeName.toLowerCase() != b.toLowerCase())
        ? !1
        : null == c || a.getAttribute(c) == d;
    },
    isAncestorNode: function (a, b) {
      for (var c = b; null != c; ) {
        if (c == a) return !0;
        c = c.parentNode;
      }
      return !1;
    },
    getChildNodes: function (a, b) {
      b = b || mxConstants.NODETYPE_ELEMENT;
      for (var c = [], d = a.firstChild; null != d; ) d.nodeType == b && c.push(d), (d = d.nextSibling);
      return c;
    },
    importNode: function (a, b, c) {
      return mxClient.IS_IE && (null == document.documentMode || 10 > document.documentMode)
        ? mxUtils.importNodeImplementation(a, b, c)
        : a.importNode(b, c);
    },
    importNodeImplementation: function (a, b, c) {
      switch (b.nodeType) {
        case 1:
          var d = a.createElement(b.nodeName);
          if (b.attributes && 0 < b.attributes.length)
            for (var e = 0; e < b.attributes.length; e++)
              d.setAttribute(b.attributes[e].nodeName, b.getAttribute(b.attributes[e].nodeName));
          if (c && b.childNodes && 0 < b.childNodes.length)
            for (e = 0; e < b.childNodes.length; e++)
              d.appendChild(mxUtils.importNodeImplementation(a, b.childNodes[e], c));
          return d;
        case 3:
        case 4:
        case 8:
          return a.createTextNode(null != b.nodeValue ? b.nodeValue : b.value);
      }
    },
    createXmlDocument: function () {
      var a = null;
      document.implementation &&
        document.implementation.createDocument &&
        (a = document.implementation.createDocument('', '', null));
      return a;
    },
    parseXml: function (a) {
      return new DOMParser().parseFromString(a, 'text/xml');
    },
    clearSelection: (function () {
      return document.selection
        ? function () {
            document.selection.empty();
          }
        : window.getSelection
        ? function () {
            window.getSelection().empty
              ? window.getSelection().empty()
              : window.getSelection().removeAllRanges && window.getSelection().removeAllRanges();
          }
        : function () {};
    })(),
    removeWhitespace: function (a, b) {
      for (var c = b ? a.previousSibling : a.nextSibling; null != c && c.nodeType == mxConstants.NODETYPE_TEXT; ) {
        var d = b ? c.previousSibling : c.nextSibling,
          e = mxUtils.getTextContent(c);
        0 == mxUtils.trim(e).length && c.parentNode.removeChild(c);
        c = d;
      }
    },
    htmlEntities: function (a, b) {
      a = String(a || '');
      a = a.replace(/&/g, '&amp;');
      a = a.replace(/"/g, '&quot;');
      a = a.replace(/\'/g, '&#39;');
      a = a.replace(/</g, '&lt;');
      a = a.replace(/>/g, '&gt;');
      if (null == b || b) a = a.replace(/\n/g, '&#xa;');
      return a;
    },
    decodeHtml: function (a) {
      var b = document.createElement('textarea');
      b.innerHTML = a;
      return b.value;
    },
    getXml: function (a, b) {
      var c = '';
      mxClient.IS_IE || mxClient.IS_IE11
        ? (c = mxUtils.getPrettyXml(a, '', '', ''))
        : null != window.XMLSerializer
        ? (c = new XMLSerializer().serializeToString(a))
        : null != a.xml &&
          (c = a.xml
            .replace(/\r\n\t[\t]*/g, '')
            .replace(/>\r\n/g, '>')
            .replace(/\r\n/g, '\n'));
      return (c = c.replace(/\n/g, b || '&#xa;'));
    },
    getPrettyXml: function (a, b, c, d, e) {
      var f = [];
      if (null != a)
        if (
          ((b = null != b ? b : '  '),
          (c = null != c ? c : ''),
          (d = null != d ? d : '\n'),
          null != a.namespaceURI &&
            a.namespaceURI != e &&
            ((e = a.namespaceURI), null == a.getAttribute('xmlns') && a.setAttribute('xmlns', a.namespaceURI)),
          a.nodeType == mxConstants.NODETYPE_DOCUMENT)
        )
          f.push(mxUtils.getPrettyXml(a.documentElement, b, c, d, e));
        else if (a.nodeType == mxConstants.NODETYPE_DOCUMENT_FRAGMENT) {
          var g = a.firstChild;
          if (null != g) for (; null != g; ) f.push(mxUtils.getPrettyXml(g, b, c, d, e)), (g = g.nextSibling);
        } else if (a.nodeType == mxConstants.NODETYPE_COMMENT)
          (a = mxUtils.getTextContent(a)), 0 < a.length && f.push(c + '\x3c!--' + a + '--\x3e' + d);
        else if (a.nodeType == mxConstants.NODETYPE_TEXT)
          (a = mxUtils.trim(mxUtils.getTextContent(a))), 0 < a.length && f.push(c + mxUtils.htmlEntities(a, !1) + d);
        else if (a.nodeType == mxConstants.NODETYPE_CDATA)
          (a = mxUtils.getTextContent(a)), 0 < a.length && f.push(c + '<![CDATA[' + a + ']]' + d);
        else {
          f.push(c + '<' + a.nodeName);
          g = a.attributes;
          if (null != g)
            for (var k = 0; k < g.length; k++) {
              var h = mxUtils.htmlEntities(g[k].value);
              f.push(' ' + g[k].nodeName + '="' + h + '"');
            }
          g = a.firstChild;
          if (null != g) {
            for (f.push('>' + d); null != g; ) f.push(mxUtils.getPrettyXml(g, b, c + b, d, e)), (g = g.nextSibling);
            f.push(c + '</' + a.nodeName + '>' + d);
          } else f.push(' />' + d);
        }
      return f.join('');
    },
    extractTextWithWhitespace: function (a) {
      function b(a) {
        if (1 != a.length || ('BR' != a[0].nodeName && '\n' != a[0].innerHTML))
          for (var e = 0; e < a.length; e++) {
            var g = a[e];
            'BR' == g.nodeName ||
            '\n' == g.innerHTML ||
            ((1 == a.length || 0 == e) && 'DIV' == g.nodeName && '<br>' == g.innerHTML.toLowerCase())
              ? d.push('\n')
              : (3 === g.nodeType || 4 === g.nodeType
                  ? 0 < g.nodeValue.length && d.push(g.nodeValue)
                  : 8 !== g.nodeType && 0 < g.childNodes.length && b(g.childNodes),
                e < a.length - 1 && 0 <= mxUtils.indexOf(c, a[e + 1].nodeName) && d.push('\n'));
          }
      }
      var c = 'BLOCKQUOTE DIV H1 H2 H3 H4 H5 H6 OL P PRE TABLE UL'.split(' '),
        d = [];
      b(a);
      return d.join('');
    },
    replaceTrailingNewlines: function (a, b) {
      for (var c = ''; 0 < a.length && '\n' == a.charAt(a.length - 1); ) (a = a.substring(0, a.length - 1)), (c += b);
      return a + c;
    },
    getTextContent: function (a) {
      return mxClient.IS_IE && void 0 !== a.innerText
        ? a.innerText
        : null != a
        ? a[void 0 === a.textContent ? 'text' : 'textContent']
        : '';
    },
    setTextContent: function (a, b) {
      void 0 !== a.innerText ? (a.innerText = b) : (a[void 0 === a.textContent ? 'text' : 'textContent'] = b);
    },
    getInnerHtml: (function () {
      return mxClient.IS_IE
        ? function (a) {
            return null != a ? a.innerHTML : '';
          }
        : function (a) {
            return null != a ? new XMLSerializer().serializeToString(a) : '';
          };
    })(),
    getOuterHtml: (function () {
      return mxClient.IS_IE
        ? function (a) {
            if (null != a) {
              if (null != a.outerHTML) return a.outerHTML;
              var b = [];
              b.push('<' + a.nodeName);
              var c = a.attributes;
              if (null != c)
                for (var d = 0; d < c.length; d++) {
                  var e = c[d].value;
                  null != e &&
                    0 < e.length &&
                    (b.push(' '), b.push(c[d].nodeName), b.push('="'), b.push(e), b.push('"'));
                }
              0 == a.innerHTML.length
                ? b.push('/>')
                : (b.push('>'), b.push(a.innerHTML), b.push('</' + a.nodeName + '>'));
              return b.join('');
            }
            return '';
          }
        : function (a) {
            return null != a ? new XMLSerializer().serializeToString(a) : '';
          };
    })(),
    write: function (a, b) {
      var c = a.ownerDocument.createTextNode(b);
      null != a && a.appendChild(c);
      return c;
    },
    writeln: function (a, b) {
      var c = a.ownerDocument.createTextNode(b);
      null != a && (a.appendChild(c), a.appendChild(document.createElement('br')));
      return c;
    },
    br: function (a, b) {
      b = b || 1;
      for (var c = null, d = 0; d < b; d++) null != a && ((c = a.ownerDocument.createElement('br')), a.appendChild(c));
      return c;
    },
    button: function (a, b, c) {
      c = null != c ? c : document;
      c = c.createElement('button');
      mxUtils.write(c, a);
      mxEvent.addListener(c, 'click', function (a) {
        b(a);
      });
      return c;
    },
    para: function (a, b) {
      var c = document.createElement('p');
      mxUtils.write(c, b);
      null != a && a.appendChild(c);
      return c;
    },
    addTransparentBackgroundFilter: function (a) {
      a.style.filter +=
        "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" +
        mxClient.imageBasePath +
        "/transparent.gif', sizingMethod='scale')";
    },
    linkAction: function (a, b, c, d, e) {
      return mxUtils.link(
        a,
        b,
        function () {
          c.execute(d);
        },
        e
      );
    },
    linkInvoke: function (a, b, c, d, e, f) {
      return mxUtils.link(
        a,
        b,
        function () {
          c[d](e);
        },
        f
      );
    },
    link: function (a, b, c, d) {
      var e = document.createElement('span');
      e.style.color = 'blue';
      e.style.textDecoration = 'underline';
      e.style.cursor = 'pointer';
      null != d && (e.style.paddingLeft = d + 'px');
      mxEvent.addListener(e, 'click', c);
      mxUtils.write(e, b);
      null != a && a.appendChild(e);
      return e;
    },
    getDocumentSize: function () {
      var a = document.body,
        b = document.documentElement;
      try {
        return new mxRectangle(0, 0, a.clientWidth || b.clientWidth, Math.max(a.clientHeight || 0, b.clientHeight));
      } catch (c) {
        return new mxRectangle();
      }
    },
    fit: function (a) {
      var b = mxUtils.getDocumentSize(),
        c = parseInt(a.offsetLeft),
        d = parseInt(a.offsetWidth),
        e = mxUtils.getDocumentScrollOrigin(a.ownerDocument),
        f = e.x,
        e = e.y,
        g = f + b.width;
      c + d > g && (a.style.left = Math.max(f, g - d) + 'px');
      c = parseInt(a.offsetTop);
      d = parseInt(a.offsetHeight);
      b = e + b.height;
      c + d > b && (a.style.top = Math.max(e, b - d) + 'px');
    },
    load: function (a) {
      a = new mxXmlRequest(a, null, 'GET', !1);
      a.send();
      return a;
    },
    get: function (a, b, c, d, e, f, g) {
      a = new mxXmlRequest(a, null, 'GET');
      var k = a.setRequestHeaders;
      g &&
        (a.setRequestHeaders = function (a, b) {
          k.apply(this, arguments);
          for (var c in g) a.setRequestHeader(c, g[c]);
        });
      null != d && a.setBinary(d);
      a.send(b, c, e, f);
      return a;
    },
    getAll: function (a, b, c) {
      for (
        var d = a.length,
          e = [],
          f = 0,
          g = function () {
            0 == f && null != c && c();
            f++;
          },
          k = 0;
        k < a.length;
        k++
      )
        (function (a, c) {
          mxUtils.get(
            a,
            function (a) {
              var f = a.getStatus();
              200 > f || 299 < f ? g() : ((e[c] = a), d--, 0 == d && b(e));
            },
            g
          );
        })(a[k], k);
      0 == d && b(e);
    },
    post: function (a, b, c, d) {
      return new mxXmlRequest(a, b).send(c, d);
    },
    submit: function (a, b, c, d) {
      return new mxXmlRequest(a, b).simulate(c, d);
    },
    loadInto: function (a, b, c) {
      mxClient.IS_IE
        ? (b.onreadystatechange = function () {
            4 == b.readyState && c();
          })
        : b.addEventListener('load', c, !1);
      b.load(a);
    },
    getValue: function (a, b, c) {
      a = null != a ? a[b] : null;
      null == a && (a = c);
      return a;
    },
    getNumber: function (a, b, c) {
      a = null != a ? a[b] : null;
      null == a && (a = c || 0);
      return Number(a);
    },
    getColor: function (a, b, c) {
      a = null != a ? a[b] : null;
      null == a ? (a = c) : a == mxConstants.NONE && (a = null);
      return a;
    },
    isEmptyObject: function (a) {
      for (var b in a) return !1;
      return !0;
    },
    clone: function (a, b, c) {
      c = null != c ? c : !1;
      var d = null;
      if (null != a && 'function' == typeof a.constructor)
        if (a.constructor === Element) d = a.cloneNode(null != c ? !c : !1);
        else {
          var d = new a.constructor(),
            e;
          for (e in a)
            e != mxObjectIdentity.FIELD_NAME &&
              (null == b || 0 > mxUtils.indexOf(b, e)) &&
              (d[e] = c || 'object' != typeof a[e] ? a[e] : mxUtils.clone(a[e]));
        }
      return d;
    },
    equalPoints: function (a, b) {
      if ((null == a && null != b) || (null != a && null == b) || (null != a && null != b && a.length != b.length))
        return !1;
      if (null != a && null != b)
        for (var c = 0; c < a.length; c++)
          if (
            (null != a[c] && null == b[c]) ||
            (null == a[c] && null != b[c]) ||
            (null != a[c] && null != b[c] && (a[c].x != b[c].x || a[c].y != b[c].y))
          )
            return !1;
      return !0;
    },
    equalEntries: function (a, b) {
      var c = 0;
      if ((null == a && null != b) || (null != a && null == b) || (null != a && null != b && a.length != b.length))
        return !1;
      if (null != a && null != b) {
        for (var d in b) c++;
        for (d in a) if ((c--, !((mxUtils.isNaN(a[d]) && mxUtils.isNaN(b[d])) || a[d] == b[d]))) return !1;
      }
      return 0 == c;
    },
    removeDuplicates: function (a) {
      for (var b = new mxDictionary(), c = [], d = 0; d < a.length; d++) b.get(a[d]) || (c.push(a[d]), b.put(a[d], !0));
      return c;
    },
    isNaN: function (a) {
      return 'number' == typeof a && isNaN(a);
    },
    extend: function (a, b) {
      var c = function () {};
      c.prototype = b.prototype;
      a.prototype = new c();
      a.prototype.constructor = a;
    },
    toString: function (a) {
      var b = '',
        c;
      for (c in a)
        try {
          if (null == a[c]) b += c + ' = [null]\n';
          else if ('function' == typeof a[c]) b += c + ' => [Function]\n';
          else if ('object' == typeof a[c])
            var d = mxUtils.getFunctionName(a[c].constructor),
              b = b + (c + ' => [' + d + ']\n');
          else b += c + ' = ' + a[c] + '\n';
        } catch (e) {
          b += c + '=' + e.message;
        }
      return b;
    },
    toRadians: function (a) {
      return (Math.PI * a) / 180;
    },
    toDegree: function (a) {
      return (180 * a) / Math.PI;
    },
    arcToCurves: function (a, b, c, d, e, f, g, k, h) {
      k -= a;
      h -= b;
      if (0 === c || 0 === d) return p;
      c = Math.abs(c);
      d = Math.abs(d);
      var l = -k / 2,
        m = -h / 2,
        n = Math.cos((e * Math.PI) / 180),
        p = Math.sin((e * Math.PI) / 180);
      e = n * l + p * m;
      var l = -1 * p * l + n * m,
        m = e * e,
        r = l * l,
        t = c * c,
        u = d * d,
        x = m / t + r / u;
      1 < x
        ? ((c *= Math.sqrt(x)), (d *= Math.sqrt(x)), (f = 0))
        : ((x = 1), f === g && (x = -1), (f = x * Math.sqrt((t * u - t * r - u * m) / (t * r + u * m))));
      m = (f * c * l) / d;
      r = (-1 * f * d * e) / c;
      k = n * m - p * r + k / 2;
      h = p * m + n * r + h / 2;
      t = Math.atan2((l - r) / d, (e - m) / c) - Math.atan2(0, 1);
      f = 0 <= t ? t : 2 * Math.PI + t;
      t = Math.atan2((-l - r) / d, (-e - m) / c) - Math.atan2((l - r) / d, (e - m) / c);
      e = 0 <= t ? t : 2 * Math.PI + t;
      0 == g && 0 < e ? (e -= 2 * Math.PI) : 0 != g && 0 > e && (e += 2 * Math.PI);
      g = (2 * e) / Math.PI;
      g = Math.ceil(0 > g ? -1 * g : g);
      e /= g;
      l = ((8 / 3) * Math.sin(e / 4) * Math.sin(e / 4)) / Math.sin(e / 2);
      m = n * c;
      n *= d;
      c *= p;
      d *= p;
      for (
        var z = Math.cos(f), D = Math.sin(f), r = -l * (m * D + d * z), t = -l * (c * D - n * z), p = [], B = 0;
        B < g;
        ++B
      ) {
        f += e;
        var z = Math.cos(f),
          D = Math.sin(f),
          u = m * z - d * D + k,
          x = c * z + n * D + h,
          C = -l * (m * D + d * z),
          z = -l * (c * D - n * z),
          D = 6 * B;
        p[D] = Number(r + a);
        p[D + 1] = Number(t + b);
        p[D + 2] = Number(u - C + a);
        p[D + 3] = Number(x - z + b);
        p[D + 4] = Number(u + a);
        p[D + 5] = Number(x + b);
        r = u + C;
        t = x + z;
      }
      return p;
    },
    getBoundingBox: function (a, b, c) {
      var d = null;
      if (null != a && null != b && 0 != b) {
        b = mxUtils.toRadians(b);
        var d = Math.cos(b),
          e = Math.sin(b);
        c = null != c ? c : new mxPoint(a.x + a.width / 2, a.y + a.height / 2);
        var f = new mxPoint(a.x, a.y);
        b = new mxPoint(a.x + a.width, a.y);
        var g = new mxPoint(b.x, a.y + a.height);
        a = new mxPoint(a.x, g.y);
        f = mxUtils.getRotatedPoint(f, d, e, c);
        b = mxUtils.getRotatedPoint(b, d, e, c);
        g = mxUtils.getRotatedPoint(g, d, e, c);
        a = mxUtils.getRotatedPoint(a, d, e, c);
        d = new mxRectangle(f.x, f.y, 0, 0);
        d.add(new mxRectangle(b.x, b.y, 0, 0));
        d.add(new mxRectangle(g.x, g.y, 0, 0));
        d.add(new mxRectangle(a.x, a.y, 0, 0));
      }
      return d;
    },
    getRotatedPoint: function (a, b, c, d) {
      d = null != d ? d : new mxPoint();
      var e = a.x - d.x;
      a = a.y - d.y;
      return new mxPoint(e * b - a * c + d.x, a * b + e * c + d.y);
    },
    getPortConstraints: function (a, b, c, d) {
      b = mxUtils.getValue(
        a.style,
        mxConstants.STYLE_PORT_CONSTRAINT,
        mxUtils.getValue(
          b.style,
          c ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT : mxConstants.STYLE_TARGET_PORT_CONSTRAINT,
          null
        )
      );
      if (null == b) return d;
      d = b.toString();
      b = mxConstants.DIRECTION_MASK_NONE;
      c = 0;
      1 == mxUtils.getValue(a.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0) &&
        (c = mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0));
      a = 0;
      45 < c ? ((a = 1), 135 <= c && (a = 2)) : -45 > c && ((a = 3), -135 >= c && (a = 2));
      if (0 <= d.indexOf(mxConstants.DIRECTION_NORTH))
        switch (a) {
          case 0:
            b |= mxConstants.DIRECTION_MASK_NORTH;
            break;
          case 1:
            b |= mxConstants.DIRECTION_MASK_EAST;
            break;
          case 2:
            b |= mxConstants.DIRECTION_MASK_SOUTH;
            break;
          case 3:
            b |= mxConstants.DIRECTION_MASK_WEST;
        }
      if (0 <= d.indexOf(mxConstants.DIRECTION_WEST))
        switch (a) {
          case 0:
            b |= mxConstants.DIRECTION_MASK_WEST;
            break;
          case 1:
            b |= mxConstants.DIRECTION_MASK_NORTH;
            break;
          case 2:
            b |= mxConstants.DIRECTION_MASK_EAST;
            break;
          case 3:
            b |= mxConstants.DIRECTION_MASK_SOUTH;
        }
      if (0 <= d.indexOf(mxConstants.DIRECTION_SOUTH))
        switch (a) {
          case 0:
            b |= mxConstants.DIRECTION_MASK_SOUTH;
            break;
          case 1:
            b |= mxConstants.DIRECTION_MASK_WEST;
            break;
          case 2:
            b |= mxConstants.DIRECTION_MASK_NORTH;
            break;
          case 3:
            b |= mxConstants.DIRECTION_MASK_EAST;
        }
      if (0 <= d.indexOf(mxConstants.DIRECTION_EAST))
        switch (a) {
          case 0:
            b |= mxConstants.DIRECTION_MASK_EAST;
            break;
          case 1:
            b |= mxConstants.DIRECTION_MASK_SOUTH;
            break;
          case 2:
            b |= mxConstants.DIRECTION_MASK_WEST;
            break;
          case 3:
            b |= mxConstants.DIRECTION_MASK_NORTH;
        }
      return b;
    },
    reversePortConstraints: function (a) {
      var b;
      b = (a & mxConstants.DIRECTION_MASK_WEST) << 3;
      b |= (a & mxConstants.DIRECTION_MASK_NORTH) << 1;
      b |= (a & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
      return (b |= (a & mxConstants.DIRECTION_MASK_EAST) >> 3);
    },
    findNearestSegment: function (a, b, c) {
      var d = -1;
      if (0 < a.absolutePoints.length)
        for (var e = a.absolutePoints[0], f = null, g = 1; g < a.absolutePoints.length; g++) {
          var k = a.absolutePoints[g],
            e = mxUtils.ptSegDistSq(e.x, e.y, k.x, k.y, b, c);
          if (null == f || e < f) (f = e), (d = g - 1);
          e = k;
        }
      return d;
    },
    getDirectedBounds: function (a, b, c, d, e) {
      var f = mxUtils.getValue(c, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
      d = null != d ? d : mxUtils.getValue(c, mxConstants.STYLE_FLIPH, !1);
      e = null != e ? e : mxUtils.getValue(c, mxConstants.STYLE_FLIPV, !1);
      b.x = Math.round(Math.max(0, Math.min(a.width, b.x)));
      b.y = Math.round(Math.max(0, Math.min(a.height, b.y)));
      b.width = Math.round(Math.max(0, Math.min(a.width, b.width)));
      b.height = Math.round(Math.max(0, Math.min(a.height, b.height)));
      if (
        (e && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH)) ||
        (d && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST))
      )
        (c = b.x), (b.x = b.width), (b.width = c);
      if (
        (d && (f == mxConstants.DIRECTION_SOUTH || f == mxConstants.DIRECTION_NORTH)) ||
        (e && (f == mxConstants.DIRECTION_EAST || f == mxConstants.DIRECTION_WEST))
      )
        (c = b.y), (b.y = b.height), (b.height = c);
      d = mxRectangle.fromRectangle(b);
      f == mxConstants.DIRECTION_SOUTH
        ? ((d.y = b.x), (d.x = b.height), (d.width = b.y), (d.height = b.width))
        : f == mxConstants.DIRECTION_WEST
        ? ((d.y = b.height), (d.x = b.width), (d.width = b.x), (d.height = b.y))
        : f == mxConstants.DIRECTION_NORTH && ((d.y = b.width), (d.x = b.y), (d.width = b.height), (d.height = b.x));
      return new mxRectangle(a.x + d.x, a.y + d.y, a.width - d.width - d.x, a.height - d.height - d.y);
    },
    getPerimeterPoint: function (a, b, c) {
      for (var d = null, e = 0; e < a.length - 1; e++) {
        var f = mxUtils.intersection(a[e].x, a[e].y, a[e + 1].x, a[e + 1].y, b.x, b.y, c.x, c.y);
        if (null != f) {
          var g = c.x - f.x,
            k = c.y - f.y,
            f = { p: f, distSq: k * k + g * g };
          null != f && (null == d || d.distSq > f.distSq) && (d = f);
        }
      }
      return null != d ? d.p : null;
    },
    intersectsPoints: function (a, b) {
      for (var c = 0; c < b.length - 1; c++) if (mxUtils.rectangleIntersectsSegment(a, b[c], b[c + 1])) return !0;
      return !1;
    },
    rectangleIntersectsSegment: function (a, b, c) {
      var d = a.y,
        e = a.x,
        f = d + a.height,
        g = e + a.width;
      a = b.x;
      var k = c.x;
      b.x > c.x && ((a = c.x), (k = b.x));
      k > g && (k = g);
      a < e && (a = e);
      if (a > k) return !1;
      var e = b.y,
        g = c.y,
        h = c.x - b.x;
      1e-7 < Math.abs(h) && ((c = (c.y - b.y) / h), (b = b.y - c * b.x), (e = c * a + b), (g = c * k + b));
      e > g && ((b = g), (g = e), (e = b));
      g > f && (g = f);
      e < d && (e = d);
      return e > g ? !1 : !0;
    },
    contains: function (a, b, c) {
      return a.x <= b && a.x + a.width >= b && a.y <= c && a.y + a.height >= c;
    },
    intersects: function (a, b) {
      var c = a.width,
        d = a.height,
        e = b.width,
        f = b.height;
      if (0 >= e || 0 >= f || 0 >= c || 0 >= d) return !1;
      var g = a.x,
        k = a.y,
        h = b.x,
        l = b.y,
        e = e + h,
        f = f + l,
        c = c + g,
        d = d + k;
      return (e < h || e > g) && (f < l || f > k) && (c < g || c > h) && (d < k || d > l);
    },
    intersectsHotspot: function (a, b, c, d, e, f) {
      d = null != d ? d : 1;
      e = null != e ? e : 0;
      f = null != f ? f : 0;
      if (0 < d) {
        var g = a.getCenterX(),
          k = a.getCenterY(),
          h = a.width,
          l = a.height,
          m = mxUtils.getValue(a.style, mxConstants.STYLE_STARTSIZE) * a.view.scale;
        0 < m &&
          (mxUtils.getValue(a.style, mxConstants.STYLE_HORIZONTAL, !0)
            ? ((k = a.y + m / 2), (l = m))
            : ((g = a.x + m / 2), (h = m)));
        h = Math.max(e, h * d);
        l = Math.max(e, l * d);
        0 < f && ((h = Math.min(h, f)), (l = Math.min(l, f)));
        d = new mxRectangle(g - h / 2, k - l / 2, h, l);
        g = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0);
        0 != g &&
          ((e = Math.cos(-g)),
          (f = Math.sin(-g)),
          (g = new mxPoint(a.getCenterX(), a.getCenterY())),
          (a = mxUtils.getRotatedPoint(new mxPoint(b, c), e, f, g)),
          (b = a.x),
          (c = a.y));
        return mxUtils.contains(d, b, c);
      }
      return !0;
    },
    getOffset: function (a, b) {
      for (
        var c = 0, d = 0, e = !1, f = a, g = document.body, k = document.documentElement;
        null != f && f != g && f != k && !e;

      ) {
        var h = mxUtils.getCurrentStyle(f);
        null != h && (e = e || 'fixed' == h.position);
        f = f.parentNode;
      }
      b || e || ((e = mxUtils.getDocumentScrollOrigin(a.ownerDocument)), (c += e.x), (d += e.y));
      e = a.getBoundingClientRect();
      null != e && ((c += e.left), (d += e.top));
      return new mxPoint(c, d);
    },
    getDocumentScrollOrigin: function (a) {
      a = a.defaultView || a.parentWindow;
      return new mxPoint(
        null != a && void 0 !== window.pageXOffset
          ? window.pageXOffset
          : (document.documentElement || document.body.parentNode || document.body).scrollLeft,
        null != a && void 0 !== window.pageYOffset
          ? window.pageYOffset
          : (document.documentElement || document.body.parentNode || document.body).scrollTop
      );
    },
    getScrollOrigin: function (a, b, c) {
      b = null != b ? b : !1;
      c = null != c ? c : !0;
      for (
        var d = null != a ? a.ownerDocument : document, e = d.body, f = d.documentElement, g = new mxPoint(), k = !1;
        null != a && a != e && a != f;

      ) {
        isNaN(a.scrollLeft) || isNaN(a.scrollTop) || ((g.x += a.scrollLeft), (g.y += a.scrollTop));
        var h = mxUtils.getCurrentStyle(a);
        null != h && (k = k || 'fixed' == h.position);
        a = b ? a.parentNode : null;
      }
      !k && c && ((a = mxUtils.getDocumentScrollOrigin(d)), (g.x += a.x), (g.y += a.y));
      return g;
    },
    convertPoint: function (a, b, c) {
      var d = mxUtils.getScrollOrigin(a, !1);
      a = mxUtils.getOffset(a);
      a.x -= d.x;
      a.y -= d.y;
      return new mxPoint(b - a.x, c - a.y);
    },
    ltrim: function (a, b) {
      return null != a ? a.replace(new RegExp('^[' + (b || '\\s') + ']+', 'g'), '') : null;
    },
    rtrim: function (a, b) {
      return null != a ? a.replace(new RegExp('[' + (b || '\\s') + ']+$', 'g'), '') : null;
    },
    trim: function (a, b) {
      return mxUtils.ltrim(mxUtils.rtrim(a, b), b);
    },
    isNumeric: function (a) {
      return !isNaN(parseFloat(a)) && isFinite(a) && ('string' != typeof a || 0 > a.toLowerCase().indexOf('0x'));
    },
    isInteger: function (a) {
      return String(parseInt(a)) === String(a);
    },
    mod: function (a, b) {
      return ((a % b) + b) % b;
    },
    intersection: function (a, b, c, d, e, f, g, k) {
      var h = (k - f) * (c - a) - (g - e) * (d - b);
      g = ((g - e) * (b - f) - (k - f) * (a - e)) / h;
      e = ((c - a) * (b - f) - (d - b) * (a - e)) / h;
      return 0 <= g && 1 >= g && 0 <= e && 1 >= e ? new mxPoint(a + g * (c - a), b + g * (d - b)) : null;
    },
    ptSegDistSq: function (a, b, c, d, e, f) {
      c -= a;
      d -= b;
      e -= a;
      f -= b;
      0 >= e * c + f * d
        ? (c = 0)
        : ((e = c - e), (f = d - f), (a = e * c + f * d), (c = 0 >= a ? 0 : (a * a) / (c * c + d * d)));
      e = e * e + f * f - c;
      0 > e && (e = 0);
      return e;
    },
    ptLineDist: function (a, b, c, d, e, f) {
      return Math.abs((d - b) * e - (c - a) * f + c * b - d * a) / Math.sqrt((d - b) * (d - b) + (c - a) * (c - a));
    },
    relativeCcw: function (a, b, c, d, e, f) {
      c -= a;
      d -= b;
      e -= a;
      f -= b;
      a = e * d - f * c;
      0 == a && ((a = e * c + f * d), 0 < a && ((a = (e - c) * c + (f - d) * d), 0 > a && (a = 0)));
      return 0 > a ? -1 : 0 < a ? 1 : 0;
    },
    animateChanges: function (a, b) {
      mxEffects.animateChanges.apply(this, arguments);
    },
    cascadeOpacity: function (a, b, c) {
      mxEffects.cascadeOpacity.apply(this, arguments);
    },
    fadeOut: function (a, b, c, d, e, f) {
      mxEffects.fadeOut.apply(this, arguments);
    },
    setOpacity: function (a, b) {
      mxClient.IS_IE && ('undefined' === typeof document.documentMode || 9 > document.documentMode)
        ? (a.style.filter = 100 <= b ? '' : 'alpha(opacity=' + b + ')')
        : (a.style.opacity = b / 100);
    },
    createImage: function (a) {
      var b;
      b = document.createElement('img');
      b.setAttribute('src', a);
      b.setAttribute('border', '0');
      return b;
    },
    sortCells: function (a, b) {
      b = null != b ? b : !0;
      var c = new mxDictionary();
      a.sort(function (a, e) {
        var d = c.get(a);
        null == d && ((d = mxCellPath.create(a).split(mxCellPath.PATH_SEPARATOR)), c.put(a, d));
        var g = c.get(e);
        null == g && ((g = mxCellPath.create(e).split(mxCellPath.PATH_SEPARATOR)), c.put(e, g));
        d = mxCellPath.compare(d, g);
        return 0 == d ? 0 : 0 < d == b ? 1 : -1;
      });
      return a;
    },
    getStylename: function (a) {
      return null != a && ((a = a.split(';')[0]), 0 > a.indexOf('=')) ? a : '';
    },
    getStylenames: function (a) {
      var b = [];
      if (null != a) {
        a = a.split(';');
        for (var c = 0; c < a.length; c++) 0 > a[c].indexOf('=') && b.push(a[c]);
      }
      return b;
    },
    indexOfStylename: function (a, b) {
      if (null != a && null != b)
        for (var c = a.split(';'), d = 0, e = 0; e < c.length; e++) {
          if (c[e] == b) return d;
          d += c[e].length + 1;
        }
      return -1;
    },
    addStylename: function (a, b) {
      0 > mxUtils.indexOfStylename(a, b) &&
        (null == a ? (a = '') : 0 < a.length && ';' != a.charAt(a.length - 1) && (a += ';'), (a += b));
      return a;
    },
    removeStylename: function (a, b) {
      var c = [];
      if (null != a) for (var d = a.split(';'), e = 0; e < d.length; e++) d[e] != b && c.push(d[e]);
      return c.join(';');
    },
    removeAllStylenames: function (a) {
      var b = [];
      if (null != a) {
        a = a.split(';');
        for (var c = 0; c < a.length; c++) 0 <= a[c].indexOf('=') && b.push(a[c]);
      }
      return b.join(';');
    },
    setCellStyles: function (a, b, c, d) {
      if (null != b && 0 < b.length) {
        a.beginUpdate();
        try {
          for (var e = 0; e < b.length; e++)
            if (null != b[e]) {
              var f = mxUtils.setStyle(a.getStyle(b[e]), c, d);
              a.setStyle(b[e], f);
            }
        } finally {
          a.endUpdate();
        }
      }
    },
    hex2rgb: function (a) {
      if (null != a && 7 == a.length && '#' == a.charAt(0)) {
        var b = parseInt(a.substring(1, 3), 16),
          c = parseInt(a.substring(3, 5), 16);
        a = parseInt(a.substring(5, 7), 16);
        a = 'rgb(' + b + ', ' + c + ', ' + a + ')';
      }
      return a;
    },
    hex2rgba: function (a) {
      if (null != a && 7 <= a.length && '#' == a.charAt(0)) {
        var b = parseInt(a.substring(1, 3), 16),
          c = parseInt(a.substring(3, 5), 16),
          d = parseInt(a.substring(5, 7), 16),
          e = 1;
        7 < a.length && (e = parseInt(a.substring(7, 9), 16) / 255);
        a = 'rgba(' + b + ', ' + c + ', ' + d + ', ' + e + ')';
      }
      return a;
    },
    rgba2hex: function (a) {
      return (rgb =
        a && a.match ? a.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i) : a) &&
        4 === rgb.length
        ? '#' +
            ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +
            ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) +
            ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2)
        : a;
    },
    setCssText: function (a, b) {
      if (null != a && null != b)
        for (var c = b.split(';'), d = 0; d < c.length; d++) {
          var e = c[d].split(':');
          1 < e.length &&
            ((e[0] = mxUtils.trim(
              e[0].replace(/-([a-z])/gi, function (a, b) {
                return b.toUpperCase();
              })
            )),
            (a[e[0]] = mxUtils.trim(e[1])));
        }
    },
    setStyle: function (a, b, c) {
      var d = null != c && ('undefined' == typeof c.length || 0 < c.length);
      if (null == a || 0 == a.length) d && (a = b + '=' + c + ';');
      else if (a.substring(0, b.length + 1) == b + '=') {
        var e = a.indexOf(';');
        a = d ? b + '=' + c + (0 > e ? ';' : a.substring(e)) : 0 > e || e == a.length - 1 ? '' : a.substring(e + 1);
      } else {
        var f = a.indexOf(';' + b + '=');
        0 > f
          ? d && ((d = ';' == a.charAt(a.length - 1) ? '' : ';'), (a = a + d + b + '=' + c + ';'))
          : ((e = a.indexOf(';', f + 1)),
            (a = d
              ? a.substring(0, f + 1) + b + '=' + c + (0 > e ? ';' : a.substring(e))
              : a.substring(0, f) + (0 > e ? ';' : a.substring(e))));
      }
      return a;
    },
    setCellStyleFlags: function (a, b, c, d, e) {
      if (null != b && 0 < b.length) {
        a.beginUpdate();
        try {
          for (var f = 0; f < b.length; f++)
            if (null != b[f]) {
              var g = mxUtils.setStyleFlag(a.getStyle(b[f]), c, d, e);
              a.setStyle(b[f], g);
            }
        } finally {
          a.endUpdate();
        }
      }
    },
    setStyleFlag: function (a, b, c, d) {
      if (null == a || 0 == a.length) a = d || null == d ? b + '=' + c : b + '=0';
      else {
        var e = a.indexOf(b + '=');
        if (0 > e)
          (e = ';' == a.charAt(a.length - 1) ? '' : ';'), (a = d || null == d ? a + e + b + '=' + c : a + e + b + '=0');
        else {
          var f = a.indexOf(';', e),
            g;
          g = 0 > f ? a.substring(e + b.length + 1) : a.substring(e + b.length + 1, f);
          g = null == d ? parseInt(g) ^ c : d ? parseInt(g) | c : parseInt(g) & ~c;
          a = a.substring(0, e) + b + '=' + g + (0 <= f ? a.substring(f) : '');
        }
      }
      return a;
    },
    getAlignmentAsPoint: function (a, b) {
      var c = -0.5,
        d = -0.5;
      a == mxConstants.ALIGN_LEFT ? (c = 0) : a == mxConstants.ALIGN_RIGHT && (c = -1);
      b == mxConstants.ALIGN_TOP ? (d = 0) : b == mxConstants.ALIGN_BOTTOM && (d = -1);
      return new mxPoint(c, d);
    },
    getSizeForString: function (a, b, c, d, e) {
      b = null != b ? b : mxConstants.DEFAULT_FONTSIZE;
      c = null != c ? c : mxConstants.DEFAULT_FONTFAMILY;
      var f = document.createElement('div');
      f.style.fontFamily = c;
      f.style.fontSize = Math.round(b) + 'px';
      f.style.lineHeight = Math.round(b * mxConstants.LINE_HEIGHT) + 'px';
      null != e &&
        ((e & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (f.style.fontWeight = 'bold'),
        (e & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (f.style.fontStyle = 'italic'),
        (b = []),
        (e & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && b.push('underline'),
        (e & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && b.push('line-through'),
        0 < b.length && (f.style.textDecoration = b.join(' ')));
      f.style.position = 'absolute';
      f.style.visibility = 'hidden';
      f.style.display = 'inline-block';
      f.style.zoom = '1';
      null != d ? ((f.style.width = d + 'px'), (f.style.whiteSpace = 'normal')) : (f.style.whiteSpace = 'nowrap');
      f.innerHTML = a;
      document.body.appendChild(f);
      a = new mxRectangle(0, 0, f.offsetWidth, f.offsetHeight);
      document.body.removeChild(f);
      return a;
    },
    getViewXml: function (a, b, c, d, e) {
      d = null != d ? d : 0;
      e = null != e ? e : 0;
      b = null != b ? b : 1;
      null == c && (c = [a.getModel().getRoot()]);
      var f = a.getView(),
        g = null,
        k = f.isEventsEnabled();
      f.setEventsEnabled(!1);
      var h = f.drawPane,
        l = f.overlayPane;
      a.dialect == mxConstants.DIALECT_SVG
        ? ((f.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g')),
          f.canvas.appendChild(f.drawPane),
          (f.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g')))
        : ((f.drawPane = f.drawPane.cloneNode(!1)),
          f.canvas.appendChild(f.drawPane),
          (f.overlayPane = f.overlayPane.cloneNode(!1)));
      f.canvas.appendChild(f.overlayPane);
      var m = f.getTranslate();
      f.translate = new mxPoint(d, e);
      b = new mxTemporaryCellStates(a.getView(), b, c);
      try {
        g = new mxCodec().encode(a.getView());
      } finally {
        b.destroy(),
          (f.translate = m),
          f.canvas.removeChild(f.drawPane),
          f.canvas.removeChild(f.overlayPane),
          (f.drawPane = h),
          (f.overlayPane = l),
          f.setEventsEnabled(k);
      }
      return g;
    },
    getScaleForPageCount: function (a, b, c, d) {
      if (1 > a) return 1;
      c = null != c ? c : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
      d = null != d ? d : 0;
      var e = c.width - 2 * d;
      c = c.height - 2 * d;
      d = b.getGraphBounds().clone();
      b = b.getView().getScale();
      d.width /= b;
      d.height /= b;
      b = d.width;
      var f = Math.sqrt(a);
      d = Math.sqrt(b / d.height / (e / c));
      c = f * d;
      d = f / d;
      if (1 > c && d > a) {
        var g = d / a;
        d = a;
        c /= g;
      }
      1 > d && c > a && ((g = c / a), (c = a), (d /= g));
      g = Math.ceil(c) * Math.ceil(d);
      for (f = 0; g > a; ) {
        var g = Math.floor(c) / c,
          k = Math.floor(d) / d;
        1 == g && (g = Math.floor(c - 1) / c);
        1 == k && (k = Math.floor(d - 1) / d);
        g = g > k ? g : k;
        c *= g;
        d *= g;
        g = Math.ceil(c) * Math.ceil(d);
        f++;
        if (10 < f) break;
      }
      return ((e * c) / b) * 0.99999;
    },
    show: function (a, b, c, d, e, f) {
      c = null != c ? c : 0;
      d = null != d ? d : 0;
      null == b ? (b = window.open().document) : b.open();
      9 == document.documentMode &&
        b.writeln('\x3c!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=9"><![endif]--\x3e');
      var g = a.getGraphBounds(),
        k = Math.ceil(c - g.x),
        h = Math.ceil(d - g.y);
      null == e && (e = Math.ceil(g.width + c) + Math.ceil(Math.ceil(g.x) - g.x));
      null == f && (f = Math.ceil(g.height + d) + Math.ceil(Math.ceil(g.y) - g.y));
      if (mxClient.IS_IE || 11 == document.documentMode) {
        d = '<html><head>';
        g = document.getElementsByTagName('base');
        for (c = 0; c < g.length; c++) d += g[c].outerHTML;
        d += '<style>';
        for (c = 0; c < document.styleSheets.length; c++)
          try {
            d += document.styleSheets[c].cssText;
          } catch (l) {}
        d =
          d +
          '</style></head><body style="margin:0px;">' +
          ('<div style="position:absolute;overflow:hidden;width:' +
            e +
            'px;height:' +
            f +
            'px;"><div style="position:relative;left:' +
            k +
            'px;top:' +
            h +
            'px;">') +
          a.container.innerHTML;
        b.writeln(d + '</div></div></body><html>');
        b.close();
      } else {
        b.writeln('<html><head>');
        g = document.getElementsByTagName('base');
        for (c = 0; c < g.length; c++) b.writeln(mxUtils.getOuterHtml(g[c]));
        d = document.getElementsByTagName('link');
        for (c = 0; c < d.length; c++) b.writeln(mxUtils.getOuterHtml(d[c]));
        d = document.getElementsByTagName('style');
        for (c = 0; c < d.length; c++) b.writeln(mxUtils.getOuterHtml(d[c]));
        b.writeln('</head><body style="margin:0px;"></body></html>');
        b.close();
        c = b.createElement('div');
        c.position = 'absolute';
        c.overflow = 'hidden';
        c.style.width = e + 'px';
        c.style.height = f + 'px';
        e = b.createElement('div');
        e.style.position = 'absolute';
        e.style.left = k + 'px';
        e.style.top = h + 'px';
        f = a.container.firstChild;
        for (d = null; null != f; )
          (g = f.cloneNode(!0)),
            f == a.view.drawPane.ownerSVGElement ? (c.appendChild(g), (d = g)) : e.appendChild(g),
            (f = f.nextSibling);
        b.body.appendChild(c);
        null != e.firstChild && b.body.appendChild(e);
        null != d &&
          ((d.style.minWidth = ''),
          (d.style.minHeight = ''),
          d.firstChild.setAttribute('transform', 'translate(' + k + ',' + h + ')'));
      }
      mxUtils.removeCursors(b.body);
      return b;
    },
    printScreen: function (a) {
      var b = window.open();
      a.getGraphBounds();
      mxUtils.show(a, b.document);
      a = function () {
        b.focus();
        b.print();
        b.close();
      };
      mxClient.IS_GC ? b.setTimeout(a, 500) : a();
    },
    popup: function (a, b) {
      if (b) {
        var c = document.createElement('div');
        c.style.overflow = 'scroll';
        c.style.width = '636px';
        c.style.height = '460px';
        var d = document.createElement('pre');
        d.innerHTML = mxUtils.htmlEntities(a, !1).replace(/\n/g, '<br>').replace(/ /g, '&nbsp;');
        c.appendChild(d);
        c = new mxWindow(
          'Popup Window',
          c,
          document.body.clientWidth / 2 - 320,
          Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight) / 2 - 240,
          640,
          480,
          !1,
          !0
        );
        c.setClosable(!0);
        c.setVisible(!0);
      } else
        mxClient.IS_NS
          ? ((c = window.open()), c.document.writeln('<pre>' + mxUtils.htmlEntities(a) + '</pre'), c.document.close())
          : ((c = window.open()),
            (d = c.document.createElement('pre')),
            (d.innerHTML = mxUtils.htmlEntities(a, !1).replace(/\n/g, '<br>').replace(/ /g, '&nbsp;')),
            c.document.body.appendChild(d));
    },
    alert: function (a) {
      alert(a);
    },
    prompt: function (a, b) {
      return prompt(a, null != b ? b : '');
    },
    confirm: function (a) {
      return confirm(a);
    },
    error: function (a, b, c, d) {
      var e = document.createElement('div');
      e.style.padding = '20px';
      var f = document.createElement('img');
      f.setAttribute('src', d || mxUtils.errorImage);
      f.setAttribute('valign', 'bottom');
      f.style.verticalAlign = 'middle';
      e.appendChild(f);
      e.appendChild(document.createTextNode(''));
      e.appendChild(document.createTextNode(''));
      e.appendChild(document.createTextNode(''));
      mxUtils.write(e, a);
      a = document.body.clientWidth;
      d = document.body.clientHeight || document.documentElement.clientHeight;
      var g = new mxWindow(
        mxResources.get(mxUtils.errorResource) || mxUtils.errorResource,
        e,
        (a - b) / 2,
        d / 4,
        b,
        null,
        !1,
        !0
      );
      c &&
        (mxUtils.br(e),
        (b = document.createElement('p')),
        (c = document.createElement('button')),
        mxClient.IS_IE ? (c.style.cssText = 'float:right') : c.setAttribute('style', 'float:right'),
        mxEvent.addListener(c, 'click', function (a) {
          g.destroy();
        }),
        mxUtils.write(c, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource),
        b.appendChild(c),
        e.appendChild(b),
        mxUtils.br(e),
        g.setClosable(!0));
      g.setVisible(!0);
      return g;
    },
    makeDraggable: function (a, b, c, d, e, f, g, k, h, l) {
      a = new mxDragSource(a, c);
      a.dragOffset = new mxPoint(null != e ? e : 0, null != f ? f : mxConstants.TOOLTIP_VERTICAL_OFFSET);
      a.autoscroll = g;
      a.setGuidesEnabled(!1);
      null != h && (a.highlightDropTargets = h);
      null != l && (a.getDropTarget = l);
      a.getGraphForEvent = function (a) {
        return 'function' == typeof b ? b(a) : b;
      };
      null != d &&
        ((a.createDragElement = function () {
          return d.cloneNode(!0);
        }),
        k &&
          (a.createPreviewElement = function (a) {
            var b = d.cloneNode(!0),
              c = parseInt(b.style.width),
              e = parseInt(b.style.height);
            b.style.width = Math.round(c * a.view.scale) + 'px';
            b.style.height = Math.round(e * a.view.scale) + 'px';
            return b;
          }));
      return a;
    },
    format: function (a) {
      return parseFloat(parseFloat(a).toFixed(2));
    },
  },
  mxConstants = {
    DEFAULT_HOTSPOT: 0.3,
    MIN_HOTSPOT_SIZE: 8,
    MAX_HOTSPOT_SIZE: 0,
    RENDERING_HINT_EXACT: 'exact',
    RENDERING_HINT_FASTER: 'faster',
    RENDERING_HINT_FASTEST: 'fastest',
    DIALECT_SVG: 'svg',
    DIALECT_MIXEDHTML: 'mixedHtml',
    DIALECT_PREFERHTML: 'preferHtml',
    DIALECT_STRICTHTML: 'strictHtml',
    NS_SVG: 'http://www.w3.org/2000/svg',
    NS_XHTML: 'http://www.w3.org/1999/xhtml',
    NS_XLINK: 'http://www.w3.org/1999/xlink',
    SHADOWCOLOR: 'gray',
    VML_SHADOWCOLOR: 'gray',
    SHADOW_OFFSET_X: 2,
    SHADOW_OFFSET_Y: 3,
    SHADOW_OPACITY: 1,
    NODETYPE_ELEMENT: 1,
    NODETYPE_ATTRIBUTE: 2,
    NODETYPE_TEXT: 3,
    NODETYPE_CDATA: 4,
    NODETYPE_ENTITY_REFERENCE: 5,
    NODETYPE_ENTITY: 6,
    NODETYPE_PROCESSING_INSTRUCTION: 7,
    NODETYPE_COMMENT: 8,
    NODETYPE_DOCUMENT: 9,
    NODETYPE_DOCUMENTTYPE: 10,
    NODETYPE_DOCUMENT_FRAGMENT: 11,
    NODETYPE_NOTATION: 12,
    TOOLTIP_VERTICAL_OFFSET: 16,
    DEFAULT_VALID_COLOR: '#00FF00',
    DEFAULT_INVALID_COLOR: '#FF0000',
    OUTLINE_HIGHLIGHT_COLOR: '#00FF00',
    OUTLINE_HIGHLIGHT_STROKEWIDTH: 5,
    HIGHLIGHT_STROKEWIDTH: 3,
    HIGHLIGHT_SIZE: 2,
    HIGHLIGHT_OPACITY: 100,
    CURSOR_MOVABLE_VERTEX: 'move',
    CURSOR_MOVABLE_EDGE: 'move',
    CURSOR_LABEL_HANDLE: 'default',
    CURSOR_TERMINAL_HANDLE: 'pointer',
    CURSOR_BEND_HANDLE: 'crosshair',
    CURSOR_VIRTUAL_BEND_HANDLE: 'crosshair',
    CURSOR_CONNECT: 'pointer',
    HIGHLIGHT_COLOR: '#00FF00',
    CONNECT_TARGET_COLOR: '#0000FF',
    INVALID_CONNECT_TARGET_COLOR: '#FF0000',
    DROP_TARGET_COLOR: '#0000FF',
    VALID_COLOR: '#00FF00',
    INVALID_COLOR: '#FF0000',
    EDGE_SELECTION_COLOR: '#00FF00',
    VERTEX_SELECTION_COLOR: '#00FF00',
    VERTEX_SELECTION_STROKEWIDTH: 1,
    EDGE_SELECTION_STROKEWIDTH: 1,
    VERTEX_SELECTION_DASHED: !0,
    EDGE_SELECTION_DASHED: !0,
    GUIDE_COLOR: '#FF0000',
    GUIDE_STROKEWIDTH: 1,
    OUTLINE_COLOR: '#0099FF',
    OUTLINE_STROKEWIDTH: mxClient.IS_IE ? 2 : 3,
    HANDLE_SIZE: 6,
    LABEL_HANDLE_SIZE: 4,
    HANDLE_FILLCOLOR: '#00FF00',
    HANDLE_STROKECOLOR: 'black',
    LABEL_HANDLE_FILLCOLOR: 'yellow',
    CONNECT_HANDLE_FILLCOLOR: '#0000FF',
    LOCKED_HANDLE_FILLCOLOR: '#FF0000',
    OUTLINE_HANDLE_FILLCOLOR: '#00FFFF',
    OUTLINE_HANDLE_STROKECOLOR: '#0033FF',
    DEFAULT_FONTFAMILY: 'Arial,Helvetica',
    DEFAULT_FONTSIZE: 11,
    DEFAULT_TEXT_DIRECTION: '',
    LINE_HEIGHT: 1.2,
    WORD_WRAP: 'normal',
    ABSOLUTE_LINE_HEIGHT: !1,
    DEFAULT_FONTSTYLE: 0,
    DEFAULT_STARTSIZE: 40,
    DEFAULT_MARKERSIZE: 6,
    DEFAULT_IMAGESIZE: 24,
    ENTITY_SEGMENT: 30,
    RECTANGLE_ROUNDING_FACTOR: 0.15,
    LINE_ARCSIZE: 20,
    ARROW_SPACING: 0,
    ARROW_WIDTH: 30,
    ARROW_SIZE: 30,
    PAGE_FORMAT_A4_PORTRAIT: new mxRectangle(0, 0, 827, 1169),
    PAGE_FORMAT_A4_LANDSCAPE: new mxRectangle(0, 0, 1169, 827),
    PAGE_FORMAT_LETTER_PORTRAIT: new mxRectangle(0, 0, 850, 1100),
    PAGE_FORMAT_LETTER_LANDSCAPE: new mxRectangle(0, 0, 1100, 850),
    NONE: 'none',
    STYLE_PERIMETER: 'perimeter',
    STYLE_SOURCE_PORT: 'sourcePort',
    STYLE_TARGET_PORT: 'targetPort',
    STYLE_PORT_CONSTRAINT: 'portConstraint',
    STYLE_PORT_CONSTRAINT_ROTATION: 'portConstraintRotation',
    STYLE_SOURCE_PORT_CONSTRAINT: 'sourcePortConstraint',
    STYLE_TARGET_PORT_CONSTRAINT: 'targetPortConstraint',
    STYLE_OPACITY: 'opacity',
    STYLE_FILL_OPACITY: 'fillOpacity',
    STYLE_STROKE_OPACITY: 'strokeOpacity',
    STYLE_TEXT_OPACITY: 'textOpacity',
    STYLE_TEXT_DIRECTION: 'textDirection',
    STYLE_OVERFLOW: 'overflow',
    STYLE_BLOCK_SPACING: 'blockSpacing',
    STYLE_ORTHOGONAL: 'orthogonal',
    STYLE_EXIT_X: 'exitX',
    STYLE_EXIT_Y: 'exitY',
    STYLE_EXIT_DX: 'exitDx',
    STYLE_EXIT_DY: 'exitDy',
    STYLE_EXIT_PERIMETER: 'exitPerimeter',
    STYLE_ENTRY_X: 'entryX',
    STYLE_ENTRY_Y: 'entryY',
    STYLE_ENTRY_DX: 'entryDx',
    STYLE_ENTRY_DY: 'entryDy',
    STYLE_ENTRY_PERIMETER: 'entryPerimeter',
    STYLE_WHITE_SPACE: 'whiteSpace',
    STYLE_ROTATION: 'rotation',
    STYLE_FILLCOLOR: 'fillColor',
    STYLE_POINTER_EVENTS: 'pointerEvents',
    STYLE_SWIMLANE_FILLCOLOR: 'swimlaneFillColor',
    STYLE_MARGIN: 'margin',
    STYLE_GRADIENTCOLOR: 'gradientColor',
    STYLE_GRADIENT_DIRECTION: 'gradientDirection',
    STYLE_STROKECOLOR: 'strokeColor',
    STYLE_SEPARATORCOLOR: 'separatorColor',
    STYLE_STROKEWIDTH: 'strokeWidth',
    STYLE_ALIGN: 'align',
    STYLE_VERTICAL_ALIGN: 'verticalAlign',
    STYLE_LABEL_WIDTH: 'labelWidth',
    STYLE_LABEL_POSITION: 'labelPosition',
    STYLE_VERTICAL_LABEL_POSITION: 'verticalLabelPosition',
    STYLE_IMAGE_ASPECT: 'imageAspect',
    STYLE_IMAGE_ALIGN: 'imageAlign',
    STYLE_IMAGE_VERTICAL_ALIGN: 'imageVerticalAlign',
    STYLE_GLASS: 'glass',
    STYLE_IMAGE: 'image',
    STYLE_IMAGE_WIDTH: 'imageWidth',
    STYLE_IMAGE_HEIGHT: 'imageHeight',
    STYLE_IMAGE_BACKGROUND: 'imageBackground',
    STYLE_IMAGE_BORDER: 'imageBorder',
    STYLE_FLIPH: 'flipH',
    STYLE_FLIPV: 'flipV',
    STYLE_NOLABEL: 'noLabel',
    STYLE_NOEDGESTYLE: 'noEdgeStyle',
    STYLE_LABEL_BACKGROUNDCOLOR: 'labelBackgroundColor',
    STYLE_LABEL_BORDERCOLOR: 'labelBorderColor',
    STYLE_LABEL_PADDING: 'labelPadding',
    STYLE_INDICATOR_SHAPE: 'indicatorShape',
    STYLE_INDICATOR_IMAGE: 'indicatorImage',
    STYLE_INDICATOR_COLOR: 'indicatorColor',
    STYLE_INDICATOR_STROKECOLOR: 'indicatorStrokeColor',
    STYLE_INDICATOR_GRADIENTCOLOR: 'indicatorGradientColor',
    STYLE_INDICATOR_SPACING: 'indicatorSpacing',
    STYLE_INDICATOR_WIDTH: 'indicatorWidth',
    STYLE_INDICATOR_HEIGHT: 'indicatorHeight',
    STYLE_INDICATOR_DIRECTION: 'indicatorDirection',
    STYLE_SHADOW: 'shadow',
    STYLE_SEGMENT: 'segment',
    STYLE_ENDARROW: 'endArrow',
    STYLE_STARTARROW: 'startArrow',
    STYLE_ENDSIZE: 'endSize',
    STYLE_STARTSIZE: 'startSize',
    STYLE_SWIMLANE_LINE: 'swimlaneLine',
    STYLE_SWIMLANE_HEAD: 'swimlaneHead',
    STYLE_SWIMLANE_BODY: 'swimlaneBody',
    STYLE_ENDFILL: 'endFill',
    STYLE_STARTFILL: 'startFill',
    STYLE_DASHED: 'dashed',
    STYLE_DASH_PATTERN: 'dashPattern',
    STYLE_FIX_DASH: 'fixDash',
    STYLE_ROUNDED: 'rounded',
    STYLE_CURVED: 'curved',
    STYLE_ARCSIZE: 'arcSize',
    STYLE_ABSOLUTE_ARCSIZE: 'absoluteArcSize',
    STYLE_SOURCE_PERIMETER_SPACING: 'sourcePerimeterSpacing',
    STYLE_TARGET_PERIMETER_SPACING: 'targetPerimeterSpacing',
    STYLE_PERIMETER_SPACING: 'perimeterSpacing',
    STYLE_SPACING: 'spacing',
    STYLE_SPACING_TOP: 'spacingTop',
    STYLE_SPACING_LEFT: 'spacingLeft',
    STYLE_SPACING_BOTTOM: 'spacingBottom',
    STYLE_SPACING_RIGHT: 'spacingRight',
    STYLE_HORIZONTAL: 'horizontal',
    STYLE_DIRECTION: 'direction',
    STYLE_ANCHOR_POINT_DIRECTION: 'anchorPointDirection',
    STYLE_ELBOW: 'elbow',
    STYLE_FONTCOLOR: 'fontColor',
    STYLE_FONTFAMILY: 'fontFamily',
    STYLE_FONTSIZE: 'fontSize',
    STYLE_FONTSTYLE: 'fontStyle',
    STYLE_ASPECT: 'aspect',
    STYLE_AUTOSIZE: 'autosize',
    STYLE_FOLDABLE: 'foldable',
    STYLE_EDITABLE: 'editable',
    STYLE_BACKGROUND_OUTLINE: 'backgroundOutline',
    STYLE_BENDABLE: 'bendable',
    STYLE_MOVABLE: 'movable',
    STYLE_RESIZABLE: 'resizable',
    STYLE_RESIZE_WIDTH: 'resizeWidth',
    STYLE_RESIZE_HEIGHT: 'resizeHeight',
    STYLE_ROTATABLE: 'rotatable',
    STYLE_CLONEABLE: 'cloneable',
    STYLE_DELETABLE: 'deletable',
    STYLE_SHAPE: 'shape',
    STYLE_EDGE: 'edgeStyle',
    STYLE_JETTY_SIZE: 'jettySize',
    STYLE_SOURCE_JETTY_SIZE: 'sourceJettySize',
    STYLE_TARGET_JETTY_SIZE: 'targetJettySize',
    STYLE_LOOP: 'loopStyle',
    STYLE_ORTHOGONAL_LOOP: 'orthogonalLoop',
    STYLE_ROUTING_CENTER_X: 'routingCenterX',
    STYLE_ROUTING_CENTER_Y: 'routingCenterY',
    STYLE_CLIP_PATH: 'clipPath',
    FONT_BOLD: 1,
    FONT_ITALIC: 2,
    FONT_UNDERLINE: 4,
    FONT_STRIKETHROUGH: 8,
    SHAPE_RECTANGLE: 'rectangle',
    SHAPE_ELLIPSE: 'ellipse',
    SHAPE_DOUBLE_ELLIPSE: 'doubleEllipse',
    SHAPE_RHOMBUS: 'rhombus',
    SHAPE_LINE: 'line',
    SHAPE_IMAGE: 'image',
    SHAPE_ARROW: 'arrow',
    SHAPE_ARROW_CONNECTOR: 'arrowConnector',
    SHAPE_LABEL: 'label',
    SHAPE_CYLINDER: 'cylinder',
    SHAPE_SWIMLANE: 'swimlane',
    SHAPE_CONNECTOR: 'connector',
    SHAPE_ACTOR: 'actor',
    SHAPE_CLOUD: 'cloud',
    SHAPE_TRIANGLE: 'triangle',
    SHAPE_HEXAGON: 'hexagon',
    ARROW_CLASSIC: 'classic',
    ARROW_CLASSIC_THIN: 'classicThin',
    ARROW_BLOCK: 'block',
    ARROW_BLOCK_THIN: 'blockThin',
    ARROW_OPEN: 'open',
    ARROW_OPEN_THIN: 'openThin',
    ARROW_OVAL: 'oval',
    ARROW_DIAMOND: 'diamond',
    ARROW_DIAMOND_THIN: 'diamondThin',
    ALIGN_LEFT: 'left',
    ALIGN_CENTER: 'center',
    ALIGN_RIGHT: 'right',
    ALIGN_TOP: 'top',
    ALIGN_MIDDLE: 'middle',
    ALIGN_BOTTOM: 'bottom',
    DIRECTION_NORTH: 'north',
    DIRECTION_SOUTH: 'south',
    DIRECTION_EAST: 'east',
    DIRECTION_WEST: 'west',
    DIRECTION_RADIAL: 'radial',
    TEXT_DIRECTION_DEFAULT: '',
    TEXT_DIRECTION_AUTO: 'auto',
    TEXT_DIRECTION_LTR: 'ltr',
    TEXT_DIRECTION_RTL: 'rtl',
    DIRECTION_MASK_NONE: 0,
    DIRECTION_MASK_WEST: 1,
    DIRECTION_MASK_NORTH: 2,
    DIRECTION_MASK_SOUTH: 4,
    DIRECTION_MASK_EAST: 8,
    DIRECTION_MASK_ALL: 15,
    ELBOW_VERTICAL: 'vertical',
    ELBOW_HORIZONTAL: 'horizontal',
    EDGESTYLE_ELBOW: 'elbowEdgeStyle',
    EDGESTYLE_ENTITY_RELATION: 'entityRelationEdgeStyle',
    EDGESTYLE_LOOP: 'loopEdgeStyle',
    EDGESTYLE_SIDETOSIDE: 'sideToSideEdgeStyle',
    EDGESTYLE_TOPTOBOTTOM: 'topToBottomEdgeStyle',
    EDGESTYLE_ORTHOGONAL: 'orthogonalEdgeStyle',
    EDGESTYLE_SEGMENT: 'segmentEdgeStyle',
    PERIMETER_ELLIPSE: 'ellipsePerimeter',
    PERIMETER_RECTANGLE: 'rectanglePerimeter',
    PERIMETER_RHOMBUS: 'rhombusPerimeter',
    PERIMETER_HEXAGON: 'hexagonPerimeter',
    PERIMETER_TRIANGLE: 'trianglePerimeter',
  };
function mxEventObject(a) {
  this.name = a;
  this.properties = [];
  for (var b = 1; b < arguments.length; b += 2)
    null != arguments[b + 1] && (this.properties[arguments[b]] = arguments[b + 1]);
}
mxEventObject.prototype.name = null;
mxEventObject.prototype.properties = null;
mxEventObject.prototype.consumed = !1;
mxEventObject.prototype.getName = function () {
  return this.name;
};
mxEventObject.prototype.getProperties = function () {
  return this.properties;
};
mxEventObject.prototype.getProperty = function (a) {
  return this.properties[a];
};
mxEventObject.prototype.isConsumed = function () {
  return this.consumed;
};
mxEventObject.prototype.consume = function () {
  this.consumed = !0;
};
function mxMouseEvent(a, b) {
  this.evt = a;
  this.sourceState = this.state = b;
}
mxMouseEvent.prototype.consumed = !1;
mxMouseEvent.prototype.evt = null;
mxMouseEvent.prototype.graphX = null;
mxMouseEvent.prototype.graphY = null;
mxMouseEvent.prototype.state = null;
mxMouseEvent.prototype.sourceState = null;
mxMouseEvent.prototype.getEvent = function () {
  return this.evt;
};
mxMouseEvent.prototype.getSource = function () {
  return mxEvent.getSource(this.evt);
};
mxMouseEvent.prototype.isSource = function (a) {
  return null != a ? mxUtils.isAncestorNode(a.node, this.getSource()) : !1;
};
mxMouseEvent.prototype.getX = function () {
  return mxEvent.getClientX(this.getEvent());
};
mxMouseEvent.prototype.getY = function () {
  return mxEvent.getClientY(this.getEvent());
};
mxMouseEvent.prototype.getGraphX = function () {
  return this.graphX;
};
mxMouseEvent.prototype.getGraphY = function () {
  return this.graphY;
};
mxMouseEvent.prototype.getState = function () {
  return this.state;
};
mxMouseEvent.prototype.getCell = function () {
  var a = this.getState();
  return null != a ? a.cell : null;
};
mxMouseEvent.prototype.isPopupTrigger = function () {
  return mxEvent.isPopupTrigger(this.getEvent());
};
mxMouseEvent.prototype.isConsumed = function () {
  return this.consumed;
};
mxMouseEvent.prototype.consume = function (a) {
  (a = null != a ? a : null != this.evt.touches || mxEvent.isMouseEvent(this.evt)) &&
    this.evt.preventDefault &&
    this.evt.preventDefault();
  mxClient.IS_IE && (this.evt.returnValue = !0);
  this.consumed = !0;
};
function mxEventSource(a) {
  this.setEventSource(a);
}
mxEventSource.prototype.eventListeners = null;
mxEventSource.prototype.eventsEnabled = !0;
mxEventSource.prototype.eventSource = null;
mxEventSource.prototype.isEventsEnabled = function () {
  return this.eventsEnabled;
};
mxEventSource.prototype.setEventsEnabled = function (a) {
  this.eventsEnabled = a;
};
mxEventSource.prototype.getEventSource = function () {
  return this.eventSource;
};
mxEventSource.prototype.setEventSource = function (a) {
  this.eventSource = a;
};
mxEventSource.prototype.addListener = function (a, b) {
  null == this.eventListeners && (this.eventListeners = []);
  this.eventListeners.push(a);
  this.eventListeners.push(b);
};
mxEventSource.prototype.removeListener = function (a) {
  if (null != this.eventListeners)
    for (var b = 0; b < this.eventListeners.length; )
      this.eventListeners[b + 1] == a ? this.eventListeners.splice(b, 2) : (b += 2);
};
mxEventSource.prototype.fireEvent = function (a, b) {
  if (null != this.eventListeners && this.isEventsEnabled()) {
    null == a && (a = new mxEventObject());
    null == b && (b = this.getEventSource());
    null == b && (b = this);
    for (var c = 0; c < this.eventListeners.length; c += 2) {
      var d = this.eventListeners[c];
      (null != d && d != a.getName()) || this.eventListeners[c + 1].apply(this, [b, a]);
    }
  }
};
var mxEvent = {
  addListener: (function () {
    if (window.addEventListener) {
      var a = !1;
      try {
        document.addEventListener(
          'test',
          function () {},
          Object.defineProperty &&
            Object.defineProperty({}, 'passive', {
              get: function () {
                a = !0;
              },
            })
        );
      } catch (b) {}
      return function (b, c, d) {
        b.addEventListener(c, d, a ? { passive: !1 } : !1);
        null == b.mxListenerList && (b.mxListenerList = []);
        b.mxListenerList.push({ name: c, f: d });
      };
    }
    return function (a, c, d) {
      a.attachEvent('on' + c, d);
      null == a.mxListenerList && (a.mxListenerList = []);
      a.mxListenerList.push({ name: c, f: d });
    };
  })(),
  removeListener: (function () {
    var a = function (a, c, d) {
      if (null != a.mxListenerList) {
        c = a.mxListenerList.length;
        for (var b = 0; b < c; b++)
          if (a.mxListenerList[b].f == d) {
            a.mxListenerList.splice(b, 1);
            break;
          }
        0 == a.mxListenerList.length && (a.mxListenerList = null);
      }
    };
    return window.removeEventListener
      ? function (b, c, d) {
          b.removeEventListener(c, d, !1);
          a(b, c, d);
        }
      : function (b, c, d) {
          b.detachEvent('on' + c, d);
          a(b, c, d);
        };
  })(),
  removeAllListeners: function (a) {
    var b = a.mxListenerList;
    if (null != b)
      for (; 0 < b.length; ) {
        var c = b[0];
        mxEvent.removeListener(a, c.name, c.f);
      }
  },
  addGestureListeners: function (a, b, c, d) {
    null != b && mxEvent.addListener(a, mxClient.IS_POINTER ? 'pointerdown' : 'mousedown', b);
    null != c && mxEvent.addListener(a, mxClient.IS_POINTER ? 'pointermove' : 'mousemove', c);
    null != d && mxEvent.addListener(a, mxClient.IS_POINTER ? 'pointerup' : 'mouseup', d);
    !mxClient.IS_POINTER &&
      mxClient.IS_TOUCH &&
      (null != b && mxEvent.addListener(a, 'touchstart', b),
      null != c && mxEvent.addListener(a, 'touchmove', c),
      null != d && mxEvent.addListener(a, 'touchend', d));
  },
  removeGestureListeners: function (a, b, c, d) {
    null != b && mxEvent.removeListener(a, mxClient.IS_POINTER ? 'pointerdown' : 'mousedown', b);
    null != c && mxEvent.removeListener(a, mxClient.IS_POINTER ? 'pointermove' : 'mousemove', c);
    null != d && mxEvent.removeListener(a, mxClient.IS_POINTER ? 'pointerup' : 'mouseup', d);
    !mxClient.IS_POINTER &&
      mxClient.IS_TOUCH &&
      (null != b && mxEvent.removeListener(a, 'touchstart', b),
      null != c && mxEvent.removeListener(a, 'touchmove', c),
      null != d && mxEvent.removeListener(a, 'touchend', d));
  },
  redirectMouseEvents: function (a, b, c, d, e, f, g) {
    var k = function (a) {
      return 'function' == typeof c ? c(a) : c;
    };
    mxEvent.addGestureListeners(
      a,
      function (a) {
        null != d ? d(a) : mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a, k(a)));
      },
      function (a) {
        null != e ? e(a) : mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a, k(a)));
      },
      function (a) {
        null != f ? f(a) : mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a, k(a)));
      }
    );
    mxEvent.addListener(a, 'dblclick', function (a) {
      if (null != g) g(a);
      else if (!mxEvent.isConsumed(a)) {
        var c = k(a);
        b.dblClick(a, null != c ? c.cell : null);
      }
    });
  },
  release: function (a) {
    try {
      if (null != a) {
        mxEvent.removeAllListeners(a);
        var b = a.childNodes;
        if (null != b) {
          var c = b.length;
          for (a = 0; a < c; a += 1) mxEvent.release(b[a]);
        }
      }
    } catch (d) {}
  },
  addMouseWheelListener: function (a, b) {
    if (null != a) {
      b = null != b ? b : window;
      if (mxClient.IS_SF && !mxClient.IS_TOUCH) {
        var c = 1;
        mxEvent.addListener(b, 'gesturestart', function (a) {
          mxEvent.consume(a);
          c = 1;
        });
        mxEvent.addListener(b, 'gesturechange', function (b) {
          mxEvent.consume(b);
          var d = c - b.scale;
          0.2 < Math.abs(d) && (a(b, 0 > d, !0), (c = b.scale));
        });
        mxEvent.addListener(b, 'gestureend', function (a) {
          mxEvent.consume(a);
        });
      } else {
        var d = [],
          e = 0,
          f = 0;
        mxEvent.addGestureListeners(
          b,
          mxUtils.bind(this, function (a) {
            mxEvent.isMouseEvent(a) || null == a.pointerId || d.push(a);
          }),
          mxUtils.bind(this, function (b) {
            if (!mxEvent.isMouseEvent(b) && 2 == d.length) {
              for (var c = 0; c < d.length; c++)
                if (b.pointerId == d[c].pointerId) {
                  d[c] = b;
                  break;
                }
              b = Math.abs(d[0].clientX - d[1].clientX);
              var c = Math.abs(d[0].clientY - d[1].clientY),
                g = Math.abs(b - e),
                l = Math.abs(c - f);
              if (g > mxEvent.PINCH_THRESHOLD || l > mxEvent.PINCH_THRESHOLD)
                a(
                  d[0],
                  g > l ? b > e : c > f,
                  !0,
                  d[0].clientX + (d[1].clientX - d[0].clientX) / 2,
                  d[0].clientY + (d[1].clientY - d[0].clientY) / 2
                ),
                  (e = b),
                  (f = c);
            }
          }),
          mxUtils.bind(this, function (a) {
            d = [];
            f = e = 0;
          })
        );
      }
      mxEvent.addListener(b, 'wheel', function (b) {
        null == b && (b = window.event);
        b.ctrlKey && b.preventDefault();
        (0.5 < Math.abs(b.deltaX) || 0.5 < Math.abs(b.deltaY)) && a(b, 0 == b.deltaY ? 0 < -b.deltaX : 0 < -b.deltaY);
      });
    }
  },
  disableContextMenu: function (a) {
    mxEvent.addListener(a, 'contextmenu', function (a) {
      a.preventDefault && a.preventDefault();
      return !1;
    });
  },
  getSource: function (a) {
    return null != a.srcElement ? a.srcElement : a.target;
  },
  isConsumed: function (a) {
    return null != a.isConsumed && a.isConsumed;
  },
  isTouchEvent: function (a) {
    return null != a.pointerType
      ? 'touch' == a.pointerType || a.pointerType === a.MSPOINTER_TYPE_TOUCH
      : null != a.mozInputSource
      ? 5 == a.mozInputSource
      : 0 == a.type.indexOf('touch');
  },
  isPenEvent: function (a) {
    return null != a.pointerType
      ? 'pen' == a.pointerType || a.pointerType === a.MSPOINTER_TYPE_PEN
      : null != a.mozInputSource
      ? 2 == a.mozInputSource
      : 0 == a.type.indexOf('pen');
  },
  isMultiTouchEvent: function (a) {
    return null != a.type && 0 == a.type.indexOf('touch') && null != a.touches && 1 < a.touches.length;
  },
  isMouseEvent: function (a) {
    return !mxClient.IS_ANDROID && mxClient.IS_LINUX && mxClient.IS_GC
      ? !0
      : null != a.pointerType
      ? 'mouse' == a.pointerType || a.pointerType === a.MSPOINTER_TYPE_MOUSE
      : null != a.mozInputSource
      ? 1 == a.mozInputSource
      : 0 == a.type.indexOf('mouse');
  },
  isLeftMouseButton: function (a) {
    return 'buttons' in a && ('mousedown' == a.type || 'mousemove' == a.type)
      ? 1 == a.buttons
      : 'which' in a
      ? 1 === a.which
      : 1 === a.button;
  },
  isMiddleMouseButton: function (a) {
    return 'which' in a ? 2 === a.which : 4 === a.button;
  },
  isRightMouseButton: function (a) {
    return 'which' in a ? 3 === a.which : 2 === a.button;
  },
  isPopupTrigger: function (a) {
    return (
      mxEvent.isRightMouseButton(a) ||
      (mxClient.IS_MAC &&
        mxEvent.isControlDown(a) &&
        !mxEvent.isShiftDown(a) &&
        !mxEvent.isMetaDown(a) &&
        !mxEvent.isAltDown(a))
    );
  },
  isShiftDown: function (a) {
    return null != a ? a.shiftKey : !1;
  },
  isAltDown: function (a) {
    return null != a ? a.altKey : !1;
  },
  isControlDown: function (a) {
    return null != a ? a.ctrlKey : !1;
  },
  isMetaDown: function (a) {
    return null != a ? a.metaKey : !1;
  },
  getMainEvent: function (a) {
    ('touchstart' != a.type && 'touchmove' != a.type) || null == a.touches || null == a.touches[0]
      ? 'touchend' == a.type && null != a.changedTouches && null != a.changedTouches[0] && (a = a.changedTouches[0])
      : (a = a.touches[0]);
    return a;
  },
  getClientX: function (a) {
    return mxEvent.getMainEvent(a).clientX;
  },
  getClientY: function (a) {
    return mxEvent.getMainEvent(a).clientY;
  },
  consume: function (a, b, c) {
    c = null != c ? c : !0;
    if (null != b ? b : 1)
      a.preventDefault ? (c && a.stopPropagation(), a.preventDefault()) : c && (a.cancelBubble = !0);
    a.isConsumed = !0;
    a.preventDefault || (a.returnValue = !1);
  },
  LABEL_HANDLE: -1,
  ROTATION_HANDLE: -2,
  CUSTOM_HANDLE: -100,
  VIRTUAL_HANDLE: -1e5,
  MOUSE_DOWN: 'mouseDown',
  MOUSE_MOVE: 'mouseMove',
  MOUSE_UP: 'mouseUp',
  ACTIVATE: 'activate',
  RESIZE_START: 'resizeStart',
  RESIZE: 'resize',
  RESIZE_END: 'resizeEnd',
  MOVE_START: 'moveStart',
  MOVE: 'move',
  MOVE_END: 'moveEnd',
  PAN_START: 'panStart',
  PAN: 'pan',
  PAN_END: 'panEnd',
  MINIMIZE: 'minimize',
  NORMALIZE: 'normalize',
  MAXIMIZE: 'maximize',
  HIDE: 'hide',
  SHOW: 'show',
  CLOSE: 'close',
  DESTROY: 'destroy',
  REFRESH: 'refresh',
  SIZE: 'size',
  SELECT: 'select',
  FIRED: 'fired',
  FIRE_MOUSE_EVENT: 'fireMouseEvent',
  GESTURE: 'gesture',
  TAP_AND_HOLD: 'tapAndHold',
  GET: 'get',
  RECEIVE: 'receive',
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  SUSPEND: 'suspend',
  RESUME: 'resume',
  MARK: 'mark',
  ROOT: 'root',
  POST: 'post',
  OPEN: 'open',
  SAVE: 'save',
  BEFORE_ADD_VERTEX: 'beforeAddVertex',
  ADD_VERTEX: 'addVertex',
  AFTER_ADD_VERTEX: 'afterAddVertex',
  DONE: 'done',
  EXECUTE: 'execute',
  EXECUTED: 'executed',
  BEGIN_UPDATE: 'beginUpdate',
  START_EDIT: 'startEdit',
  END_UPDATE: 'endUpdate',
  END_EDIT: 'endEdit',
  BEFORE_UNDO: 'beforeUndo',
  UNDO: 'undo',
  REDO: 'redo',
  CHANGE: 'change',
  NOTIFY: 'notify',
  LAYOUT_CELLS: 'layoutCells',
  CLICK: 'click',
  SCALE: 'scale',
  TRANSLATE: 'translate',
  SCALE_AND_TRANSLATE: 'scaleAndTranslate',
  UP: 'up',
  DOWN: 'down',
  ADD: 'add',
  REMOVE: 'remove',
  CLEAR: 'clear',
  ADD_CELLS: 'addCells',
  CELLS_ADDED: 'cellsAdded',
  MOVE_CELLS: 'moveCells',
  CELLS_MOVED: 'cellsMoved',
  RESIZE_CELLS: 'resizeCells',
  CELLS_RESIZED: 'cellsResized',
  TOGGLE_CELLS: 'toggleCells',
  CELLS_TOGGLED: 'cellsToggled',
  ORDER_CELLS: 'orderCells',
  CELLS_ORDERED: 'cellsOrdered',
  REMOVE_CELLS: 'removeCells',
  CELLS_REMOVED: 'cellsRemoved',
  GROUP_CELLS: 'groupCells',
  UNGROUP_CELLS: 'ungroupCells',
  REMOVE_CELLS_FROM_PARENT: 'removeCellsFromParent',
  FOLD_CELLS: 'foldCells',
  CELLS_FOLDED: 'cellsFolded',
  ALIGN_CELLS: 'alignCells',
  LABEL_CHANGED: 'labelChanged',
  CONNECT_CELL: 'connectCell',
  CELL_CONNECTED: 'cellConnected',
  SPLIT_EDGE: 'splitEdge',
  FLIP_EDGE: 'flipEdge',
  START_EDITING: 'startEditing',
  EDITING_STARTED: 'editingStarted',
  EDITING_STOPPED: 'editingStopped',
  ADD_OVERLAY: 'addOverlay',
  REMOVE_OVERLAY: 'removeOverlay',
  UPDATE_CELL_SIZE: 'updateCellSize',
  ESCAPE: 'escape',
  DOUBLE_CLICK: 'doubleClick',
  START: 'start',
  RESET: 'reset',
  PINCH_THRESHOLD: 10,
};
function mxXmlRequest(a, b, c, d, e, f) {
  this.url = a;
  this.params = b;
  this.method = c || 'POST';
  this.async = null != d ? d : !0;
  this.username = e;
  this.password = f;
}
mxXmlRequest.prototype.url = null;
mxXmlRequest.prototype.params = null;
mxXmlRequest.prototype.method = null;
mxXmlRequest.prototype.async = null;
mxXmlRequest.prototype.binary = !1;
mxXmlRequest.prototype.withCredentials = !1;
mxXmlRequest.prototype.username = null;
mxXmlRequest.prototype.password = null;
mxXmlRequest.prototype.request = null;
mxXmlRequest.prototype.decodeSimulateValues = !1;
mxXmlRequest.prototype.isBinary = function () {
  return this.binary;
};
mxXmlRequest.prototype.setBinary = function (a) {
  this.binary = a;
};
mxXmlRequest.prototype.getText = function () {
  return this.request.responseText;
};
mxXmlRequest.prototype.isReady = function () {
  return 4 == this.request.readyState;
};
mxXmlRequest.prototype.getDocumentElement = function () {
  var a = this.getXml();
  return null != a ? a.documentElement : null;
};
mxXmlRequest.prototype.getXml = function () {
  var a = this.request.responseXML;
  if (9 <= document.documentMode || null == a || null == a.documentElement)
    a = mxUtils.parseXml(this.request.responseText);
  return a;
};
mxXmlRequest.prototype.getStatus = function () {
  return null != this.request ? this.request.status : null;
};
mxXmlRequest.prototype.create = (function () {
  if (window.XMLHttpRequest)
    return function () {
      var a = new XMLHttpRequest();
      this.isBinary() && a.overrideMimeType && a.overrideMimeType('text/plain; charset=x-user-defined');
      return a;
    };
  if ('undefined' != typeof ActiveXObject)
    return function () {
      return new ActiveXObject('Microsoft.XMLHTTP');
    };
})();
mxXmlRequest.prototype.send = function (a, b, c, d) {
  this.request = this.create();
  null != this.request &&
    (null != a &&
      (this.request.onreadystatechange = mxUtils.bind(this, function () {
        this.isReady() && (a(this), (this.request.onreadystatechange = null));
      })),
    this.request.open(this.method, this.url, this.async, this.username, this.password),
    this.setRequestHeaders(this.request, this.params),
    window.XMLHttpRequest && this.withCredentials && (this.request.withCredentials = 'true'),
    (null == document.documentMode || 9 < document.documentMode) &&
      window.XMLHttpRequest &&
      null != c &&
      null != d &&
      ((this.request.timeout = c), (this.request.ontimeout = d)),
    this.request.send(this.params));
};
mxXmlRequest.prototype.setRequestHeaders = function (a, b) {
  null != b && a.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
};
mxXmlRequest.prototype.simulate = function (a, b) {
  a = a || document;
  var c = null;
  a == document && ((c = window.onbeforeunload), (window.onbeforeunload = null));
  var d = a.createElement('form');
  d.setAttribute('method', this.method);
  d.setAttribute('action', this.url);
  null != b && d.setAttribute('target', b);
  d.style.display = 'none';
  d.style.visibility = 'hidden';
  for (var e = 0 < this.params.indexOf('&') ? this.params.split('&') : this.params.split(), f = 0; f < e.length; f++) {
    var g = e[f].indexOf('=');
    if (0 < g) {
      var k = e[f].substring(0, g),
        g = e[f].substring(g + 1);
      this.decodeSimulateValues && (g = decodeURIComponent(g));
      var h = a.createElement('textarea');
      h.setAttribute('wrap', 'off');
      h.setAttribute('name', k);
      mxUtils.write(h, g);
      d.appendChild(h);
    }
  }
  a.body.appendChild(d);
  d.submit();
  null != d.parentNode && d.parentNode.removeChild(d);
  null != c && (window.onbeforeunload = c);
};
function mxImage(a, b, c, d, e) {
  this.src = a;
  this.width = null != b ? b : this.width;
  this.height = null != c ? c : this.height;
  this.x = null != d ? d : this.x;
  this.y = null != e ? e : this.y;
}
mxImage.prototype.src = null;
mxImage.prototype.width = 0;
mxImage.prototype.height = 0;
mxImage.prototype.x = 0;
mxImage.prototype.y = 0;
function mxUndoableEdit(a, b) {
  this.source = a;
  this.changes = [];
  this.significant = null != b ? b : !0;
}
mxUndoableEdit.prototype.source = null;
mxUndoableEdit.prototype.changes = null;
mxUndoableEdit.prototype.significant = null;
mxUndoableEdit.prototype.undone = !1;
mxUndoableEdit.prototype.redone = !1;
mxUndoableEdit.prototype.isEmpty = function () {
  return 0 == this.changes.length;
};
mxUndoableEdit.prototype.isSignificant = function () {
  return this.significant;
};
mxUndoableEdit.prototype.add = function (a) {
  this.changes.push(a);
};
mxUndoableEdit.prototype.notify = function () {};
mxUndoableEdit.prototype.die = function () {};
mxUndoableEdit.prototype.undo = function () {
  if (!this.undone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    for (var a = this.changes.length - 1; 0 <= a; a--) {
      var b = this.changes[a];
      null != b.execute ? b.execute() : null != b.undo && b.undo();
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', b));
    }
    this.undone = !0;
    this.redone = !1;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
mxUndoableEdit.prototype.redo = function () {
  if (!this.redone) {
    this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
    for (var a = this.changes.length, b = 0; b < a; b++) {
      var c = this.changes[b];
      null != c.execute ? c.execute() : null != c.redo && c.redo();
      this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', c));
    }
    this.undone = !1;
    this.redone = !0;
    this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  }
  this.notify();
};
var mxUrlConverter = function () {};
mxUrlConverter.prototype.enabled = !0;
mxUrlConverter.prototype.baseUrl = null;
mxUrlConverter.prototype.baseDomain = null;
mxUrlConverter.prototype.updateBaseUrl = function () {
  this.baseDomain = location.protocol + '//' + location.host;
  this.baseUrl = this.baseDomain + location.pathname;
  var a = this.baseUrl.lastIndexOf('/');
  0 < a && (this.baseUrl = this.baseUrl.substring(0, a + 1));
};
mxUrlConverter.prototype.isEnabled = function () {
  return this.enabled;
};
mxUrlConverter.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxUrlConverter.prototype.getBaseUrl = function () {
  return this.baseUrl;
};
mxUrlConverter.prototype.setBaseUrl = function (a) {
  this.baseUrl = a;
};
mxUrlConverter.prototype.getBaseDomain = function () {
  return this.baseDomain;
};
mxUrlConverter.prototype.setBaseDomain = function (a) {
  this.baseDomain = a;
};
mxUrlConverter.prototype.isRelativeUrl = function (a) {
  return (
    null != a &&
    '//' != a.substring(0, 2) &&
    'http://' != a.substring(0, 7) &&
    'https://' != a.substring(0, 8) &&
    'data:image' != a.substring(0, 10) &&
    'file://' != a.substring(0, 7)
  );
};
mxUrlConverter.prototype.convert = function (a) {
  this.isEnabled() &&
    this.isRelativeUrl(a) &&
    (null == this.getBaseUrl() && this.updateBaseUrl(),
    (a = '/' == a.charAt(0) ? this.getBaseDomain() + a : this.getBaseUrl() + a));
  return a;
};
function mxPanningManager(a) {
  this.thread = null;
  this.active = !1;
  this.dy = this.dx = this.t0y = this.t0x = this.tdy = this.tdx = 0;
  this.scrollbars = !1;
  this.scrollTop = this.scrollLeft = 0;
  this.mouseListener = {
    mouseDown: function (a, b) {},
    mouseMove: function (a, b) {},
    mouseUp: mxUtils.bind(this, function (a, b) {
      this.active && this.stop();
    }),
  };
  a.addMouseListener(this.mouseListener);
  this.mouseUpListener = mxUtils.bind(this, function () {
    this.active && this.stop();
  });
  mxEvent.addListener(document, 'mouseup', this.mouseUpListener);
  var b = mxUtils.bind(this, function () {
    this.scrollbars = mxUtils.hasScrollbars(a.container);
    this.scrollLeft = a.container.scrollLeft;
    this.scrollTop = a.container.scrollTop;
    return window.setInterval(
      mxUtils.bind(this, function () {
        this.tdx -= this.dx;
        this.tdy -= this.dy;
        this.scrollbars
          ? (a.panGraph(-a.container.scrollLeft - Math.ceil(this.dx), -a.container.scrollTop - Math.ceil(this.dy)),
            (a.panDx = this.scrollLeft - a.container.scrollLeft),
            (a.panDy = this.scrollTop - a.container.scrollTop),
            a.fireEvent(new mxEventObject(mxEvent.PAN)))
          : a.panGraph(this.getDx(), this.getDy());
      }),
      this.delay
    );
  });
  this.isActive = function () {
    return active;
  };
  this.getDx = function () {
    return Math.round(this.tdx);
  };
  this.getDy = function () {
    return Math.round(this.tdy);
  };
  this.start = function () {
    this.t0x = a.view.translate.x;
    this.t0y = a.view.translate.y;
    this.active = !0;
  };
  this.panTo = function (c, d, e, f) {
    this.active || this.start();
    this.scrollLeft = a.container.scrollLeft;
    this.scrollTop = a.container.scrollTop;
    var g = a.container;
    this.dx = c + (null != e ? e : 0) - g.scrollLeft - g.clientWidth;
    this.dx =
      0 > this.dx && Math.abs(this.dx) < this.border
        ? this.border + this.dx
        : this.handleMouseOut
        ? Math.max(this.dx, 0)
        : 0;
    0 == this.dx &&
      ((this.dx = c - g.scrollLeft),
      (this.dx =
        0 < this.dx && this.dx < this.border ? this.dx - this.border : this.handleMouseOut ? Math.min(0, this.dx) : 0));
    this.dy = d + (null != f ? f : 0) - g.scrollTop - g.clientHeight;
    this.dy =
      0 > this.dy && Math.abs(this.dy) < this.border
        ? this.border + this.dy
        : this.handleMouseOut
        ? Math.max(this.dy, 0)
        : 0;
    0 == this.dy &&
      ((this.dy = d - g.scrollTop),
      (this.dy =
        0 < this.dy && this.dy < this.border ? this.dy - this.border : this.handleMouseOut ? Math.min(0, this.dy) : 0));
    0 != this.dx || 0 != this.dy
      ? ((this.dx *= this.damper), (this.dy *= this.damper), null == this.thread && (this.thread = b()))
      : null != this.thread && (window.clearInterval(this.thread), (this.thread = null));
  };
  this.stop = function () {
    if (this.active)
      if (
        ((this.active = !1),
        null != this.thread && (window.clearInterval(this.thread), (this.thread = null)),
        (this.tdy = this.tdx = 0),
        this.scrollbars)
      )
        (a.panDx = 0), (a.panDy = 0), a.fireEvent(new mxEventObject(mxEvent.PAN));
      else {
        var b = a.panDx,
          d = a.panDy;
        if (0 != b || 0 != d)
          a.panGraph(0, 0), a.view.setTranslate(this.t0x + b / a.view.scale, this.t0y + d / a.view.scale);
      }
  };
  this.destroy = function () {
    a.removeMouseListener(this.mouseListener);
    mxEvent.removeListener(document, 'mouseup', this.mouseUpListener);
  };
}
mxPanningManager.prototype.damper = 1 / 6;
mxPanningManager.prototype.delay = 10;
mxPanningManager.prototype.handleMouseOut = !0;
mxPanningManager.prototype.border = 0;
function mxPopupMenu(a) {
  this.factoryMethod = a;
  null != a && this.init();
}
mxPopupMenu.prototype = new mxEventSource();
mxPopupMenu.prototype.constructor = mxPopupMenu;
mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + '/submenu.gif';
mxPopupMenu.prototype.zIndex = 10006;
mxPopupMenu.prototype.factoryMethod = null;
mxPopupMenu.prototype.useLeftButtonForPopup = !1;
mxPopupMenu.prototype.enabled = !0;
mxPopupMenu.prototype.itemCount = 0;
mxPopupMenu.prototype.autoExpand = !1;
mxPopupMenu.prototype.smartSeparators = !1;
mxPopupMenu.prototype.labels = !0;
mxPopupMenu.prototype.init = function () {
  this.table = document.createElement('table');
  this.table.className = 'mxPopupMenu';
  this.tbody = document.createElement('tbody');
  this.table.appendChild(this.tbody);
  this.div = document.createElement('div');
  this.div.className = 'mxPopupMenu';
  this.div.style.display = 'inline';
  this.div.style.zIndex = this.zIndex;
  this.div.appendChild(this.table);
  mxEvent.disableContextMenu(this.div);
};
mxPopupMenu.prototype.isEnabled = function () {
  return this.enabled;
};
mxPopupMenu.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxPopupMenu.prototype.isPopupTrigger = function (a) {
  return a.isPopupTrigger() || (this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(a.getEvent()));
};
mxPopupMenu.prototype.addItem = function (a, b, c, d, e, f, g, k) {
  d = d || this;
  this.itemCount++;
  d.willAddSeparator && (d.containsItems && this.addSeparator(d, !0), (d.willAddSeparator = !1));
  d.containsItems = !0;
  var h = document.createElement('tr');
  h.className = 'mxPopupMenuItem';
  var l = document.createElement('td');
  l.className = 'mxPopupMenuIcon';
  null != b
    ? ((e = document.createElement('img')), (e.src = b), l.appendChild(e))
    : null != e && ((b = document.createElement('div')), (b.className = e), l.appendChild(b));
  h.appendChild(l);
  this.labels &&
    ((l = document.createElement('td')),
    (l.className = 'mxPopupMenuItem' + (null == f || f ? '' : ' mxDisabled')),
    mxUtils.write(l, a),
    (l.align = 'left'),
    h.appendChild(l),
    (a = document.createElement('td')),
    (a.className = 'mxPopupMenuItem' + (null == f || f ? '' : ' mxDisabled')),
    (a.style.paddingRight = '6px'),
    (a.style.textAlign = 'right'),
    h.appendChild(a),
    null == d.div && this.createSubmenu(d));
  d.tbody.appendChild(h);
  if (0 != g && 0 != f) {
    var m = null;
    mxEvent.addGestureListeners(
      h,
      mxUtils.bind(this, function (a) {
        this.eventReceiver = h;
        d.activeRow != h &&
          d.activeRow != d &&
          (null != d.activeRow && null != d.activeRow.div.parentNode && this.hideSubmenu(d),
          null != h.div && (this.showSubmenu(d, h), (d.activeRow = h)));
        null != document.selection && 8 == document.documentMode && (m = document.selection.createRange());
        mxEvent.consume(a);
      }),
      mxUtils.bind(this, function (a) {
        d.activeRow != h &&
          d.activeRow != d &&
          (null != d.activeRow && null != d.activeRow.div.parentNode && this.hideSubmenu(d),
          this.autoExpand && null != h.div && (this.showSubmenu(d, h), (d.activeRow = h)));
        k || (h.className = 'mxPopupMenuItemHover');
      }),
      mxUtils.bind(this, function (a) {
        if (this.eventReceiver == h) {
          d.activeRow != h && this.hideMenu();
          if (null != m) {
            try {
              m.select();
            } catch (p) {}
            m = null;
          }
          null != c && c(a);
        }
        this.eventReceiver = null;
        mxEvent.consume(a);
      })
    );
    k ||
      mxEvent.addListener(
        h,
        'mouseout',
        mxUtils.bind(this, function (a) {
          h.className = 'mxPopupMenuItem';
        })
      );
  }
  return h;
};
mxPopupMenu.prototype.addCheckmark = function (a, b) {
  var c = a.firstChild.nextSibling;
  c.style.backgroundImage = "url('" + b + "')";
  c.style.backgroundRepeat = 'no-repeat';
  c.style.backgroundPosition = '2px 50%';
};
mxPopupMenu.prototype.createSubmenu = function (a) {
  a.table = document.createElement('table');
  a.table.className = 'mxPopupMenu';
  a.tbody = document.createElement('tbody');
  a.table.appendChild(a.tbody);
  a.div = document.createElement('div');
  a.div.className = 'mxPopupMenu';
  a.div.style.position = 'absolute';
  a.div.style.display = 'inline';
  a.div.style.zIndex = this.zIndex;
  a.div.appendChild(a.table);
  var b = document.createElement('img');
  b.setAttribute('src', this.submenuImage);
  td = a.firstChild.nextSibling.nextSibling;
  td.appendChild(b);
};
mxPopupMenu.prototype.showSubmenu = function (a, b) {
  if (null != b.div) {
    b.div.style.left = a.div.offsetLeft + b.offsetLeft + b.offsetWidth - 1 + 'px';
    b.div.style.top = a.div.offsetTop + b.offsetTop + 'px';
    document.body.appendChild(b.div);
    var c = parseInt(b.div.offsetLeft),
      d = parseInt(b.div.offsetWidth),
      e = mxUtils.getDocumentScrollOrigin(document),
      f = document.documentElement;
    c + d > e.x + (document.body.clientWidth || f.clientWidth) &&
      (b.div.style.left = Math.max(0, a.div.offsetLeft - d + (mxClient.IS_IE ? 6 : -6)) + 'px');
    b.div.style.overflowY = 'auto';
    b.div.style.overflowX = 'hidden';
    b.div.style.maxHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight) - 10 + 'px';
    mxUtils.fit(b.div);
  }
};
mxPopupMenu.prototype.addSeparator = function (a, b) {
  a = a || this;
  if (this.smartSeparators && !b) a.willAddSeparator = !0;
  else if (null != a.tbody) {
    a.willAddSeparator = !1;
    var c = document.createElement('tr'),
      d = document.createElement('td');
    d.className = 'mxPopupMenuIcon';
    d.style.padding = '0 0 0 0px';
    c.appendChild(d);
    d = document.createElement('td');
    d.style.padding = '0 0 0 0px';
    d.setAttribute('colSpan', '2');
    var e = document.createElement('hr');
    e.setAttribute('size', '1');
    d.appendChild(e);
    c.appendChild(d);
    a.tbody.appendChild(c);
  }
};
mxPopupMenu.prototype.popup = function (a, b, c, d) {
  if (null != this.div && null != this.tbody && null != this.factoryMethod) {
    this.div.style.left = a + 'px';
    for (this.div.style.top = b + 'px'; null != this.tbody.firstChild; )
      mxEvent.release(this.tbody.firstChild), this.tbody.removeChild(this.tbody.firstChild);
    this.itemCount = 0;
    this.factoryMethod(this, c, d);
    0 < this.itemCount && (this.showMenu(), this.fireEvent(new mxEventObject(mxEvent.SHOW)));
  }
};
mxPopupMenu.prototype.isMenuShowing = function () {
  return null != this.div && this.div.parentNode == document.body;
};
mxPopupMenu.prototype.showMenu = function () {
  9 <= document.documentMode && (this.div.style.filter = 'none');
  document.body.appendChild(this.div);
  mxUtils.fit(this.div);
};
mxPopupMenu.prototype.hideMenu = function () {
  null != this.div &&
    (null != this.div.parentNode && this.div.parentNode.removeChild(this.div),
    this.hideSubmenu(this),
    (this.containsItems = !1),
    this.fireEvent(new mxEventObject(mxEvent.HIDE)));
};
mxPopupMenu.prototype.hideSubmenu = function (a) {
  null != a.activeRow &&
    (this.hideSubmenu(a.activeRow),
    null != a.activeRow.div.parentNode && a.activeRow.div.parentNode.removeChild(a.activeRow.div),
    (a.activeRow = null));
};
mxPopupMenu.prototype.destroy = function () {
  null != this.div &&
    (mxEvent.release(this.div),
    null != this.div.parentNode && this.div.parentNode.removeChild(this.div),
    (this.div = null));
};
function mxImageExport() {}
mxImageExport.prototype.includeOverlays = !1;
mxImageExport.prototype.drawState = function (a, b) {
  null != a &&
    (this.visitStatesRecursive(
      a,
      b,
      mxUtils.bind(this, function () {
        this.drawCellState.apply(this, arguments);
      })
    ),
    this.includeOverlays &&
      this.visitStatesRecursive(
        a,
        b,
        mxUtils.bind(this, function () {
          this.drawOverlays.apply(this, arguments);
        })
      ));
};
mxImageExport.prototype.visitStatesRecursive = function (a, b, c) {
  if (null != a) {
    c(a, b);
    for (var d = a.view.graph, e = d.model.getChildCount(a.cell), f = 0; f < e; f++) {
      var g = d.view.getState(d.model.getChildAt(a.cell, f));
      this.visitStatesRecursive(g, b, c);
    }
  }
};
mxImageExport.prototype.getLinkForCellState = function (a, b) {
  return null;
};
mxImageExport.prototype.getLinkTargetForCellState = function (a, b) {
  return null;
};
mxImageExport.prototype.drawCellState = function (a, b) {
  var c = this.getLinkForCellState(a, b);
  null != c && b.setLink(c, this.getLinkTargetForCellState(a, b));
  this.drawShape(a, b);
  this.drawText(a, b);
  null != c && b.setLink(null);
};
mxImageExport.prototype.drawShape = function (a, b) {
  a.shape instanceof mxShape &&
    a.shape.checkBounds() &&
    (b.save(), a.shape.beforePaint(b), a.shape.paint(b), a.shape.afterPaint(b), b.restore());
};
mxImageExport.prototype.drawText = function (a, b) {
  null != a.text &&
    a.text.checkBounds() &&
    (b.save(), a.text.beforePaint(b), a.text.paint(b), a.text.afterPaint(b), b.restore());
};
mxImageExport.prototype.drawOverlays = function (a, b) {
  null != a.overlays &&
    a.overlays.visit(function (a, d) {
      d instanceof mxShape && d.paint(b);
    });
};
function mxAbstractCanvas2D() {
  this.converter = this.createUrlConverter();
  this.reset();
}
mxAbstractCanvas2D.prototype.state = null;
mxAbstractCanvas2D.prototype.states = null;
mxAbstractCanvas2D.prototype.path = null;
mxAbstractCanvas2D.prototype.rotateHtml = !0;
mxAbstractCanvas2D.prototype.lastX = 0;
mxAbstractCanvas2D.prototype.lastY = 0;
mxAbstractCanvas2D.prototype.moveOp = 'M';
mxAbstractCanvas2D.prototype.lineOp = 'L';
mxAbstractCanvas2D.prototype.quadOp = 'Q';
mxAbstractCanvas2D.prototype.curveOp = 'C';
mxAbstractCanvas2D.prototype.closeOp = 'Z';
mxAbstractCanvas2D.prototype.pointerEvents = !1;
mxAbstractCanvas2D.prototype.createUrlConverter = function () {
  return new mxUrlConverter();
};
mxAbstractCanvas2D.prototype.reset = function () {
  this.state = this.createState();
  this.states = [];
};
mxAbstractCanvas2D.prototype.createState = function () {
  return {
    dx: 0,
    dy: 0,
    scale: 1,
    alpha: 1,
    fillAlpha: 1,
    strokeAlpha: 1,
    fillColor: null,
    gradientFillAlpha: 1,
    gradientColor: null,
    gradientAlpha: 1,
    gradientDirection: null,
    strokeColor: null,
    strokeWidth: 1,
    dashed: !1,
    dashPattern: '3 3',
    fixDash: !1,
    lineCap: 'flat',
    lineJoin: 'miter',
    miterLimit: 10,
    fontColor: '#000000',
    fontBackgroundColor: null,
    fontBorderColor: null,
    fontSize: mxConstants.DEFAULT_FONTSIZE,
    fontFamily: mxConstants.DEFAULT_FONTFAMILY,
    fontStyle: 0,
    shadow: !1,
    shadowColor: mxConstants.SHADOWCOLOR,
    shadowAlpha: mxConstants.SHADOW_OPACITY,
    shadowDx: mxConstants.SHADOW_OFFSET_X,
    shadowDy: mxConstants.SHADOW_OFFSET_Y,
    rotation: 0,
    rotationCx: 0,
    rotationCy: 0,
  };
};
mxAbstractCanvas2D.prototype.format = function (a) {
  return Math.round(parseFloat(a));
};
mxAbstractCanvas2D.prototype.addOp = function () {
  if (null != this.path && (this.path.push(arguments[0]), 2 < arguments.length))
    for (var a = this.state, b = 2; b < arguments.length; b += 2)
      (this.lastX = arguments[b - 1]),
        (this.lastY = arguments[b]),
        this.path.push(this.format((this.lastX + a.dx) * a.scale)),
        this.path.push(this.format((this.lastY + a.dy) * a.scale));
};
mxAbstractCanvas2D.prototype.rotatePoint = function (a, b, c, d, e) {
  c *= Math.PI / 180;
  return mxUtils.getRotatedPoint(new mxPoint(a, b), Math.cos(c), Math.sin(c), new mxPoint(d, e));
};
mxAbstractCanvas2D.prototype.save = function () {
  this.states.push(this.state);
  this.state = mxUtils.clone(this.state);
};
mxAbstractCanvas2D.prototype.restore = function () {
  0 < this.states.length && (this.state = this.states.pop());
};
mxAbstractCanvas2D.prototype.setLink = function (a, b) {};
mxAbstractCanvas2D.prototype.scale = function (a) {
  this.state.scale *= a;
  this.state.strokeWidth *= a;
};
mxAbstractCanvas2D.prototype.translate = function (a, b) {
  this.state.dx += a;
  this.state.dy += b;
};
mxAbstractCanvas2D.prototype.rotate = function (a, b, c, d, e) {};
mxAbstractCanvas2D.prototype.setAlpha = function (a) {
  this.state.alpha = a;
};
mxAbstractCanvas2D.prototype.setFillAlpha = function (a) {
  this.state.fillAlpha = a;
};
mxAbstractCanvas2D.prototype.setStrokeAlpha = function (a) {
  this.state.strokeAlpha = a;
};
mxAbstractCanvas2D.prototype.setFillColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.fillColor = a;
  this.state.gradientColor = null;
};
mxAbstractCanvas2D.prototype.setGradient = function (a, b, c, d, e, f, g, k, h) {
  c = this.state;
  c.fillColor = a;
  c.gradientFillAlpha = null != k ? k : 1;
  c.gradientColor = b;
  c.gradientAlpha = null != h ? h : 1;
  c.gradientDirection = g;
};
mxAbstractCanvas2D.prototype.setStrokeColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.strokeColor = a;
};
mxAbstractCanvas2D.prototype.setStrokeWidth = function (a) {
  this.state.strokeWidth = a;
};
mxAbstractCanvas2D.prototype.setDashed = function (a, b) {
  this.state.dashed = a;
  this.state.fixDash = b;
};
mxAbstractCanvas2D.prototype.setDashPattern = function (a) {
  this.state.dashPattern = a;
};
mxAbstractCanvas2D.prototype.setLineCap = function (a) {
  this.state.lineCap = a;
};
mxAbstractCanvas2D.prototype.setLineJoin = function (a) {
  this.state.lineJoin = a;
};
mxAbstractCanvas2D.prototype.setMiterLimit = function (a) {
  this.state.miterLimit = a;
};
mxAbstractCanvas2D.prototype.setFontColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.fontColor = a;
};
mxAbstractCanvas2D.prototype.setFontBackgroundColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.fontBackgroundColor = a;
};
mxAbstractCanvas2D.prototype.setFontBorderColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.fontBorderColor = a;
};
mxAbstractCanvas2D.prototype.setFontSize = function (a) {
  this.state.fontSize = parseFloat(a);
};
mxAbstractCanvas2D.prototype.setFontFamily = function (a) {
  this.state.fontFamily = a;
};
mxAbstractCanvas2D.prototype.setFontStyle = function (a) {
  null == a && (a = 0);
  this.state.fontStyle = a;
};
mxAbstractCanvas2D.prototype.setShadow = function (a) {
  this.state.shadow = a;
};
mxAbstractCanvas2D.prototype.setShadowColor = function (a) {
  a == mxConstants.NONE && (a = null);
  this.state.shadowColor = a;
};
mxAbstractCanvas2D.prototype.setShadowAlpha = function (a) {
  this.state.shadowAlpha = a;
};
mxAbstractCanvas2D.prototype.setShadowOffset = function (a, b) {
  this.state.shadowDx = a;
  this.state.shadowDy = b;
};
mxAbstractCanvas2D.prototype.begin = function () {
  this.lastY = this.lastX = 0;
  this.path = [];
};
mxAbstractCanvas2D.prototype.moveTo = function (a, b) {
  this.addOp(this.moveOp, a, b);
};
mxAbstractCanvas2D.prototype.lineTo = function (a, b) {
  this.addOp(this.lineOp, a, b);
};
mxAbstractCanvas2D.prototype.quadTo = function (a, b, c, d) {
  this.addOp(this.quadOp, a, b, c, d);
};
mxAbstractCanvas2D.prototype.curveTo = function (a, b, c, d, e, f) {
  this.addOp(this.curveOp, a, b, c, d, e, f);
};
mxAbstractCanvas2D.prototype.arcTo = function (a, b, c, d, e, f, g) {
  a = mxUtils.arcToCurves(this.lastX, this.lastY, a, b, c, d, e, f, g);
  if (null != a) for (b = 0; b < a.length; b += 6) this.curveTo(a[b], a[b + 1], a[b + 2], a[b + 3], a[b + 4], a[b + 5]);
};
mxAbstractCanvas2D.prototype.close = function (a, b, c, d, e, f) {
  this.addOp(this.closeOp);
};
mxAbstractCanvas2D.prototype.end = function () {};
function mxSvgCanvas2D(a, b) {
  mxAbstractCanvas2D.call(this);
  this.root = a;
  this.gradients = [];
  this.defs = null;
  this.styleEnabled = null != b ? b : !1;
  var c = null;
  if (a.ownerDocument != document) for (c = a; null != c && 'svg' != c.nodeName; ) c = c.parentNode;
  null != c &&
    (0 < c.getElementsByTagName('defs').length && (this.defs = c.getElementsByTagName('defs')[0]),
    null == this.defs &&
      ((this.defs = this.createElement('defs')),
      null != c.firstChild ? c.insertBefore(this.defs, c.firstChild) : c.appendChild(this.defs)),
    this.styleEnabled && this.defs.appendChild(this.createStyle()));
}
mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);
(function () {
  mxSvgCanvas2D.prototype.useDomParser =
    !mxClient.IS_IE && 'function' === typeof DOMParser && 'function' === typeof XMLSerializer;
  if (mxSvgCanvas2D.prototype.useDomParser)
    try {
      var a = new DOMParser().parseFromString('test text', 'text/html');
      mxSvgCanvas2D.prototype.useDomParser = null != a;
    } catch (b) {
      mxSvgCanvas2D.prototype.useDomParser = !1;
    }
  mxSvgCanvas2D.prototype.useAbsoluteIds =
    !mxClient.IS_CHROMEAPP &&
    !mxClient.IS_IE &&
    !mxClient.IS_IE11 &&
    !mxClient.IS_EDGE &&
    0 < document.getElementsByTagName('base').length;
})();
mxSvgCanvas2D.prototype.node = null;
mxSvgCanvas2D.prototype.matchHtmlAlignment = !0;
mxSvgCanvas2D.prototype.textEnabled = !0;
mxSvgCanvas2D.prototype.foEnabled = !0;
mxSvgCanvas2D.prototype.foAltText = '[Object]';
mxSvgCanvas2D.prototype.foOffset = 0;
mxSvgCanvas2D.prototype.textOffset = 0;
mxSvgCanvas2D.prototype.imageOffset = 0;
mxSvgCanvas2D.prototype.strokeTolerance = 0;
mxSvgCanvas2D.prototype.minStrokeWidth = 1;
mxSvgCanvas2D.prototype.refCount = 0;
mxSvgCanvas2D.prototype.lineHeightCorrection = 1;
mxSvgCanvas2D.prototype.pointerEventsValue = 'all';
mxSvgCanvas2D.prototype.fontMetricsPadding = 10;
mxSvgCanvas2D.prototype.cacheOffsetSize = !0;
mxSvgCanvas2D.prototype.setCssText = function (a, b) {
  mxClient.IS_IE || mxClient.IS_IE11 ? a.setAttribute('style', b) : mxUtils.setCssText(a.style, b);
};
mxSvgCanvas2D.prototype.format = function (a) {
  return parseFloat(parseFloat(a).toFixed(2));
};
mxSvgCanvas2D.prototype.getBaseUrl = function () {
  var a = window.location.href,
    b = a.lastIndexOf('#');
  0 < b && (a = a.substring(0, b));
  return a;
};
mxSvgCanvas2D.prototype.reset = function () {
  mxAbstractCanvas2D.prototype.reset.apply(this, arguments);
  this.gradients = [];
};
mxSvgCanvas2D.prototype.createStyle = function (a) {
  a = this.createElement('style');
  a.setAttribute('type', 'text/css');
  mxUtils.write(
    a,
    'svg{font-family:' +
      mxConstants.DEFAULT_FONTFAMILY +
      ';font-size:' +
      mxConstants.DEFAULT_FONTSIZE +
      ';fill:none;stroke-miterlimit:10}'
  );
  return a;
};
mxSvgCanvas2D.prototype.createElement = function (a, b) {
  if (null != this.root.ownerDocument.createElementNS)
    return this.root.ownerDocument.createElementNS(b || mxConstants.NS_SVG, a);
  var c = this.root.ownerDocument.createElement(a);
  null != b && c.setAttribute('xmlns', b);
  return c;
};
mxSvgCanvas2D.prototype.getAlternateText = function (a, b, c, d, e, f, g, k, h, l, m, n, p) {
  return null != f ? this.foAltText : null;
};
mxSvgCanvas2D.prototype.createAlternateContent = function (a, b, c, d, e, f, g, k, h, l, m, n, p) {
  a = this.getAlternateText(a, b, c, d, e, f, g, k, h, l, m, n, p);
  d = this.state;
  return null != a && 0 < d.fontSize
    ? ((k = k == mxConstants.ALIGN_TOP ? 1 : k == mxConstants.ALIGN_BOTTOM ? 0 : 0.3),
      (e = g == mxConstants.ALIGN_RIGHT ? 'end' : g == mxConstants.ALIGN_LEFT ? 'start' : 'middle'),
      (g = this.createElement('text')),
      g.setAttribute('x', Math.round(b + d.dx)),
      g.setAttribute('y', Math.round(c + d.dy + k * d.fontSize)),
      g.setAttribute('fill', d.fontColor || 'black'),
      g.setAttribute('font-family', d.fontFamily),
      g.setAttribute('font-size', Math.round(d.fontSize) + 'px'),
      'start' != e && g.setAttribute('text-anchor', e),
      (d.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && g.setAttribute('font-weight', 'bold'),
      (d.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && g.setAttribute('font-style', 'italic'),
      (b = []),
      (d.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && b.push('underline'),
      (d.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && b.push('line-through'),
      0 < b.length && g.setAttribute('text-decoration', b.join(' ')),
      mxUtils.write(g, a),
      g)
    : null;
};
mxSvgCanvas2D.prototype.createGradientId = function (a, b, c, d, e) {
  a = mxUtils.rgba2hex(a);
  '#' == a.charAt(0) && (a = a.substring(1));
  b = mxUtils.rgba2hex(b);
  '#' == b.charAt(0) && (b = b.substring(1));
  a = a.toLowerCase() + '-' + c;
  b = b.toLowerCase() + '-' + d;
  c = null;
  null == e || e == mxConstants.DIRECTION_SOUTH
    ? (c = 's')
    : e == mxConstants.DIRECTION_EAST
    ? (c = 'e')
    : e == mxConstants.DIRECTION_RADIAL
    ? (c = 'r')
    : ((d = a),
      (a = b),
      (b = d),
      e == mxConstants.DIRECTION_NORTH ? (c = 's') : e == mxConstants.DIRECTION_WEST && (c = 'e'));
  return 'mx-gradient-' + a + '-' + b + '-' + c;
};
mxSvgCanvas2D.prototype.getSvgGradient = function (a, b, c, d, e) {
  var f = this.createGradientId(a, b, c, d, e),
    g = this.gradients[f];
  if (null == g) {
    var k = this.root.ownerSVGElement,
      h = 0,
      l = f + '-' + h;
    if (null != k)
      for (g = k.ownerDocument.getElementById(l); null != g && g.ownerSVGElement != k; )
        (l = f + '-' + h++), (g = k.ownerDocument.getElementById(l));
    else l = 'id' + ++this.refCount;
    null == g &&
      ((g = this.createSvgGradient(a, b, c, d, e)),
      g.setAttribute('id', l),
      null != this.defs ? this.defs.appendChild(g) : k.appendChild(g));
    this.gradients[f] = g;
  }
  return g.getAttribute('id');
};
mxSvgCanvas2D.prototype.createSvgGradient = function (a, b, c, d, e) {
  var f = this.createElement(e == mxConstants.DIRECTION_RADIAL ? 'radialGradient' : 'linearGradient');
  f.setAttribute('x1', '0%');
  f.setAttribute('y1', '0%');
  f.setAttribute('x2', '0%');
  f.setAttribute('y2', '0%');
  null == e || e == mxConstants.DIRECTION_SOUTH
    ? f.setAttribute('y2', '100%')
    : e == mxConstants.DIRECTION_EAST
    ? f.setAttribute('x2', '100%')
    : e == mxConstants.DIRECTION_NORTH
    ? f.setAttribute('y1', '100%')
    : e == mxConstants.DIRECTION_WEST && f.setAttribute('x1', '100%');
  e = this.createElement('stop');
  e.setAttribute('offset', '0%');
  e.style.stopColor = a;
  e.style.stopOpacity = c;
  f.appendChild(e);
  e = this.createElement('stop');
  e.setAttribute('offset', '100%');
  e.style.stopColor = b;
  e.style.stopOpacity = d;
  f.appendChild(e);
  return f;
};
mxSvgCanvas2D.prototype.addNode = function (a, b) {
  var c = this.node,
    d = this.state;
  if (null != c) {
    if ('path' == c.nodeName)
      if (null != this.path && 0 < this.path.length) c.setAttribute('d', this.path.join(' '));
      else return;
    a && null != d.fillColor
      ? this.updateFill()
      : this.styleEnabled ||
        ('ellipse' == c.nodeName && mxClient.IS_FF
          ? c.setAttribute('fill', 'transparent')
          : c.setAttribute('fill', 'none'),
        (a = !1));
    b && null != d.strokeColor ? this.updateStroke() : this.styleEnabled || c.setAttribute('stroke', 'none');
    null != d.transform && 0 < d.transform.length && c.setAttribute('transform', d.transform);
    this.pointerEvents
      ? c.setAttribute('pointer-events', this.pointerEventsValue)
      : this.pointerEvents || null != this.originalRoot || c.setAttribute('pointer-events', 'none');
    d.shadow && this.root.appendChild(this.createShadow(c));
    0 < this.strokeTolerance && (!a || null == d.fillColor) && this.addTolerance(c);
    (('rect' != c.nodeName && 'path' != c.nodeName && 'ellipse' != c.nodeName) ||
      ('none' != c.getAttribute('fill') && 'transparent' != c.getAttribute('fill')) ||
      'none' != c.getAttribute('stroke') ||
      'none' != c.getAttribute('pointer-events')) &&
      this.root.appendChild(c);
    this.node = null;
  }
};
mxSvgCanvas2D.prototype.addTolerance = function (a) {
  this.root.appendChild(this.createTolerance(a));
};
mxSvgCanvas2D.prototype.updateFill = function () {
  var a = this.state;
  (1 > a.alpha || 1 > a.fillAlpha) && this.node.setAttribute('fill-opacity', a.alpha * a.fillAlpha);
  if (null != a.fillColor)
    if (null != a.gradientColor && a.gradientColor != mxConstants.NONE)
      if (
        ((a = this.getSvgGradient(
          String(a.fillColor),
          String(a.gradientColor),
          a.gradientFillAlpha,
          a.gradientAlpha,
          a.gradientDirection
        )),
        this.root.ownerDocument == document && this.useAbsoluteIds)
      ) {
        var b = this.getBaseUrl().replace(/([\(\)])/g, '\\$1');
        this.node.setAttribute('fill', 'url(' + b + '#' + a + ')');
      } else this.node.setAttribute('fill', 'url(#' + a + ')');
    else this.node.setAttribute('fill', String(a.fillColor).toLowerCase());
};
mxSvgCanvas2D.prototype.getCurrentStrokeWidth = function () {
  return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
};
mxSvgCanvas2D.prototype.updateStroke = function () {
  var a = this.state;
  this.node.setAttribute('stroke', String(a.strokeColor).toLowerCase());
  (1 > a.alpha || 1 > a.strokeAlpha) && this.node.setAttribute('stroke-opacity', a.alpha * a.strokeAlpha);
  var b = this.getCurrentStrokeWidth();
  1 != b && this.node.setAttribute('stroke-width', b);
  'path' == this.node.nodeName && this.updateStrokeAttributes();
  a.dashed &&
    this.node.setAttribute('stroke-dasharray', this.createDashPattern((a.fixDash ? 1 : a.strokeWidth) * a.scale));
};
mxSvgCanvas2D.prototype.updateStrokeAttributes = function () {
  var a = this.state;
  null != a.lineJoin && 'miter' != a.lineJoin && this.node.setAttribute('stroke-linejoin', a.lineJoin);
  if (null != a.lineCap) {
    var b = a.lineCap;
    'flat' == b && (b = 'butt');
    'butt' != b && this.node.setAttribute('stroke-linecap', b);
  }
  null == a.miterLimit ||
    (this.styleEnabled && 10 == a.miterLimit) ||
    this.node.setAttribute('stroke-miterlimit', a.miterLimit);
};
mxSvgCanvas2D.prototype.createDashPattern = function (a) {
  var b = [];
  if ('string' === typeof this.state.dashPattern) {
    var c = this.state.dashPattern.split(' ');
    if (0 < c.length) for (var d = 0; d < c.length; d++) b[d] = Number(c[d]) * a;
  }
  return b.join(' ');
};
mxSvgCanvas2D.prototype.createTolerance = function (a) {
  a = a.cloneNode(!0);
  var b = parseFloat(a.getAttribute('stroke-width') || 1) + this.strokeTolerance;
  a.setAttribute('pointer-events', 'stroke');
  a.setAttribute('visibility', 'hidden');
  a.removeAttribute('stroke-dasharray');
  a.setAttribute('stroke-width', b);
  a.setAttribute('fill', 'none');
  a.setAttribute('stroke', mxClient.IS_OT ? 'none' : 'white');
  return a;
};
mxSvgCanvas2D.prototype.createShadow = function (a) {
  a = a.cloneNode(!0);
  var b = this.state;
  'none' == a.getAttribute('fill') ||
    (mxClient.IS_FF && 'transparent' == a.getAttribute('fill')) ||
    a.setAttribute('fill', b.shadowColor);
  'none' != a.getAttribute('stroke') && a.setAttribute('stroke', b.shadowColor);
  a.setAttribute(
    'transform',
    'translate(' +
      this.format(b.shadowDx * b.scale) +
      ',' +
      this.format(b.shadowDy * b.scale) +
      ')' +
      (b.transform || '')
  );
  a.setAttribute('opacity', b.shadowAlpha);
  return a;
};
mxSvgCanvas2D.prototype.setLink = function (a, b) {
  if (null == a) this.root = this.originalRoot;
  else {
    this.originalRoot = this.root;
    var c = this.createElement('a');
    null == c.setAttributeNS || (this.root.ownerDocument != document && null == document.documentMode)
      ? c.setAttribute('xlink:href', a)
      : c.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', a);
    null != b && c.setAttribute('target', b);
    this.root.appendChild(c);
    this.root = c;
  }
};
mxSvgCanvas2D.prototype.rotate = function (a, b, c, d, e) {
  if (0 != a || b || c) {
    var f = this.state;
    d += f.dx;
    e += f.dy;
    d *= f.scale;
    e *= f.scale;
    f.transform = f.transform || '';
    if (b && c) a += 180;
    else if (b != c) {
      var g = b ? d : 0,
        k = b ? -1 : 1,
        h = c ? e : 0,
        l = c ? -1 : 1;
      f.transform +=
        'translate(' +
        this.format(g) +
        ',' +
        this.format(h) +
        ')scale(' +
        this.format(k) +
        ',' +
        this.format(l) +
        ')translate(' +
        this.format(-g) +
        ',' +
        this.format(-h) +
        ')';
    }
    if (b ? !c : c) a *= -1;
    0 != a && (f.transform += 'rotate(' + this.format(a) + ',' + this.format(d) + ',' + this.format(e) + ')');
    f.rotation += a;
    f.rotationCx = d;
    f.rotationCy = e;
  }
};
mxSvgCanvas2D.prototype.begin = function () {
  mxAbstractCanvas2D.prototype.begin.apply(this, arguments);
  this.node = this.createElement('path');
};
mxSvgCanvas2D.prototype.rect = function (a, b, c, d) {
  var e = this.state,
    f = this.createElement('rect');
  f.setAttribute('x', this.format((a + e.dx) * e.scale));
  f.setAttribute('y', this.format((b + e.dy) * e.scale));
  f.setAttribute('width', this.format(c * e.scale));
  f.setAttribute('height', this.format(d * e.scale));
  this.node = f;
};
mxSvgCanvas2D.prototype.roundrect = function (a, b, c, d, e, f) {
  this.rect(a, b, c, d);
  0 < e && this.node.setAttribute('rx', this.format(e * this.state.scale));
  0 < f && this.node.setAttribute('ry', this.format(f * this.state.scale));
};
mxSvgCanvas2D.prototype.ellipse = function (a, b, c, d) {
  var e = this.state,
    f = this.createElement('ellipse');
  f.setAttribute('cx', this.format((a + c / 2 + e.dx) * e.scale));
  f.setAttribute('cy', this.format((b + d / 2 + e.dy) * e.scale));
  f.setAttribute('rx', (c / 2) * e.scale);
  f.setAttribute('ry', (d / 2) * e.scale);
  this.node = f;
};
mxSvgCanvas2D.prototype.image = function (a, b, c, d, e, f, g, k, h) {
  e = this.converter.convert(e);
  f = null != f ? f : !0;
  g = null != g ? g : !1;
  k = null != k ? k : !1;
  var l = this.state;
  a += l.dx;
  b += l.dy;
  var m = this.createElement('image');
  m.setAttribute('x', this.format(a * l.scale) + this.imageOffset);
  m.setAttribute('y', this.format(b * l.scale) + this.imageOffset);
  m.setAttribute('width', this.format(c * l.scale));
  m.setAttribute('height', this.format(d * l.scale));
  null == m.setAttributeNS ? m.setAttribute('xlink:href', e) : m.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', e);
  f || m.setAttribute('preserveAspectRatio', 'none');
  (1 > l.alpha || 1 > l.fillAlpha) && m.setAttribute('opacity', l.alpha * l.fillAlpha);
  e = this.state.transform || '';
  if (g || k) {
    var n = (f = 1),
      p = 0,
      r = 0;
    g && ((f = -1), (p = -c - 2 * a));
    k && ((n = -1), (r = -d - 2 * b));
    e += 'scale(' + f + ',' + n + ')translate(' + p * l.scale + ',' + r * l.scale + ')';
  }
  0 < e.length && m.setAttribute('transform', e);
  this.pointerEvents || m.setAttribute('pointer-events', 'none');
  null != h && this.processClipPath(m, h, new mxRectangle(a, b, c, d));
  this.root.appendChild(m);
};
mxSvgCanvas2D.prototype.processClipPath = function (a, b, c) {
  try {
    var d = this.createElement('clipPath');
    d.setAttribute('id', this.createClipPathId(b));
    d.setAttribute('clipPathUnits', 'objectBoundingBox');
    var e = this.appendClipPath(d, b, c);
    if (null != e) {
      var f = this.state;
      a.setAttribute('x', c.x * f.scale - (c.width * f.scale * e.x) / e.width + this.imageOffset);
      a.setAttribute('y', c.y * f.scale - (c.height * f.scale * e.y) / e.height + this.imageOffset);
      a.setAttribute('width', (c.width * f.scale) / e.width);
      a.setAttribute('height', (c.height * f.scale) / e.height);
    }
    this.setClip(a, d);
  } catch (g) {}
};
mxSvgCanvas2D.prototype.convertHtml = function (a) {
  if (this.useDomParser) {
    var b = new DOMParser().parseFromString(a, 'text/html');
    null != b &&
      ((a = new XMLSerializer().serializeToString(b.body)),
      '<body' == a.substring(0, 5) && (a = a.substring(a.indexOf('>', 5) + 1)),
      '</body>' == a.substring(a.length - 7, a.length) && (a = a.substring(0, a.length - 7)));
  } else {
    if (null != document.implementation && null != document.implementation.createDocument) {
      var b = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null),
        c = b.createElement('body');
      b.documentElement.appendChild(c);
      var d = document.createElement('div');
      d.innerHTML = a;
      for (a = d.firstChild; null != a; ) (d = a.nextSibling), c.appendChild(b.adoptNode(a)), (a = d);
      return c.innerHTML;
    }
    b = document.createElement('textarea');
    b.innerHTML = a
      .replace(/&amp;/g, '&amp;amp;')
      .replace(/&#60;/g, '&amp;lt;')
      .replace(/&#62;/g, '&amp;gt;')
      .replace(/&lt;/g, '&amp;lt;')
      .replace(/&gt;/g, '&amp;gt;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    a = b.value
      .replace(/&/g, '&amp;')
      .replace(/&amp;lt;/g, '&lt;')
      .replace(/&amp;gt;/g, '&gt;')
      .replace(/&amp;amp;/g, '&amp;')
      .replace(/<br>/g, '<br />')
      .replace(/<hr>/g, '<hr />')
      .replace(/(<img[^>]+)>/gm, '$1 />');
  }
  return a;
};
mxSvgCanvas2D.prototype.createDiv = function (a) {
  mxUtils.isNode(a) || (a = '<div><div>' + this.convertHtml(a) + '</div></div>');
  if (mxClient.IS_IE || mxClient.IS_IE11 || !document.createElementNS)
    return (
      mxUtils.isNode(a) && (a = '<div><div>' + mxUtils.getXml(a) + '</div></div>'),
      mxUtils.parseXml('<div xmlns="http://www.w3.org/1999/xhtml">' + a + '</div>').documentElement
    );
  var b = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
  if (mxUtils.isNode(a)) {
    var c = document.createElement('div'),
      d = c.cloneNode(!1);
    this.root.ownerDocument != document ? c.appendChild(a.cloneNode(!0)) : c.appendChild(a);
    d.appendChild(c);
    b.appendChild(d);
  } else b.innerHTML = a;
  return b;
};
mxSvgCanvas2D.prototype.updateText = function (a, b, c, d, e, f, g, k, h, l, m) {
  null != m &&
    null != m.firstChild &&
    null != m.firstChild.firstChild &&
    this.updateTextNodes(a, b, c, d, e, f, g, k, h, l, m.firstChild);
};
mxSvgCanvas2D.prototype.addForeignObject = function (a, b, c, d, e, f, g, k, h, l, m, n, p, r, t) {
  p = this.createElement('g');
  var u = this.createElement('foreignObject');
  this.setCssText(u, 'overflow: visible; text-align: left;');
  u.setAttribute('pointer-events', 'none');
  r.ownerDocument != document && (r = mxUtils.importNodeImplementation(u.ownerDocument, r, !0));
  u.appendChild(r);
  p.appendChild(u);
  this.updateTextNodes(a, b, c, d, f, g, k, l, m, n, p);
  this.root.ownerDocument != document &&
    ((a = this.createAlternateContent(u, a, b, c, d, e, f, g, k, h, l, m, n)),
    null != a &&
      (u.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility'),
      (b = this.createElement('switch')),
      b.appendChild(u),
      b.appendChild(a),
      p.appendChild(b)));
  t.appendChild(p);
};
mxSvgCanvas2D.prototype.updateTextNodes = function (a, b, c, d, e, f, g, k, h, l, m) {
  var n = this.state.scale;
  mxSvgCanvas2D.createCss(
    c + 2,
    d,
    e,
    f,
    g,
    k,
    h,
    null != this.state.fontBackgroundColor ? this.state.fontBackgroundColor : null,
    null != this.state.fontBorderColor ? this.state.fontBorderColor : null,
    'display: flex; align-items: unsafe ' +
      (f == mxConstants.ALIGN_TOP ? 'flex-start' : f == mxConstants.ALIGN_BOTTOM ? 'flex-end' : 'center') +
      '; justify-content: unsafe ' +
      (e == mxConstants.ALIGN_LEFT ? 'flex-start' : e == mxConstants.ALIGN_RIGHT ? 'flex-end' : 'center') +
      '; ',
    this.getTextCss(),
    n,
    mxUtils.bind(this, function (c, d, e, f, g) {
      a += this.state.dx;
      b += this.state.dy;
      var k = m.firstChild,
        h = k.firstChild,
        p = h.firstChild,
        r = (this.rotateHtml ? this.state.rotation : 0) + (null != l ? l : 0),
        t =
          (0 != this.foOffset ? 'translate(' + this.foOffset + ' ' + this.foOffset + ')' : '') +
          (1 != n ? 'scale(' + n + ')' : '');
      this.setCssText(p.firstChild, g);
      this.setCssText(p, f);
      p.setAttribute(
        'data-drawio-colors',
        'color: ' +
          this.state.fontColor +
          '; ' +
          (null == this.state.fontBackgroundColor ? '' : 'background-color: ' + this.state.fontBackgroundColor + '; ') +
          (null == this.state.fontBorderColor ? '' : 'border-color: ' + this.state.fontBorderColor + '; ')
      );
      k.setAttribute('width', Math.ceil((1 / Math.min(1, n)) * 100) + '%');
      k.setAttribute('height', Math.ceil((1 / Math.min(1, n)) * 100) + '%');
      d = Math.round(b + d);
      0 > d ? k.setAttribute('y', d) : (k.removeAttribute('y'), (e += 'padding-top: ' + d + 'px; '));
      this.setCssText(h, e + 'margin-left: ' + Math.round(a + c) + 'px;');
      t += 0 != r ? 'rotate(' + r + ' ' + a + ' ' + b + ')' : '';
      '' != t ? m.setAttribute('transform', t) : m.removeAttribute('transform');
      1 != this.state.alpha ? m.setAttribute('opacity', this.state.alpha) : m.removeAttribute('opacity');
    })
  );
};
mxSvgCanvas2D.createCss = function (a, b, c, d, e, f, g, k, h, l, m, n, p) {
  n =
    'box-sizing: border-box; font-size: 0; text-align: ' +
    (c == mxConstants.ALIGN_LEFT ? 'left' : c == mxConstants.ALIGN_RIGHT ? 'right' : 'center') +
    '; ';
  var r = mxUtils.getAlignmentAsPoint(c, d);
  c = 'overflow: hidden; ';
  var t = 'width: 1px; ',
    u = 'height: 1px; ',
    x = r.x * a,
    r = r.y * b;
  g
    ? ((t = 'width: ' + Math.round(a) + 'px; '), (n += 'max-height: ' + Math.round(b) + 'px; '), (r = 0))
    : 'fill' == f
    ? ((t = 'width: ' + Math.round(a) + 'px; '),
      (u = 'height: ' + Math.round(b) + 'px; '),
      (m += 'width: 100%; height: 100%; '),
      (n += 'width: ' + Math.round(a - 2) + 'px; ' + u))
    : 'width' == f
    ? ((t = 'width: ' + Math.round(a - 2) + 'px; '),
      (m += 'width: 100%; '),
      (n += t),
      (r = 0),
      0 < b && (n += 'max-height: ' + Math.round(b) + 'px; '))
    : 'block' == f
    ? ((t = 'width: ' + Math.round(a - 2) + 'px; '),
      (m += 'width: 100%; '),
      (c = ''),
      (r = 0),
      (n += t),
      'middle' == d && (n += 'max-height: ' + Math.round(b) + 'px; '))
    : ((c = ''), (r = 0));
  b = '';
  null != k && (b += 'background-color: ' + k + '; ');
  null != h && (b += 'border: 1px solid ' + h + '; ');
  '' == c || g ? (m += b) : (n += b);
  e && 0 < a
    ? ((m += 'white-space: normal; word-wrap: ' + mxConstants.WORD_WRAP + '; '),
      (t = 'width: ' + Math.round(a) + 'px; '),
      '' != c && 'fill' != f && (r = 0))
    : ((m += 'white-space: nowrap; '), '' == c && 'block' != f && (x = 0));
  p(x, r, l + t + u, n + c, m, c);
};
mxSvgCanvas2D.prototype.getTextCss = function () {
  var a = this.state,
    b =
      'display: inline-block; font-size: ' +
      a.fontSize +
      'px; font-family: ' +
      a.fontFamily +
      '; color: ' +
      a.fontColor +
      '; line-height: ' +
      (mxConstants.ABSOLUTE_LINE_HEIGHT
        ? a.fontSize * mxConstants.LINE_HEIGHT + 'px'
        : mxConstants.LINE_HEIGHT * this.lineHeightCorrection) +
      '; pointer-events: ' +
      (this.pointerEvents ? this.pointerEventsValue : 'none') +
      '; ';
  (a.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (b += 'font-weight: bold; ');
  (a.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (b += 'font-style: italic; ');
  var c = [];
  (a.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && c.push('underline');
  (a.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && c.push('line-through');
  0 < c.length && (b += 'text-decoration: ' + c.join(' ') + '; ');
  return b;
};
mxSvgCanvas2D.prototype.text = function (a, b, c, d, e, f, g, k, h, l, m, n, p) {
  if (this.textEnabled && null != e)
    if (((n = null != n ? n : 0), this.foEnabled && 'html' == h)) {
      var r = this.createDiv(e);
      null != r &&
        (null != p && r.setAttribute('dir', p),
        this.addForeignObject(a, b, c, d, e, f, g, k, h, l, m, n, p, r, this.root));
    } else this.plainText(a + this.state.dx, b + this.state.dy, c, d, e, f, g, k, l, m, n, p);
};
mxSvgCanvas2D.prototype.createClip = function (a, b, c, d) {
  a = Math.round(a);
  b = Math.round(b);
  c = Math.round(c);
  d = Math.round(d);
  for (
    var e = 'mx-clip-' + a + '-' + b + '-' + c + '-' + d, f = 0, g = e + '-' + f;
    null != document.getElementById(g);

  )
    g = e + '-' + ++f;
  e = this.createElement('clipPath');
  e.setAttribute('id', g);
  g = this.createElement('rect');
  g.setAttribute('x', a);
  g.setAttribute('y', b);
  g.setAttribute('width', c);
  g.setAttribute('height', d);
  e.appendChild(g);
  return e;
};
mxSvgCanvas2D.prototype.createClipPathId = function (a) {
  a = 'mx-clippath-' + a.replace(/[^a-zA-Z0-9]+/g, '-');
  for (var b = '-' == a.charAt(a.length - 1) ? '' : '-', c = 0, d = a + b + c; null != document.getElementById(d); )
    d = a + b + ++c;
  return d;
};
mxSvgCanvas2D.prototype.appendClipPath = function (a, b, c) {
  var d = b.match(/\(([^)]+)\)/),
    e = null;
  'polygon' == b.substring(0, 7)
    ? (e = this.appendPolygonClip(d[1], a, c))
    : 'circle' == b.substring(0, 6)
    ? (e = this.appendCircleClip(d[1], a, c))
    : 'ellipse' == b.substring(0, 7)
    ? (e = this.appendEllipseClip(d[1], a, c))
    : 'inset' == b.substring(0, 5) && (e = this.appendInsetClip(d[1], a, c));
  return e;
};
mxSvgCanvas2D.prototype.appendPolygonClip = function (a, b, c) {
  c = this.createElement('polygon');
  a = a.split(/[ ,]+/);
  for (var d = null, e = null, f = null, g = null, k = [], h = 0; h < a.length; h++) {
    var l = this.parseClipValue(a, h);
    if (0 == h % 2) {
      if (null == d || d > l) d = l;
      if (null == f || f < l) f = l;
    } else {
      if (null == e || e > l) e = l;
      if (null == g || g < l) g = l;
    }
    k.push(l);
  }
  c.setAttribute('points', k.join(','));
  b.appendChild(c);
  return new mxRectangle(d, e, f - d, g - e);
};
mxSvgCanvas2D.prototype.appendCircleClip = function (a, b, c) {
  c = this.createElement('circle');
  var d = a.split(/[ ,]+/);
  a = this.parseClipValue(d, 0);
  var e = this.parseClipValue(d, 2),
    d = this.parseClipValue(d, 3);
  c.setAttribute('r', a);
  c.setAttribute('cx', e);
  c.setAttribute('cy', d);
  b.appendChild(c);
  return new mxRectangle(e - a, d - a, 2 * a, 2 * a);
};
mxSvgCanvas2D.prototype.appendEllipseClip = function (a, b, c) {
  c = this.createElement('ellipse');
  var d = a.split(/[ ,]+/);
  a = this.parseClipValue(d, 0);
  var e = this.parseClipValue(d, 1),
    f = this.parseClipValue(d, 3),
    d = this.parseClipValue(d, 4);
  c.setAttribute('rx', a);
  c.setAttribute('ry', e);
  c.setAttribute('cx', f);
  c.setAttribute('cy', d);
  b.appendChild(c);
  return new mxRectangle(f - a, d - e, 2 * a, 2 * e);
};
mxSvgCanvas2D.prototype.appendInsetClip = function (a, b, c) {
  c = this.createElement('rect');
  var d = a.split(/[ ,]+/);
  a = this.parseClipValue(d, 0);
  var e = this.parseClipValue(d, 1),
    f = this.parseClipValue(d, 2),
    g = this.parseClipValue(d, 3),
    e = 1 - e - g,
    f = 1 - a - f;
  c.setAttribute('x', g);
  c.setAttribute('y', a);
  c.setAttribute('width', e);
  c.setAttribute('height', f);
  4 < d.length &&
    'round' == d[4] &&
    ((d = this.parseClipValue(d, 5)), c.setAttribute('rx', d), c.setAttribute('ry', d));
  b.appendChild(c);
  return new mxRectangle(g, a, e, f);
};
mxSvgCanvas2D.prototype.parseClipValue = function (a, b) {
  var c = a[Math.min(b, a.length - 1)],
    d = 1;
  'center' == c
    ? (d = 0.5)
    : 'top' == c || 'left' == c
    ? (d = 0)
    : ((c = parseFloat(c)), isNaN(c) || (d = Math.max(0, Math.min(1, c / 100))));
  return d;
};
mxSvgCanvas2D.prototype.setClip = function (a, b) {
  null != this.defs ? this.defs.appendChild(b) : this.root.appendChild(b);
  if (
    mxClient.IS_CHROMEAPP ||
    mxClient.IS_IE ||
    mxClient.IS_IE11 ||
    mxClient.IS_EDGE ||
    this.root.ownerDocument != document
  )
    a.setAttribute('clip-path', 'url(#' + b.getAttribute('id') + ')');
  else {
    var c = this.getBaseUrl().replace(/([\(\)])/g, '\\$1');
    a.setAttribute('clip-path', 'url(' + c + '#' + b.getAttribute('id') + ')');
  }
};
mxSvgCanvas2D.prototype.plainText = function (a, b, c, d, e, f, g, k, h, l, m, n) {
  m = null != m ? m : 0;
  k = this.state;
  var p = k.fontSize,
    r = this.createElement('g'),
    t = k.transform || '';
  this.updateFont(r);
  this.pointerEvents || null != this.originalRoot || r.setAttribute('pointer-events', 'none');
  0 != m && (t += 'rotate(' + m + ',' + this.format(a * k.scale) + ',' + this.format(b * k.scale) + ')');
  null != n && r.setAttribute('direction', n);
  l &&
    0 < c &&
    0 < d &&
    ((n = a),
    (m = b),
    f == mxConstants.ALIGN_CENTER ? (n -= c / 2) : f == mxConstants.ALIGN_RIGHT && (n -= c),
    'fill' != h && (g == mxConstants.ALIGN_MIDDLE ? (m -= d / 2) : g == mxConstants.ALIGN_BOTTOM && (m -= d)),
    this.setClip(r, this.createClip(n * k.scale - 2, m * k.scale - 2, c * k.scale + 4, d * k.scale + 4)));
  m = f == mxConstants.ALIGN_RIGHT ? 'end' : f == mxConstants.ALIGN_CENTER ? 'middle' : 'start';
  'start' != m && r.setAttribute('text-anchor', m);
  (this.styleEnabled && p == mxConstants.DEFAULT_FONTSIZE) || r.setAttribute('font-size', p * k.scale + 'px');
  0 < t.length && r.setAttribute('transform', t);
  1 > k.alpha && r.setAttribute('opacity', k.alpha);
  t = e.split('\n');
  n = Math.round(p * mxConstants.LINE_HEIGHT);
  var u = p + (t.length - 1) * n;
  m = b + p - 1;
  g == mxConstants.ALIGN_MIDDLE
    ? 'fill' == h
      ? (m -= d / 2)
      : ((l = (this.matchHtmlAlignment && l && 0 < d ? Math.min(u, d) : u) / 2), (m -= l))
    : g == mxConstants.ALIGN_BOTTOM &&
      ('fill' == h ? (m -= d) : ((l = this.matchHtmlAlignment && l && 0 < d ? Math.min(u, d) : u), (m -= l + 1)));
  for (l = 0; l < t.length; l++)
    0 < t[l].length &&
      0 < mxUtils.trim(t[l]).length &&
      ((p = this.createElement('text')),
      p.setAttribute('x', this.format(a * k.scale) + this.textOffset),
      p.setAttribute('y', this.format(m * k.scale) + this.textOffset),
      mxUtils.write(p, t[l]),
      r.appendChild(p)),
      (m += n);
  this.root.appendChild(r);
  this.addTextBackground(r, e, a, b, c, 'fill' == h ? d : u, f, g, h);
};
mxSvgCanvas2D.prototype.updateFont = function (a) {
  var b = this.state;
  a.setAttribute('fill', b.fontColor);
  (this.styleEnabled && b.fontFamily == mxConstants.DEFAULT_FONTFAMILY) || a.setAttribute('font-family', b.fontFamily);
  (b.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && a.setAttribute('font-weight', 'bold');
  (b.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && a.setAttribute('font-style', 'italic');
  var c = [];
  (b.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && c.push('underline');
  (b.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && c.push('line-through');
  0 < c.length && a.setAttribute('text-decoration', c.join(' '));
};
mxSvgCanvas2D.prototype.addTextBackground = function (a, b, c, d, e, f, g, k, h) {
  var l = this.state;
  if (null != l.fontBackgroundColor || null != l.fontBorderColor) {
    var m = null;
    if ('fill' == h || 'width' == h)
      g == mxConstants.ALIGN_CENTER ? (c -= e / 2) : g == mxConstants.ALIGN_RIGHT && (c -= e),
        k == mxConstants.ALIGN_MIDDLE ? (d -= f / 2) : k == mxConstants.ALIGN_BOTTOM && (d -= f),
        (m = new mxRectangle((c + 1) * l.scale, d * l.scale, (e - 2) * l.scale, (f + 2) * l.scale));
    else if (null != a.getBBox && this.root.ownerDocument == document)
      try {
        var m = a.getBBox(),
          n = mxClient.IS_IE && mxClient.IS_SVG,
          m = new mxRectangle(m.x, m.y + (n ? 0 : 1), m.width, m.height + (n ? 1 : 0));
      } catch (p) {}
    if (null == m || 0 == m.width || 0 == m.height)
      (m = document.createElement('div')),
        (m.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT
          ? l.fontSize * mxConstants.LINE_HEIGHT + 'px'
          : mxConstants.LINE_HEIGHT),
        (m.style.fontSize = l.fontSize + 'px'),
        (m.style.fontFamily = l.fontFamily),
        (m.style.whiteSpace = 'nowrap'),
        (m.style.position = 'absolute'),
        (m.style.visibility = 'hidden'),
        (m.style.display = 'inline-block'),
        (m.style.zoom = '1'),
        (l.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (m.style.fontWeight = 'bold'),
        (l.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (m.style.fontStyle = 'italic'),
        (b = mxUtils.htmlEntities(b, !1)),
        (m.innerHTML = b.replace(/\n/g, '<br/>')),
        document.body.appendChild(m),
        (e = m.offsetWidth),
        (f = m.offsetHeight),
        m.parentNode.removeChild(m),
        g == mxConstants.ALIGN_CENTER ? (c -= e / 2) : g == mxConstants.ALIGN_RIGHT && (c -= e),
        k == mxConstants.ALIGN_MIDDLE ? (d -= f / 2) : k == mxConstants.ALIGN_BOTTOM && (d -= f),
        (m = new mxRectangle((c + 1) * l.scale, (d + 2) * l.scale, e * l.scale, (f + 1) * l.scale));
    null != m &&
      ((b = this.createElement('rect')),
      b.setAttribute('fill', l.fontBackgroundColor || 'none'),
      b.setAttribute('stroke', l.fontBorderColor || 'none'),
      b.setAttribute('x', Math.floor(m.x - 1)),
      b.setAttribute('y', Math.floor(m.y - 1)),
      b.setAttribute('width', Math.ceil(m.width + 2)),
      b.setAttribute('height', Math.ceil(m.height)),
      (l = null != l.fontBorderColor ? Math.max(1, this.format(l.scale)) : 0),
      b.setAttribute('stroke-width', l),
      this.root.ownerDocument == document &&
        1 == mxUtils.mod(l, 2) &&
        b.setAttribute('transform', 'translate(0.5, 0.5)'),
      a.insertBefore(b, a.firstChild));
  }
};
mxSvgCanvas2D.prototype.stroke = function () {
  this.addNode(!1, !0);
};
mxSvgCanvas2D.prototype.fill = function () {
  this.addNode(!0, !1);
};
mxSvgCanvas2D.prototype.fillAndStroke = function () {
  this.addNode(!0, !0);
};
function mxShape(a) {
  this.stencil = a;
  this.initStyles();
}
mxShape.prototype.dialect = null;
mxShape.prototype.scale = 1;
mxShape.prototype.antiAlias = !0;
mxShape.prototype.minSvgStrokeWidth = 1;
mxShape.prototype.bounds = null;
mxShape.prototype.points = null;
mxShape.prototype.node = null;
mxShape.prototype.state = null;
mxShape.prototype.style = null;
mxShape.prototype.boundingBox = null;
mxShape.prototype.stencil = null;
mxShape.prototype.svgStrokeTolerance = 8;
mxShape.prototype.pointerEvents = !0;
mxShape.prototype.svgPointerEvents = 'all';
mxShape.prototype.shapePointerEvents = !1;
mxShape.prototype.stencilPointerEvents = !1;
mxShape.prototype.outline = !1;
mxShape.prototype.visible = !0;
mxShape.prototype.useSvgBoundingBox = !1;
mxShape.prototype.init = function (a) {
  null == this.node && ((this.node = this.create(a)), null != a && a.appendChild(this.node));
};
mxShape.prototype.initStyles = function (a) {
  this.strokewidth = 1;
  this.rotation = 0;
  this.strokeOpacity = this.fillOpacity = this.opacity = 100;
  this.flipV = this.flipH = !1;
};
mxShape.prototype.isHtmlAllowed = function () {
  return !1;
};
mxShape.prototype.getSvgScreenOffset = function () {
  return 1 ==
    mxUtils.mod(
      Math.max(
        1,
        Math.round(
          (this.stencil && 'inherit' != this.stencil.strokewidth
            ? Number(this.stencil.strokewidth)
            : this.strokewidth) * this.scale
        )
      ),
      2
    )
    ? 0.5
    : 0;
};
mxShape.prototype.create = function (a) {
  return null != a && null != a.ownerSVGElement ? this.createSvg(a) : this.createHtml(a);
};
mxShape.prototype.createSvg = function () {
  return document.createElementNS(mxConstants.NS_SVG, 'g');
};
mxShape.prototype.createHtml = function () {
  var a = document.createElement('div');
  a.style.position = 'absolute';
  return a;
};
mxShape.prototype.reconfigure = function () {
  this.redraw();
};
mxShape.prototype.redraw = function () {
  this.updateBoundsFromPoints();
  this.visible && this.checkBounds()
    ? ((this.node.style.visibility = 'visible'),
      this.clear(),
      'DIV' == this.node.nodeName ? this.redrawHtmlShape() : this.redrawShape(),
      this.updateBoundingBox())
    : ((this.node.style.visibility = 'hidden'), (this.boundingBox = null));
};
mxShape.prototype.clear = function () {
  if (null != this.node.ownerSVGElement)
    for (; null != this.node.lastChild; ) this.node.removeChild(this.node.lastChild);
  else
    (this.node.style.cssText = 'position:absolute;' + (null != this.cursor ? 'cursor:' + this.cursor + ';' : '')),
      (this.node.innerHTML = '');
};
mxShape.prototype.updateBoundsFromPoints = function () {
  var a = this.points;
  if (null != a && 0 < a.length && null != a[0]) {
    this.bounds = new mxRectangle(Number(a[0].x), Number(a[0].y), 1, 1);
    for (var b = 1; b < this.points.length; b++)
      null != a[b] && this.bounds.add(new mxRectangle(Number(a[b].x), Number(a[b].y), 1, 1));
  }
};
mxShape.prototype.getLabelBounds = function (a) {
  var b = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST),
    c = a;
  b != mxConstants.DIRECTION_SOUTH &&
    b != mxConstants.DIRECTION_NORTH &&
    null != this.state &&
    null != this.state.text &&
    this.state.text.isPaintBoundsInverted() &&
    ((c = c.clone()), (b = c.width), (c.width = c.height), (c.height = b));
  c = this.getLabelMargins(c);
  if (null != c) {
    var d = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, !1),
      e = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, !1);
    null != this.state &&
      null != this.state.text &&
      this.state.text.isPaintBoundsInverted() &&
      ((b = c.x), (c.x = c.height), (c.height = c.width), (c.width = c.y), (c.y = b), (b = d), (d = e), (e = b));
    return mxUtils.getDirectedBounds(a, c, this.style, d, e);
  }
  return a;
};
mxShape.prototype.getLabelMargins = function (a) {
  return null;
};
mxShape.prototype.checkBounds = function () {
  return (
    !isNaN(this.scale) &&
    isFinite(this.scale) &&
    0 < this.scale &&
    null != this.bounds &&
    !isNaN(this.bounds.x) &&
    !isNaN(this.bounds.y) &&
    !isNaN(this.bounds.width) &&
    !isNaN(this.bounds.height) &&
    0 < this.bounds.width &&
    0 < this.bounds.height
  );
};
mxShape.prototype.redrawShape = function () {
  var a = this.createCanvas();
  null != a &&
    ((a.pointerEvents = this.pointerEvents),
    this.beforePaint(a),
    this.paint(a),
    this.afterPaint(a),
    this.node != a.root && this.node.insertAdjacentHTML('beforeend', a.root.outerHTML),
    'DIV' == this.node.nodeName &&
      8 == document.documentMode &&
      ((this.node.style.filter = ''), mxUtils.addTransparentBackgroundFilter(this.node)),
    this.destroyCanvas(a));
};
mxShape.prototype.createCanvas = function () {
  var a = null;
  null != this.node.ownerSVGElement && (a = this.createSvgCanvas());
  null != a &&
    this.outline &&
    (a.setStrokeWidth(this.strokewidth),
    a.setStrokeColor(this.stroke),
    null != this.isDashed && a.setDashed(this.isDashed),
    (a.setStrokeWidth = function () {}),
    (a.setStrokeColor = function () {}),
    (a.setFillColor = function () {}),
    (a.setGradient = function () {}),
    (a.setDashed = function () {}),
    (a.text = function () {}));
  return a;
};
mxShape.prototype.createSvgCanvas = function () {
  var a = new mxSvgCanvas2D(this.node, !1);
  a.strokeTolerance = this.svgStrokeTolerance;
  a.pointerEventsValue = this.svgPointerEvents;
  var b = this.getSvgScreenOffset();
  0 != b
    ? this.node.setAttribute('transform', 'translate(' + b + ',' + b + ')')
    : this.node.removeAttribute('transform');
  a.minStrokeWidth = this.minSvgStrokeWidth;
  this.antiAlias ||
    (a.format = function (a) {
      return Math.round(parseFloat(a));
    });
  return a;
};
mxShape.prototype.redrawHtmlShape = function () {
  this.updateHtmlBounds(this.node);
  this.updateHtmlFilters(this.node);
  this.updateHtmlColors(this.node);
};
mxShape.prototype.updateHtmlFilters = function (a) {
  var b = '';
  100 > this.opacity && (b += 'alpha(opacity=' + this.opacity + ')');
  this.isShadow &&
    (b +=
      "progid:DXImageTransform.Microsoft.dropShadow (OffX='" +
      Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) +
      "', OffY='" +
      Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) +
      "', Color='" +
      mxConstants.VML_SHADOWCOLOR +
      "')");
  if (null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE) {
    var c = this.fill,
      d = this.gradient,
      e = '0',
      f = { east: 0, south: 1, west: 2, north: 3 },
      g = null != this.direction ? f[this.direction] : 0;
    null != this.gradientDirection && (g = mxUtils.mod(g + f[this.gradientDirection] - 1, 4));
    1 == g ? ((e = '1'), (f = c), (c = d), (d = f)) : 2 == g ? ((f = c), (c = d), (d = f)) : 3 == g && (e = '1');
    b +=
      "progid:DXImageTransform.Microsoft.gradient(startColorStr='" +
      c +
      "', endColorStr='" +
      d +
      "', gradientType='" +
      e +
      "')";
  }
  a.style.filter = b;
};
mxShape.prototype.updateHtmlColors = function (a) {
  var b = this.stroke;
  null != b && b != mxConstants.NONE
    ? ((a.style.borderColor = b),
      this.isDashed ? (a.style.borderStyle = 'dashed') : 0 < this.strokewidth && (a.style.borderStyle = 'solid'),
      (a.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + 'px'))
    : (a.style.borderWidth = '0px');
  b = this.outline ? null : this.fill;
  null != b && b != mxConstants.NONE
    ? ((a.style.backgroundColor = b), (a.style.backgroundImage = 'none'))
    : this.pointerEvents
    ? (a.style.backgroundColor = 'transparent')
    : 8 == document.documentMode
    ? mxUtils.addTransparentBackgroundFilter(a)
    : this.setTransparentBackgroundImage(a);
};
mxShape.prototype.updateHtmlBounds = function (a) {
  var b = 9 <= document.documentMode ? 0 : Math.ceil(this.strokewidth * this.scale);
  a.style.borderWidth = Math.max(1, b) + 'px';
  a.style.overflow = 'hidden';
  a.style.left = Math.round(this.bounds.x - b / 2) + 'px';
  a.style.top = Math.round(this.bounds.y - b / 2) + 'px';
  'CSS1Compat' == document.compatMode && (b = -b);
  a.style.width = Math.round(Math.max(0, this.bounds.width + b)) + 'px';
  a.style.height = Math.round(Math.max(0, this.bounds.height + b)) + 'px';
};
mxShape.prototype.destroyCanvas = function (a) {
  if (a instanceof mxSvgCanvas2D) {
    for (var b in a.gradients) {
      var c = a.gradients[b];
      null != c && (c.mxRefCount = (c.mxRefCount || 0) + 1);
    }
    this.releaseSvgGradients(this.oldGradients);
    this.oldGradients = a.gradients;
  }
};
mxShape.prototype.beforePaint = function (a) {};
mxShape.prototype.afterPaint = function (a) {};
mxShape.prototype.paint = function (a) {
  var b = !1;
  if (null != a && this.outline) {
    var c = a.stroke;
    a.stroke = function () {
      b = !0;
      c.apply(this, arguments);
    };
    var d = a.fillAndStroke;
    a.fillAndStroke = function () {
      b = !0;
      d.apply(this, arguments);
    };
  }
  var e = this.scale,
    f = this.bounds.x / e,
    g = this.bounds.y / e,
    k = this.bounds.width / e,
    h = this.bounds.height / e;
  if (this.isPaintBoundsInverted())
    var l = (k - h) / 2,
      f = f + l,
      g = g - l,
      l = k,
      k = h,
      h = l;
  this.updateTransform(a, f, g, k, h);
  this.configureCanvas(a, f, g, k, h);
  l = null;
  if (
    (null == this.stencil && null == this.points && this.shapePointerEvents) ||
    (null != this.stencil && this.stencilPointerEvents)
  ) {
    var m = this.createBoundingBox();
    this.dialect == mxConstants.DIALECT_SVG
      ? ((l = this.createTransparentSvgRectangle(m.x, m.y, m.width, m.height)), this.node.appendChild(l))
      : ((e = a.createRect('rect', m.x / e, m.y / e, m.width / e, m.height / e)),
        e.appendChild(a.createTransparentFill()),
        (e.stroked = 'false'),
        a.root.appendChild(e));
  }
  null != this.stencil
    ? this.stencil.drawShape(a, this, f, g, k, h)
    : (a.setStrokeWidth(this.strokewidth),
      (e = this.getWaypoints()),
      null != e ? 1 < e.length && this.paintEdgeShape(a, e) : this.paintVertexShape(a, f, g, k, h));
  null != l && null != a.state && null != a.state.transform && l.setAttribute('transform', a.state.transform);
  null != a && this.outline && !b && (a.rect(f, g, k, h), a.stroke());
};
mxShape.prototype.getWaypoints = function () {
  var a = this.points,
    b = null;
  if (null != a && ((b = []), 0 < a.length)) {
    var c = this.scale,
      d = Math.max(c, 1),
      e = a[0];
    b.push(new mxPoint(e.x / c, e.y / c));
    for (var f = 1; f < a.length; f++) {
      var g = a[f];
      (Math.abs(e.x - g.x) >= d || Math.abs(e.y - g.y) >= d) && b.push(new mxPoint(g.x / c, g.y / c));
      e = g;
    }
  }
  return b;
};
mxShape.prototype.configureCanvas = function (a, b, c, d, e) {
  var f = null;
  null != this.style && (f = this.style.dashPattern);
  a.setAlpha(this.opacity / 100);
  a.setFillAlpha(this.fillOpacity / 100);
  a.setStrokeAlpha(this.strokeOpacity / 100);
  null != this.isShadow && a.setShadow(this.isShadow);
  null != this.isDashed &&
    a.setDashed(
      this.isDashed,
      null != this.style ? 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, !1) : !1
    );
  null != f && a.setDashPattern(f);
  null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE
    ? ((b = this.getGradientBounds(a, b, c, d, e)),
      a.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection))
    : a.setFillColor(this.fill);
  a.setStrokeColor(this.stroke);
  this.configurePointerEvents(a);
};
mxShape.prototype.configurePointerEvents = function (a) {
  null == this.style ||
    (null != this.fill && this.fill != mxConstants.NONE && 0 != this.opacity && 0 != this.fillOpacity) ||
    '0' != mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') ||
    (a.pointerEvents = !1);
};
mxShape.prototype.getGradientBounds = function (a, b, c, d, e) {
  return new mxRectangle(b, c, d, e);
};
mxShape.prototype.updateTransform = function (a, b, c, d, e) {
  a.scale(this.scale);
  a.rotate(this.getShapeRotation(), this.flipH, this.flipV, b + d / 2, c + e / 2);
};
mxShape.prototype.paintVertexShape = function (a, b, c, d, e) {
  this.paintBackground(a, b, c, d, e);
  (this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)) ||
    (a.setShadow(!1), this.paintForeground(a, b, c, d, e));
};
mxShape.prototype.paintBackground = function (a, b, c, d, e) {};
mxShape.prototype.paintForeground = function (a, b, c, d, e) {};
mxShape.prototype.paintEdgeShape = function (a, b) {};
mxShape.prototype.getArcSize = function (a, b) {
  var c;
  '1' == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)
    ? (c = Math.min(
        a / 2,
        Math.min(b / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2)
      ))
    : ((c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100),
      (c = Math.min(a * c, b * c)));
  return c;
};
mxShape.prototype.paintGlassEffect = function (a, b, c, d, e, f) {
  var g = Math.ceil(this.strokewidth / 2);
  a.setGradient('#ffffff', '#ffffff', b, c, d, 0.6 * e, 'south', 0.9, 0.1);
  a.begin();
  f += 2 * g;
  this.isRounded
    ? (a.moveTo(b - g + f, c - g),
      a.quadTo(b - g, c - g, b - g, c - g + f),
      a.lineTo(b - g, c + 0.4 * e),
      a.quadTo(b + 0.5 * d, c + 0.7 * e, b + d + g, c + 0.4 * e),
      a.lineTo(b + d + g, c - g + f),
      a.quadTo(b + d + g, c - g, b + d + g - f, c - g))
    : (a.moveTo(b - g, c - g),
      a.lineTo(b - g, c + 0.4 * e),
      a.quadTo(b + 0.5 * d, c + 0.7 * e, b + d + g, c + 0.4 * e),
      a.lineTo(b + d + g, c - g));
  a.close();
  a.fill();
};
mxShape.prototype.addPoints = function (a, b, c, d, e, f, g) {
  if (null != b && 0 < b.length) {
    g = null != g ? g : !0;
    var k = b[b.length - 1];
    if (e && c) {
      b = b.slice();
      var h = b[0],
        h = new mxPoint(k.x + (h.x - k.x) / 2, k.y + (h.y - k.y) / 2);
      b.splice(0, 0, h);
    }
    var l = b[0],
      h = 1;
    for (g ? a.moveTo(l.x, l.y) : a.lineTo(l.x, l.y); h < (e ? b.length : b.length - 1); ) {
      g = b[mxUtils.mod(h, b.length)];
      var m = l.x - g.x,
        l = l.y - g.y;
      if (c && (0 != m || 0 != l) && (null == f || 0 > mxUtils.indexOf(f, h - 1))) {
        var n = Math.sqrt(m * m + l * l);
        a.lineTo(g.x + (m * Math.min(d, n / 2)) / n, g.y + (l * Math.min(d, n / 2)) / n);
        for (
          l = b[mxUtils.mod(h + 1, b.length)];
          h < b.length - 2 && 0 == Math.round(l.x - g.x) && 0 == Math.round(l.y - g.y);

        )
          (l = b[mxUtils.mod(h + 2, b.length)]), h++;
        m = l.x - g.x;
        l = l.y - g.y;
        n = Math.max(1, Math.sqrt(m * m + l * l));
        m = g.x + (m * Math.min(d, n / 2)) / n;
        l = g.y + (l * Math.min(d, n / 2)) / n;
        a.quadTo(g.x, g.y, m, l);
        g = new mxPoint(m, l);
      } else a.lineTo(g.x, g.y);
      l = g;
      h++;
    }
    e ? a.close() : a.lineTo(k.x, k.y);
  }
};
mxShape.prototype.resetStyles = function () {
  this.initStyles();
  this.spacing = 0;
  delete this.fill;
  delete this.gradient;
  delete this.gradientDirection;
  delete this.stroke;
  delete this.startSize;
  delete this.endSize;
  delete this.startArrow;
  delete this.endArrow;
  delete this.direction;
  delete this.isShadow;
  delete this.isDashed;
  delete this.isRounded;
  delete this.glass;
};
mxShape.prototype.apply = function (a) {
  this.state = a;
  this.style = a.style;
  if (null != this.style) {
    this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);
    this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);
    this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);
    this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);
    this.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);
    this.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);
    this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);
    this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);
    this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);
    this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);
    this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);
    this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);
    this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);
    this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);
    this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);
    this.flipH = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0);
    this.flipV = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
    null != this.stencil &&
      ((this.flipH = 1 == mxUtils.getValue(this.style, 'stencilFlipH', 0) || this.flipH),
      (this.flipV = 1 == mxUtils.getValue(this.style, 'stencilFlipV', 0) || this.flipV));
    if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)
      (a = this.flipH), (this.flipH = this.flipV), (this.flipV = a);
    this.isShadow = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow);
    this.isDashed = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed);
    this.isRounded = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded);
    this.glass = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass);
    this.fill == mxConstants.NONE && (this.fill = null);
    this.gradient == mxConstants.NONE && (this.gradient = null);
    this.stroke == mxConstants.NONE && (this.stroke = null);
  }
};
mxShape.prototype.setCursor = function (a) {
  null == a && (a = '');
  this.cursor = a;
  null != this.node && (this.node.style.cursor = a);
};
mxShape.prototype.getCursor = function () {
  return this.cursor;
};
mxShape.prototype.isRoundable = function () {
  return !1;
};
mxShape.prototype.updateBoundingBox = function () {
  if (this.useSvgBoundingBox && null != this.node && null != this.node.ownerSVGElement)
    try {
      var a = this.node.getBBox();
      if (0 < a.width && 0 < a.height) {
        this.boundingBox = new mxRectangle(a.x, a.y, a.width, a.height);
        this.boundingBox.grow((this.strokewidth * this.scale) / 2);
        return;
      }
    } catch (c) {}
  if (null != this.bounds) {
    a = this.createBoundingBox();
    if (null != a) {
      this.augmentBoundingBox(a);
      var b = this.getShapeRotation();
      0 != b && (a = mxUtils.getBoundingBox(a, b));
    }
    this.boundingBox = a;
  }
};
mxShape.prototype.createBoundingBox = function () {
  var a = this.bounds.clone();
  ((null != this.stencil &&
    (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)) ||
    this.isPaintBoundsInverted()) &&
    a.rotate90();
  return a;
};
mxShape.prototype.augmentBoundingBox = function (a) {
  this.isShadow &&
    ((a.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale)),
    (a.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale)));
  a.grow((this.strokewidth * this.scale) / 2);
};
mxShape.prototype.isPaintBoundsInverted = function () {
  return (
    null == this.stencil &&
    (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)
  );
};
mxShape.prototype.getRotation = function () {
  return null != this.rotation ? this.rotation : 0;
};
mxShape.prototype.getTextRotation = function () {
  var a = this.getRotation();
  1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) && (a += mxText.prototype.verticalTextRotation);
  return a;
};
mxShape.prototype.getShapeRotation = function () {
  var a = this.getRotation();
  null != this.direction &&
    (this.direction == mxConstants.DIRECTION_NORTH
      ? (a += 270)
      : this.direction == mxConstants.DIRECTION_WEST
      ? (a += 180)
      : this.direction == mxConstants.DIRECTION_SOUTH && (a += 90));
  return a;
};
mxShape.prototype.createTransparentSvgRectangle = function (a, b, c, d) {
  var e = document.createElementNS(mxConstants.NS_SVG, 'rect');
  e.setAttribute('x', a);
  e.setAttribute('y', b);
  e.setAttribute('width', c);
  e.setAttribute('height', d);
  e.setAttribute('fill', 'none');
  e.setAttribute('stroke', 'none');
  e.setAttribute('pointer-events', 'all');
  return e;
};
mxShape.prototype.setTransparentBackgroundImage = function (a) {
  a.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
};
mxShape.prototype.intersectsRectangle = function (a) {
  return (
    null != a &&
    null != this.node &&
    'hidden' != this.node.style.visibility &&
    'none' != this.node.style.display &&
    mxUtils.intersects(this.bounds, a)
  );
};
mxShape.prototype.releaseSvgGradients = function (a) {
  if (null != a)
    for (var b in a) {
      var c = a[b];
      null != c &&
        ((c.mxRefCount = (c.mxRefCount || 0) - 1),
        0 == c.mxRefCount && null != c.parentNode && c.parentNode.removeChild(c));
    }
};
mxShape.prototype.destroy = function () {
  null != this.node &&
    (mxEvent.release(this.node),
    null != this.node.parentNode && this.node.parentNode.removeChild(this.node),
    (this.node = null));
  this.releaseSvgGradients(this.oldGradients);
  this.oldGradients = null;
};
function mxStencil(a) {
  this.desc = a;
  this.parseDescription();
  this.parseConstraints();
}
mxUtils.extend(mxStencil, mxShape);
mxStencil.defaultLocalized = !1;
mxStencil.allowEval = !1;
mxStencil.prototype.desc = null;
mxStencil.prototype.constraints = null;
mxStencil.prototype.aspect = null;
mxStencil.prototype.w0 = null;
mxStencil.prototype.h0 = null;
mxStencil.prototype.bgNode = null;
mxStencil.prototype.fgNode = null;
mxStencil.prototype.strokewidth = null;
mxStencil.prototype.parseDescription = function () {
  this.fgNode = this.desc.getElementsByTagName('foreground')[0];
  this.bgNode = this.desc.getElementsByTagName('background')[0];
  this.w0 = Number(this.desc.getAttribute('w') || 100);
  this.h0 = Number(this.desc.getAttribute('h') || 100);
  var a = this.desc.getAttribute('aspect');
  this.aspect = null != a ? a : 'variable';
  a = this.desc.getAttribute('strokewidth');
  this.strokewidth = null != a ? a : '1';
};
mxStencil.prototype.parseConstraints = function () {
  var a = this.desc.getElementsByTagName('connections')[0];
  if (null != a && ((a = mxUtils.getChildNodes(a)), null != a && 0 < a.length)) {
    this.constraints = [];
    for (var b = 0; b < a.length; b++) this.constraints.push(this.parseConstraint(a[b]));
  }
};
mxStencil.prototype.parseConstraint = function (a) {
  var b = Number(a.getAttribute('x')),
    c = Number(a.getAttribute('y')),
    d = '1' == a.getAttribute('perimeter');
  a = a.getAttribute('name');
  return new mxConnectionConstraint(new mxPoint(b, c), d, a);
};
mxStencil.prototype.evaluateTextAttribute = function (a, b, c) {
  b = this.evaluateAttribute(a, b, c);
  a = a.getAttribute('localized');
  if ((mxStencil.defaultLocalized && null == a) || '1' == a) b = mxResources.get(b);
  return b;
};
mxStencil.prototype.evaluateAttribute = function (a, b, c) {
  b = a.getAttribute(b);
  null == b &&
    ((a = mxUtils.getTextContent(a)),
    null != a && mxStencil.allowEval && ((a = mxUtils.eval(a)), 'function' == typeof a && (b = a(c))));
  return b;
};
mxStencil.prototype.drawShape = function (a, b, c, d, e, f) {
  var g = a.states.slice(),
    k = mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, null),
    k = this.computeAspect(b.style, c, d, e, f, k),
    h = Math.min(k.width, k.height),
    h =
      'inherit' == this.strokewidth
        ? Number(mxUtils.getNumber(b.style, mxConstants.STYLE_STROKEWIDTH, 1))
        : Number(this.strokewidth) * h;
  a.setStrokeWidth(h);
  null != b.style &&
    '1' == mxUtils.getValue(b.style, mxConstants.STYLE_POINTER_EVENTS, '0') &&
    (a.setStrokeColor(mxConstants.NONE), a.rect(c, d, e, f), a.stroke(), a.setStrokeColor(b.stroke));
  this.drawChildren(a, b, c, d, e, f, this.bgNode, k, !1, !0);
  this.drawChildren(
    a,
    b,
    c,
    d,
    e,
    f,
    this.fgNode,
    k,
    !0,
    !b.outline || null == b.style || 0 == mxUtils.getValue(b.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)
  );
  a.states.length != g.length && (a.states = g);
};
mxStencil.prototype.drawChildren = function (a, b, c, d, e, f, g, k, h, l) {
  if (null != g && 0 < e && 0 < f)
    for (c = g.firstChild; null != c; )
      c.nodeType == mxConstants.NODETYPE_ELEMENT && this.drawNode(a, b, c, k, h, l), (c = c.nextSibling);
};
mxStencil.prototype.computeAspect = function (a, b, c, d, e, f) {
  a = b;
  b = d / this.w0;
  var g = e / this.h0;
  if ((f = f == mxConstants.DIRECTION_NORTH || f == mxConstants.DIRECTION_SOUTH)) {
    g = d / this.h0;
    b = e / this.w0;
    var k = (d - e) / 2;
    a += k;
    c -= k;
  }
  'fixed' == this.aspect &&
    ((b = g = Math.min(b, g)),
    f
      ? ((a += (e - this.w0 * b) / 2), (c += (d - this.h0 * g) / 2))
      : ((a += (d - this.w0 * b) / 2), (c += (e - this.h0 * g) / 2)));
  return new mxRectangle(a, c, b, g);
};
mxStencil.prototype.drawNode = function (a, b, c, d, e, f) {
  var g = c.nodeName,
    k = d.x,
    h = d.y,
    l = d.width,
    m = d.height,
    n = Math.min(l, m);
  if ('save' == g) a.save();
  else if ('restore' == g) a.restore();
  else if (f) {
    if ('path' == g) {
      a.begin();
      n = !0;
      if ('1' == c.getAttribute('rounded')) {
        for (var n = !1, p = Number(c.getAttribute('arcSize')), r = 0, t = [], u = c.firstChild; null != u; ) {
          if (u.nodeType == mxConstants.NODETYPE_ELEMENT) {
            var x = u.nodeName;
            if ('move' == x || 'line' == x)
              ('move' != x && 0 != t.length) || t.push([]),
                t[t.length - 1].push(
                  new mxPoint(k + Number(u.getAttribute('x')) * l, h + Number(u.getAttribute('y')) * m)
                ),
                r++;
            else {
              n = !0;
              break;
            }
          }
          u = u.nextSibling;
        }
        if (!n && 0 < r)
          for (l = 0; l < t.length; l++)
            (m = !1),
              (h = t[l][0]),
              (k = t[l][t[l].length - 1]),
              h.x == k.x && h.y == k.y && (t[l].pop(), (m = !0)),
              this.addPoints(a, t[l], !0, p, m);
        else n = !0;
      }
      if (n)
        for (u = c.firstChild; null != u; )
          u.nodeType == mxConstants.NODETYPE_ELEMENT && this.drawNode(a, b, u, d, e, f), (u = u.nextSibling);
    } else if ('close' == g) a.close();
    else if ('move' == g) a.moveTo(k + Number(c.getAttribute('x')) * l, h + Number(c.getAttribute('y')) * m);
    else if ('line' == g) a.lineTo(k + Number(c.getAttribute('x')) * l, h + Number(c.getAttribute('y')) * m);
    else if ('quad' == g)
      a.quadTo(
        k + Number(c.getAttribute('x1')) * l,
        h + Number(c.getAttribute('y1')) * m,
        k + Number(c.getAttribute('x2')) * l,
        h + Number(c.getAttribute('y2')) * m
      );
    else if ('curve' == g)
      a.curveTo(
        k + Number(c.getAttribute('x1')) * l,
        h + Number(c.getAttribute('y1')) * m,
        k + Number(c.getAttribute('x2')) * l,
        h + Number(c.getAttribute('y2')) * m,
        k + Number(c.getAttribute('x3')) * l,
        h + Number(c.getAttribute('y3')) * m
      );
    else if ('arc' == g)
      a.arcTo(
        Number(c.getAttribute('rx')) * l,
        Number(c.getAttribute('ry')) * m,
        Number(c.getAttribute('x-axis-rotation')),
        Number(c.getAttribute('large-arc-flag')),
        Number(c.getAttribute('sweep-flag')),
        k + Number(c.getAttribute('x')) * l,
        h + Number(c.getAttribute('y')) * m
      );
    else if ('rect' == g)
      a.rect(
        k + Number(c.getAttribute('x')) * l,
        h + Number(c.getAttribute('y')) * m,
        Number(c.getAttribute('w')) * l,
        Number(c.getAttribute('h')) * m
      );
    else if ('roundrect' == g)
      (b = Number(c.getAttribute('arcsize'))),
        0 == b && (b = 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR),
        (d = Number(c.getAttribute('w')) * l),
        (f = Number(c.getAttribute('h')) * m),
        (b = Number(b) / 100),
        (b = Math.min(d * b, f * b)),
        a.roundrect(k + Number(c.getAttribute('x')) * l, h + Number(c.getAttribute('y')) * m, d, f, b, b);
    else if ('ellipse' == g)
      a.ellipse(
        k + Number(c.getAttribute('x')) * l,
        h + Number(c.getAttribute('y')) * m,
        Number(c.getAttribute('w')) * l,
        Number(c.getAttribute('h')) * m
      );
    else if ('image' == g)
      b.outline ||
        ((b = this.evaluateAttribute(c, 'src', b)),
        a.image(
          k + Number(c.getAttribute('x')) * l,
          h + Number(c.getAttribute('y')) * m,
          Number(c.getAttribute('w')) * l,
          Number(c.getAttribute('h')) * m,
          b,
          !1,
          '1' == c.getAttribute('flipH'),
          '1' == c.getAttribute('flipV')
        ));
    else if ('text' == g)
      b.outline ||
        ((d = this.evaluateTextAttribute(c, 'str', b)),
        (f = '1' == c.getAttribute('vertical') ? -90 : 0),
        '0' == c.getAttribute('align-shape') &&
          ((n = b.rotation),
          (p = 1 == mxUtils.getValue(b.style, mxConstants.STYLE_FLIPH, 0)),
          (b = 1 == mxUtils.getValue(b.style, mxConstants.STYLE_FLIPV, 0)),
          (f = p && b ? f - n : p || b ? f + n : f - n)),
        (f -= c.getAttribute('rotation')),
        a.text(
          k + Number(c.getAttribute('x')) * l,
          h + Number(c.getAttribute('y')) * m,
          0,
          0,
          d,
          c.getAttribute('align') || 'left',
          c.getAttribute('valign') || 'top',
          !1,
          '',
          null,
          !1,
          f
        ));
    else if ('include-shape' == g)
      (n = mxStencilRegistry.getStencil(c.getAttribute('name'))),
        null != n &&
          ((k += Number(c.getAttribute('x')) * l),
          (h += Number(c.getAttribute('y')) * m),
          (d = Number(c.getAttribute('w')) * l),
          (f = Number(c.getAttribute('h')) * m),
          n.drawShape(a, b, k, h, d, f));
    else if ('fillstroke' == g) a.fillAndStroke();
    else if ('fill' == g) a.fill();
    else if ('stroke' == g) a.stroke();
    else if ('strokewidth' == g)
      (l = '1' == c.getAttribute('fixed') ? 1 : n), a.setStrokeWidth(Number(c.getAttribute('width')) * l);
    else if ('dashed' == g) a.setDashed('1' == c.getAttribute('dashed'));
    else if ('dashpattern' == g) {
      if (((c = c.getAttribute('pattern')), null != c)) {
        c = c.split(' ');
        m = [];
        for (l = 0; l < c.length; l++) 0 < c[l].length && m.push(Number(c[l]) * n);
        c = m.join(' ');
        a.setDashPattern(c);
      }
    } else
      'strokecolor' == g
        ? a.setStrokeColor(c.getAttribute('color'))
        : 'linecap' == g
        ? a.setLineCap(c.getAttribute('cap'))
        : 'linejoin' == g
        ? a.setLineJoin(c.getAttribute('join'))
        : 'miterlimit' == g
        ? a.setMiterLimit(Number(c.getAttribute('limit')))
        : 'fillcolor' == g
        ? a.setFillColor(c.getAttribute('color'))
        : 'alpha' == g
        ? a.setAlpha(c.getAttribute('alpha'))
        : 'fillalpha' == g
        ? a.setAlpha(c.getAttribute('alpha'))
        : 'strokealpha' == g
        ? a.setAlpha(c.getAttribute('alpha'))
        : 'fontcolor' == g
        ? a.setFontColor(c.getAttribute('color'))
        : 'fontstyle' == g
        ? a.setFontStyle(c.getAttribute('style'))
        : 'fontfamily' == g
        ? a.setFontFamily(c.getAttribute('family'))
        : 'fontsize' == g && a.setFontSize(Number(c.getAttribute('size')) * n);
    !e || ('fillstroke' != g && 'fill' != g && 'stroke' != g) || a.setShadow(!1);
  }
};
var mxStencilRegistry = {
    stencils: {},
    addStencil: function (a, b) {
      mxStencilRegistry.stencils[a] = b;
    },
    getStencil: function (a) {
      return mxStencilRegistry.stencils[a];
    },
  },
  mxMarker = {
    markers: [],
    addMarker: function (a, b) {
      mxMarker.markers[a] = b;
    },
    createMarker: function (a, b, c, d, e, f, g, k, h, l) {
      var m = mxMarker.markers[c];
      return null != m ? m(a, b, c, d, e, f, g, k, h, l) : null;
    },
  };
(function () {
  function a(a) {
    a = null != a ? a : 2;
    return function (b, c, d, k, h, l, m, n, p, r) {
      c = h * p * 1.118;
      n = l * p * 1.118;
      h *= m + p;
      l *= m + p;
      var e = k.clone();
      e.x -= c;
      e.y -= n;
      m = d != mxConstants.ARROW_CLASSIC && d != mxConstants.ARROW_CLASSIC_THIN ? 1 : 0.75;
      k.x += -h * m - c;
      k.y += -l * m - n;
      return function () {
        b.begin();
        b.moveTo(e.x, e.y);
        b.lineTo(e.x - h - l / a, e.y - l + h / a);
        (d != mxConstants.ARROW_CLASSIC && d != mxConstants.ARROW_CLASSIC_THIN) ||
          b.lineTo(e.x - (3 * h) / 4, e.y - (3 * l) / 4);
        b.lineTo(e.x + l / a - h, e.y - l - h / a);
        b.close();
        r ? b.fillAndStroke() : b.stroke();
      };
    };
  }
  function b(a) {
    a = null != a ? a : 2;
    return function (b, c, d, k, h, l, m, n, p, r) {
      c = h * p * 1.118;
      d = l * p * 1.118;
      h *= m + p;
      l *= m + p;
      var e = k.clone();
      e.x -= c;
      e.y -= d;
      k.x += 2 * -c;
      k.y += 2 * -d;
      return function () {
        b.begin();
        b.moveTo(e.x - h - l / a, e.y - l + h / a);
        b.lineTo(e.x, e.y);
        b.lineTo(e.x + l / a - h, e.y - l - h / a);
        b.stroke();
      };
    };
  }
  function c(a, b, c, g, k, h, l, m, n, p) {
    m = c == mxConstants.ARROW_DIAMOND ? 0.7071 : 0.9862;
    b = k * n * m;
    m *= h * n;
    k *= l + n;
    h *= l + n;
    var d = g.clone();
    d.x -= b;
    d.y -= m;
    g.x += -k - b;
    g.y += -h - m;
    var e = c == mxConstants.ARROW_DIAMOND ? 2 : 3.4;
    return function () {
      a.begin();
      a.moveTo(d.x, d.y);
      a.lineTo(d.x - k / 2 - h / e, d.y + k / e - h / 2);
      a.lineTo(d.x - k, d.y - h);
      a.lineTo(d.x - k / 2 + h / e, d.y - h / 2 - k / e);
      a.close();
      p ? a.fillAndStroke() : a.stroke();
    };
  }
  mxMarker.addMarker('classic', a(2));
  mxMarker.addMarker('classicThin', a(3));
  mxMarker.addMarker('block', a(2));
  mxMarker.addMarker('blockThin', a(3));
  mxMarker.addMarker('open', b(2));
  mxMarker.addMarker('openThin', b(3));
  mxMarker.addMarker('oval', function (a, b, c, g, k, h, l, m, n, p) {
    var d = l / 2,
      e = g.clone();
    g.x -= k * d;
    g.y -= h * d;
    return function () {
      a.ellipse(e.x - d, e.y - d, l, l);
      p ? a.fillAndStroke() : a.stroke();
    };
  });
  mxMarker.addMarker('baseDash', function (a, b, c, g, k, h, l, m, n, p) {
    var d = k * (l + n + 1),
      e = h * (l + n + 1);
    return function () {
      a.begin();
      a.moveTo(g.x - e / 2, g.y + d / 2);
      a.lineTo(g.x + e / 2, g.y - d / 2);
      a.stroke();
    };
  });
  mxMarker.addMarker('doubleBlock', function (a, b, c, g, k, h, l, m, n, p) {
    b = k * n * 1.118;
    m = h * n * 1.118;
    k *= l + n;
    h *= l + n;
    var d = g.clone();
    d.x -= b;
    d.y -= m;
    c = c != mxConstants.ARROW_CLASSIC && c != mxConstants.ARROW_CLASSIC_THIN ? 1 : 0.75;
    g.x += -k * c * 2 - b;
    g.y += -h * c * 2 - m;
    return function () {
      a.begin();
      a.moveTo(d.x, d.y);
      a.lineTo(d.x - k - h / 2, d.y - h + k / 2);
      a.lineTo(d.x + h / 2 - k, d.y - h - k / 2);
      a.close();
      a.moveTo(d.x - k, d.y - h);
      a.lineTo(d.x - 2 * k - 0.5 * h, d.y + 0.5 * k - 2 * h);
      a.lineTo(d.x - 2 * k + 0.5 * h, d.y - 0.5 * k - 2 * h);
      a.close();
      p ? a.fillAndStroke() : a.stroke();
    };
  });
  mxMarker.addMarker('diamond', c);
  mxMarker.addMarker('diamondThin', c);
})();
function mxActor(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxActor, mxShape);
mxActor.prototype.paintVertexShape = function (a, b, c, d, e) {
  a.translate(b, c);
  a.begin();
  this.redrawPath(a, b, c, d, e);
  a.fillAndStroke();
};
mxActor.prototype.redrawPath = function (a, b, c, d, e) {
  b = d / 3;
  a.moveTo(0, e);
  a.curveTo(0, (3 * e) / 5, 0, (2 * e) / 5, d / 2, (2 * e) / 5);
  a.curveTo(d / 2 - b, (2 * e) / 5, d / 2 - b, 0, d / 2, 0);
  a.curveTo(d / 2 + b, 0, d / 2 + b, (2 * e) / 5, d / 2, (2 * e) / 5);
  a.curveTo(d, (2 * e) / 5, d, (3 * e) / 5, d, e);
  a.close();
};
function mxCloud(a, b, c, d) {
  mxActor.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxCloud, mxActor);
mxCloud.prototype.redrawPath = function (a, b, c, d, e) {
  a.moveTo(0.25 * d, 0.25 * e);
  a.curveTo(0.05 * d, 0.25 * e, 0, 0.5 * e, 0.16 * d, 0.55 * e);
  a.curveTo(0, 0.66 * e, 0.18 * d, 0.9 * e, 0.31 * d, 0.8 * e);
  a.curveTo(0.4 * d, e, 0.7 * d, e, 0.8 * d, 0.8 * e);
  a.curveTo(d, 0.8 * e, d, 0.6 * e, 0.875 * d, 0.5 * e);
  a.curveTo(d, 0.3 * e, 0.8 * d, 0.1 * e, 0.625 * d, 0.2 * e);
  a.curveTo(0.5 * d, 0.05 * e, 0.3 * d, 0.05 * e, 0.25 * d, 0.25 * e);
  a.close();
};
function mxRectangleShape(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxRectangleShape, mxShape);
mxRectangleShape.prototype.isHtmlAllowed = function () {
  var a = !0;
  null != this.style && (a = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1'));
  return (
    !this.isRounded && !this.glass && 0 == this.rotation && (a || (null != this.fill && this.fill != mxConstants.NONE))
  );
};
mxRectangleShape.prototype.paintBackground = function (a, b, c, d, e) {
  if (this.isRounded) {
    var f;
    '1' == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)
      ? (f = Math.min(
          d / 2,
          Math.min(e / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2)
        ))
      : ((f =
          mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100),
        (f = Math.min(d * f, e * f)));
    a.roundrect(b, c, d, e, f, f);
  } else a.rect(b, c, d, e);
  a.fillAndStroke();
};
mxRectangleShape.prototype.isRoundable = function () {
  return !0;
};
mxRectangleShape.prototype.paintForeground = function (a, b, c, d, e) {
  this.glass &&
    !this.outline &&
    null != this.fill &&
    this.fill != mxConstants.NONE &&
    this.paintGlassEffect(a, b, c, d, e, this.getArcSize(d + this.strokewidth, e + this.strokewidth));
};
function mxEllipse(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxEllipse, mxShape);
mxEllipse.prototype.paintVertexShape = function (a, b, c, d, e) {
  a.ellipse(b, c, d, e);
  a.fillAndStroke();
};
function mxDoubleEllipse(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxDoubleEllipse, mxShape);
mxDoubleEllipse.prototype.paintBackground = function (a, b, c, d, e) {
  a.ellipse(b, c, d, e);
  a.fillAndStroke();
};
mxDoubleEllipse.prototype.paintForeground = function (a, b, c, d, e) {
  if (!this.outline) {
    var f = mxUtils.getValue(
      this.style,
      mxConstants.STYLE_MARGIN,
      Math.min(3 + this.strokewidth, Math.min(d / 5, e / 5))
    );
    d -= 2 * f;
    e -= 2 * f;
    0 < d && 0 < e && a.ellipse(b + f, c + f, d, e);
    a.stroke();
  }
};
mxDoubleEllipse.prototype.getLabelBounds = function (a) {
  var b =
    mxUtils.getValue(
      this.style,
      mxConstants.STYLE_MARGIN,
      Math.min(3 + this.strokewidth, Math.min(a.width / 5 / this.scale, a.height / 5 / this.scale))
    ) * this.scale;
  return new mxRectangle(a.x + b, a.y + b, a.width - 2 * b, a.height - 2 * b);
};
function mxRhombus(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxRhombus, mxShape);
mxRhombus.prototype.isRoundable = function () {
  return !0;
};
mxRhombus.prototype.paintVertexShape = function (a, b, c, d, e) {
  var f = d / 2,
    g = e / 2,
    k = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  a.begin();
  this.addPoints(
    a,
    [new mxPoint(b + f, c), new mxPoint(b + d, c + g), new mxPoint(b + f, c + e), new mxPoint(b, c + g)],
    this.isRounded,
    k,
    !0
  );
  a.fillAndStroke();
};
function mxPolyline(a, b, c) {
  mxShape.call(this);
  this.points = a;
  this.stroke = b;
  this.strokewidth = null != c ? c : 1;
}
mxUtils.extend(mxPolyline, mxShape);
mxPolyline.prototype.getRotation = function () {
  return 0;
};
mxPolyline.prototype.getShapeRotation = function () {
  return 0;
};
mxPolyline.prototype.isPaintBoundsInverted = function () {
  return !1;
};
mxPolyline.prototype.paintEdgeShape = function (a, b) {
  var c = a.pointerEventsValue;
  a.pointerEventsValue = 'stroke';
  null == this.style || 1 != this.style[mxConstants.STYLE_CURVED]
    ? this.paintLine(a, b, this.isRounded)
    : this.paintCurvedLine(a, b);
  a.pointerEventsValue = c;
};
mxPolyline.prototype.paintLine = function (a, b, c) {
  var d = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  a.begin();
  this.addPoints(a, b, c, d, !1);
  a.stroke();
};
mxPolyline.prototype.paintCurvedLine = function (a, b) {
  a.begin();
  var c = b[0],
    d = b.length;
  a.moveTo(c.x, c.y);
  for (c = 1; c < d - 2; c++) {
    var e = b[c],
      f = b[c + 1];
    a.quadTo(e.x, e.y, (e.x + f.x) / 2, (e.y + f.y) / 2);
  }
  e = b[d - 2];
  f = b[d - 1];
  a.quadTo(e.x, e.y, f.x, f.y);
  a.stroke();
};
function mxArrow(a, b, c, d, e, f, g) {
  mxShape.call(this);
  this.points = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.spacing = null != f ? f : mxConstants.ARROW_SPACING;
  this.endSize = null != g ? g : mxConstants.ARROW_SIZE;
}
mxUtils.extend(mxArrow, mxShape);
mxArrow.prototype.augmentBoundingBox = function (a) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  a.grow((Math.max(this.arrowWidth, this.endSize) / 2 + this.strokewidth) * this.scale);
};
mxArrow.prototype.paintEdgeShape = function (a, b) {
  var c = mxConstants.ARROW_SPACING,
    d = mxConstants.ARROW_WIDTH,
    e = b[0],
    f = b[b.length - 1],
    g = f.x - e.x,
    k = f.y - e.y,
    h = Math.sqrt(g * g + k * k),
    l = h - 2 * c - mxConstants.ARROW_SIZE,
    g = g / h,
    k = k / h,
    h = (d * k) / 3,
    d = (-d * g) / 3,
    m = e.x - h / 2 + c * g,
    e = e.y - d / 2 + c * k,
    n = m + h,
    p = e + d,
    r = n + l * g,
    l = p + l * k,
    t = r + h,
    u = l + d,
    x = t - 3 * h,
    z = u - 3 * d;
  a.begin();
  a.moveTo(m, e);
  a.lineTo(n, p);
  a.lineTo(r, l);
  a.lineTo(t, u);
  a.lineTo(f.x - c * g, f.y - c * k);
  a.lineTo(x, z);
  a.lineTo(x + h, z + d);
  a.close();
  a.fillAndStroke();
};
function mxArrowConnector(a, b, c, d, e, f, g) {
  mxShape.call(this);
  this.points = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
  this.arrowWidth = null != e ? e : mxConstants.ARROW_WIDTH;
  this.arrowSpacing = null != f ? f : mxConstants.ARROW_SPACING;
  this.startSize = mxConstants.ARROW_SIZE / 5;
  this.endSize = mxConstants.ARROW_SIZE / 5;
}
mxUtils.extend(mxArrowConnector, mxShape);
mxArrowConnector.prototype.useSvgBoundingBox = !0;
mxArrowConnector.prototype.isRoundable = function () {
  return !0;
};
mxArrowConnector.prototype.resetStyles = function () {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.arrowSpacing = mxConstants.ARROW_SPACING;
};
mxArrowConnector.prototype.apply = function (a) {
  mxShape.prototype.apply.apply(this, arguments);
  null != this.style &&
    ((this.startSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5)),
    (this.endSize = 3 * mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5)));
};
mxArrowConnector.prototype.augmentBoundingBox = function (a) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var b = this.getEdgeWidth();
  this.isMarkerStart() && (b = Math.max(b, this.getStartArrowWidth()));
  this.isMarkerEnd() && (b = Math.max(b, this.getEndArrowWidth()));
  a.grow((b / 2 + this.strokewidth) * this.scale);
};
mxArrowConnector.prototype.paintEdgeShape = function (a, b) {
  var c = this.strokewidth;
  this.outline && (c = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth)));
  var d = this.getStartArrowWidth() + c,
    e = this.getEndArrowWidth() + c,
    f = this.outline ? this.getEdgeWidth() + c : this.getEdgeWidth(),
    g = this.isOpenEnded(),
    k = this.isMarkerStart(),
    h = this.isMarkerEnd(),
    l = g ? 0 : this.arrowSpacing + c / 2,
    m = this.startSize + c,
    c = this.endSize + c,
    n = this.isArrowRounded(),
    p = b[b.length - 1],
    r = b[1].x - b[0].x,
    t = b[1].y - b[0].y,
    u = Math.sqrt(r * r + t * t);
  if (0 != u) {
    var x = r / u,
      z,
      D = x,
      B = t / u,
      C,
      J = B,
      u = f * B,
      v = -f * x,
      K = [];
    n ? a.setLineJoin('round') : 2 < b.length && a.setMiterLimit(1.42);
    a.begin();
    r = x;
    t = B;
    if (k && !g) this.paintMarker(a, b[0].x, b[0].y, x, B, m, d, f, l, !0);
    else {
      z = b[0].x + u / 2 + l * x;
      C = b[0].y + v / 2 + l * B;
      var O = b[0].x - u / 2 + l * x,
        T = b[0].y - v / 2 + l * B;
      g
        ? (a.moveTo(z, C),
          K.push(function () {
            a.lineTo(O, T);
          }))
        : (a.moveTo(O, T), a.lineTo(z, C));
    }
    for (var M = (C = z = 0), u = 0; u < b.length - 2; u++)
      if (
        ((v = mxUtils.relativeCcw(b[u].x, b[u].y, b[u + 1].x, b[u + 1].y, b[u + 2].x, b[u + 2].y)),
        (z = b[u + 2].x - b[u + 1].x),
        (C = b[u + 2].y - b[u + 1].y),
        (M = Math.sqrt(z * z + C * C)),
        0 != M)
      ) {
        D = z / M;
        J = C / M;
        M = Math.max(Math.sqrt((x * D + B * J + 1) / 2), 0.04);
        z = x + D;
        C = B + J;
        var U = Math.sqrt(z * z + C * C);
        if (0 != U) {
          z /= U;
          C /= U;
          var U = Math.max(M, Math.min(this.strokewidth / 200 + 0.04, 0.35)),
            M = 0 != v && n ? Math.max(0.1, U) : Math.max(M, 0.06),
            da = b[u + 1].x + (C * f) / 2 / M,
            ha = b[u + 1].y - (z * f) / 2 / M;
          C = b[u + 1].x - (C * f) / 2 / M;
          z = b[u + 1].y + (z * f) / 2 / M;
          0 != v && n
            ? -1 == v
              ? ((v = C + J * f),
                (M = z - D * f),
                a.lineTo(C + B * f, z - x * f),
                a.quadTo(da, ha, v, M),
                (function (b, c) {
                  K.push(function () {
                    a.lineTo(b, c);
                  });
                })(C, z))
              : (a.lineTo(da, ha),
                (function (b, c) {
                  var d = da - B * f,
                    e = ha + x * f,
                    g = da - J * f,
                    k = ha + D * f;
                  K.push(function () {
                    a.quadTo(b, c, d, e);
                  });
                  K.push(function () {
                    a.lineTo(g, k);
                  });
                })(C, z))
            : (a.lineTo(da, ha),
              (function (b, c) {
                K.push(function () {
                  a.lineTo(b, c);
                });
              })(C, z));
          x = D;
          B = J;
        }
      }
    u = f * J;
    v = -f * D;
    if (h && !g) this.paintMarker(a, p.x, p.y, -x, -B, c, e, f, l, !1);
    else {
      a.lineTo(p.x - l * D + u / 2, p.y - l * J + v / 2);
      var Y = p.x - l * D - u / 2,
        P = p.y - l * J - v / 2;
      g
        ? (a.moveTo(Y, P),
          K.splice(0, 0, function () {
            a.moveTo(Y, P);
          }))
        : a.lineTo(Y, P);
    }
    for (u = K.length - 1; 0 <= u; u--) K[u]();
    g ? (a.end(), a.stroke()) : (a.close(), a.fillAndStroke());
    a.setShadow(!1);
    a.setMiterLimit(4);
    n && a.setLineJoin('flat');
    2 < b.length &&
      (a.setMiterLimit(4),
      k && !g && (a.begin(), this.paintMarker(a, b[0].x, b[0].y, r, t, m, d, f, l, !0), a.stroke(), a.end()),
      h && !g && (a.begin(), this.paintMarker(a, p.x, p.y, -x, -B, c, e, f, l, !0), a.stroke(), a.end()));
  }
};
mxArrowConnector.prototype.paintMarker = function (a, b, c, d, e, f, g, k, h, l) {
  g = k / g;
  var m = (k * e) / 2;
  k = (-k * d) / 2;
  var n = (h + f) * d;
  f = (h + f) * e;
  l ? a.moveTo(b - m + n, c - k + f) : a.lineTo(b - m + n, c - k + f);
  a.lineTo(b - m / g + n, c - k / g + f);
  a.lineTo(b + h * d, c + h * e);
  a.lineTo(b + m / g + n, c + k / g + f);
  a.lineTo(b + m + n, c + k + f);
};
mxArrowConnector.prototype.isArrowRounded = function () {
  return this.isRounded;
};
mxArrowConnector.prototype.getStartArrowWidth = function () {
  return mxConstants.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEndArrowWidth = function () {
  return mxConstants.ARROW_WIDTH;
};
mxArrowConnector.prototype.getEdgeWidth = function () {
  return mxConstants.ARROW_WIDTH / 3;
};
mxArrowConnector.prototype.isOpenEnded = function () {
  return !1;
};
mxArrowConnector.prototype.isMarkerStart = function () {
  return mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE;
};
mxArrowConnector.prototype.isMarkerEnd = function () {
  return mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE;
};
function mxText(a, b, c, d, e, f, g, k, h, l, m, n, p, r, t, u, x, z, D, B, C) {
  mxShape.call(this);
  this.value = a;
  this.bounds = b;
  this.color = null != e ? e : 'black';
  this.align = null != c ? c : mxConstants.ALIGN_CENTER;
  this.valign = null != d ? d : mxConstants.ALIGN_MIDDLE;
  this.family = null != f ? f : mxConstants.DEFAULT_FONTFAMILY;
  this.size = null != g ? g : mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = null != k ? k : mxConstants.DEFAULT_FONTSTYLE;
  this.spacing = parseInt(h || 2);
  this.spacingTop = this.spacing + parseInt(l || 0);
  this.spacingRight = this.spacing + parseInt(m || 0);
  this.spacingBottom = this.spacing + parseInt(n || 0);
  this.spacingLeft = this.spacing + parseInt(p || 0);
  this.horizontal = null != r ? r : !0;
  this.background = t;
  this.border = u;
  this.wrap = null != x ? x : !1;
  this.clipped = null != z ? z : !1;
  this.overflow = null != D ? D : 'visible';
  this.labelPadding = null != B ? B : 0;
  this.textDirection = C;
  this.rotation = 0;
  this.updateMargin();
}
mxUtils.extend(mxText, mxShape);
mxText.prototype.baseSpacingTop = 0;
mxText.prototype.baseSpacingBottom = 0;
mxText.prototype.baseSpacingLeft = 0;
mxText.prototype.baseSpacingRight = 0;
mxText.prototype.replaceLinefeeds = !0;
mxText.prototype.verticalTextRotation = -90;
mxText.prototype.ignoreClippedStringSize = !0;
mxText.prototype.ignoreStringSize = !1;
mxText.prototype.textWidthPadding = 8 != document.documentMode || mxClient.IS_EM ? 3 : 4;
mxText.prototype.lastValue = null;
mxText.prototype.cacheEnabled = !0;
mxText.prototype.isHtmlAllowed = function () {
  return 8 != document.documentMode || mxClient.IS_EM;
};
mxText.prototype.getSvgScreenOffset = function () {
  return 0;
};
mxText.prototype.checkBounds = function () {
  return (
    !isNaN(this.scale) &&
    isFinite(this.scale) &&
    0 < this.scale &&
    null != this.bounds &&
    !isNaN(this.bounds.x) &&
    !isNaN(this.bounds.y) &&
    !isNaN(this.bounds.width) &&
    !isNaN(this.bounds.height)
  );
};
mxText.prototype.configurePointerEvents = function (a) {};
mxText.prototype.paint = function (a, b) {
  var c = this.scale,
    d = this.bounds.x / c,
    e = this.bounds.y / c,
    f = this.bounds.width / c,
    c = this.bounds.height / c;
  this.updateTransform(a, d, e, f, c);
  this.configureCanvas(a, d, e, f, c);
  if (b)
    a.updateText(
      d,
      e,
      f,
      c,
      this.align,
      this.valign,
      this.wrap,
      this.overflow,
      this.clipped,
      this.getTextRotation(),
      this.node
    );
  else {
    var g = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML,
      k = g ? 'html' : '',
      h = this.value;
    g || 'html' != k || (h = mxUtils.htmlEntities(h, !1));
    'html' != k || mxUtils.isNode(this.value) || (h = mxUtils.replaceTrailingNewlines(h, '<div><br></div>'));
    var h = !mxUtils.isNode(this.value) && this.replaceLinefeeds && 'html' == k ? h.replace(/\n/g, '<br/>') : h,
      l = this.textDirection;
    l != mxConstants.TEXT_DIRECTION_AUTO || g || (l = this.getAutoDirection());
    l != mxConstants.TEXT_DIRECTION_LTR && l != mxConstants.TEXT_DIRECTION_RTL && (l = null);
    a.text(
      d,
      e,
      f,
      c,
      h,
      this.align,
      this.valign,
      this.wrap,
      k,
      this.overflow,
      this.clipped,
      this.getTextRotation(),
      l
    );
  }
};
mxText.prototype.redraw = function () {
  if (
    this.visible &&
    this.checkBounds() &&
    this.cacheEnabled &&
    this.lastValue == this.value &&
    (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)
  )
    if ('DIV' == this.node.nodeName)
      mxClient.IS_SVG
        ? this.redrawHtmlShapeWithCss3()
        : (this.updateSize(this.node, null == this.state || null == this.state.view.textDiv),
          mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)
            ? this.updateHtmlFilter()
            : this.updateHtmlTransform()),
        this.updateBoundingBox();
    else {
      var a = this.createCanvas();
      null != a && null != a.updateText
        ? ((a.pointerEvents = this.pointerEvents), this.paint(a, !0), this.destroyCanvas(a), this.updateBoundingBox())
        : mxShape.prototype.redraw.apply(this, arguments);
    }
  else
    mxShape.prototype.redraw.apply(this, arguments),
      mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML
        ? (this.lastValue = this.value)
        : (this.lastValue = null);
};
mxText.prototype.resetStyles = function () {
  mxShape.prototype.resetStyles.apply(this, arguments);
  this.color = 'black';
  this.align = mxConstants.ALIGN_CENTER;
  this.valign = mxConstants.ALIGN_MIDDLE;
  this.family = mxConstants.DEFAULT_FONTFAMILY;
  this.size = mxConstants.DEFAULT_FONTSIZE;
  this.fontStyle = mxConstants.DEFAULT_FONTSTYLE;
  this.spacingLeft = this.spacingBottom = this.spacingRight = this.spacingTop = this.spacing = 2;
  this.horizontal = !0;
  delete this.background;
  delete this.border;
  this.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;
  delete this.margin;
};
mxText.prototype.apply = function (a) {
  var b = this.spacing;
  mxShape.prototype.apply.apply(this, arguments);
  null != this.style &&
    ((this.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle)),
    (this.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family)),
    (this.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size)),
    (this.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color)),
    (this.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align)),
    (this.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign)),
    (this.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing))),
    (this.spacingTop =
      parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - b)) + this.spacing),
    (this.spacingRight =
      parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - b)) + this.spacing),
    (this.spacingBottom =
      parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - b)) + this.spacing),
    (this.spacingLeft =
      parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - b)) + this.spacing),
    (this.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal)),
    (this.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background)),
    (this.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border)),
    (this.textDirection = mxUtils.getValue(
      this.style,
      mxConstants.STYLE_TEXT_DIRECTION,
      mxConstants.DEFAULT_TEXT_DIRECTION
    )),
    (this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100)),
    this.updateMargin());
  this.flipH = this.flipV = null;
};
mxText.prototype.getAutoDirection = function () {
  var a = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(this.value);
  return null != a && 0 < a.length && 'z' < a[0] ? mxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;
};
mxText.prototype.getContentNode = function () {
  var a = this.node;
  null != a &&
    (a =
      null == a.ownerSVGElement
        ? this.node.firstChild.firstChild
        : a.firstChild.firstChild.firstChild.firstChild.firstChild);
  return a;
};
mxText.prototype.updateBoundingBox = function () {
  var a = this.node;
  this.boundingBox = this.bounds.clone();
  var b = this.getTextRotation(),
    c =
      null != this.style
        ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER)
        : null,
    d =
      null != this.style
        ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE)
        : null;
  if (
    !(
      this.ignoreStringSize ||
      null == a ||
      'fill' == this.overflow ||
      (this.clipped && this.ignoreClippedStringSize && c == mxConstants.ALIGN_CENTER && d == mxConstants.ALIGN_MIDDLE)
    )
  ) {
    d = c = null;
    if (null != a.ownerSVGElement)
      if (
        null != a.firstChild &&
        null != a.firstChild.firstChild &&
        'foreignObject' == a.firstChild.firstChild.nodeName
      )
        (a = a.firstChild.firstChild.firstChild.firstChild),
          (d = a.offsetHeight * this.scale),
          (c = 'width' == this.overflow ? this.boundingBox.width : a.offsetWidth * this.scale);
      else
        try {
          var e = a.getBBox();
          'string' == typeof this.value && 0 == mxUtils.trim(this.value)
            ? (this.boundingBox = null)
            : (this.boundingBox = 0 == e.width && 0 == e.height ? null : new mxRectangle(e.x, e.y, e.width, e.height));
          return;
        } catch (f) {}
    else {
      c = null != this.state ? this.state.view.textDiv : null;
      if (null == this.offsetWidth || null == this.offsetHeight)
        null != c && (this.updateFont(c), this.updateSize(c, !1), this.updateInnerHtml(c), (a = c)),
          (e = a),
          8 != document.documentMode || mxClient.IS_EM
            ? null != e.firstChild && 'DIV' == e.firstChild.nodeName && (e = e.firstChild)
            : ((d = Math.round(this.bounds.width / this.scale)),
              this.wrap && 0 < d
                ? ((a.style.wordWrap = mxConstants.WORD_WRAP),
                  (a.style.whiteSpace = 'normal'),
                  'break-word' != a.style.wordWrap &&
                    ((a = e.getElementsByTagName('div')),
                    0 < a.length && (e = a[a.length - 1]),
                    (c = e.offsetWidth + 2),
                    (a = this.node.getElementsByTagName('div')),
                    this.clipped && (c = Math.min(d, c)),
                    1 < a.length && (a[a.length - 2].style.width = c + 'px')))
                : (a.style.whiteSpace = 'nowrap')),
          (this.offsetWidth = e.offsetWidth + this.textWidthPadding),
          (this.offsetHeight = e.offsetHeight);
      c = this.offsetWidth * this.scale;
      d = this.offsetHeight * this.scale;
    }
    null != c && null != d && (this.boundingBox = new mxRectangle(this.bounds.x, this.bounds.y, c, d));
  }
  null != this.boundingBox &&
    (0 != b
      ? ((b = mxUtils.getBoundingBox(
          new mxRectangle(
            this.margin.x * this.boundingBox.width,
            this.margin.y * this.boundingBox.height,
            this.boundingBox.width,
            this.boundingBox.height
          ),
          b,
          new mxPoint(0, 0)
        )),
        (this.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox)),
        (this.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width),
        (this.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height),
        (this.boundingBox.x += b.x),
        (this.boundingBox.y += b.y),
        (this.boundingBox.width = b.width),
        (this.boundingBox.height = b.height))
      : ((this.boundingBox.x += this.margin.x * this.boundingBox.width),
        (this.boundingBox.y += this.margin.y * this.boundingBox.height),
        (this.unrotatedBoundingBox = null)));
};
mxText.prototype.getShapeRotation = function () {
  return 0;
};
mxText.prototype.getTextRotation = function () {
  return null != this.state && null != this.state.shape ? this.state.shape.getTextRotation() : 0;
};
mxText.prototype.isPaintBoundsInverted = function () {
  return !this.horizontal && null != this.state && this.state.view.graph.model.isVertex(this.state.cell);
};
mxText.prototype.configureCanvas = function (a, b, c, d, e) {
  mxShape.prototype.configureCanvas.apply(this, arguments);
  a.setFontColor(this.color);
  a.setFontBackgroundColor(this.background);
  a.setFontBorderColor(this.border);
  a.setFontFamily(this.family);
  a.setFontSize(this.size);
  a.setFontStyle(this.fontStyle);
};
mxText.prototype.getHtmlValue = function () {
  var a = this.value;
  this.dialect != mxConstants.DIALECT_STRICTHTML && (a = mxUtils.htmlEntities(a, !1));
  a = mxUtils.replaceTrailingNewlines(a, '<div><br></div>');
  return (a = this.replaceLinefeeds ? a.replace(/\n/g, '<br/>') : a);
};
mxText.prototype.getTextCss = function () {
  var a =
    'display: inline-block; font-size: ' +
    this.size +
    'px; font-family: ' +
    this.family +
    '; color: ' +
    this.color +
    '; line-height: ' +
    (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + 'px' : mxConstants.LINE_HEIGHT) +
    '; pointer-events: ' +
    (this.pointerEvents ? 'all' : 'none') +
    '; ';
  (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (a += 'font-weight: bold; ');
  (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (a += 'font-style: italic; ');
  var b = [];
  (this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && b.push('underline');
  (this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && b.push('line-through');
  0 < b.length && (a += 'text-decoration: ' + b.join(' ') + '; ');
  return a;
};
mxText.prototype.redrawHtmlShape = function () {
  if (mxClient.IS_SVG) this.redrawHtmlShapeWithCss3();
  else {
    var a = this.node.style;
    a.whiteSpace = 'normal';
    a.overflow = '';
    a.width = '';
    a.height = '';
    this.updateValue();
    this.updateFont(this.node);
    this.updateSize(this.node, null == this.state || null == this.state.view.textDiv);
    this.offsetHeight = this.offsetWidth = null;
    mxClient.IS_IE && (null == document.documentMode || 8 >= document.documentMode)
      ? this.updateHtmlFilter()
      : this.updateHtmlTransform();
  }
};
mxText.prototype.redrawHtmlShapeWithCss3 = function () {
  var a = Math.max(0, Math.round(this.bounds.width / this.scale)),
    b = Math.max(0, Math.round(this.bounds.height / this.scale)),
    c =
      'position: absolute; left: ' +
      Math.round(this.bounds.x) +
      'px; top: ' +
      Math.round(this.bounds.y) +
      'px; pointer-events: none; ',
    d = this.getTextCss();
  mxSvgCanvas2D.createCss(
    a + 2,
    b,
    this.align,
    this.valign,
    this.wrap,
    this.overflow,
    this.clipped,
    null != this.background ? mxUtils.htmlEntities(this.background) : null,
    null != this.border ? mxUtils.htmlEntities(this.border) : null,
    c,
    d,
    this.scale,
    mxUtils.bind(this, function (a, c, d, k, h, l) {
      a = this.getTextRotation();
      a =
        (1 != this.scale ? 'scale(' + this.scale + ') ' : '') +
        (0 != a ? 'rotate(' + a + 'deg) ' : '') +
        (0 != this.margin.x || 0 != this.margin.y
          ? 'translate(' + 100 * this.margin.x + '%,' + 100 * this.margin.y + '%)'
          : '');
      '' != a && (a = 'transform-origin: 0 0; transform: ' + a + '; ');
      'block' == this.overflow && this.valign == mxConstants.ALIGN_MIDDLE && (a += 'max-height: ' + (b + 1) + 'px;');
      '' == l
        ? ((d += k), (k = 'display:inline-block; min-width: 100%; ' + a))
        : ((k += a), mxClient.IS_SF && (k += '-webkit-clip-path: content-box;'));
      'block' == this.overflow && (k += 'width: 100%; ');
      100 > this.opacity && (h += 'opacity: ' + this.opacity / 100 + '; ');
      this.node.setAttribute('style', d);
      d = mxUtils.isNode(this.value) ? this.value.outerHTML : this.getHtmlValue();
      null == this.node.firstChild &&
        ((this.node.innerHTML = '<div><div>' + d + '</div></div>'),
        mxClient.IS_IE11 && this.fixFlexboxForIe11(this.node));
      this.node.firstChild.firstChild.setAttribute('style', h);
      this.node.firstChild.setAttribute('style', k);
    })
  );
};
mxText.prototype.fixFlexboxForIe11 = function (a) {
  for (var b = a.querySelectorAll('div[style*="display: flex; justify-content: flex-end;"]'), c = 0; c < b.length; c++)
    (b[c].style.justifyContent = 'flex-start'), (b[c].style.flexDirection = 'row-reverse');
  if (!this.wrap)
    for (
      b = a.querySelectorAll('div[style*="display: flex; justify-content: center;"]'), a = -window.innerWidth, c = 0;
      c < b.length;
      c++
    )
      (b[c].style.marginLeft = a + 'px'), (b[c].style.marginRight = a + 'px');
};
mxText.prototype.updateHtmlTransform = function () {
  var a = this.getTextRotation(),
    b = this.node.style,
    c = this.margin.x,
    d = this.margin.y;
  0 != a
    ? (mxUtils.setPrefixedStyle(b, 'transformOrigin', 100 * -c + '% ' + 100 * -d + '%'),
      mxUtils.setPrefixedStyle(
        b,
        'transform',
        'translate(' + 100 * c + '%,' + 100 * d + '%) scale(' + this.scale + ') rotate(' + a + 'deg)'
      ))
    : (mxUtils.setPrefixedStyle(b, 'transformOrigin', '0% 0%'),
      mxUtils.setPrefixedStyle(
        b,
        'transform',
        'scale(' + this.scale + ') translate(' + 100 * c + '%,' + 100 * d + '%)'
      ));
  b.left =
    Math.round(this.bounds.x - Math.ceil(c * ('fill' != this.overflow && 'width' != this.overflow ? 3 : 1))) + 'px';
  b.top = Math.round(this.bounds.y - d * ('fill' != this.overflow ? 3 : 1)) + 'px';
  b.opacity = 100 > this.opacity ? this.opacity / 100 : '';
};
mxText.prototype.updateInnerHtml = function (a) {
  if (mxUtils.isNode(this.value)) a.innerHTML = this.value.outerHTML;
  else {
    var b = this.value;
    this.dialect != mxConstants.DIALECT_STRICTHTML && (b = mxUtils.htmlEntities(b, !1));
    b = mxUtils.replaceTrailingNewlines(b, '<div>&nbsp;</div>');
    b = this.replaceLinefeeds ? b.replace(/\n/g, '<br/>') : b;
    a.innerHTML = '<div style="display:inline-block;_display:inline;">' + b + '</div>';
  }
};
mxText.prototype.updateHtmlFilter = function () {
  var a = this.node.style,
    b = this.margin.x,
    c = this.margin.y,
    d = this.scale;
  mxUtils.setOpacity(this.node, this.opacity);
  var e,
    f = 0,
    g = null != this.state ? this.state.view.textDiv : null,
    k = this.node;
  if (null != g) {
    g.style.overflow = '';
    g.style.height = '';
    g.style.width = '';
    this.updateFont(g);
    this.updateSize(g, !1);
    this.updateInnerHtml(g);
    var h = Math.round(this.bounds.width / this.scale);
    this.wrap && 0 < h
      ? ((g.style.whiteSpace = 'normal'),
        (g.style.wordWrap = mxConstants.WORD_WRAP),
        (e = h),
        this.clipped && (e = Math.min(e, this.bounds.width)),
        (g.style.width = e + 'px'))
      : (g.style.whiteSpace = 'nowrap');
    k = g;
    null != k.firstChild &&
      'DIV' == k.firstChild.nodeName &&
      ((k = k.firstChild), this.wrap && 'break-word' == g.style.wordWrap && (k.style.width = '100%'));
    !this.clipped && this.wrap && 0 < h && ((e = k.offsetWidth + this.textWidthPadding), (g.style.width = e + 'px'));
    f = k.offsetHeight + 2;
  } else null != k.firstChild && 'DIV' == k.firstChild.nodeName && ((k = k.firstChild), (f = k.offsetHeight));
  e = k.offsetWidth + this.textWidthPadding;
  this.clipped && (f = Math.min(f, this.bounds.height));
  h = this.bounds.width / d;
  g = this.bounds.height / d;
  'fill' == this.overflow ? ((f = g), (e = h)) : 'width' == this.overflow && ((f = k.scrollHeight), (e = h));
  this.offsetWidth = e;
  this.offsetHeight = f;
  'fill' != this.overflow &&
    'width' != this.overflow &&
    (this.clipped && (e = Math.min(h, e)), (h = e), this.wrap && (a.width = Math.round(h) + 'px'));
  var g = f * d,
    h = h * d,
    l = this.getTextRotation() * (Math.PI / 180);
  e = parseFloat(parseFloat(Math.cos(l)).toFixed(8));
  f = parseFloat(parseFloat(Math.sin(-l)).toFixed(8));
  l %= 2 * Math.PI;
  0 > l && (l += 2 * Math.PI);
  l %= Math.PI;
  l > Math.PI / 2 && (l = Math.PI - l);
  var k = Math.cos(l),
    m = Math.sin(-l),
    b = h * -(b + 0.5),
    c = g * -(c + 0.5);
  0 != l &&
    ((l =
      'progid:DXImageTransform.Microsoft.Matrix(M11=' +
      e +
      ', M12=' +
      f +
      ', M21=' +
      -f +
      ', M22=' +
      e +
      ", sizingMethod='auto expand')"),
    (a.filter = null != a.filter && 0 < a.filter.length ? a.filter + (' ' + l) : l));
  a.zoom = d;
  a.left = Math.round(this.bounds.x + ((h - h * k + g * m) / 2 - e * b - f * c) - h / 2) + 'px';
  a.top = Math.round(this.bounds.y + ((g - g * k + h * m) / 2 + f * b - e * c) - g / 2 + 0) + 'px';
};
mxText.prototype.updateValue = function () {
  if (mxUtils.isNode(this.value)) (this.node.innerHTML = ''), this.node.appendChild(this.value);
  else {
    var a = this.value;
    this.dialect != mxConstants.DIALECT_STRICTHTML && (a = mxUtils.htmlEntities(a, !1));
    var a = mxUtils.replaceTrailingNewlines(a, '<div><br></div>'),
      a = this.replaceLinefeeds ? a.replace(/\n/g, '<br/>') : a,
      b = null != this.background && this.background != mxConstants.NONE ? this.background : null,
      c = null != this.border && this.border != mxConstants.NONE ? this.border : null;
    if ('fill' == this.overflow || 'width' == this.overflow)
      null != b && (this.node.style.backgroundColor = b), null != c && (this.node.style.border = '1px solid ' + c);
    else {
      var d = '';
      null != b && (d += 'background-color:' + mxUtils.htmlEntities(b) + ';');
      null != c && (d += 'border:1px solid ' + mxUtils.htmlEntities(c) + ';');
      a =
        '<div style="zoom:1;' +
        d +
        'display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:' +
        (mxConstants.ABSOLUTE_LINE_HEIGHT ? this.size * mxConstants.LINE_HEIGHT + 'px' : mxConstants.LINE_HEIGHT) +
        '">' +
        a +
        '</div>';
    }
    this.node.innerHTML = a;
    a = this.node.getElementsByTagName('div');
    0 < a.length &&
      ((b = this.textDirection),
      b == mxConstants.TEXT_DIRECTION_AUTO &&
        this.dialect != mxConstants.DIALECT_STRICTHTML &&
        (b = this.getAutoDirection()),
      b == mxConstants.TEXT_DIRECTION_LTR || b == mxConstants.TEXT_DIRECTION_RTL
        ? a[a.length - 1].setAttribute('dir', b)
        : a[a.length - 1].removeAttribute('dir'));
  }
};
mxText.prototype.updateFont = function (a) {
  a = a.style;
  a.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT
    ? this.size * mxConstants.LINE_HEIGHT + 'px'
    : mxConstants.LINE_HEIGHT;
  a.fontSize = this.size + 'px';
  a.fontFamily = this.family;
  a.verticalAlign = 'top';
  a.color = this.color;
  a.fontWeight = (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD ? 'bold' : '';
  a.fontStyle = (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC ? 'italic' : '';
  var b = [];
  (this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && b.push('underline');
  (this.fontStyle & mxConstants.FONT_STRIKETHROUGH) == mxConstants.FONT_STRIKETHROUGH && b.push('line-through');
  a.textDecoration = b.join(' ');
  a.textAlign =
    this.align == mxConstants.ALIGN_CENTER ? 'center' : this.align == mxConstants.ALIGN_RIGHT ? 'right' : 'left';
};
mxText.prototype.updateSize = function (a, b) {
  var c = Math.max(0, Math.round(this.bounds.width / this.scale)),
    d = Math.max(0, Math.round(this.bounds.height / this.scale)),
    e = a.style;
  this.clipped
    ? ((e.overflow = 'hidden'), (e.maxHeight = d + 'px'), (e.maxWidth = c + 'px'))
    : 'fill' == this.overflow
    ? ((e.width = c + 1 + 'px'), (e.height = d + 1 + 'px'), (e.overflow = 'hidden'))
    : 'width' == this.overflow
    ? ((e.width = c + 1 + 'px'), (e.maxHeight = d + 1 + 'px'), (e.overflow = 'hidden'))
    : 'block' == this.overflow && (e.width = c + 1 + 'px');
  if (this.wrap && 0 < c) {
    if (
      ((e.wordWrap = mxConstants.WORD_WRAP),
      (e.whiteSpace = 'normal'),
      (e.width = c + 'px'),
      b && 'fill' != this.overflow && 'width' != this.overflow)
    ) {
      d = a;
      null != d.firstChild &&
        'DIV' == d.firstChild.nodeName &&
        ((d = d.firstChild), 'break-word' == a.style.wordWrap && (d.style.width = '100%'));
      var f = d.offsetWidth;
      if (0 == f) {
        var g = a.parentNode;
        a.style.visibility = 'hidden';
        document.body.appendChild(a);
        f = d.offsetWidth;
        a.style.visibility = '';
        g.appendChild(a);
      }
      f += 3;
      this.clipped && (f = Math.min(f, c));
      e.width = f + 'px';
    }
  } else e.whiteSpace = 'nowrap';
};
mxText.prototype.updateMargin = function () {
  this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
};
mxText.prototype.getSpacing = function (a) {
  return new mxPoint(
    this.align == mxConstants.ALIGN_CENTER
      ? (this.spacingLeft - this.spacingRight) / 2
      : this.align == mxConstants.ALIGN_RIGHT
      ? -this.spacingRight - (a ? 0 : this.baseSpacingRight)
      : this.spacingLeft + (a ? 0 : this.baseSpacingLeft),
    this.valign == mxConstants.ALIGN_MIDDLE
      ? (this.spacingTop - this.spacingBottom) / 2
      : this.valign == mxConstants.ALIGN_BOTTOM
      ? -this.spacingBottom - (a ? 0 : this.baseSpacingBottom)
      : this.spacingTop + (a ? 0 : this.baseSpacingTop)
  );
};
function mxTriangle() {
  mxActor.call(this);
}
mxUtils.extend(mxTriangle, mxActor);
mxTriangle.prototype.isRoundable = function () {
  return !0;
};
mxTriangle.prototype.redrawPath = function (a, b, c, d, e) {
  b = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(a, [new mxPoint(0, 0), new mxPoint(d, 0.5 * e), new mxPoint(0, e)], this.isRounded, b, !0);
};
function mxHexagon() {
  mxActor.call(this);
}
mxUtils.extend(mxHexagon, mxActor);
mxHexagon.prototype.redrawPath = function (a, b, c, d, e) {
  b = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
  this.addPoints(
    a,
    [
      new mxPoint(0.25 * d, 0),
      new mxPoint(0.75 * d, 0),
      new mxPoint(d, 0.5 * e),
      new mxPoint(0.75 * d, e),
      new mxPoint(0.25 * d, e),
      new mxPoint(0, 0.5 * e),
    ],
    this.isRounded,
    b,
    !0
  );
};
function mxLine(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.stroke = b;
  this.strokewidth = null != c ? c : 1;
  this.vertical = null != d ? d : this.vertical;
}
mxUtils.extend(mxLine, mxShape);
mxLine.prototype.vertical = !1;
mxLine.prototype.paintVertexShape = function (a, b, c, d, e) {
  a.begin();
  if (this.vertical) {
    var f = b + d / 2;
    a.moveTo(f, c);
    a.lineTo(f, c + e);
  } else (f = c + e / 2), a.moveTo(b, f), a.lineTo(b + d, f);
  a.stroke();
};
function mxImageShape(a, b, c, d, e) {
  mxShape.call(this);
  this.bounds = a;
  this.image = b;
  this.fill = c;
  this.stroke = d;
  this.strokewidth = null != e ? e : 1;
  this.shadow = !1;
}
mxUtils.extend(mxImageShape, mxRectangleShape);
mxImageShape.prototype.preserveImageAspect = !0;
mxImageShape.prototype.getSvgScreenOffset = function () {
  return 0;
};
mxImageShape.prototype.apply = function (a) {
  mxShape.prototype.apply.apply(this, arguments);
  this.gradient = this.stroke = this.fill = null;
  null != this.style &&
    ((this.preserveImageAspect = 1 == mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1)),
    (this.imageBackground = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null)),
    (this.imageBorder = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null)),
    (this.flipH = this.flipH || 1 == mxUtils.getValue(this.style, 'imageFlipH', 0)),
    (this.flipV = this.flipV || 1 == mxUtils.getValue(this.style, 'imageFlipV', 0)),
    (this.clipPath = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null)));
};
mxImageShape.prototype.isHtmlAllowed = function () {
  return !this.preserveImageAspect;
};
mxImageShape.prototype.createHtml = function () {
  var a = document.createElement('div');
  a.style.position = 'absolute';
  return a;
};
mxImageShape.prototype.isRoundable = function () {
  return !1;
};
mxImageShape.prototype.getImageDataUri = function () {
  return this.image;
};
mxImageShape.prototype.configurePointerEvents = function (a) {};
mxImageShape.prototype.paintVertexShape = function (a, b, c, d, e) {
  null != this.image
    ? (null != this.imageBackground &&
        (a.setFillColor(this.imageBackground),
        a.setStrokeColor(this.imageBorder),
        a.rect(b, c, d, e),
        a.fillAndStroke()),
      a.image(b, c, d, e, this.getImageDataUri(), this.preserveImageAspect, !1, !1, this.clipPath),
      null != this.imageBorder && (a.setShadow(!1), a.setStrokeColor(this.imageBorder), a.rect(b, c, d, e), a.stroke()))
    : mxRectangleShape.prototype.paintBackground.apply(this, arguments);
};
mxImageShape.prototype.redrawHtmlShape = function () {
  this.node.style.left = Math.round(this.bounds.x) + 'px';
  this.node.style.top = Math.round(this.bounds.y) + 'px';
  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + 'px';
  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + 'px';
  this.node.innerHTML = '';
  if (null != this.image) {
    var a = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, ''),
      b = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, '');
    this.node.style.backgroundColor = a;
    this.node.style.borderColor = b;
    a = document.createElement('img');
    a.setAttribute('border', '0');
    a.style.position = 'absolute';
    a.src = this.image;
    b = 100 > this.opacity ? 'alpha(opacity=' + this.opacity + ')' : '';
    this.node.style.filter = b;
    this.flipH && this.flipV
      ? (b += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2)')
      : this.flipH
      ? (b += 'progid:DXImageTransform.Microsoft.BasicImage(mirror=1)')
      : this.flipV && (b += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)');
    a.style.filter != b && (a.style.filter = b);
    'image' == a.nodeName
      ? (a.style.rotation = this.rotation)
      : 0 != this.rotation
      ? mxUtils.setPrefixedStyle(a.style, 'transform', 'rotate(' + this.rotation + 'deg)')
      : mxUtils.setPrefixedStyle(a.style, 'transform', '');
    a.style.width = this.node.style.width;
    a.style.height = this.node.style.height;
    this.node.style.backgroundImage = '';
    this.node.appendChild(a);
  } else this.setTransparentBackgroundImage(this.node);
};
function mxLabel(a, b, c, d) {
  mxRectangleShape.call(this, a, b, c, d);
}
mxUtils.extend(mxLabel, mxRectangleShape);
mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;
mxLabel.prototype.spacing = 2;
mxLabel.prototype.indicatorSize = 10;
mxLabel.prototype.indicatorSpacing = 2;
mxLabel.prototype.init = function (a) {
  mxShape.prototype.init.apply(this, arguments);
  null != this.indicatorShape &&
    ((this.indicator = new this.indicatorShape()),
    (this.indicator.dialect = this.dialect),
    this.indicator.init(this.node));
};
mxLabel.prototype.redraw = function () {
  null != this.indicator &&
    ((this.indicator.fill = this.indicatorColor),
    (this.indicator.stroke = this.indicatorStrokeColor),
    (this.indicator.gradient = this.indicatorGradientColor),
    (this.indicator.direction = this.indicatorDirection),
    this.indicator.redraw());
  mxShape.prototype.redraw.apply(this, arguments);
};
mxLabel.prototype.isHtmlAllowed = function () {
  return (
    mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) &&
    null == this.indicatorColor &&
    null == this.indicatorShape
  );
};
mxLabel.prototype.paintForeground = function (a, b, c, d, e) {
  this.paintImage(a, b, c, d, e);
  this.paintIndicator(a, b, c, d, e);
  mxRectangleShape.prototype.paintForeground.apply(this, arguments);
};
mxLabel.prototype.paintImage = function (a, b, c, d, e) {
  null != this.image &&
    ((b = this.getImageBounds(b, c, d, e)),
    (c = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null)),
    a.image(b.x, b.y, b.width, b.height, this.image, !1, !1, !1, c));
};
mxLabel.prototype.getImageBounds = function (a, b, c, d) {
  var e = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT),
    f = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE),
    g = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE),
    k = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE),
    h = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
  a = e == mxConstants.ALIGN_CENTER ? a + (c - g) / 2 : e == mxConstants.ALIGN_RIGHT ? a + (c - g - h) : a + h;
  b = f == mxConstants.ALIGN_TOP ? b + h : f == mxConstants.ALIGN_BOTTOM ? b + (d - k - h) : b + (d - k) / 2;
  return new mxRectangle(a, b, g, k);
};
mxLabel.prototype.paintIndicator = function (a, b, c, d, e) {
  null != this.indicator
    ? ((this.indicator.bounds = this.getIndicatorBounds(b, c, d, e)), this.indicator.paint(a))
    : null != this.indicatorImage &&
      ((b = this.getIndicatorBounds(b, c, d, e)),
      a.image(b.x, b.y, b.width, b.height, this.indicatorImage, !1, !1, !1));
};
mxLabel.prototype.getIndicatorBounds = function (a, b, c, d) {
  var e = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT),
    f = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE),
    g = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize),
    k = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize),
    h = this.spacing + 5;
  a = e == mxConstants.ALIGN_RIGHT ? a + (c - g - h) : e == mxConstants.ALIGN_CENTER ? a + (c - g) / 2 : a + h;
  b = f == mxConstants.ALIGN_BOTTOM ? b + (d - k - h) : f == mxConstants.ALIGN_TOP ? b + h : b + (d - k) / 2;
  return new mxRectangle(a, b, g, k);
};
mxLabel.prototype.redrawHtmlShape = function () {
  for (mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments); this.node.hasChildNodes(); )
    this.node.removeChild(this.node.lastChild);
  if (null != this.image) {
    var a = document.createElement('img');
    a.style.position = 'relative';
    a.setAttribute('border', '0');
    var b = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
    b.x -= this.bounds.x;
    b.y -= this.bounds.y;
    a.style.left = Math.round(b.x) + 'px';
    a.style.top = Math.round(b.y) + 'px';
    a.style.width = Math.round(b.width) + 'px';
    a.style.height = Math.round(b.height) + 'px';
    a.src = this.image;
    this.node.appendChild(a);
  }
};
function mxCylinder(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxCylinder, mxShape);
mxCylinder.prototype.maxHeight = 40;
mxCylinder.prototype.paintVertexShape = function (a, b, c, d, e) {
  a.translate(b, c);
  a.begin();
  this.redrawPath(a, b, c, d, e, !1);
  a.fillAndStroke();
  (this.outline && null != this.style && 0 != mxUtils.getValue(this.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0)) ||
    (a.setShadow(!1), a.begin(), this.redrawPath(a, b, c, d, e, !0), a.stroke());
};
mxCylinder.prototype.getCylinderSize = function (a, b, c, d) {
  return Math.min(this.maxHeight, Math.round(d / 5));
};
mxCylinder.prototype.redrawPath = function (a, b, c, d, e, f) {
  b = this.getCylinderSize(b, c, d, e);
  if ((f && null != this.fill) || (!f && null == this.fill))
    a.moveTo(0, b), a.curveTo(0, 2 * b, d, 2 * b, d, b), f || (a.stroke(), a.begin());
  f ||
    (a.moveTo(0, b),
    a.curveTo(0, -b / 3, d, -b / 3, d, b),
    a.lineTo(d, e - b),
    a.curveTo(d, e + b / 3, 0, e + b / 3, 0, e - b),
    a.close());
};
function mxConnector(a, b, c) {
  mxPolyline.call(this, a, b, c);
}
mxUtils.extend(mxConnector, mxPolyline);
mxConnector.prototype.updateBoundingBox = function () {
  this.useSvgBoundingBox = null != this.style && 1 == this.style[mxConstants.STYLE_CURVED];
  mxShape.prototype.updateBoundingBox.apply(this, arguments);
};
mxConnector.prototype.paintEdgeShape = function (a, b) {
  var c = this.createMarker(a, b, !0),
    d = this.createMarker(a, b, !1);
  mxPolyline.prototype.paintEdgeShape.apply(this, arguments);
  a.setFillColor(this.stroke);
  a.setShadow(!1);
  a.setDashed(!1);
  null != c && c();
  null != d && d();
};
mxConnector.prototype.createMarker = function (a, b, c) {
  var d = null,
    e = b.length,
    f = mxUtils.getValue(this.style, c ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW),
    g = c ? b[1] : b[e - 2];
  b = c ? b[0] : b[e - 1];
  if (null != f && null != g && null != b)
    var d = b.x - g.x,
      e = b.y - g.y,
      k = Math.sqrt(d * d + e * e),
      g = d / k,
      d = e / k,
      e = mxUtils.getNumber(
        this.style,
        c ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE,
        mxConstants.DEFAULT_MARKERSIZE
      ),
      d = mxMarker.createMarker(
        a,
        this,
        f,
        b,
        g,
        d,
        e,
        c,
        this.strokewidth,
        0 != this.style[c ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL]
      );
  return d;
};
mxConnector.prototype.augmentBoundingBox = function (a) {
  mxShape.prototype.augmentBoundingBox.apply(this, arguments);
  var b = 0;
  mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE &&
    (b = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1);
  mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE &&
    (b = Math.max(b, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1);
  a.grow(b * this.scale);
};
function mxSwimlane(a, b, c, d) {
  mxShape.call(this);
  this.bounds = a;
  this.fill = b;
  this.stroke = c;
  this.strokewidth = null != d ? d : 1;
}
mxUtils.extend(mxSwimlane, mxShape);
mxSwimlane.prototype.imageSize = 16;
mxSwimlane.prototype.apply = function (a) {
  mxShape.prototype.apply.apply(this, arguments);
  null != this.style &&
    (this.laneFill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE));
};
mxSwimlane.prototype.isRoundable = function () {
  return !0;
};
mxSwimlane.prototype.getTitleSize = function () {
  return Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
};
mxSwimlane.prototype.getLabelBounds = function (a) {
  var b = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0),
    c = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0);
  a = new mxRectangle(a.x, a.y, a.width, a.height);
  var d = this.isHorizontal(),
    e = this.getTitleSize(),
    f = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH,
    d = d == !f,
    b = !d && b != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST),
    c = d && c != (this.direction == mxConstants.DIRECTION_SOUTH || this.direction == mxConstants.DIRECTION_WEST);
  if (f) {
    e = Math.min(a.width, e * this.scale);
    if (b || c) a.x += a.width - e;
    a.width = e;
  } else {
    e = Math.min(a.height, e * this.scale);
    if (b || c) a.y += a.height - e;
    a.height = e;
  }
  return a;
};
mxSwimlane.prototype.getGradientBounds = function (a, b, c, d, e) {
  a = this.getTitleSize();
  return this.isHorizontal() ? new mxRectangle(b, c, d, Math.min(a, e)) : new mxRectangle(b, c, Math.min(a, d), e);
};
mxSwimlane.prototype.getSwimlaneArcSize = function (a, b, c) {
  if ('1' == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0))
    return Math.min(
      a / 2,
      Math.min(b / 2, mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2)
    );
  a = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
  return c * a * 3;
};
mxSwimlane.prototype.isHorizontal = function () {
  return 1 == mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1);
};
mxSwimlane.prototype.paintVertexShape = function (a, b, c, d, e) {
  if (!this.outline) {
    var f = this.getTitleSize(),
      g = 0,
      f = this.isHorizontal() ? Math.min(f, e) : Math.min(f, d);
    a.translate(b, c);
    this.isRounded
      ? ((g = this.getSwimlaneArcSize(d, e, f)),
        (g = Math.min((this.isHorizontal() ? e : d) - f, Math.min(f, g))),
        this.paintRoundedSwimlane(a, b, c, d, e, f, g))
      : this.paintSwimlane(a, b, c, d, e, f);
    var k = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);
    this.paintSeparator(a, b, c, d, e, f, k);
    null != this.image &&
      ((e = this.getImageBounds(b, c, d, e)),
      (k = mxUtils.getValue(this.style, mxConstants.STYLE_CLIP_PATH, null)),
      a.image(e.x - b, e.y - c, e.width, e.height, this.image, !1, !1, !1, k));
    this.glass && (a.setShadow(!1), this.paintGlassEffect(a, 0, 0, d, f, g));
  }
};
mxSwimlane.prototype.configurePointerEvents = function (a) {
  var b = !0,
    c = !0,
    d = !0;
  null != this.style &&
    ((b = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1')),
    (c = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1)),
    (d = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1)));
  (b || c || d) && mxShape.prototype.configurePointerEvents.apply(this, arguments);
};
mxSwimlane.prototype.paintSwimlane = function (a, b, c, d, e, f) {
  var g = this.laneFill,
    k = !0,
    h = !0,
    l = !0,
    m = !0;
  null != this.style &&
    ((k = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1')),
    (h = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1)),
    (l = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1)),
    (m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1)));
  this.isHorizontal()
    ? (a.begin(),
      a.moveTo(0, f),
      a.lineTo(0, 0),
      a.lineTo(d, 0),
      a.lineTo(d, f),
      l ? a.fillAndStroke() : a.fill(),
      f < e &&
        ((g != mxConstants.NONE && k) || (a.pointerEvents = !1),
        g != mxConstants.NONE && a.setFillColor(g),
        a.begin(),
        a.moveTo(0, f),
        a.lineTo(0, e),
        a.lineTo(d, e),
        a.lineTo(d, f),
        m ? (g == mxConstants.NONE ? a.stroke() : m && a.fillAndStroke()) : g != mxConstants.NONE && a.fill()))
    : (a.begin(),
      a.moveTo(f, 0),
      a.lineTo(0, 0),
      a.lineTo(0, e),
      a.lineTo(f, e),
      l ? a.fillAndStroke() : a.fill(),
      f < d &&
        ((g != mxConstants.NONE && k) || (a.pointerEvents = !1),
        g != mxConstants.NONE && a.setFillColor(g),
        a.begin(),
        a.moveTo(f, 0),
        a.lineTo(d, 0),
        a.lineTo(d, e),
        a.lineTo(f, e),
        m ? (g == mxConstants.NONE ? a.stroke() : m && a.fillAndStroke()) : g != mxConstants.NONE && a.fill()));
  h && this.paintDivider(a, b, c, d, e, f, g == mxConstants.NONE);
};
mxSwimlane.prototype.paintRoundedSwimlane = function (a, b, c, d, e, f, g) {
  var k = this.laneFill,
    h = !0,
    l = !0,
    m = !0,
    n = !0;
  null != this.style &&
    ((h = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1')),
    (l = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1)),
    (m = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_HEAD, 1)),
    (n = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_BODY, 1)));
  this.isHorizontal()
    ? (a.begin(),
      a.moveTo(d, f),
      a.lineTo(d, g),
      a.quadTo(d, 0, d - Math.min(d / 2, g), 0),
      a.lineTo(Math.min(d / 2, g), 0),
      a.quadTo(0, 0, 0, g),
      a.lineTo(0, f),
      m ? a.fillAndStroke() : a.fill(),
      f < e &&
        ((k != mxConstants.NONE && h) || (a.pointerEvents = !1),
        k != mxConstants.NONE && a.setFillColor(k),
        a.begin(),
        a.moveTo(0, f),
        a.lineTo(0, e - g),
        a.quadTo(0, e, Math.min(d / 2, g), e),
        a.lineTo(d - Math.min(d / 2, g), e),
        a.quadTo(d, e, d, e - g),
        a.lineTo(d, f),
        n ? (k == mxConstants.NONE ? a.stroke() : n && a.fillAndStroke()) : k != mxConstants.NONE && a.fill()))
    : (a.begin(),
      a.moveTo(f, 0),
      a.lineTo(g, 0),
      a.quadTo(0, 0, 0, Math.min(e / 2, g)),
      a.lineTo(0, e - Math.min(e / 2, g)),
      a.quadTo(0, e, g, e),
      a.lineTo(f, e),
      m ? a.fillAndStroke() : a.fill(),
      f < d &&
        ((k != mxConstants.NONE && h) || (a.pointerEvents = !1),
        k != mxConstants.NONE && a.setFillColor(k),
        a.begin(),
        a.moveTo(f, e),
        a.lineTo(d - g, e),
        a.quadTo(d, e, d, e - Math.min(e / 2, g)),
        a.lineTo(d, Math.min(e / 2, g)),
        a.quadTo(d, 0, d - g, 0),
        a.lineTo(f, 0),
        n ? (k == mxConstants.NONE ? a.stroke() : n && a.fillAndStroke()) : k != mxConstants.NONE && a.fill()));
  l && this.paintDivider(a, b, c, d, e, f, k == mxConstants.NONE);
};
mxSwimlane.prototype.paintDivider = function (a, b, c, d, e, f, g) {
  0 != f &&
    (g || a.setShadow(!1),
    a.begin(),
    this.isHorizontal() ? (a.moveTo(0, f), a.lineTo(d, f)) : (a.moveTo(f, 0), a.lineTo(f, e)),
    a.stroke());
};
mxSwimlane.prototype.paintSeparator = function (a, b, c, d, e, f, g) {
  g != mxConstants.NONE &&
    (a.setStrokeColor(g),
    a.setDashed(!0),
    a.begin(),
    this.isHorizontal() ? (a.moveTo(d, f), a.lineTo(d, e)) : (a.moveTo(f, 0), a.lineTo(d, 0)),
    a.stroke(),
    a.setDashed(!1));
};
mxSwimlane.prototype.getImageBounds = function (a, b, c, d) {
  return this.isHorizontal()
    ? new mxRectangle(a + c - this.imageSize, b, this.imageSize, this.imageSize)
    : new mxRectangle(a, b, this.imageSize, this.imageSize);
};
function mxGraphLayout(a) {
  this.graph = a;
}
mxGraphLayout.prototype.graph = null;
mxGraphLayout.prototype.useBoundingBox = !0;
mxGraphLayout.prototype.parent = null;
mxGraphLayout.prototype.moveCell = function (a, b, c) {};
mxGraphLayout.prototype.resizeCell = function (a, b) {};
mxGraphLayout.prototype.execute = function (a) {};
mxGraphLayout.prototype.getGraph = function () {
  return this.graph;
};
mxGraphLayout.prototype.getConstraint = function (a, b, c, d) {
  return this.graph.getCurrentCellStyle(b)[a];
};
mxGraphLayout.traverse = function (a, b, c, d, e) {
  if (
    null != c &&
    null != a &&
    ((b = null != b ? b : !0),
    (e = e || new mxDictionary()),
    !e.get(a) && (e.put(a, !0), (d = c(a, d)), null == d || d)) &&
    ((d = this.graph.model.getEdgeCount(a)), 0 < d)
  )
    for (var f = 0; f < d; f++) {
      var g = this.graph.model.getEdgeAt(a, f),
        k = this.graph.model.getTerminal(g, !0) == a;
      if (!b || k) (k = this.graph.view.getVisibleTerminal(g, !k)), this.traverse(k, b, c, g, e);
    }
};
mxGraphLayout.prototype.isAncestor = function (a, b, c) {
  if (!c) return this.graph.model.getParent(b) == a;
  if (b == a) return !1;
  for (; null != b && b != a; ) b = this.graph.model.getParent(b);
  return b == a;
};
mxGraphLayout.prototype.isVertexMovable = function (a) {
  return this.graph.isCellMovable(a);
};
mxGraphLayout.prototype.isVertexIgnored = function (a) {
  return !this.graph.getModel().isVertex(a) || !this.graph.isCellVisible(a);
};
mxGraphLayout.prototype.isEdgeIgnored = function (a) {
  var b = this.graph.getModel();
  return !b.isEdge(a) || !this.graph.isCellVisible(a) || null == b.getTerminal(a, !0) || null == b.getTerminal(a, !1);
};
mxGraphLayout.prototype.setEdgeStyleEnabled = function (a, b) {
  this.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, b ? '0' : '1', [a]);
};
mxGraphLayout.prototype.setOrthogonalEdge = function (a, b) {
  this.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL, b ? '1' : '0', [a]);
};
mxGraphLayout.prototype.getParentOffset = function (a) {
  var b = new mxPoint();
  if (null != a && a != this.parent) {
    var c = this.graph.getModel();
    if (c.isAncestor(this.parent, a))
      for (var d = c.getGeometry(a); a != this.parent; )
        (b.x += d.x), (b.y += d.y), (a = c.getParent(a)), (d = c.getGeometry(a));
  }
  return b;
};
mxGraphLayout.prototype.setEdgePoints = function (a, b) {
  if (null != a) {
    var c = this.graph.model,
      d = c.getGeometry(a);
    null == d ? ((d = new mxGeometry()), d.setRelative(!0)) : (d = d.clone());
    if (null != this.parent && null != b)
      for (var e = c.getParent(a), e = this.getParentOffset(e), f = 0; f < b.length; f++)
        (b[f].x -= e.x), (b[f].y -= e.y);
    d.points = b;
    c.setGeometry(a, d);
  }
};
mxGraphLayout.prototype.setVertexLocation = function (a, b, c) {
  var d = this.graph.getModel(),
    e = d.getGeometry(a),
    f = null;
  if (null != e) {
    f = new mxRectangle(b, c, e.width, e.height);
    if (this.useBoundingBox) {
      var g = this.graph.getView().getState(a);
      if (null != g && null != g.text && null != g.text.boundingBox) {
        var k = this.graph.getView().scale,
          h = g.text.boundingBox;
        g.text.boundingBox.x < g.x && ((b += (g.x - h.x) / k), (f.width = h.width));
        g.text.boundingBox.y < g.y && ((c += (g.y - h.y) / k), (f.height = h.height));
      }
    }
    null != this.parent &&
      ((g = d.getParent(a)), null != g && g != this.parent && ((g = this.getParentOffset(g)), (b -= g.x), (c -= g.y)));
    if (e.x != b || e.y != c) (e = e.clone()), (e.x = b), (e.y = c), d.setGeometry(a, e);
  }
  return f;
};
mxGraphLayout.prototype.getVertexBounds = function (a) {
  var b = this.graph.getModel().getGeometry(a);
  if (this.useBoundingBox) {
    var c = this.graph.getView().getState(a);
    if (null != c && null != c.text && null != c.text.boundingBox)
      var d = this.graph.getView().scale,
        e = c.text.boundingBox,
        f = Math.max(c.x - e.x, 0) / d,
        g = Math.max(c.y - e.y, 0) / d,
        b = new mxRectangle(
          b.x - f,
          b.y - g,
          b.width + f + Math.max(e.x + e.width - (c.x + c.width), 0) / d,
          b.height + g + Math.max(e.y + e.height - (c.y + c.height), 0) / d
        );
  }
  null != this.parent &&
    ((a = this.graph.getModel().getParent(a)),
    (b = b.clone()),
    null != a && a != this.parent && ((a = this.getParentOffset(a)), (b.x += a.x), (b.y += a.y)));
  return new mxRectangle(b.x, b.y, b.width, b.height);
};
mxGraphLayout.prototype.arrangeGroups = function (a, b, c, d, e, f) {
  return this.graph.updateGroupBounds(a, b, !0, c, d, e, f);
};
function WeightedCellSorter(a, b) {
  this.cell = a;
  this.weightedValue = b;
}
WeightedCellSorter.prototype.weightedValue = 0;
WeightedCellSorter.prototype.nudge = !1;
WeightedCellSorter.prototype.visited = !1;
WeightedCellSorter.prototype.rankIndex = null;
WeightedCellSorter.prototype.cell = null;
WeightedCellSorter.prototype.compare = function (a, b) {
  return null != a && null != b
    ? b.weightedValue > a.weightedValue
      ? -1
      : b.weightedValue < a.weightedValue
      ? 1
      : b.nudge
      ? -1
      : 1
    : 0;
};
function mxStackLayout(a, b, c, d, e, f) {
  mxGraphLayout.call(this, a);
  this.horizontal = null != b ? b : !0;
  this.spacing = null != c ? c : 0;
  this.x0 = null != d ? d : 0;
  this.y0 = null != e ? e : 0;
  this.border = null != f ? f : 0;
}
mxStackLayout.prototype = new mxGraphLayout();
mxStackLayout.prototype.constructor = mxStackLayout;
mxStackLayout.prototype.horizontal = null;
mxStackLayout.prototype.spacing = null;
mxStackLayout.prototype.x0 = null;
mxStackLayout.prototype.y0 = null;
mxStackLayout.prototype.border = 0;
mxStackLayout.prototype.marginTop = 0;
mxStackLayout.prototype.marginLeft = 0;
mxStackLayout.prototype.marginRight = 0;
mxStackLayout.prototype.marginBottom = 0;
mxStackLayout.prototype.keepFirstLocation = !1;
mxStackLayout.prototype.fill = !1;
mxStackLayout.prototype.resizeParent = !1;
mxStackLayout.prototype.resizeParentMax = !1;
mxStackLayout.prototype.resizeLast = !1;
mxStackLayout.prototype.wrap = null;
mxStackLayout.prototype.borderCollapse = !0;
mxStackLayout.prototype.allowGaps = !1;
mxStackLayout.prototype.gridSize = 0;
mxStackLayout.prototype.isHorizontal = function () {
  return this.horizontal;
};
mxStackLayout.prototype.moveCell = function (a, b, c) {
  var d = this.graph.getModel(),
    e = d.getParent(a),
    f = this.isHorizontal();
  if (null != a && null != e) {
    var g = 0,
      k = d.getChildCount(e);
    c = f ? b : c;
    b = this.graph.getView().getState(e);
    null != b && (c -= f ? b.x : b.y);
    c /= this.graph.view.scale;
    for (b = 0; b < k; b++) {
      var h = d.getChildAt(e, b);
      if (h != a && ((h = d.getGeometry(h)), null != h)) {
        h = f ? h.x + h.width / 2 : h.y + h.height / 2;
        if (g <= c && h > c) break;
        g = h;
      }
    }
    f = e.getIndex(a);
    f = Math.max(0, b - (b > f ? 1 : 0));
    d.add(e, a, f);
  }
};
mxStackLayout.prototype.getParentSize = function (a) {
  var b = this.graph.getModel(),
    c = b.getGeometry(a);
  null != this.graph.container &&
    ((null == c && b.isLayer(a)) || a == this.graph.getView().currentRoot) &&
    (c = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1));
  return c;
};
mxStackLayout.prototype.getLayoutCells = function (a) {
  for (var b = this.graph.getModel(), c = b.getChildCount(a), d = [], e = 0; e < c; e++) {
    var f = b.getChildAt(a, e);
    !this.isVertexIgnored(f) && this.isVertexMovable(f) && d.push(f);
  }
  this.allowGaps &&
    d.sort(
      mxUtils.bind(this, function (a, b) {
        var c = this.graph.getCellGeometry(a),
          d = this.graph.getCellGeometry(b);
        return this.horizontal ? (c.x == d.x ? 0 : c.x > d.x > 0 ? 1 : -1) : c.y == d.y ? 0 : c.y > d.y > 0 ? 1 : -1;
      })
    );
  return d;
};
mxStackLayout.prototype.snap = function (a) {
  if (null != this.gridSize && 0 < this.gridSize && ((a = Math.max(a, this.gridSize)), 1 < a / this.gridSize)) {
    var b = a % this.gridSize;
    a += b > this.gridSize / 2 ? this.gridSize - b : -b;
  }
  return a;
};
mxStackLayout.prototype.execute = function (a) {
  if (null != a) {
    var b = this.getParentSize(a),
      c = this.isHorizontal(),
      d = this.graph.getModel(),
      e = null;
    null != b && (e = c ? b.height - this.marginTop - this.marginBottom : b.width - this.marginLeft - this.marginRight);
    var e = e - 2 * this.border,
      f = this.x0 + this.border + this.marginLeft,
      g = this.y0 + this.border + this.marginTop;
    if (this.graph.isSwimlane(a)) {
      var k = this.graph.getCellStyle(a),
        h = mxUtils.getNumber(k, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE),
        k = 1 == mxUtils.getValue(k, mxConstants.STYLE_HORIZONTAL, !0);
      null != b && (h = k ? Math.min(h, b.height) : Math.min(h, b.width));
      c == k && (e -= h);
      k ? (g += h) : (f += h);
    }
    d.beginUpdate();
    try {
      for (var h = 0, k = null, l = 0, m = null, n = this.getLayoutCells(a), p = 0; p < n.length; p++) {
        var r = n[p],
          t = d.getGeometry(r);
        if (null != t) {
          t = t.clone();
          null != this.wrap &&
            null != k &&
            ((c && k.x + k.width + t.width + 2 * this.spacing > this.wrap) ||
              (!c && k.y + k.height + t.height + 2 * this.spacing > this.wrap)) &&
            ((k = null), c ? (g += h + this.spacing) : (f += h + this.spacing), (h = 0));
          var h = Math.max(h, c ? t.height : t.width),
            u = 0;
          if (!this.borderCollapse)
            var x = this.graph.getCellStyle(r),
              u = mxUtils.getNumber(x, mxConstants.STYLE_STROKEWIDTH, 1);
          if (null != k) {
            var z = l + this.spacing + Math.floor(u / 2);
            c
              ? (t.x = this.snap((this.allowGaps ? Math.max(z, t.x) : z) - this.marginLeft) + this.marginLeft)
              : (t.y = this.snap((this.allowGaps ? Math.max(z, t.y) : z) - this.marginTop) + this.marginTop);
          } else
            this.keepFirstLocation ||
              (c
                ? (t.x =
                    this.allowGaps && t.x > f ? Math.max(this.snap(t.x - this.marginLeft) + this.marginLeft, f) : f)
                : (t.y =
                    this.allowGaps && t.y > g ? Math.max(this.snap(t.y - this.marginTop) + this.marginTop, g) : g));
          c ? (t.y = g) : (t.x = f);
          this.fill && null != e && (c ? (t.height = e) : (t.width = e));
          c ? (t.width = this.snap(t.width)) : (t.height = this.snap(t.height));
          this.setChildGeometry(r, t);
          m = r;
          k = t;
          l = c ? k.x + k.width + Math.floor(u / 2) : k.y + k.height + Math.floor(u / 2);
        }
      }
      this.resizeParent && null != b && null != k && !this.graph.isCellCollapsed(a)
        ? this.updateParentGeometry(a, b, k)
        : this.resizeLast &&
          null != b &&
          null != k &&
          null != m &&
          (c
            ? (k.width = b.width - k.x - this.spacing - this.marginRight - this.marginLeft)
            : (k.height = b.height - k.y - this.spacing - this.marginBottom),
          this.setChildGeometry(m, k));
    } finally {
      d.endUpdate();
    }
  }
};
mxStackLayout.prototype.setChildGeometry = function (a, b) {
  var c = this.graph.getCellGeometry(a);
  (null != c && b.x == c.x && b.y == c.y && b.width == c.width && b.height == c.height) ||
    this.graph.getModel().setGeometry(a, b);
};
mxStackLayout.prototype.updateParentGeometry = function (a, b, c) {
  var d = this.isHorizontal(),
    e = this.graph.getModel(),
    f = b.clone();
  d
    ? ((c = c.x + c.width + this.marginRight + this.border),
      (f.width = this.resizeParentMax ? Math.max(f.width, c) : c))
    : ((c = c.y + c.height + this.marginBottom + this.border),
      (f.height = this.resizeParentMax ? Math.max(f.height, c) : c));
  (b.x == f.x && b.y == f.y && b.width == f.width && b.height == f.height) || e.setGeometry(a, f);
};
function mxPartitionLayout(a, b, c, d) {
  mxGraphLayout.call(this, a);
  this.horizontal = null != b ? b : !0;
  this.spacing = c || 0;
  this.border = d || 0;
}
mxPartitionLayout.prototype = new mxGraphLayout();
mxPartitionLayout.prototype.constructor = mxPartitionLayout;
mxPartitionLayout.prototype.horizontal = null;
mxPartitionLayout.prototype.spacing = null;
mxPartitionLayout.prototype.border = null;
mxPartitionLayout.prototype.resizeVertices = !0;
mxPartitionLayout.prototype.isHorizontal = function () {
  return this.horizontal;
};
mxPartitionLayout.prototype.moveCell = function (a, b, c) {
  c = this.graph.getModel();
  var d = c.getParent(a);
  if (null != a && null != d) {
    var e,
      f = 0,
      g = c.getChildCount(d);
    for (e = 0; e < g; e++) {
      var k = c.getChildAt(d, e),
        k = this.getVertexBounds(k);
      if (null != k) {
        k = k.x + k.width / 2;
        if (f < b && k > b) break;
        f = k;
      }
    }
    b = d.getIndex(a);
    b = Math.max(0, e - (e > b ? 1 : 0));
    c.add(d, a, b);
  }
};
mxPartitionLayout.prototype.execute = function (a) {
  var b = this.isHorizontal(),
    c = this.graph.getModel(),
    d = c.getGeometry(a);
  null != this.graph.container &&
    ((null == d && c.isLayer(a)) || a == this.graph.getView().currentRoot) &&
    (d = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1));
  if (null != d) {
    for (var e = [], f = c.getChildCount(a), g = 0; g < f; g++) {
      var k = c.getChildAt(a, g);
      !this.isVertexIgnored(k) && this.isVertexMovable(k) && e.push(k);
    }
    f = e.length;
    if (0 < f) {
      var h = this.border,
        l = this.border,
        m = b ? d.height : d.width,
        m = m - 2 * this.border;
      a = this.graph.isSwimlane(a) ? this.graph.getStartSize(a) : new mxRectangle();
      m -= b ? a.height : a.width;
      h += a.width;
      l += a.height;
      a = this.border + (f - 1) * this.spacing;
      d = b ? (d.width - h - a) / f : (d.height - l - a) / f;
      if (0 < d) {
        c.beginUpdate();
        try {
          for (g = 0; g < f; g++) {
            var k = e[g],
              n = c.getGeometry(k);
            null != n &&
              ((n = n.clone()),
              (n.x = h),
              (n.y = l),
              b
                ? (this.resizeVertices && ((n.width = d), (n.height = m)), (h += d + this.spacing))
                : (this.resizeVertices && ((n.height = d), (n.width = m)), (l += d + this.spacing)),
              c.setGeometry(k, n));
          }
        } finally {
          c.endUpdate();
        }
      }
    }
  }
};
function mxCompactTreeLayout(a, b, c) {
  mxGraphLayout.call(this, a);
  this.horizontal = null != b ? b : !0;
  this.invert = null != c ? c : !1;
}
mxCompactTreeLayout.prototype = new mxGraphLayout();
mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;
mxCompactTreeLayout.prototype.horizontal = null;
mxCompactTreeLayout.prototype.invert = null;
mxCompactTreeLayout.prototype.resizeParent = !0;
mxCompactTreeLayout.prototype.maintainParentLocation = !1;
mxCompactTreeLayout.prototype.groupPadding = 10;
mxCompactTreeLayout.prototype.groupPaddingTop = 0;
mxCompactTreeLayout.prototype.groupPaddingRight = 0;
mxCompactTreeLayout.prototype.groupPaddingBottom = 0;
mxCompactTreeLayout.prototype.groupPaddingLeft = 0;
mxCompactTreeLayout.prototype.parentsChanged = null;
mxCompactTreeLayout.prototype.moveTree = !1;
mxCompactTreeLayout.prototype.visited = null;
mxCompactTreeLayout.prototype.levelDistance = 10;
mxCompactTreeLayout.prototype.nodeDistance = 20;
mxCompactTreeLayout.prototype.resetEdges = !0;
mxCompactTreeLayout.prototype.prefHozEdgeSep = 5;
mxCompactTreeLayout.prototype.prefVertEdgeOff = 4;
mxCompactTreeLayout.prototype.minEdgeJetty = 8;
mxCompactTreeLayout.prototype.channelBuffer = 4;
mxCompactTreeLayout.prototype.edgeRouting = !0;
mxCompactTreeLayout.prototype.sortEdges = !1;
mxCompactTreeLayout.prototype.alignRanks = !1;
mxCompactTreeLayout.prototype.maxRankHeight = null;
mxCompactTreeLayout.prototype.root = null;
mxCompactTreeLayout.prototype.node = null;
mxCompactTreeLayout.prototype.isVertexIgnored = function (a) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(a).length;
};
mxCompactTreeLayout.prototype.isHorizontal = function () {
  return this.horizontal;
};
mxCompactTreeLayout.prototype.execute = function (a, b) {
  this.parent = a;
  var c = this.graph.getModel();
  if (null == b)
    if (0 < this.graph.getEdges(a, c.getParent(a), this.invert, !this.invert, !1).length) this.root = a;
    else {
      var d = this.graph.findTreeRoots(a, !0, this.invert);
      if (0 < d.length)
        for (var e = 0; e < d.length; e++)
          if (
            !this.isVertexIgnored(d[e]) &&
            0 < this.graph.getEdges(d[e], null, this.invert, !this.invert, !1).length
          ) {
            this.root = d[e];
            break;
          }
    }
  else this.root = b;
  if (null != this.root) {
    this.parentsChanged = this.resizeParent ? {} : null;
    this.parentY = this.parentX = null;
    if (a != this.root && null != c.isVertex(a) && this.maintainParentLocation) {
      var f = this.graph.getCellGeometry(a);
      null != f && ((this.parentX = f.x), (this.parentY = f.y));
    }
    c.beginUpdate();
    try {
      if (
        ((this.visited = {}),
        (this.node = this.dfs(this.root, a)),
        this.alignRanks &&
          ((this.maxRankHeight = []), this.findRankHeights(this.node, 0), this.setCellHeights(this.node, 0)),
        null != this.node)
      ) {
        this.layout(this.node);
        var g = this.graph.gridSize,
          d = g;
        if (!this.moveTree) {
          var k = this.getVertexBounds(this.root);
          null != k && ((g = k.x), (d = k.y));
        }
        k = null;
        k = this.isHorizontal() ? this.horizontalLayout(this.node, g, d) : this.verticalLayout(this.node, null, g, d);
        if (null != k) {
          var h = (e = 0);
          0 > k.x && (e = Math.abs(g - k.x));
          0 > k.y && (h = Math.abs(d - k.y));
          (0 == e && 0 == h) || this.moveNode(this.node, e, h);
          this.resizeParent && this.adjustParents();
          this.edgeRouting && this.localEdgeProcessing(this.node);
        }
        null != this.parentX &&
          null != this.parentY &&
          ((f = this.graph.getCellGeometry(a)),
          null != f && ((f = f.clone()), (f.x = this.parentX), (f.y = this.parentY), c.setGeometry(a, f)));
      }
    } finally {
      c.endUpdate();
    }
  }
};
mxCompactTreeLayout.prototype.moveNode = function (a, b, c) {
  a.x += b;
  a.y += c;
  this.apply(a);
  for (a = a.child; null != a; ) this.moveNode(a, b, c), (a = a.next);
};
mxCompactTreeLayout.prototype.sortOutgoingEdges = function (a, b) {
  var c = new mxDictionary();
  b.sort(function (b, e) {
    var d = b.getTerminal(b.getTerminal(!1) == a),
      g = c.get(d);
    null == g && ((g = mxCellPath.create(d).split(mxCellPath.PATH_SEPARATOR)), c.put(d, g));
    var d = e.getTerminal(e.getTerminal(!1) == a),
      k = c.get(d);
    null == k && ((k = mxCellPath.create(d).split(mxCellPath.PATH_SEPARATOR)), c.put(d, k));
    return mxCellPath.compare(g, k);
  });
};
mxCompactTreeLayout.prototype.findRankHeights = function (a, b) {
  if (null == this.maxRankHeight[b] || this.maxRankHeight[b] < a.height) this.maxRankHeight[b] = a.height;
  for (var c = a.child; null != c; ) this.findRankHeights(c, b + 1), (c = c.next);
};
mxCompactTreeLayout.prototype.setCellHeights = function (a, b) {
  null != this.maxRankHeight[b] && this.maxRankHeight[b] > a.height && (a.height = this.maxRankHeight[b]);
  for (var c = a.child; null != c; ) this.setCellHeights(c, b + 1), (c = c.next);
};
mxCompactTreeLayout.prototype.dfs = function (a, b) {
  var c = mxCellPath.create(a),
    d = null;
  if (null != a && null == this.visited[c] && !this.isVertexIgnored(a)) {
    this.visited[c] = a;
    var d = this.createNode(a),
      c = this.graph.getModel(),
      e = null,
      f = this.graph.getEdges(a, b, this.invert, !this.invert, !1, !0),
      g = this.graph.getView();
    this.sortEdges && this.sortOutgoingEdges(a, f);
    for (var k = 0; k < f.length; k++) {
      var h = f[k];
      if (!this.isEdgeIgnored(h)) {
        this.resetEdges && this.setEdgePoints(h, null);
        this.edgeRouting && (this.setEdgeStyleEnabled(h, !1), this.setEdgePoints(h, null));
        var l = g.getState(h),
          h = null != l ? l.getVisibleTerminal(this.invert) : g.getVisibleTerminal(h, this.invert),
          l = this.dfs(h, b);
        null != l && null != c.getGeometry(h) && (null == e ? (d.child = l) : (e.next = l), (e = l));
      }
    }
  }
  return d;
};
mxCompactTreeLayout.prototype.layout = function (a) {
  if (null != a) {
    for (var b = a.child; null != b; ) this.layout(b), (b = b.next);
    null != a.child ? this.attachParent(a, this.join(a)) : this.layoutLeaf(a);
  }
};
mxCompactTreeLayout.prototype.horizontalLayout = function (a, b, c, d) {
  a.x += b + a.offsetX;
  a.y += c + a.offsetY;
  d = this.apply(a, d);
  b = a.child;
  if (null != b) {
    d = this.horizontalLayout(b, a.x, a.y, d);
    c = a.y + b.offsetY;
    for (var e = b.next; null != e; )
      (d = this.horizontalLayout(e, a.x + b.offsetX, c, d)), (c += e.offsetY), (e = e.next);
  }
  return d;
};
mxCompactTreeLayout.prototype.verticalLayout = function (a, b, c, d, e) {
  a.x += c + a.offsetY;
  a.y += d + a.offsetX;
  e = this.apply(a, e);
  b = a.child;
  if (null != b)
    for (e = this.verticalLayout(b, a, a.x, a.y, e), c = a.x + b.offsetY, d = b.next; null != d; )
      (e = this.verticalLayout(d, a, c, a.y + b.offsetX, e)), (c += d.offsetY), (d = d.next);
  return e;
};
mxCompactTreeLayout.prototype.attachParent = function (a, b) {
  var c = this.nodeDistance + this.levelDistance,
    d = (b - a.width) / 2 - this.nodeDistance,
    e = d + a.width + 2 * this.nodeDistance - b;
  a.child.offsetX = c + a.height;
  a.child.offsetY = e;
  a.contour.upperHead = this.createLine(a.height, 0, this.createLine(c, e, a.contour.upperHead));
  a.contour.lowerHead = this.createLine(a.height, 0, this.createLine(c, d, a.contour.lowerHead));
};
mxCompactTreeLayout.prototype.layoutLeaf = function (a) {
  var b = 2 * this.nodeDistance;
  a.contour.upperTail = this.createLine(a.height + b, 0);
  a.contour.upperHead = a.contour.upperTail;
  a.contour.lowerTail = this.createLine(0, -a.width - b);
  a.contour.lowerHead = this.createLine(a.height + b, 0, a.contour.lowerTail);
};
mxCompactTreeLayout.prototype.join = function (a) {
  var b = 2 * this.nodeDistance,
    c = a.child;
  a.contour = c.contour;
  for (var d = c.width + b, e = d, c = c.next; null != c; ) {
    var f = this.merge(a.contour, c.contour);
    c.offsetY = f + d;
    c.offsetX = 0;
    d = c.width + b;
    e += f + d;
    c = c.next;
  }
  return e;
};
mxCompactTreeLayout.prototype.merge = function (a, b) {
  for (var c = 0, d = 0, e = 0, f = a.lowerHead, g = b.upperHead; null != g && null != f; ) {
    var k = this.offset(c, d, g.dx, g.dy, f.dx, f.dy),
      d = d + k,
      e = e + k;
    c + g.dx <= f.dx ? ((c += g.dx), (d += g.dy), (g = g.next)) : ((c -= f.dx), (d -= f.dy), (f = f.next));
  }
  null != g
    ? ((c = this.bridge(a.upperTail, 0, 0, g, c, d)),
      (a.upperTail = null != c.next ? b.upperTail : c),
      (a.lowerTail = b.lowerTail))
    : ((c = this.bridge(b.lowerTail, c, d, f, 0, 0)), null == c.next && (a.lowerTail = c));
  a.lowerHead = b.lowerHead;
  return e;
};
mxCompactTreeLayout.prototype.offset = function (a, b, c, d, e, f) {
  if (e <= a || 0 >= a + c) return 0;
  a =
    0 < e * d - c * f
      ? 0 > a
        ? (a * d) / c - b
        : 0 < a
        ? (a * f) / e - b
        : -b
      : e < a + c
      ? f - (b + ((e - a) * d) / c)
      : e > a + c
      ? ((c + a) * f) / e - (b + d)
      : f - (b + d);
  return 0 < a ? a : 0;
};
mxCompactTreeLayout.prototype.bridge = function (a, b, c, d, e, f) {
  b = e + d.dx - b;
  0 == d.dx ? (e = d.dy) : ((e = b * d.dy), (e /= d.dx));
  b = this.createLine(b, e, d.next);
  a.next = this.createLine(0, f + d.dy - e - c, b);
  return b;
};
mxCompactTreeLayout.prototype.createNode = function (a) {
  var b = {};
  b.cell = a;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  a = this.getVertexBounds(a);
  null != a &&
    (this.isHorizontal() ? ((b.width = a.height), (b.height = a.width)) : ((b.width = a.width), (b.height = a.height)));
  b.offsetX = 0;
  b.offsetY = 0;
  b.contour = {};
  return b;
};
mxCompactTreeLayout.prototype.apply = function (a, b) {
  var c = this.graph.getModel(),
    d = a.cell,
    e = c.getGeometry(d);
  null != d &&
    null != e &&
    (this.isVertexMovable(d) &&
      ((e = this.setVertexLocation(d, a.x, a.y)),
      this.resizeParent &&
        ((c = c.getParent(d)),
        (d = mxCellPath.create(c)),
        null == this.parentsChanged[d] && (this.parentsChanged[d] = c))),
    (b =
      null == b
        ? new mxRectangle(e.x, e.y, e.width, e.height)
        : new mxRectangle(
            Math.min(b.x, e.x),
            Math.min(b.y, e.y),
            Math.max(b.x + b.width, e.x + e.width),
            Math.max(b.y + b.height, e.y + e.height)
          )));
  return b;
};
mxCompactTreeLayout.prototype.createLine = function (a, b, c) {
  var d = {};
  d.dx = a;
  d.dy = b;
  d.next = c;
  return d;
};
mxCompactTreeLayout.prototype.adjustParents = function () {
  var a = [],
    b;
  for (b in this.parentsChanged) a.push(this.parentsChanged[b]);
  this.arrangeGroups(
    mxUtils.sortCells(a, !0),
    this.groupPadding,
    this.groupPaddingTop,
    this.groupPaddingRight,
    this.groupPaddingBottom,
    this.groupPaddingLeft
  );
};
mxCompactTreeLayout.prototype.localEdgeProcessing = function (a) {
  this.processNodeOutgoing(a);
  for (a = a.child; null != a; ) this.localEdgeProcessing(a), (a = a.next);
};
mxCompactTreeLayout.prototype.processNodeOutgoing = function (a) {
  for (var b = a.child, c = a.cell, d = 0, e = []; null != b; ) {
    d++;
    var f = b.x;
    this.horizontal && (f = b.y);
    e.push(new WeightedCellSorter(b, f));
    b = b.next;
  }
  e.sort(WeightedCellSorter.prototype.compare);
  var f = a.width,
    g = (d + 1) * this.prefHozEdgeSep;
  f > g + 2 * this.prefHozEdgeSep && (f -= 2 * this.prefHozEdgeSep);
  a = f / d;
  b = a / 2;
  f > g + 2 * this.prefHozEdgeSep && (b += this.prefHozEdgeSep);
  for (var f = this.minEdgeJetty - this.prefVertEdgeOff, g = this.getVertexBounds(c), k = 0; k < e.length; k++) {
    for (
      var h = e[k].cell.cell,
        l = this.getVertexBounds(h),
        h = this.graph.getEdgesBetween(c, h, !1),
        m = [],
        n,
        p,
        r = 0;
      r < h.length;
      r++
    )
      this.horizontal
        ? ((n = g.x + g.width),
          (p = g.y + b),
          m.push(new mxPoint(n, p)),
          (n = g.x + g.width + f),
          m.push(new mxPoint(n, p)),
          (p = l.y + l.height / 2))
        : ((n = g.x + b),
          (p = g.y + g.height),
          m.push(new mxPoint(n, p)),
          (p = g.y + g.height + f),
          m.push(new mxPoint(n, p)),
          (n = l.x + l.width / 2)),
        m.push(new mxPoint(n, p)),
        this.setEdgePoints(h[r], m);
    k < d / 2 ? (f += this.prefVertEdgeOff) : k > d / 2 && (f -= this.prefVertEdgeOff);
    b += a;
  }
};
function mxRadialTreeLayout(a) {
  mxCompactTreeLayout.call(this, a, !1);
}
mxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);
mxRadialTreeLayout.prototype.angleOffset = 0.5;
mxRadialTreeLayout.prototype.rootx = 0;
mxRadialTreeLayout.prototype.rooty = 0;
mxRadialTreeLayout.prototype.levelDistance = 120;
mxRadialTreeLayout.prototype.nodeDistance = 10;
mxRadialTreeLayout.prototype.autoRadius = !1;
mxRadialTreeLayout.prototype.sortEdges = !1;
mxRadialTreeLayout.prototype.rowMinX = [];
mxRadialTreeLayout.prototype.rowMaxX = [];
mxRadialTreeLayout.prototype.rowMinCenX = [];
mxRadialTreeLayout.prototype.rowMaxCenX = [];
mxRadialTreeLayout.prototype.rowRadi = [];
mxRadialTreeLayout.prototype.row = [];
mxRadialTreeLayout.prototype.isVertexIgnored = function (a) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(a).length;
};
mxRadialTreeLayout.prototype.execute = function (a, b) {
  this.parent = a;
  this.edgeRouting = this.useBoundingBox = !1;
  mxCompactTreeLayout.prototype.execute.apply(this, arguments);
  var c = null,
    d = this.getVertexBounds(this.root);
  this.centerX = d.x + d.width / 2;
  this.centerY = d.y + d.height / 2;
  for (var e in this.visited) {
    var f = this.getVertexBounds(this.visited[e]),
      c = null != c ? c : f.clone();
    c.add(f);
  }
  this.calcRowDims([this.node], 0);
  for (var g = 0, k = 0, c = 0; c < this.row.length; c++)
    (e = (this.rowMaxX[c] - this.centerX - this.nodeDistance) / this.rowRadi[c]),
      (g = Math.max(g, (this.centerX - this.rowMinX[c] - this.nodeDistance) / this.rowRadi[c])),
      (k = Math.max(k, e));
  for (c = 0; c < this.row.length; c++) {
    var h = this.centerX - this.nodeDistance - g * this.rowRadi[c],
      l = this.centerX + this.nodeDistance + k * this.rowRadi[c] - h;
    for (e = 0; e < this.row[c].length; e++)
      (f = this.row[c]),
        (d = f[e]),
        (f = this.getVertexBounds(d.cell)),
        (d.theta = ((f.x + f.width / 2 - h) / l) * Math.PI * 2);
  }
  for (c = this.row.length - 2; 0 <= c; c--)
    for (f = this.row[c], e = 0; e < f.length; e++) {
      d = f[e];
      g = d.child;
      for (h = k = 0; null != g; ) (h += g.theta), k++, (g = g.next);
      0 < k &&
        ((g = h / k),
        g > d.theta && e < f.length - 1
          ? (d.theta = Math.min(g, f[e + 1].theta - Math.PI / 10))
          : g < d.theta && 0 < e && (d.theta = Math.max(g, f[e - 1].theta + Math.PI / 10)));
    }
  for (c = 0; c < this.row.length; c++)
    for (e = 0; e < this.row[c].length; e++)
      (f = this.row[c]),
        (d = f[e]),
        (f = this.getVertexBounds(d.cell)),
        this.setVertexLocation(
          d.cell,
          this.centerX - f.width / 2 + this.rowRadi[c] * Math.cos(d.theta),
          this.centerY - f.height / 2 + this.rowRadi[c] * Math.sin(d.theta)
        );
};
mxRadialTreeLayout.prototype.calcRowDims = function (a, b) {
  if (null != a && 0 != a.length) {
    this.rowMinX[b] = this.centerX;
    this.rowMaxX[b] = this.centerX;
    this.rowMinCenX[b] = this.centerX;
    this.rowMaxCenX[b] = this.centerX;
    this.row[b] = [];
    for (var c = !1, d = 0; d < a.length; d++)
      for (var e = null != a[d] ? a[d].child : null; null != e; ) {
        var f = this.getVertexBounds(e.cell);
        this.rowMinX[b] = Math.min(f.x, this.rowMinX[b]);
        this.rowMaxX[b] = Math.max(f.x + f.width, this.rowMaxX[b]);
        this.rowMinCenX[b] = Math.min(f.x + f.width / 2, this.rowMinCenX[b]);
        this.rowMaxCenX[b] = Math.max(f.x + f.width / 2, this.rowMaxCenX[b]);
        this.rowRadi[b] = f.y - this.getVertexBounds(this.root).y;
        null != e.child && (c = !0);
        this.row[b].push(e);
        e = e.next;
      }
    c && this.calcRowDims(this.row[b], b + 1);
  }
};
function mxFastOrganicLayout(a) {
  mxGraphLayout.call(this, a);
}
mxFastOrganicLayout.prototype = new mxGraphLayout();
mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;
mxFastOrganicLayout.prototype.useInputOrigin = !0;
mxFastOrganicLayout.prototype.resetEdges = !0;
mxFastOrganicLayout.prototype.disableEdgeStyle = !0;
mxFastOrganicLayout.prototype.forceConstant = 50;
mxFastOrganicLayout.prototype.forceConstantSquared = 0;
mxFastOrganicLayout.prototype.minDistanceLimit = 2;
mxFastOrganicLayout.prototype.maxDistanceLimit = 500;
mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;
mxFastOrganicLayout.prototype.initialTemp = 200;
mxFastOrganicLayout.prototype.temperature = 0;
mxFastOrganicLayout.prototype.maxIterations = 0;
mxFastOrganicLayout.prototype.iteration = 0;
mxFastOrganicLayout.prototype.allowedToRun = !0;
mxFastOrganicLayout.prototype.isVertexIgnored = function (a) {
  return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(a).length;
};
mxFastOrganicLayout.prototype.execute = function (a) {
  var b = this.graph.getModel();
  this.vertexArray = [];
  for (var c = this.graph.getChildVertices(a), d = 0; d < c.length; d++)
    this.isVertexIgnored(c[d]) || this.vertexArray.push(c[d]);
  var e = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null,
    f = this.vertexArray.length;
  this.indices = [];
  this.dispX = [];
  this.dispY = [];
  this.cellLocation = [];
  this.isMoveable = [];
  this.neighbours = [];
  this.radius = [];
  this.radiusSquared = [];
  0.001 > this.forceConstant && (this.forceConstant = 0.001);
  this.forceConstantSquared = this.forceConstant * this.forceConstant;
  for (d = 0; d < this.vertexArray.length; d++) {
    var g = this.vertexArray[d];
    this.cellLocation[d] = [];
    var k = mxObjectIdentity.get(g);
    this.indices[k] = d;
    var h = this.getVertexBounds(g),
      l = h.width,
      m = h.height,
      n = h.x,
      p = h.y;
    this.cellLocation[d][0] = n + l / 2;
    this.cellLocation[d][1] = p + m / 2;
    this.radius[d] = Math.min(l, m);
    this.radiusSquared[d] = this.radius[d] * this.radius[d];
  }
  b.beginUpdate();
  try {
    for (d = 0; d < f; d++) {
      this.dispX[d] = 0;
      this.dispY[d] = 0;
      this.isMoveable[d] = this.isVertexMovable(this.vertexArray[d]);
      var r = this.graph.getConnections(this.vertexArray[d], a),
        c = this.graph.getOpposites(r, this.vertexArray[d]);
      this.neighbours[d] = [];
      for (l = 0; l < c.length; l++) {
        this.resetEdges && this.graph.resetEdge(r[l]);
        this.disableEdgeStyle && this.setEdgeStyleEnabled(r[l], !1);
        var k = mxObjectIdentity.get(c[l]),
          t = this.indices[k];
        this.neighbours[d][l] = null != t ? t : d;
      }
    }
    this.temperature = this.initialTemp;
    0 == this.maxIterations && (this.maxIterations = 20 * Math.sqrt(f));
    for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++) {
      if (!this.allowedToRun) return;
      this.calcRepulsion();
      this.calcAttraction();
      this.calcPositions();
      this.reduceTemperature();
    }
    a = c = null;
    for (d = 0; d < this.vertexArray.length; d++)
      (g = this.vertexArray[d]),
        this.isVertexMovable(g) &&
          ((h = this.getVertexBounds(g)),
          null != h &&
            ((this.cellLocation[d][0] -= h.width / 2),
            (this.cellLocation[d][1] -= h.height / 2),
            (n = this.graph.snap(Math.round(this.cellLocation[d][0]))),
            (p = this.graph.snap(Math.round(this.cellLocation[d][1]))),
            this.setVertexLocation(g, n, p),
            (c = null == c ? n : Math.min(c, n)),
            (a = null == a ? p : Math.min(a, p))));
    d = -(c || 0) + 1;
    g = -(a || 0) + 1;
    null != e && ((d += e.x), (g += e.y));
    this.graph.moveCells(this.vertexArray, d, g);
  } finally {
    b.endUpdate();
  }
};
mxFastOrganicLayout.prototype.calcPositions = function () {
  for (var a = 0; a < this.vertexArray.length; a++)
    if (this.isMoveable[a]) {
      var b = Math.sqrt(this.dispX[a] * this.dispX[a] + this.dispY[a] * this.dispY[a]);
      0.001 > b && (b = 0.001);
      var c = (this.dispX[a] / b) * Math.min(b, this.temperature),
        b = (this.dispY[a] / b) * Math.min(b, this.temperature);
      this.dispX[a] = 0;
      this.dispY[a] = 0;
      this.cellLocation[a][0] += c;
      this.cellLocation[a][1] += b;
    }
};
mxFastOrganicLayout.prototype.calcAttraction = function () {
  for (var a = 0; a < this.vertexArray.length; a++)
    for (var b = 0; b < this.neighbours[a].length; b++) {
      var c = this.neighbours[a][b];
      if (a != c && this.isMoveable[a] && this.isMoveable[c]) {
        var d = this.cellLocation[a][0] - this.cellLocation[c][0],
          e = this.cellLocation[a][1] - this.cellLocation[c][1],
          f = d * d + e * e - this.radiusSquared[a] - this.radiusSquared[c];
        f < this.minDistanceLimitSquared && (f = this.minDistanceLimitSquared);
        var g = Math.sqrt(f),
          f = f / this.forceConstant,
          d = (d / g) * f,
          e = (e / g) * f;
        this.dispX[a] -= d;
        this.dispY[a] -= e;
        this.dispX[c] += d;
        this.dispY[c] += e;
      }
    }
};
mxFastOrganicLayout.prototype.calcRepulsion = function () {
  for (var a = this.vertexArray.length, b = 0; b < a; b++)
    for (var c = b; c < a; c++) {
      if (!this.allowedToRun) return;
      if (c != b && this.isMoveable[b] && this.isMoveable[c]) {
        var d = this.cellLocation[b][0] - this.cellLocation[c][0],
          e = this.cellLocation[b][1] - this.cellLocation[c][1];
        0 == d && (d = 0.01 + Math.random());
        0 == e && (e = 0.01 + Math.random());
        var f = Math.sqrt(d * d + e * e),
          g = f - this.radius[b] - this.radius[c];
        g > this.maxDistanceLimit ||
          (g < this.minDistanceLimit && (g = this.minDistanceLimit),
          (g = this.forceConstantSquared / g),
          (d = (d / f) * g),
          (e = (e / f) * g),
          (this.dispX[b] += d),
          (this.dispY[b] += e),
          (this.dispX[c] -= d),
          (this.dispY[c] -= e));
      }
    }
};
mxFastOrganicLayout.prototype.reduceTemperature = function () {
  this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
};
function mxCircleLayout(a, b) {
  mxGraphLayout.call(this, a);
  this.radius = null != b ? b : 100;
}
mxCircleLayout.prototype = new mxGraphLayout();
mxCircleLayout.prototype.constructor = mxCircleLayout;
mxCircleLayout.prototype.radius = null;
mxCircleLayout.prototype.moveCircle = !1;
mxCircleLayout.prototype.x0 = 0;
mxCircleLayout.prototype.y0 = 0;
mxCircleLayout.prototype.resetEdges = !0;
mxCircleLayout.prototype.disableEdgeStyle = !0;
mxCircleLayout.prototype.execute = function (a) {
  var b = this.graph.getModel();
  b.beginUpdate();
  try {
    for (var c = 0, d = null, e = null, f = [], g = b.getChildCount(a), k = 0; k < g; k++) {
      var h = b.getChildAt(a, k);
      if (this.isVertexIgnored(h))
        this.isEdgeIgnored(h) ||
          (this.resetEdges && this.graph.resetEdge(h), this.disableEdgeStyle && this.setEdgeStyleEnabled(h, !1));
      else {
        f.push(h);
        var l = this.getVertexBounds(h),
          d = null == d ? l.y : Math.min(d, l.y),
          e = null == e ? l.x : Math.min(e, l.x),
          c = Math.max(c, Math.max(l.width, l.height));
      }
    }
    var m = this.getRadius(f.length, c);
    this.moveCircle && ((e = this.x0), (d = this.y0));
    this.circle(f, m, e, d);
  } finally {
    b.endUpdate();
  }
};
mxCircleLayout.prototype.getRadius = function (a, b) {
  return Math.max((a * b) / Math.PI, this.radius);
};
mxCircleLayout.prototype.circle = function (a, b, c, d) {
  for (var e = a.length, f = (2 * Math.PI) / e, g = 0; g < e; g++)
    this.isVertexMovable(a[g]) &&
      this.setVertexLocation(
        a[g],
        Math.round(c + b + b * Math.cos(g * f - Math.PI / 2)),
        Math.round(d + b + b * Math.sin(g * f - Math.PI / 2))
      );
};
function mxParallelEdgeLayout(a) {
  mxGraphLayout.call(this, a);
}
mxParallelEdgeLayout.prototype = new mxGraphLayout();
mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;
mxParallelEdgeLayout.prototype.spacing = 20;
mxParallelEdgeLayout.prototype.checkOverlap = !1;
mxParallelEdgeLayout.prototype.execute = function (a, b) {
  var c = this.findParallels(a, b);
  this.graph.model.beginUpdate();
  try {
    for (var d in c) {
      var e = c[d];
      1 < e.length && this.layout(e);
    }
  } finally {
    this.graph.model.endUpdate();
  }
};
mxParallelEdgeLayout.prototype.findParallels = function (a, b) {
  var c = [],
    d = mxUtils.bind(this, function (a) {
      if (!this.isEdgeIgnored(a)) {
        var b = this.getEdgeId(a);
        null != b && (null == c[b] && (c[b] = []), c[b].push(a));
      }
    });
  if (null != b) for (var e = 0; e < b.length; e++) d(b[e]);
  else for (var f = this.graph.getModel(), g = f.getChildCount(a), e = 0; e < g; e++) d(f.getChildAt(a, e));
  return c;
};
mxParallelEdgeLayout.prototype.getEdgeId = function (a) {
  var b = this.graph.getView(),
    c = b.getVisibleTerminal(a, !0),
    b = b.getVisibleTerminal(a, !1),
    d = '';
  if (null != c && null != b) {
    c = mxObjectIdentity.get(c);
    b = mxObjectIdentity.get(b);
    if (this.checkOverlap && ((a = this.graph.view.getState(a)), null != a && null != a.absolutePoints)) {
      for (var d = [], e = 0; e < a.absolutePoints.length; e++) {
        var f = a.absolutePoints[e];
        null != f && d.push(f.x, f.y);
      }
      d = d.join(',');
    }
    return (c > b ? b + '-' + c : c + '-' + b) + d;
  }
  return null;
};
mxParallelEdgeLayout.prototype.layout = function (a) {
  var b = a[0],
    c = this.graph.getView(),
    d = this.graph.getModel(),
    e = d.getGeometry(c.getVisibleTerminal(b, !0)),
    d = d.getGeometry(c.getVisibleTerminal(b, !1));
  if (e == d)
    for (var b = e.x + e.width + this.spacing, c = e.y + e.height / 2, f = 0; f < a.length; f++)
      this.route(a[f], b, c), (b += this.spacing);
  else if (null != e && null != d) {
    var b = e.x + e.width / 2,
      c = e.y + e.height / 2,
      f = d.x + d.width / 2 - b,
      g = d.y + d.height / 2 - c,
      d = Math.sqrt(f * f + g * g);
    if (0 < d)
      for (
        e = (g * this.spacing) / d,
          d = (f * this.spacing) / d,
          b = b + f / 2 + (e * (a.length - 1)) / 2,
          c = c + g / 2 - (d * (a.length - 1)) / 2,
          f = 0;
        f < a.length;
        f++
      )
        this.route(a[f], b, c), (b -= e), (c += d);
  }
};
mxParallelEdgeLayout.prototype.route = function (a, b, c) {
  this.graph.isCellMovable(a) && this.setEdgePoints(a, [new mxPoint(b, c)]);
};
function mxCompositeLayout(a, b, c) {
  mxGraphLayout.call(this, a);
  this.layouts = b;
  this.master = c;
}
mxCompositeLayout.prototype = new mxGraphLayout();
mxCompositeLayout.prototype.constructor = mxCompositeLayout;
mxCompositeLayout.prototype.layouts = null;
mxCompositeLayout.prototype.master = null;
mxCompositeLayout.prototype.moveCell = function (a, b, c) {
  null != this.master
    ? this.master.moveCell.apply(this.master, arguments)
    : this.layouts[0].moveCell.apply(this.layouts[0], arguments);
};
mxCompositeLayout.prototype.execute = function (a) {
  var b = this.graph.getModel();
  b.beginUpdate();
  try {
    for (var c = 0; c < this.layouts.length; c++) this.layouts[c].execute.apply(this.layouts[c], arguments);
  } finally {
    b.endUpdate();
  }
};
function mxEdgeLabelLayout(a, b) {
  mxGraphLayout.call(this, a);
}
mxEdgeLabelLayout.prototype = new mxGraphLayout();
mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;
mxEdgeLabelLayout.prototype.execute = function (a) {
  for (var b = this.graph.view, c = this.graph.getModel(), d = [], e = [], f = c.getChildCount(a), g = 0; g < f; g++) {
    var k = c.getChildAt(a, g),
      h = b.getState(k);
    null != h && (this.isVertexIgnored(k) ? this.isEdgeIgnored(k) || d.push(h) : e.push(h));
  }
  this.placeLabels(e, d);
};
mxEdgeLabelLayout.prototype.placeLabels = function (a, b) {
  var c = this.graph.getModel();
  c.beginUpdate();
  try {
    for (var d = 0; d < b.length; d++) {
      var e = b[d];
      if (null != e && null != e.text && null != e.text.boundingBox)
        for (var f = 0; f < a.length; f++) {
          var g = a[f];
          null != g && this.avoid(e, g);
        }
    }
  } finally {
    c.endUpdate();
  }
};
mxEdgeLabelLayout.prototype.avoid = function (a, b) {
  var c = this.graph.getModel(),
    d = a.text.boundingBox;
  if (mxUtils.intersects(d, b)) {
    var e = -d.y - d.height + b.y,
      f = -d.y + b.y + b.height,
      e = Math.abs(e) < Math.abs(f) ? e : f,
      f = -d.x - d.width + b.x,
      d = -d.x + b.x + b.width,
      d = Math.abs(f) < Math.abs(d) ? f : d;
    Math.abs(d) < Math.abs(e) ? (e = 0) : (d = 0);
    f = c.getGeometry(a.cell);
    null != f &&
      ((f = f.clone()),
      null != f.offset ? ((f.offset.x += d), (f.offset.y += e)) : (f.offset = new mxPoint(d, e)),
      c.setGeometry(a.cell, f));
  }
};
function mxGraphAbstractHierarchyCell() {
  this.x = [];
  this.y = [];
  this.temp = [];
}
mxGraphAbstractHierarchyCell.prototype.maxRank = -1;
mxGraphAbstractHierarchyCell.prototype.minRank = -1;
mxGraphAbstractHierarchyCell.prototype.x = null;
mxGraphAbstractHierarchyCell.prototype.y = null;
mxGraphAbstractHierarchyCell.prototype.width = 0;
mxGraphAbstractHierarchyCell.prototype.height = 0;
mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;
mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;
mxGraphAbstractHierarchyCell.prototype.temp = null;
mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function (a) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function (a) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.isEdge = function () {
  return !1;
};
mxGraphAbstractHierarchyCell.prototype.isVertex = function () {
  return !1;
};
mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function (a) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function (a, b) {
  return null;
};
mxGraphAbstractHierarchyCell.prototype.setX = function (a, b) {
  this.isVertex() ? (this.x[0] = b) : this.isEdge() && (this.x[a - this.minRank - 1] = b);
};
mxGraphAbstractHierarchyCell.prototype.getX = function (a) {
  return this.isVertex() ? this.x[0] : this.isEdge() ? this.x[a - this.minRank - 1] : 0;
};
mxGraphAbstractHierarchyCell.prototype.setY = function (a, b) {
  this.isVertex() ? (this.y[0] = b) : this.isEdge() && (this.y[a - this.minRank - 1] = b);
};
function mxGraphHierarchyNode(a) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  this.cell = a;
  this.id = mxObjectIdentity.get(a);
  this.connectsAsTarget = [];
  this.connectsAsSource = [];
}
mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell();
mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;
mxGraphHierarchyNode.prototype.cell = null;
mxGraphHierarchyNode.prototype.id = null;
mxGraphHierarchyNode.prototype.connectsAsTarget = null;
mxGraphHierarchyNode.prototype.connectsAsSource = null;
mxGraphHierarchyNode.prototype.hashCode = !1;
mxGraphHierarchyNode.prototype.getRankValue = function (a) {
  return this.maxRank;
};
mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function (a) {
  if (null == this.nextLayerConnectedCells) {
    this.nextLayerConnectedCells = [];
    this.nextLayerConnectedCells[0] = [];
    for (var b = 0; b < this.connectsAsTarget.length; b++) {
      var c = this.connectsAsTarget[b];
      -1 == c.maxRank || c.maxRank == a + 1
        ? this.nextLayerConnectedCells[0].push(c.source)
        : this.nextLayerConnectedCells[0].push(c);
    }
  }
  return this.nextLayerConnectedCells[0];
};
mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function (a) {
  if (null == this.previousLayerConnectedCells) {
    this.previousLayerConnectedCells = [];
    this.previousLayerConnectedCells[0] = [];
    for (var b = 0; b < this.connectsAsSource.length; b++) {
      var c = this.connectsAsSource[b];
      -1 == c.minRank || c.minRank == a - 1
        ? this.previousLayerConnectedCells[0].push(c.target)
        : this.previousLayerConnectedCells[0].push(c);
    }
  }
  return this.previousLayerConnectedCells[0];
};
mxGraphHierarchyNode.prototype.isVertex = function () {
  return !0;
};
mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function (a) {
  return this.temp[0];
};
mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function (a, b) {
  this.temp[0] = b;
};
mxGraphHierarchyNode.prototype.isAncestor = function (a) {
  if (null != a && null != this.hashCode && null != a.hashCode && this.hashCode.length < a.hashCode.length) {
    if (this.hashCode == a.hashCode) return !0;
    if (null == this.hashCode || null == this.hashCode) return !1;
    for (var b = 0; b < this.hashCode.length; b++) if (this.hashCode[b] != a.hashCode[b]) return !1;
    return !0;
  }
  return !1;
};
mxGraphHierarchyNode.prototype.getCoreCell = function () {
  return this.cell;
};
function mxGraphHierarchyEdge(a) {
  mxGraphAbstractHierarchyCell.apply(this, arguments);
  this.edges = a;
  this.ids = [];
  for (var b = 0; b < a.length; b++) this.ids.push(mxObjectIdentity.get(a[b]));
}
mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell();
mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;
mxGraphHierarchyEdge.prototype.edges = null;
mxGraphHierarchyEdge.prototype.ids = null;
mxGraphHierarchyEdge.prototype.source = null;
mxGraphHierarchyEdge.prototype.target = null;
mxGraphHierarchyEdge.prototype.isReversed = !1;
mxGraphHierarchyEdge.prototype.invert = function (a) {
  a = this.source;
  this.source = this.target;
  this.target = a;
  this.isReversed = !this.isReversed;
};
mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function (a) {
  if (null == this.nextLayerConnectedCells) {
    this.nextLayerConnectedCells = [];
    for (var b = 0; b < this.temp.length; b++)
      (this.nextLayerConnectedCells[b] = []),
        b == this.temp.length - 1
          ? this.nextLayerConnectedCells[b].push(this.source)
          : this.nextLayerConnectedCells[b].push(this);
  }
  return this.nextLayerConnectedCells[a - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function (a) {
  if (null == this.previousLayerConnectedCells) {
    this.previousLayerConnectedCells = [];
    for (var b = 0; b < this.temp.length; b++)
      (this.previousLayerConnectedCells[b] = []),
        0 == b ? this.previousLayerConnectedCells[b].push(this.target) : this.previousLayerConnectedCells[b].push(this);
  }
  return this.previousLayerConnectedCells[a - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.isEdge = function () {
  return !0;
};
mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function (a) {
  return this.temp[a - this.minRank - 1];
};
mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function (a, b) {
  this.temp[a - this.minRank - 1] = b;
};
mxGraphHierarchyEdge.prototype.getCoreCell = function () {
  return null != this.edges && 0 < this.edges.length ? this.edges[0] : null;
};
function mxGraphHierarchyModel(a, b, c, d, e) {
  a.getGraph();
  this.tightenToSource = e;
  this.roots = c;
  this.parent = d;
  this.vertexMapper = new mxDictionary();
  this.edgeMapper = new mxDictionary();
  this.maxRank = 0;
  c = [];
  null == b && (b = this.graph.getChildVertices(d));
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(a, b, c);
  for (d = 0; d < b.length; d++) {
    e = c[d].connectsAsSource;
    for (var f = 0; f < e.length; f++) {
      var g = e[f],
        k = g.edges;
      if (null != k && 0 < k.length) {
        var k = k[0],
          h = a.getVisibleTerminal(k, !1),
          h = this.vertexMapper.get(h);
        c[d] == h && ((h = a.getVisibleTerminal(k, !0)), (h = this.vertexMapper.get(h)));
        null != h &&
          c[d] != h &&
          ((g.target = h),
          0 == h.connectsAsTarget.length && (h.connectsAsTarget = []),
          0 > mxUtils.indexOf(h.connectsAsTarget, g) && h.connectsAsTarget.push(g));
      }
    }
    c[d].temp[0] = 1;
  }
}
mxGraphHierarchyModel.prototype.maxRank = null;
mxGraphHierarchyModel.prototype.vertexMapper = null;
mxGraphHierarchyModel.prototype.edgeMapper = null;
mxGraphHierarchyModel.prototype.ranks = null;
mxGraphHierarchyModel.prototype.roots = null;
mxGraphHierarchyModel.prototype.parent = null;
mxGraphHierarchyModel.prototype.dfsCount = 0;
mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1e8;
mxGraphHierarchyModel.prototype.tightenToSource = !1;
mxGraphHierarchyModel.prototype.createInternalCells = function (a, b, c) {
  for (var d = a.getGraph(), e = 0; e < b.length; e++) {
    c[e] = new mxGraphHierarchyNode(b[e]);
    this.vertexMapper.put(b[e], c[e]);
    var f = a.getEdges(b[e]);
    c[e].connectsAsSource = [];
    for (var g = 0; g < f.length; g++) {
      var k = a.getVisibleTerminal(f[g], !1);
      if (k != b[e] && a.graph.model.isVertex(k) && !a.isVertexIgnored(k)) {
        var h = a.getEdgesBetween(b[e], k, !1),
          k = a.getEdgesBetween(b[e], k, !0);
        if (null != h && 0 < h.length && null == this.edgeMapper.get(h[0]) && 2 * k.length >= h.length) {
          for (var k = new mxGraphHierarchyEdge(h), l = 0; l < h.length; l++) {
            var m = h[l];
            this.edgeMapper.put(m, k);
            d.resetEdge(m);
            a.disableEdgeStyle && (a.setEdgeStyleEnabled(m, !1), a.setOrthogonalEdge(m, !0));
          }
          k.source = c[e];
          0 > mxUtils.indexOf(c[e].connectsAsSource, k) && c[e].connectsAsSource.push(k);
        }
      }
    }
    c[e].temp[0] = 0;
  }
};
mxGraphHierarchyModel.prototype.initialRank = function () {
  var a = [];
  if (null != this.roots)
    for (var b = 0; b < this.roots.length; b++) {
      var c = this.vertexMapper.get(this.roots[b]);
      null != c && a.push(c);
    }
  for (var d = this.vertexMapper.getValues(), b = 0; b < d.length; b++) d[b].temp[0] = -1;
  for (var e = a.slice(); 0 < a.length; ) {
    var c = a[0],
      f,
      g;
    f = c.connectsAsTarget;
    g = c.connectsAsSource;
    for (var k = !0, h = this.SOURCESCANSTARTRANK, b = 0; b < f.length; b++) {
      var l = f[b];
      if (5270620 == l.temp[0]) (l = l.source), (h = Math.min(h, l.temp[0] - 1));
      else {
        k = !1;
        break;
      }
    }
    if (k) {
      c.temp[0] = h;
      this.maxRank = Math.min(this.maxRank, h);
      if (null != g)
        for (b = 0; b < g.length; b++)
          (l = g[b]), (l.temp[0] = 5270620), (l = l.target), -1 == l.temp[0] && (a.push(l), (l.temp[0] = -2));
      a.shift();
    } else if (((b = a.shift()), a.push(c), b == c && 1 == a.length)) break;
  }
  for (b = 0; b < d.length; b++) d[b].temp[0] -= this.maxRank;
  for (b = 0; b < e.length; b++)
    for (c = e[b], a = 0, f = c.connectsAsSource, d = 0; d < f.length; d++)
      (l = f[d]), (l = l.target), (c.temp[0] = Math.max(a, l.temp[0] + 1)), (a = c.temp[0]);
  this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
};
mxGraphHierarchyModel.prototype.fixRanks = function () {
  var a = [];
  this.ranks = [];
  for (var b = 0; b < this.maxRank + 1; b++) (a[b] = []), (this.ranks[b] = a[b]);
  var c = null;
  if (null != this.roots)
    for (var d = this.roots, c = [], b = 0; b < d.length; b++) {
      var e = this.vertexMapper.get(d[b]);
      c[b] = e;
    }
  this.visit(
    function (b, c, d, e, l) {
      0 == l &&
        0 > c.maxRank &&
        0 > c.minRank &&
        (a[c.temp[0]].push(c), (c.maxRank = c.temp[0]), (c.minRank = c.temp[0]), (c.temp[0] = a[c.maxRank].length - 1));
      if (null != b && null != d && 1 < b.maxRank - c.maxRank)
        for (
          d.maxRank = b.maxRank, d.minRank = c.maxRank, d.temp = [], d.x = [], d.y = [], b = d.minRank + 1;
          b < d.maxRank;
          b++
        )
          a[b].push(d), d.setGeneralPurposeVariable(b, a[b].length - 1);
    },
    c,
    !1,
    null
  );
};
mxGraphHierarchyModel.prototype.visit = function (a, b, c, d) {
  if (null != b) {
    for (var e = 0; e < b.length; e++) {
      var f = b[e];
      null != f &&
        (null == d && (d = {}),
        c
          ? ((f.hashCode = []),
            (f.hashCode[0] = this.dfsCount),
            (f.hashCode[1] = e),
            this.extendedDfs(null, f, null, a, d, f.hashCode, e, 0))
          : this.dfs(null, f, null, a, d, 0));
    }
    this.dfsCount++;
  }
};
mxGraphHierarchyModel.prototype.dfs = function (a, b, c, d, e, f) {
  if (null != b) {
    var g = b.id;
    if (null == e[g])
      for (e[g] = b, d(a, b, c, f, 0), a = b.connectsAsSource.slice(), c = 0; c < a.length; c++)
        (g = a[c]), this.dfs(b, g.target, g, d, e, f + 1);
    else d(a, b, c, f, 1);
  }
};
mxGraphHierarchyModel.prototype.extendedDfs = function (a, b, c, d, e, f, g, k) {
  if (null != b)
    if (
      (null == a ||
        (null != b.hashCode && b.hashCode[0] == a.hashCode[0]) ||
        ((f = a.hashCode.length + 1), (b.hashCode = a.hashCode.slice()), (b.hashCode[f - 1] = g)),
      (g = b.id),
      null == e[g])
    )
      for (e[g] = b, d(a, b, c, k, 0), a = b.connectsAsSource.slice(), c = 0; c < a.length; c++)
        (g = a[c]), this.extendedDfs(b, g.target, g, d, e, b.hashCode, c, k + 1);
    else d(a, b, c, k, 1);
};
function mxSwimlaneModel(a, b, c, d, e) {
  a.getGraph();
  this.tightenToSource = e;
  this.roots = c;
  this.parent = d;
  this.vertexMapper = new mxDictionary();
  this.edgeMapper = new mxDictionary();
  this.maxRank = 0;
  c = [];
  null == b && (b = this.graph.getChildVertices(d));
  this.maxRank = this.SOURCESCANSTARTRANK;
  this.createInternalCells(a, b, c);
  for (d = 0; d < b.length; d++) {
    e = c[d].connectsAsSource;
    for (var f = 0; f < e.length; f++) {
      var g = e[f],
        k = g.edges;
      if (null != k && 0 < k.length) {
        var k = k[0],
          h = a.getVisibleTerminal(k, !1),
          h = this.vertexMapper.get(h);
        c[d] == h && ((h = a.getVisibleTerminal(k, !0)), (h = this.vertexMapper.get(h)));
        null != h &&
          c[d] != h &&
          ((g.target = h),
          0 == h.connectsAsTarget.length && (h.connectsAsTarget = []),
          0 > mxUtils.indexOf(h.connectsAsTarget, g) && h.connectsAsTarget.push(g));
      }
    }
    c[d].temp[0] = 1;
  }
}
mxSwimlaneModel.prototype.maxRank = null;
mxSwimlaneModel.prototype.vertexMapper = null;
mxSwimlaneModel.prototype.edgeMapper = null;
mxSwimlaneModel.prototype.ranks = null;
mxSwimlaneModel.prototype.roots = null;
mxSwimlaneModel.prototype.parent = null;
mxSwimlaneModel.prototype.dfsCount = 0;
mxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 1e8;
mxSwimlaneModel.prototype.tightenToSource = !1;
mxSwimlaneModel.prototype.ranksPerGroup = null;
mxSwimlaneModel.prototype.createInternalCells = function (a, b, c) {
  for (var d = a.getGraph(), e = a.swimlanes, f = 0; f < b.length; f++) {
    c[f] = new mxGraphHierarchyNode(b[f]);
    this.vertexMapper.put(b[f], c[f]);
    c[f].swimlaneIndex = -1;
    for (var g = 0; g < e.length; g++)
      if (d.model.getParent(b[f]) == e[g]) {
        c[f].swimlaneIndex = g;
        break;
      }
    g = a.getEdges(b[f]);
    c[f].connectsAsSource = [];
    for (var k = 0; k < g.length; k++) {
      var h = a.getVisibleTerminal(g[k], !1);
      if (h != b[f] && a.graph.model.isVertex(h) && !a.isVertexIgnored(h)) {
        var l = a.getEdgesBetween(b[f], h, !1),
          h = a.getEdgesBetween(b[f], h, !0);
        if (null != l && 0 < l.length && null == this.edgeMapper.get(l[0]) && 2 * h.length >= l.length) {
          for (var h = new mxGraphHierarchyEdge(l), m = 0; m < l.length; m++) {
            var n = l[m];
            this.edgeMapper.put(n, h);
            d.resetEdge(n);
            a.disableEdgeStyle && (a.setEdgeStyleEnabled(n, !1), a.setOrthogonalEdge(n, !0));
          }
          h.source = c[f];
          0 > mxUtils.indexOf(c[f].connectsAsSource, h) && c[f].connectsAsSource.push(h);
        }
      }
    }
    c[f].temp[0] = 0;
  }
};
mxSwimlaneModel.prototype.initialRank = function () {
  this.ranksPerGroup = [];
  var a = [],
    b = {};
  if (null != this.roots)
    for (var c = 0; c < this.roots.length; c++) {
      var d = this.vertexMapper.get(this.roots[c]);
      this.maxChainDfs(null, d, null, b, 0);
      null != d && a.push(d);
    }
  d = [];
  b = [];
  for (c = this.ranksPerGroup.length - 1; 0 <= c; c--)
    (d[c] = c == this.ranksPerGroup.length - 1 ? 0 : b[c + 1] + 1), (b[c] = d[c] + this.ranksPerGroup[c]);
  this.maxRank = b[0];
  d = this.vertexMapper.getValues();
  for (c = 0; c < d.length; c++) d[c].temp[0] = -1;
  for (a.slice(); 0 < a.length; ) {
    var d = a[0],
      e,
      f;
    e = d.connectsAsTarget;
    f = d.connectsAsSource;
    for (var g = !0, k = b[0], c = 0; c < e.length; c++) {
      var h = e[c];
      if (5270620 == h.temp[0]) (h = h.source), (k = Math.min(k, h.temp[0] - 1));
      else {
        g = !1;
        break;
      }
    }
    if (g) {
      k > b[d.swimlaneIndex] && (k = b[d.swimlaneIndex]);
      d.temp[0] = k;
      if (null != f)
        for (c = 0; c < f.length; c++)
          (h = f[c]), (h.temp[0] = 5270620), (h = h.target), -1 == h.temp[0] && (a.push(h), (h.temp[0] = -2));
      a.shift();
    } else if (((c = a.shift()), a.push(d), c == d && 1 == a.length)) break;
  }
};
mxSwimlaneModel.prototype.maxChainDfs = function (a, b, c, d, e) {
  if (null != b && ((a = mxCellPath.create(b.cell)), null == d[a])) {
    d[a] = b;
    a = b.swimlaneIndex;
    if (null == this.ranksPerGroup[a] || this.ranksPerGroup[a] < e) this.ranksPerGroup[a] = e;
    a = b.connectsAsSource.slice();
    for (c = 0; c < a.length; c++) {
      var f = a[c],
        g = f.target;
      b.swimlaneIndex < g.swimlaneIndex
        ? this.maxChainDfs(b, g, f, mxUtils.clone(d, null, !0), 0)
        : b.swimlaneIndex == g.swimlaneIndex && this.maxChainDfs(b, g, f, mxUtils.clone(d, null, !0), e + 1);
    }
  }
};
mxSwimlaneModel.prototype.fixRanks = function () {
  var a = [];
  this.ranks = [];
  for (var b = 0; b < this.maxRank + 1; b++) (a[b] = []), (this.ranks[b] = a[b]);
  var c = null;
  if (null != this.roots)
    for (var d = this.roots, c = [], b = 0; b < d.length; b++) {
      var e = this.vertexMapper.get(d[b]);
      c[b] = e;
    }
  this.visit(
    function (b, c, d, e, l) {
      0 == l &&
        0 > c.maxRank &&
        0 > c.minRank &&
        (a[c.temp[0]].push(c), (c.maxRank = c.temp[0]), (c.minRank = c.temp[0]), (c.temp[0] = a[c.maxRank].length - 1));
      if (null != b && null != d && 1 < b.maxRank - c.maxRank)
        for (
          d.maxRank = b.maxRank, d.minRank = c.maxRank, d.temp = [], d.x = [], d.y = [], b = d.minRank + 1;
          b < d.maxRank;
          b++
        )
          a[b].push(d), d.setGeneralPurposeVariable(b, a[b].length - 1);
    },
    c,
    !1,
    null
  );
};
mxSwimlaneModel.prototype.visit = function (a, b, c, d) {
  if (null != b) {
    for (var e = 0; e < b.length; e++) {
      var f = b[e];
      null != f &&
        (null == d && (d = {}),
        c
          ? ((f.hashCode = []),
            (f.hashCode[0] = this.dfsCount),
            (f.hashCode[1] = e),
            this.extendedDfs(null, f, null, a, d, f.hashCode, e, 0))
          : this.dfs(null, f, null, a, d, 0));
    }
    this.dfsCount++;
  }
};
mxSwimlaneModel.prototype.dfs = function (a, b, c, d, e, f) {
  if (null != b) {
    var g = b.id;
    if (null == e[g])
      for (e[g] = b, d(a, b, c, f, 0), a = b.connectsAsSource.slice(), c = 0; c < a.length; c++)
        (g = a[c]), this.dfs(b, g.target, g, d, e, f + 1);
    else d(a, b, c, f, 1);
  }
};
mxSwimlaneModel.prototype.extendedDfs = function (a, b, c, d, e, f, g, k) {
  if (null != b)
    if (
      (null == a ||
        (null != b.hashCode && b.hashCode[0] == a.hashCode[0]) ||
        ((f = a.hashCode.length + 1), (b.hashCode = a.hashCode.slice()), (b.hashCode[f - 1] = g)),
      (g = b.id),
      null == e[g])
    ) {
      e[g] = b;
      d(a, b, c, k, 0);
      a = b.connectsAsSource.slice();
      c = b.connectsAsTarget.slice();
      for (g = 0; g < a.length; g++) {
        f = a[g];
        var h = f.target;
        b.swimlaneIndex <= h.swimlaneIndex && this.extendedDfs(b, h, f, d, e, b.hashCode, g, k + 1);
      }
      for (g = 0; g < c.length; g++)
        (f = c[g]),
          (h = f.source),
          b.swimlaneIndex < h.swimlaneIndex && this.extendedDfs(b, h, f, d, e, b.hashCode, g, k + 1);
    } else d(a, b, c, k, 1);
};
function mxHierarchicalLayoutStage() {}
mxHierarchicalLayoutStage.prototype.execute = function (a) {};
function mxMedianHybridCrossingReduction(a) {
  this.layout = a;
}
mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage();
mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;
mxMedianHybridCrossingReduction.prototype.layout = null;
mxMedianHybridCrossingReduction.prototype.maxIterations = 24;
mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;
mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;
mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;
mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;
mxMedianHybridCrossingReduction.prototype.execute = function (a) {
  a = this.layout.getModel();
  this.nestedBestRanks = [];
  for (var b = 0; b < a.ranks.length; b++) this.nestedBestRanks[b] = a.ranks[b].slice();
  for (
    var c = 0, d = this.calculateCrossings(a), b = 0;
    b < this.maxIterations && c < this.maxNoImprovementIterations;
    b++
  ) {
    this.weightedMedian(b, a);
    this.transpose(b, a);
    var e = this.calculateCrossings(a);
    if (e < d)
      for (d = e, e = c = 0; e < this.nestedBestRanks.length; e++)
        for (var f = a.ranks[e], g = 0; g < f.length; g++) {
          var k = f[g];
          this.nestedBestRanks[e][k.getGeneralPurposeVariable(e)] = k;
        }
    else
      for (c++, e = 0; e < this.nestedBestRanks.length; e++)
        for (f = a.ranks[e], g = 0; g < f.length; g++) (k = f[g]), k.setGeneralPurposeVariable(e, g);
    if (0 == d) break;
  }
  c = [];
  d = [];
  for (b = 0; b < a.maxRank + 1; b++) (d[b] = []), (c[b] = d[b]);
  for (b = 0; b < this.nestedBestRanks.length; b++)
    for (e = 0; e < this.nestedBestRanks[b].length; e++) d[b].push(this.nestedBestRanks[b][e]);
  a.ranks = c;
};
mxMedianHybridCrossingReduction.prototype.calculateCrossings = function (a) {
  for (var b = a.ranks.length, c = 0, d = 1; d < b; d++) c += this.calculateRankCrossing(d, a);
  return c;
};
mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function (a, b) {
  for (var c = 0, d = b.ranks[a], e = b.ranks[a - 1], f = [], g = 0; g < d.length; g++) {
    for (
      var k = d[g], h = k.getGeneralPurposeVariable(a), k = k.getPreviousLayerConnectedCells(a), l = [], m = 0;
      m < k.length;
      m++
    ) {
      var n = k[m].getGeneralPurposeVariable(a - 1);
      l.push(n);
    }
    l.sort(function (a, b) {
      return a - b;
    });
    f[h] = l;
  }
  d = [];
  for (g = 0; g < f.length; g++) d = d.concat(f[g]);
  for (f = 1; f < e.length; ) f <<= 1;
  h = 2 * f - 1;
  --f;
  e = [];
  for (g = 0; g < h; ++g) e[g] = 0;
  for (g = 0; g < d.length; g++)
    for (h = d[g] + f, ++e[h]; 0 < h; ) h % 2 && (c += e[h + 1]), (h = (h - 1) >> 1), ++e[h];
  return c;
};
mxMedianHybridCrossingReduction.prototype.transpose = function (a, b) {
  for (var c = !0, d = 0; c && 10 > d++; )
    for (var e = 1 == a % 2 && 1 == d % 2, c = !1, f = 0; f < b.ranks.length; f++) {
      for (var g = b.ranks[f], k = [], h = 0; h < g.length; h++) {
        var l = g[h],
          m = l.getGeneralPurposeVariable(f);
        0 > m && (m = h);
        k[m] = l;
      }
      for (var n = null, p = null, r, t, u = null, x = null, z, D = null, h = 0; h < g.length - 1; h++) {
        if (0 == h) {
          z = k[h];
          l = z.getNextLayerConnectedCells(f);
          m = z.getPreviousLayerConnectedCells(f);
          r = [];
          t = [];
          for (var B = 0; B < l.length; B++) r[B] = l[B].getGeneralPurposeVariable(f + 1);
          for (B = 0; B < m.length; B++) t[B] = m[B].getGeneralPurposeVariable(f - 1);
        } else (l = n), (m = p), (r = u), (t = x), (z = D);
        D = k[h + 1];
        n = D.getNextLayerConnectedCells(f);
        p = D.getPreviousLayerConnectedCells(f);
        u = [];
        x = [];
        for (B = 0; B < n.length; B++) u[B] = n[B].getGeneralPurposeVariable(f + 1);
        for (B = 0; B < p.length; B++) x[B] = p[B].getGeneralPurposeVariable(f - 1);
        for (var C = 0, J = 0, B = 0; B < r.length; B++)
          for (var v = 0; v < u.length; v++) r[B] > u[v] && C++, r[B] < u[v] && J++;
        for (B = 0; B < t.length; B++) for (v = 0; v < x.length; v++) t[B] > x[v] && C++, t[B] < x[v] && J++;
        if (J < C || (J == C && e))
          (n = z.getGeneralPurposeVariable(f)),
            z.setGeneralPurposeVariable(f, D.getGeneralPurposeVariable(f)),
            D.setGeneralPurposeVariable(f, n),
            (n = l),
            (p = m),
            (u = r),
            (x = t),
            (D = z),
            e || (c = !0);
      }
    }
};
mxMedianHybridCrossingReduction.prototype.weightedMedian = function (a, b) {
  var c = 0 == a % 2;
  if (c) for (var d = b.maxRank - 1; 0 <= d; d--) this.medianRank(d, c);
  else for (d = 1; d < b.maxRank; d++) this.medianRank(d, c);
};
mxMedianHybridCrossingReduction.prototype.medianRank = function (a, b) {
  for (var c = this.nestedBestRanks[a].length, d = [], e = [], f = 0; f < c; f++) {
    var g = this.nestedBestRanks[a][f],
      k = new MedianCellSorter();
    k.cell = g;
    var h;
    h = b ? g.getNextLayerConnectedCells(a) : g.getPreviousLayerConnectedCells(a);
    var l;
    l = b ? a + 1 : a - 1;
    null != h && 0 != h.length
      ? ((k.medianValue = this.medianValue(h, l)), d.push(k))
      : (e[g.getGeneralPurposeVariable(a)] = !0);
  }
  d.sort(MedianCellSorter.prototype.compare);
  for (f = 0; f < c; f++) null == e[f] && ((g = d.shift().cell), g.setGeneralPurposeVariable(a, f));
};
mxMedianHybridCrossingReduction.prototype.medianValue = function (a, b) {
  for (var c = [], d = 0, e = 0; e < a.length; e++) {
    var f = a[e];
    c[d++] = f.getGeneralPurposeVariable(b);
  }
  c.sort(function (a, b) {
    return a - b;
  });
  if (1 == d % 2) return c[Math.floor(d / 2)];
  if (2 == d) return (c[0] + c[1]) / 2;
  e = d / 2;
  f = c[e - 1] - c[0];
  d = c[d - 1] - c[e];
  return (c[e - 1] * d + c[e] * f) / (f + d);
};
function MedianCellSorter() {}
MedianCellSorter.prototype.medianValue = 0;
MedianCellSorter.prototype.cell = !1;
MedianCellSorter.prototype.compare = function (a, b) {
  return null != a && null != b ? (b.medianValue > a.medianValue ? -1 : b.medianValue < a.medianValue ? 1 : 0) : 0;
};
function mxMinimumCycleRemover(a) {
  this.layout = a;
}
mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage();
mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;
mxMinimumCycleRemover.prototype.layout = null;
mxMinimumCycleRemover.prototype.execute = function (a) {
  a = this.layout.getModel();
  for (var b = {}, c = a.vertexMapper.getValues(), d = {}, e = 0; e < c.length; e++) d[c[e].id] = c[e];
  c = null;
  if (null != a.roots) for (var f = a.roots, c = [], e = 0; e < f.length; e++) c[e] = a.vertexMapper.get(f[e]);
  a.visit(
    function (a, c, e, f, m) {
      c.isAncestor(a) &&
        (e.invert(),
        mxUtils.remove(e, a.connectsAsSource),
        a.connectsAsTarget.push(e),
        mxUtils.remove(e, c.connectsAsTarget),
        c.connectsAsSource.push(e));
      b[c.id] = c;
      delete d[c.id];
    },
    c,
    !0,
    null
  );
  e = mxUtils.clone(b, null, !0);
  a.visit(
    function (a, c, e, f, m) {
      c.isAncestor(a) &&
        (e.invert(),
        mxUtils.remove(e, a.connectsAsSource),
        c.connectsAsSource.push(e),
        a.connectsAsTarget.push(e),
        mxUtils.remove(e, c.connectsAsTarget));
      b[c.id] = c;
      delete d[c.id];
    },
    d,
    !0,
    e
  );
};
function mxCoordinateAssignment(a, b, c, d, e, f) {
  this.layout = a;
  this.intraCellSpacing = b;
  this.interRankCellSpacing = c;
  this.orientation = d;
  this.initialX = e;
  this.parallelEdgeSpacing = f;
}
mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage();
mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;
mxCoordinateAssignment.prototype.layout = null;
mxCoordinateAssignment.prototype.intraCellSpacing = 30;
mxCoordinateAssignment.prototype.interRankCellSpacing = 100;
mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;
mxCoordinateAssignment.prototype.maxIterations = 8;
mxCoordinateAssignment.prototype.prefHozEdgeSep = 5;
mxCoordinateAssignment.prototype.prefVertEdgeOff = 2;
mxCoordinateAssignment.prototype.minEdgeJetty = 12;
mxCoordinateAssignment.prototype.channelBuffer = 4;
mxCoordinateAssignment.prototype.jettyPositions = null;
mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxCoordinateAssignment.prototype.initialX = null;
mxCoordinateAssignment.prototype.limitX = null;
mxCoordinateAssignment.prototype.currentXDelta = null;
mxCoordinateAssignment.prototype.widestRank = null;
mxCoordinateAssignment.prototype.rankTopY = null;
mxCoordinateAssignment.prototype.rankBottomY = null;
mxCoordinateAssignment.prototype.widestRankValue = null;
mxCoordinateAssignment.prototype.rankWidths = null;
mxCoordinateAssignment.prototype.rankY = null;
mxCoordinateAssignment.prototype.fineTuning = !0;
mxCoordinateAssignment.prototype.nextLayerConnectedCache = null;
mxCoordinateAssignment.prototype.previousLayerConnectedCache = null;
mxCoordinateAssignment.prototype.groupPadding = 10;
mxCoordinateAssignment.prototype.printStatus = function () {
  var a = this.layout.getModel();
  mxLog.show();
  mxLog.writeln('======Coord assignment debug=======');
  for (var b = 0; b < a.ranks.length; b++) {
    mxLog.write('Rank ', b, ' : ');
    for (var c = a.ranks[b], d = 0; d < c.length; d++) mxLog.write(c[d].getGeneralPurposeVariable(b), '  ');
    mxLog.writeln();
  }
  mxLog.writeln('====================================');
};
mxCoordinateAssignment.prototype.execute = function (a) {
  this.jettyPositions = {};
  a = this.layout.getModel();
  this.currentXDelta = 0;
  this.initialCoords(this.layout.getGraph(), a);
  this.fineTuning && this.minNode(a);
  var b = 1e8;
  if (this.fineTuning)
    for (var c = 0; c < this.maxIterations; c++) {
      0 != c && (this.medianPos(c, a), this.minNode(a));
      if (this.currentXDelta < b) {
        for (var d = 0; d < a.ranks.length; d++)
          for (var e = a.ranks[d], f = 0; f < e.length; f++) {
            var g = e[f];
            g.setX(d, g.getGeneralPurposeVariable(d));
          }
        b = this.currentXDelta;
      } else
        for (d = 0; d < a.ranks.length; d++)
          for (e = a.ranks[d], f = 0; f < e.length; f++) (g = e[f]), g.setGeneralPurposeVariable(d, g.getX(d));
      this.minPath(this.layout.getGraph(), a);
      this.currentXDelta = 0;
    }
  this.setCellLocations(this.layout.getGraph(), a);
};
mxCoordinateAssignment.prototype.minNode = function (a) {
  for (var b = [], c = new mxDictionary(), d = [], e = 0; e <= a.maxRank; e++) {
    d[e] = a.ranks[e];
    for (var f = 0; f < d[e].length; f++) {
      var g = d[e][f],
        k = new WeightedCellSorter(g, e);
      k.rankIndex = f;
      k.visited = !0;
      b.push(k);
      c.put(g, k);
    }
  }
  a = 10 * b.length;
  for (f = 0; 0 < b.length && f <= a; ) {
    var g = b.shift(),
      e = g.cell,
      h = g.weightedValue,
      l = parseInt(g.rankIndex),
      k = e.getNextLayerConnectedCells(h),
      m = e.getPreviousLayerConnectedCells(h),
      n = k.length,
      p = m.length,
      r = this.medianXValue(k, h + 1),
      t = this.medianXValue(m, h - 1),
      u = n + p,
      x = e.getGeneralPurposeVariable(h),
      z = x;
    0 < u && (z = (r * n + t * p) / u);
    n = !1;
    z < x - 1
      ? 0 == l
        ? (e.setGeneralPurposeVariable(h, z), (n = !0))
        : ((l = d[h][l - 1]),
          (x = l.getGeneralPurposeVariable(h)),
          (x = x + l.width / 2 + this.intraCellSpacing + e.width / 2),
          x < z
            ? (e.setGeneralPurposeVariable(h, z), (n = !0))
            : x < e.getGeneralPurposeVariable(h) - 1 && (e.setGeneralPurposeVariable(h, x), (n = !0)))
      : z > x + 1 &&
        (l == d[h].length - 1
          ? (e.setGeneralPurposeVariable(h, z), (n = !0))
          : ((l = d[h][l + 1]),
            (x = l.getGeneralPurposeVariable(h)),
            (x = x - l.width / 2 - this.intraCellSpacing - e.width / 2),
            x > z
              ? (e.setGeneralPurposeVariable(h, z), (n = !0))
              : x > e.getGeneralPurposeVariable(h) + 1 && (e.setGeneralPurposeVariable(h, x), (n = !0))));
    if (n) {
      for (e = 0; e < k.length; e++)
        (h = k[e]), (h = c.get(h)), null != h && 0 == h.visited && ((h.visited = !0), b.push(h));
      for (e = 0; e < m.length; e++)
        (h = m[e]), (h = c.get(h)), null != h && 0 == h.visited && ((h.visited = !0), b.push(h));
    }
    g.visited = !1;
    f++;
  }
};
mxCoordinateAssignment.prototype.medianPos = function (a, b) {
  if (0 == a % 2) for (var c = b.maxRank; 0 < c; c--) this.rankMedianPosition(c - 1, b, c);
  else for (c = 0; c < b.maxRank - 1; c++) this.rankMedianPosition(c + 1, b, c);
};
mxCoordinateAssignment.prototype.rankMedianPosition = function (a, b, c) {
  b = b.ranks[a];
  for (var d = [], e = {}, f = 0; f < b.length; f++) {
    var g = b[f];
    d[f] = new WeightedCellSorter();
    d[f].cell = g;
    d[f].rankIndex = f;
    e[g.id] = d[f];
    var k;
    k = c < a ? g.getPreviousLayerConnectedCells(a) : g.getNextLayerConnectedCells(a);
    d[f].weightedValue = this.calculatedWeightedValue(g, k);
  }
  d.sort(WeightedCellSorter.prototype.compare);
  for (f = 0; f < d.length; f++) {
    var h,
      g = d[f].cell;
    h = 0;
    k = c < a ? g.getPreviousLayerConnectedCells(a).slice() : g.getNextLayerConnectedCells(a).slice();
    null != k && ((h = k.length), (h = 0 < h ? this.medianXValue(k, c) : g.getGeneralPurposeVariable(a)));
    var l = 0;
    k = -1e8;
    for (var m = d[f].rankIndex - 1; 0 <= m; ) {
      var n = e[b[m].id];
      if (null != n) {
        var p = n.cell;
        n.visited
          ? ((k = p.getGeneralPurposeVariable(a) + p.width / 2 + this.intraCellSpacing + l + g.width / 2), (m = -1))
          : ((l += p.width + this.intraCellSpacing), m--);
      }
    }
    l = 0;
    p = 1e8;
    for (m = d[f].rankIndex + 1; m < d.length; )
      if (((n = e[b[m].id]), null != n)) {
        var r = n.cell;
        n.visited
          ? ((p = r.getGeneralPurposeVariable(a) - r.width / 2 - this.intraCellSpacing - l - g.width / 2),
            (m = d.length))
          : ((l += r.width + this.intraCellSpacing), m++);
      }
    h >= k && h <= p
      ? g.setGeneralPurposeVariable(a, h)
      : h < k
      ? (g.setGeneralPurposeVariable(a, k), (this.currentXDelta += k - h))
      : h > p && (g.setGeneralPurposeVariable(a, p), (this.currentXDelta += h - p));
    d[f].visited = !0;
  }
};
mxCoordinateAssignment.prototype.calculatedWeightedValue = function (a, b) {
  for (var c = 0, d = 0; d < b.length; d++) {
    var e = b[d];
    a.isVertex() && e.isVertex() ? c++ : (c = a.isEdge() && e.isEdge() ? c + 8 : c + 2);
  }
  return c;
};
mxCoordinateAssignment.prototype.medianXValue = function (a, b) {
  if (0 == a.length) return 0;
  for (var c = [], d = 0; d < a.length; d++) c[d] = a[d].getGeneralPurposeVariable(b);
  c.sort(function (a, b) {
    return a - b;
  });
  if (1 == a.length % 2) return c[Math.floor(a.length / 2)];
  d = a.length / 2;
  return (c[d - 1] + c[d]) / 2;
};
mxCoordinateAssignment.prototype.initialCoords = function (a, b) {
  this.calculateWidestRank(a, b);
  for (var c = this.widestRank; 0 <= c; c--) c < b.maxRank && this.rankCoordinates(c, a, b);
  for (c = this.widestRank + 1; c <= b.maxRank; c++) 0 < c && this.rankCoordinates(c, a, b);
};
mxCoordinateAssignment.prototype.rankCoordinates = function (a, b, c) {
  b = c.ranks[a];
  c = this.initialX + (this.widestRankValue - this.rankWidths[a]) / 2;
  for (var d = !1, e = 0; e < b.length; e++) {
    var f = b[e];
    if (f.isVertex()) {
      var g = this.layout.getVertexBounds(f.cell);
      null != g
        ? this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
          ? ((f.width = g.width), (f.height = g.height))
          : ((f.width = g.height), (f.height = g.width))
        : (d = !0);
    } else
      f.isEdge() &&
        ((g = 1),
        null != f.edges ? (g = f.edges.length) : mxLog.warn('edge.edges is null'),
        (f.width = (g - 1) * this.parallelEdgeSpacing));
    c += f.width / 2;
    f.setX(a, c);
    f.setGeneralPurposeVariable(a, c);
    c += f.width / 2;
    c += this.intraCellSpacing;
  }
  1 == d && mxLog.warn('At least one cell has no bounds');
};
mxCoordinateAssignment.prototype.calculateWidestRank = function (a, b) {
  var c = -this.interRankCellSpacing,
    d = 0;
  this.rankWidths = [];
  this.rankY = [];
  for (var e = b.maxRank; 0 <= e; e--) {
    for (var f = 0, g = b.ranks[e], k = this.initialX, h = !1, l = 0; l < g.length; l++) {
      var m = g[l];
      if (m.isVertex()) {
        var n = this.layout.getVertexBounds(m.cell);
        null != n
          ? this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
            ? ((m.width = n.width), (m.height = n.height))
            : ((m.width = n.height), (m.height = n.width))
          : (h = !0);
        f = Math.max(f, m.height);
      } else
        m.isEdge() &&
          ((n = 1),
          null != m.edges ? (n = m.edges.length) : mxLog.warn('edge.edges is null'),
          (m.width = (n - 1) * this.parallelEdgeSpacing));
      k += m.width / 2;
      m.setX(e, k);
      m.setGeneralPurposeVariable(e, k);
      k += m.width / 2;
      k += this.intraCellSpacing;
      k > this.widestRankValue && ((this.widestRankValue = k), (this.widestRank = e));
      this.rankWidths[e] = k;
    }
    1 == h && mxLog.warn('At least one cell has no bounds');
    this.rankY[e] = c;
    k = f / 2 + d / 2 + this.interRankCellSpacing;
    d = f;
    c =
      this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST ? c + k : c - k;
    for (l = 0; l < g.length; l++) g[l].setY(e, c);
  }
};
mxCoordinateAssignment.prototype.minPath = function (a, b) {
  for (var c = b.edgeMapper.getValues(), d = 0; d < c.length; d++) {
    var e = c[d];
    if (!(1 > e.maxRank - e.minRank - 1)) {
      for (var f = e.getGeneralPurposeVariable(e.minRank + 1), g = !0, k = 0, h = e.minRank + 2; h < e.maxRank; h++) {
        var l = e.getGeneralPurposeVariable(h);
        f != l ? ((g = !1), (f = l)) : k++;
      }
      if (!g) {
        for (
          var g = (f = 0), l = [], m = [], n = e.getGeneralPurposeVariable(e.minRank + 1), h = e.minRank + 1;
          h < e.maxRank - 1;
          h++
        ) {
          var p = e.getX(h + 1);
          n == p
            ? ((l[h - e.minRank - 1] = n), f++)
            : this.repositionValid(b, e, h + 1, n)
            ? ((l[h - e.minRank - 1] = n), f++)
            : (n = l[h - e.minRank - 1] = p);
        }
        n = e.getX(h);
        for (h = e.maxRank - 1; h > e.minRank + 1; h--)
          (p = e.getX(h - 1)),
            n == p
              ? ((m[h - e.minRank - 2] = n), g++)
              : this.repositionValid(b, e, h - 1, n)
              ? ((m[h - e.minRank - 2] = n), g++)
              : ((m[h - e.minRank - 2] = e.getX(h - 1)), (n = p));
        if (g > k || f > k)
          if (g >= f) for (h = e.maxRank - 2; h > e.minRank; h--) e.setX(h, m[h - e.minRank - 1]);
          else if (f > g) for (h = e.minRank + 2; h < e.maxRank; h++) e.setX(h, l[h - e.minRank - 2]);
      }
    }
  }
};
mxCoordinateAssignment.prototype.repositionValid = function (a, b, c, d) {
  a = a.ranks[c];
  for (var e = -1, f = 0; f < a.length; f++)
    if (b == a[f]) {
      e = f;
      break;
    }
  if (0 > e) return !1;
  f = b.getGeneralPurposeVariable(c);
  if (d < f) {
    if (0 == e) return !0;
    a = a[e - 1];
    c = a.getGeneralPurposeVariable(c);
    c = c + a.width / 2 + this.intraCellSpacing + b.width / 2;
    if (!(c <= d)) return !1;
  } else if (d > f) {
    if (e == a.length - 1) return !0;
    a = a[e + 1];
    c = a.getGeneralPurposeVariable(c);
    c = c - a.width / 2 - this.intraCellSpacing - b.width / 2;
    if (!(c >= d)) return !1;
  }
  return !0;
};
mxCoordinateAssignment.prototype.setCellLocations = function (a, b) {
  this.rankTopY = [];
  this.rankBottomY = [];
  for (var c = 0; c < b.ranks.length; c++)
    (this.rankTopY[c] = Number.MAX_VALUE), (this.rankBottomY[c] = -Number.MAX_VALUE);
  for (var d = b.vertexMapper.getValues(), c = 0; c < d.length; c++) this.setVertexLocation(d[c]);
  (this.layout.edgeStyle != mxHierarchicalEdgeStyle.ORTHOGONAL &&
    this.layout.edgeStyle != mxHierarchicalEdgeStyle.POLYLINE &&
    this.layout.edgeStyle != mxHierarchicalEdgeStyle.CURVE) ||
    this.localEdgeProcessing(b);
  d = b.edgeMapper.getValues();
  for (c = 0; c < d.length; c++) this.setEdgePosition(d[c]);
};
mxCoordinateAssignment.prototype.localEdgeProcessing = function (a) {
  for (var b = 0; b < a.ranks.length; b++)
    for (var c = a.ranks[b], d = 0; d < c.length; d++) {
      var e = c[d];
      if (e.isVertex())
        for (var f = e.getPreviousLayerConnectedCells(b), g = b - 1, k = 0; 2 > k; k++) {
          if (-1 < g && g < a.ranks.length && null != f && 0 < f.length) {
            for (var h = [], l = 0; l < f.length; l++) {
              var m = new WeightedCellSorter(f[l], f[l].getX(g));
              h.push(m);
            }
            h.sort(WeightedCellSorter.prototype.compare);
            for (var m = e.x[0] - e.width / 2, n = m + e.width, p = (f = 0), g = [], l = 0; l < h.length; l++) {
              var r = h[l].cell,
                t;
              if (r.isVertex()) {
                t = 0 == k ? e.connectsAsSource : e.connectsAsTarget;
                for (var u = 0; u < t.length; u++)
                  if (t[u].source == r || t[u].target == r) (f += t[u].edges.length), p++, g.push(t[u]);
              } else (f += r.edges.length), p++, g.push(r);
            }
            e.width > (f + 1) * this.prefHozEdgeSep + 2 * this.prefHozEdgeSep &&
              ((m += this.prefHozEdgeSep), (n -= this.prefHozEdgeSep));
            h = (n - m) / f;
            m += h / 2;
            n = this.minEdgeJetty - this.prefVertEdgeOff;
            for (l = 0; l < g.length; l++)
              for (
                p = g[l].edges.length,
                  r = this.jettyPositions[g[l].ids[0]],
                  null == r && ((r = []), (this.jettyPositions[g[l].ids[0]] = r)),
                  l < f / 2 ? (n += this.prefVertEdgeOff) : l > f / 2 && (n -= this.prefVertEdgeOff),
                  t = 0;
                t < p;
                t++
              )
                (r[4 * t + 2 * k] = m), (m += h), (r[4 * t + 2 * k + 1] = n);
          }
          f = e.getNextLayerConnectedCells(b);
          g = b + 1;
        }
    }
};
mxCoordinateAssignment.prototype.setEdgePosition = function (a) {
  var b = 0;
  if (101207 != a.temp[0]) {
    var c = a.maxRank,
      d = a.minRank;
    c == d && ((c = a.source.maxRank), (d = a.target.minRank));
    for (
      var e = 0,
        f = this.jettyPositions[a.ids[0]],
        g = a.isReversed ? a.target.cell : a.source.cell,
        k = this.layout.graph,
        h = this.orientation == mxConstants.DIRECTION_EAST || this.orientation == mxConstants.DIRECTION_SOUTH,
        l = 0;
      l < a.edges.length;
      l++
    ) {
      var m = a.edges[l],
        n = this.layout.getVisibleTerminal(m, !0),
        p = [],
        r = a.isReversed;
      n != g && (r = !r);
      if (null != f) {
        var t = r ? 2 : 0,
          u = r ? (h ? this.rankBottomY[d] : this.rankTopY[d]) : h ? this.rankTopY[c] : this.rankBottomY[c],
          x = f[4 * e + 1 + t];
        r != h && (x = -x);
        var u = u + x,
          t = f[4 * e + t],
          z = k.model.getTerminal(m, !0);
        this.layout.isPort(z) &&
          k.model.getParent(z) == n &&
          ((t = k.view.getState(z)), (t = null != t ? t.x : n.geometry.x + a.source.width * z.geometry.x));
        this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
          ? (p.push(new mxPoint(t, u)),
            this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(t, u + x)))
          : (p.push(new mxPoint(u, t)),
            this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(u + x, t)));
      }
      t = a.x.length - 1;
      u = x = -1;
      n = a.maxRank - 1;
      r && ((t = 0), (x = a.x.length), (u = 1), (n = a.minRank + 1));
      for (; a.maxRank != a.minRank && t != x; t += u) {
        var z = a.x[t] + b,
          D = (this.rankTopY[n] + this.rankBottomY[n + 1]) / 2,
          B = (this.rankTopY[n - 1] + this.rankBottomY[n]) / 2;
        if (r)
          var C = D,
            D = B,
            B = C;
        this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
          ? (p.push(new mxPoint(z, D)), p.push(new mxPoint(z, B)))
          : (p.push(new mxPoint(D, z)), p.push(new mxPoint(B, z)));
        this.limitX = Math.max(this.limitX, z);
        n += u;
      }
      null != f &&
        ((t = r ? 2 : 0),
        (u = r ? (h ? this.rankTopY[c] : this.rankBottomY[c]) : h ? this.rankBottomY[d] : this.rankTopY[d]),
        (x = f[4 * e + 3 - t]),
        r != h && (x = -x),
        (u -= x),
        (t = f[4 * e + 2 - t]),
        (r = k.model.getTerminal(m, !1)),
        (n = this.layout.getVisibleTerminal(m, !1)),
        this.layout.isPort(r) &&
          k.model.getParent(r) == n &&
          ((t = k.view.getState(r)), (t = null != t ? t.x : n.geometry.x + a.target.width * r.geometry.x)),
        this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
          ? (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(t, u - x)),
            p.push(new mxPoint(t, u)))
          : (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(u - x, t)),
            p.push(new mxPoint(u, t))));
      a.isReversed && this.processReversedEdge(a, m);
      this.layout.setEdgePoints(m, p);
      b = 0 == b ? this.parallelEdgeSpacing : 0 < b ? -b : -b + this.parallelEdgeSpacing;
      e++;
    }
    a.temp[0] = 101207;
  }
};
mxCoordinateAssignment.prototype.setVertexLocation = function (a) {
  var b = a.cell,
    c = a.x[0] - a.width / 2,
    d = a.y[0] - a.height / 2;
  this.rankTopY[a.minRank] = Math.min(this.rankTopY[a.minRank], d);
  this.rankBottomY[a.minRank] = Math.max(this.rankBottomY[a.minRank], d + a.height);
  this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH
    ? this.layout.setVertexLocation(b, c, d)
    : this.layout.setVertexLocation(b, d, c);
  this.limitX = Math.max(this.limitX, c + a.width);
};
mxCoordinateAssignment.prototype.processReversedEdge = function (a, b) {};
function mxSwimlaneOrdering(a) {
  this.layout = a;
}
mxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage();
mxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;
mxSwimlaneOrdering.prototype.layout = null;
mxSwimlaneOrdering.prototype.execute = function (a) {
  a = this.layout.getModel();
  var b = mxUtils.clone(a.vertexMapper, null, !0),
    c = null;
  if (null != a.roots) for (var d = a.roots, c = [], e = 0; e < d.length; e++) c[e] = a.vertexMapper.get(d[e]);
  a.visit(
    function (a, c, d, e, l) {
      e = null != a && a.swimlaneIndex == c.swimlaneIndex && c.isAncestor(a);
      l = null != a && null != d && a.swimlaneIndex < c.swimlaneIndex && d.source == c;
      e
        ? (d.invert(),
          mxUtils.remove(d, a.connectsAsSource),
          c.connectsAsSource.push(d),
          a.connectsAsTarget.push(d),
          mxUtils.remove(d, c.connectsAsTarget))
        : l &&
          (d.invert(),
          mxUtils.remove(d, a.connectsAsTarget),
          c.connectsAsTarget.push(d),
          a.connectsAsSource.push(d),
          mxUtils.remove(d, c.connectsAsSource));
      a = mxCellPath.create(c.cell);
      delete b[a];
    },
    c,
    !0,
    null
  );
};
function mxHierarchicalLayout(a, b, c) {
  mxGraphLayout.call(this, a);
  this.orientation = null != b ? b : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != c ? c : !0;
}
var mxHierarchicalEdgeStyle = { ORTHOGONAL: 1, POLYLINE: 2, STRAIGHT: 3, CURVE: 4 };
mxHierarchicalLayout.prototype = new mxGraphLayout();
mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;
mxHierarchicalLayout.prototype.roots = null;
mxHierarchicalLayout.prototype.resizeParent = !1;
mxHierarchicalLayout.prototype.maintainParentLocation = !1;
mxHierarchicalLayout.prototype.moveParent = !1;
mxHierarchicalLayout.prototype.parentBorder = 0;
mxHierarchicalLayout.prototype.intraCellSpacing = 30;
mxHierarchicalLayout.prototype.interRankCellSpacing = 100;
mxHierarchicalLayout.prototype.interHierarchySpacing = 60;
mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;
mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxHierarchicalLayout.prototype.fineTuning = !0;
mxHierarchicalLayout.prototype.tightenToSource = !0;
mxHierarchicalLayout.prototype.disableEdgeStyle = !0;
mxHierarchicalLayout.prototype.traverseAncestors = !0;
mxHierarchicalLayout.prototype.model = null;
mxHierarchicalLayout.prototype.edgesCache = null;
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
mxHierarchicalLayout.prototype.getModel = function () {
  return this.model;
};
mxHierarchicalLayout.prototype.execute = function (a, b) {
  this.parent = a;
  var c = this.graph.model;
  this.edgesCache = new mxDictionary();
  this.edgeSourceTermCache = new mxDictionary();
  this.edgesTargetTermCache = new mxDictionary();
  null == b || b instanceof Array || (b = [b]);
  if (null != b || null != a) {
    this.parentY = this.parentX = null;
    if (a != this.root && null != c.isVertex(a) && this.maintainParentLocation) {
      var d = this.graph.getCellGeometry(a);
      null != d && ((this.parentX = d.x), (this.parentY = d.y));
    }
    if (null != b) {
      for (var e = [], f = 0; f < b.length; f++)
        (null != a ? c.isAncestor(a, b[f]) : 1) && c.isVertex(b[f]) && e.push(b[f]);
      this.roots = e;
    }
    c.beginUpdate();
    try {
      this.run(a),
        this.resizeParent &&
          !this.graph.isCellCollapsed(a) &&
          this.graph.updateGroupBounds([a], this.parentBorder, this.moveParent),
        null != this.parentX &&
          null != this.parentY &&
          ((d = this.graph.getCellGeometry(a)),
          null != d && ((d = d.clone()), (d.x = this.parentX), (d.y = this.parentY), c.setGeometry(a, d)));
    } finally {
      c.endUpdate();
    }
  }
};
mxHierarchicalLayout.prototype.findRoots = function (a, b) {
  var c = [];
  if (null != a && null != b) {
    var d = this.graph.model,
      e = null,
      f = -1e5,
      g;
    for (g in b) {
      var k = b[g];
      if (d.isVertex(k) && this.graph.isCellVisible(k)) {
        for (var h = this.getEdges(k), l = 0, m = 0, n = 0; n < h.length; n++)
          this.getVisibleTerminal(h[n], !0) == k ? l++ : m++;
        0 == m && 0 < l && c.push(k);
        h = l - m;
        h > f && ((f = h), (e = k));
      }
    }
    0 == c.length && null != e && c.push(e);
  }
  return c;
};
mxHierarchicalLayout.prototype.getEdges = function (a) {
  var b = this.edgesCache.get(a);
  if (null != b) return b;
  for (var c = this.graph.model, b = [], d = this.graph.isCellCollapsed(a), e = c.getChildCount(a), f = 0; f < e; f++) {
    var g = c.getChildAt(a, f);
    if (this.isPort(g)) b = b.concat(c.getEdges(g, !0, !0));
    else if (d || !this.graph.isCellVisible(g)) b = b.concat(c.getEdges(g, !0, !0));
  }
  b = b.concat(c.getEdges(a, !0, !0));
  c = [];
  for (f = 0; f < b.length; f++)
    (d = this.getVisibleTerminal(b[f], !0)),
      (e = this.getVisibleTerminal(b[f], !1)),
      (d == e ||
        (d != e &&
          ((e == a && (null == this.parent || this.isAncestor(this.parent, d, this.traverseAncestors))) ||
            (d == a && (null == this.parent || this.isAncestor(this.parent, e, this.traverseAncestors)))))) &&
        c.push(b[f]);
  this.edgesCache.put(a, c);
  return c;
};
mxHierarchicalLayout.prototype.getVisibleTerminal = function (a, b) {
  var c = this.edgesTargetTermCache;
  b && (c = this.edgeSourceTermCache);
  var d = c.get(a);
  if (null != d) return d;
  var d = this.graph.view.getState(a),
    e = null != d ? d.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(a, b);
  null == e && (e = null != d ? d.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(a, b));
  null != e && (this.isPort(e) && (e = this.graph.model.getParent(e)), c.put(a, e));
  return e;
};
mxHierarchicalLayout.prototype.run = function (a) {
  var b = [],
    c = [];
  if (null == this.roots && null != a) {
    var d = {};
    this.filterDescendants(a, d);
    this.roots = [];
    var e = !0,
      f;
    for (f in d)
      if (null != d[f]) {
        e = !1;
        break;
      }
    for (; !e; ) {
      for (var g = this.findRoots(a, d), e = 0; e < g.length; e++) {
        var k = {};
        b.push(k);
        this.traverse(g[e], !0, null, c, k, b, d);
      }
      for (e = 0; e < g.length; e++) this.roots.push(g[e]);
      e = !0;
      for (f in d)
        if (null != d[f]) {
          e = !1;
          break;
        }
    }
  } else
    for (e = 0; e < this.roots.length; e++) (k = {}), b.push(k), this.traverse(this.roots[e], !0, null, c, k, b, null);
  for (e = c = 0; e < b.length; e++) {
    k = b[e];
    d = [];
    for (f in k) d.push(k[f]);
    this.model = new mxGraphHierarchyModel(this, d, this.roots, a, this.tightenToSource);
    this.cycleStage(a);
    this.layeringStage();
    this.crossingStage(a);
    c = this.placementStage(c, a);
  }
};
mxHierarchicalLayout.prototype.filterDescendants = function (a, b) {
  var c = this.graph.model;
  c.isVertex(a) && a != this.parent && this.graph.isCellVisible(a) && (b[mxObjectIdentity.get(a)] = a);
  if (this.traverseAncestors || (a == this.parent && this.graph.isCellVisible(a)))
    for (var d = c.getChildCount(a), e = 0; e < d; e++) {
      var f = c.getChildAt(a, e);
      this.isPort(f) || this.filterDescendants(f, b);
    }
};
mxHierarchicalLayout.prototype.isPort = function (a) {
  return null != a && null != a.geometry ? a.geometry.relative : !1;
};
mxHierarchicalLayout.prototype.getEdgesBetween = function (a, b, c) {
  c = null != c ? c : !1;
  for (var d = this.getEdges(a), e = [], f = 0; f < d.length; f++) {
    var g = this.getVisibleTerminal(d[f], !0),
      k = this.getVisibleTerminal(d[f], !1);
    ((g == a && k == b) || (!c && g == b && k == a)) && e.push(d[f]);
  }
  return e;
};
mxHierarchicalLayout.prototype.traverse = function (a, b, c, d, e, f, g) {
  if (null != a && null != d) {
    var k = mxObjectIdentity.get(a);
    if (null == d[k] && (null == g || null != g[k])) {
      null == e[k] && (e[k] = a);
      null == d[k] && (d[k] = a);
      null !== g && delete g[k];
      var h = this.getEdges(a),
        k = [];
      for (c = 0; c < h.length; c++) k[c] = this.getVisibleTerminal(h[c], !0) == a;
      for (c = 0; c < h.length; c++)
        if (!b || k[c]) {
          a = this.getVisibleTerminal(h[c], !k[c]);
          for (var l = 1, m = 0; m < h.length; m++)
            if (m != c) {
              var n = k[m];
              this.getVisibleTerminal(h[m], !n) == a && (n ? l++ : l--);
            }
          0 <= l && (e = this.traverse(a, b, h[c], d, e, f, g));
        }
    } else if (null == e[k])
      for (c = 0; c < f.length; c++)
        if (((b = f[c]), null != b[k])) {
          for (h in b) e[h] = b[h];
          f.splice(c, 1);
          break;
        }
  }
  return e;
};
mxHierarchicalLayout.prototype.cycleStage = function (a) {
  new mxMinimumCycleRemover(this).execute(a);
};
mxHierarchicalLayout.prototype.layeringStage = function () {
  this.model.initialRank();
  this.model.fixRanks();
};
mxHierarchicalLayout.prototype.crossingStage = function (a) {
  new mxMedianHybridCrossingReduction(this).execute(a);
};
mxHierarchicalLayout.prototype.placementStage = function (a, b) {
  var c = new mxCoordinateAssignment(
    this,
    this.intraCellSpacing,
    this.interRankCellSpacing,
    this.orientation,
    a,
    this.parallelEdgeSpacing
  );
  c.fineTuning = this.fineTuning;
  c.execute(b);
  return c.limitX + this.interHierarchySpacing;
};
function mxSwimlaneLayout(a, b, c) {
  mxGraphLayout.call(this, a);
  this.orientation = null != b ? b : mxConstants.DIRECTION_NORTH;
  this.deterministic = null != c ? c : !0;
}
mxSwimlaneLayout.prototype = new mxGraphLayout();
mxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;
mxSwimlaneLayout.prototype.roots = null;
mxSwimlaneLayout.prototype.swimlanes = null;
mxSwimlaneLayout.prototype.dummyVertexWidth = 50;
mxSwimlaneLayout.prototype.resizeParent = !1;
mxSwimlaneLayout.prototype.maintainParentLocation = !1;
mxSwimlaneLayout.prototype.moveParent = !1;
mxSwimlaneLayout.prototype.parentBorder = 30;
mxSwimlaneLayout.prototype.intraCellSpacing = 30;
mxSwimlaneLayout.prototype.interRankCellSpacing = 100;
mxSwimlaneLayout.prototype.interHierarchySpacing = 60;
mxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;
mxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;
mxSwimlaneLayout.prototype.fineTuning = !0;
mxSwimlaneLayout.prototype.tightenToSource = !0;
mxSwimlaneLayout.prototype.disableEdgeStyle = !0;
mxSwimlaneLayout.prototype.traverseAncestors = !0;
mxSwimlaneLayout.prototype.model = null;
mxSwimlaneLayout.prototype.edgesCache = null;
mxHierarchicalLayout.prototype.edgeSourceTermCache = null;
mxHierarchicalLayout.prototype.edgesTargetTermCache = null;
mxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;
mxSwimlaneLayout.prototype.getModel = function () {
  return this.model;
};
mxSwimlaneLayout.prototype.execute = function (a, b) {
  this.parent = a;
  var c = this.graph.model;
  this.edgesCache = new mxDictionary();
  this.edgeSourceTermCache = new mxDictionary();
  this.edgesTargetTermCache = new mxDictionary();
  if (!(null == b || 1 > b.length)) {
    null == a && (a = c.getParent(b[0]));
    this.parentY = this.parentX = null;
    if (a != this.root && null != c.isVertex(a) && this.maintainParentLocation) {
      var d = this.graph.getCellGeometry(a);
      null != d && ((this.parentX = d.x), (this.parentY = d.y));
    }
    this.swimlanes = b;
    for (var e = [], f = 0; f < b.length; f++) {
      var g = this.graph.getChildCells(b[f]);
      if (null == g || 0 == g.length)
        (g = this.graph.insertVertex(b[f], null, null, 0, 0, this.dummyVertexWidth, 0)), e.push(g);
    }
    c.beginUpdate();
    try {
      this.run(a),
        this.resizeParent &&
          !this.graph.isCellCollapsed(a) &&
          this.graph.updateGroupBounds([a], this.parentBorder, this.moveParent),
        null != this.parentX &&
          null != this.parentY &&
          ((d = this.graph.getCellGeometry(a)),
          null != d && ((d = d.clone()), (d.x = this.parentX), (d.y = this.parentY), c.setGeometry(a, d))),
        this.graph.removeCells(e);
    } finally {
      c.endUpdate();
    }
  }
};
mxSwimlaneLayout.prototype.updateGroupBounds = function () {
  var a = [],
    b = this.model,
    c;
  for (c in b.edgeMapper) for (var d = b.edgeMapper[c], e = 0; e < d.edges.length; e++) a.push(d.edges[e]);
  a = this.graph.getBoundingBoxFromGeometry(a, !0);
  b = [];
  for (e = 0; e < this.swimlanes.length; e++) {
    var f = this.swimlanes[e];
    c = this.graph.getCellGeometry(f);
    if (null != c) {
      var g = this.graph.getChildCells(f),
        d = this.graph.isSwimlane(f) ? this.graph.getStartSize(f) : new mxRectangle(),
        f = this.graph.getBoundingBoxFromGeometry(g);
      b[e] = f;
      d = f.y + c.y - d.height - this.parentBorder;
      c = f.y + c.y + f.height;
      null == a
        ? (a = new mxRectangle(0, d, 0, c - d))
        : ((a.y = Math.min(a.y, d)), (a.height = Math.max(a.y + a.height, c) - a.y));
    }
  }
  for (e = 0; e < this.swimlanes.length; e++)
    if (((f = this.swimlanes[e]), (c = this.graph.getCellGeometry(f)), null != c)) {
      var g = this.graph.getChildCells(f),
        d = this.graph.isSwimlane(f) ? this.graph.getStartSize(f) : new mxRectangle(),
        k = c.clone(),
        h = d.width + (0 == e ? this.parentBorder : this.interRankCellSpacing / 2),
        l = b[e].x - h,
        m = a.y - this.parentBorder;
      k.x += l;
      k.y = m;
      k.width = b[e].width + h + this.interRankCellSpacing / 2;
      k.height = a.height + d.height + 2 * this.parentBorder;
      this.graph.model.setGeometry(f, k);
      this.graph.moveCells(g, -l, c.y - m);
    }
};
mxSwimlaneLayout.prototype.findRoots = function (a, b) {
  var c = [];
  if (null != a && null != b) {
    var d = this.graph.model,
      e = null,
      f = -1e5,
      g;
    for (g in b) {
      var k = b[g];
      if (null != k && d.isVertex(k) && this.graph.isCellVisible(k) && d.isAncestor(a, k)) {
        for (var h = this.getEdges(k), l = 0, m = 0, n = 0; n < h.length; n++) {
          var p = this.getVisibleTerminal(h[n], !0);
          p == k ? ((p = this.getVisibleTerminal(h[n], !1)), d.isAncestor(a, p) && l++) : d.isAncestor(a, p) && m++;
        }
        0 == m && 0 < l && c.push(k);
        h = l - m;
        h > f && ((f = h), (e = k));
      }
    }
    0 == c.length && null != e && c.push(e);
  }
  return c;
};
mxSwimlaneLayout.prototype.getEdges = function (a) {
  var b = this.edgesCache.get(a);
  if (null != b) return b;
  for (var c = this.graph.model, b = [], d = this.graph.isCellCollapsed(a), e = c.getChildCount(a), f = 0; f < e; f++) {
    var g = c.getChildAt(a, f);
    if (this.isPort(g)) b = b.concat(c.getEdges(g, !0, !0));
    else if (d || !this.graph.isCellVisible(g)) b = b.concat(c.getEdges(g, !0, !0));
  }
  b = b.concat(c.getEdges(a, !0, !0));
  c = [];
  for (f = 0; f < b.length; f++)
    (d = this.getVisibleTerminal(b[f], !0)),
      (e = this.getVisibleTerminal(b[f], !1)),
      (d == e ||
        (d != e &&
          ((e == a && (null == this.parent || this.graph.isValidAncestor(d, this.parent, this.traverseAncestors))) ||
            (d == a &&
              (null == this.parent || this.graph.isValidAncestor(e, this.parent, this.traverseAncestors)))))) &&
        c.push(b[f]);
  this.edgesCache.put(a, c);
  return c;
};
mxSwimlaneLayout.prototype.getVisibleTerminal = function (a, b) {
  var c = this.edgesTargetTermCache;
  b && (c = this.edgeSourceTermCache);
  var d = c.get(a);
  if (null != d) return d;
  var d = this.graph.view.getState(a),
    e = null != d ? d.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(a, b);
  null == e && (e = null != d ? d.getVisibleTerminal(b) : this.graph.view.getVisibleTerminal(a, b));
  null != e && (this.isPort(e) && (e = this.graph.model.getParent(e)), c.put(a, e));
  return e;
};
mxSwimlaneLayout.prototype.run = function (a) {
  var b = [],
    c = {};
  if (null != this.swimlanes && 0 < this.swimlanes.length && null != a) {
    for (var d = {}, e = 0; e < this.swimlanes.length; e++) this.filterDescendants(this.swimlanes[e], d);
    this.roots = [];
    var e = !0,
      f;
    for (f in d)
      if (null != d[f]) {
        e = !1;
        break;
      }
    for (var g = 0; !e && g < this.swimlanes.length; ) {
      var k = this.findRoots(this.swimlanes[g], d);
      if (0 == k.length) g++;
      else {
        for (e = 0; e < k.length; e++) {
          var h = {};
          b.push(h);
          this.traverse(k[e], !0, null, c, h, b, d, g);
        }
        for (e = 0; e < k.length; e++) this.roots.push(k[e]);
        e = !0;
        for (f in d)
          if (null != d[f]) {
            e = !1;
            break;
          }
      }
    }
  } else
    for (e = 0; e < this.roots.length; e++) (h = {}), b.push(h), this.traverse(this.roots[e], !0, null, c, h, b, null);
  b = [];
  for (f in c) b.push(c[f]);
  this.model = new mxSwimlaneModel(this, b, this.roots, a, this.tightenToSource);
  this.cycleStage(a);
  this.layeringStage();
  this.crossingStage(a);
  this.placementStage(0, a);
};
mxSwimlaneLayout.prototype.filterDescendants = function (a, b) {
  var c = this.graph.model;
  c.isVertex(a) &&
    a != this.parent &&
    c.getParent(a) != this.parent &&
    this.graph.isCellVisible(a) &&
    (b[mxObjectIdentity.get(a)] = a);
  if (this.traverseAncestors || (a == this.parent && this.graph.isCellVisible(a)))
    for (var d = c.getChildCount(a), e = 0; e < d; e++) {
      var f = c.getChildAt(a, e);
      this.isPort(f) || this.filterDescendants(f, b);
    }
};
mxSwimlaneLayout.prototype.isPort = function (a) {
  return a.geometry.relative ? !0 : !1;
};
mxSwimlaneLayout.prototype.getEdgesBetween = function (a, b, c) {
  c = null != c ? c : !1;
  for (var d = this.getEdges(a), e = [], f = 0; f < d.length; f++) {
    var g = this.getVisibleTerminal(d[f], !0),
      k = this.getVisibleTerminal(d[f], !1);
    ((g == a && k == b) || (!c && g == b && k == a)) && e.push(d[f]);
  }
  return e;
};
mxSwimlaneLayout.prototype.traverse = function (a, b, c, d, e, f, g, k) {
  if (null != a && null != d) {
    var h = mxObjectIdentity.get(a);
    if (null == d[h] && (null == g || null != g[h])) {
      null == e[h] && (e[h] = a);
      null == d[h] && (d[h] = a);
      null !== g && delete g[h];
      var l = this.getEdges(a),
        h = this.graph.model;
      for (c = 0; c < l.length; c++) {
        var m = this.getVisibleTerminal(l[c], !0),
          n = m == a;
        n && (m = this.getVisibleTerminal(l[c], !1));
        for (var p = 0; p < this.swimlanes.length && !h.isAncestor(this.swimlanes[p], m); ) p++;
        p >= this.swimlanes.length ||
          !(p > k || ((!b || n) && p == k)) ||
          (e = this.traverse(m, b, l[c], d, e, f, g, p));
      }
    } else if (null == e[h])
      for (c = 0; c < f.length; c++)
        if (((a = f[c]), null != a[h])) {
          for (l in a) e[l] = a[l];
          f.splice(c, 1);
          break;
        }
  }
  return e;
};
mxSwimlaneLayout.prototype.cycleStage = function (a) {
  new mxSwimlaneOrdering(this).execute(a);
};
mxSwimlaneLayout.prototype.layeringStage = function () {
  this.model.initialRank();
  this.model.fixRanks();
};
mxSwimlaneLayout.prototype.crossingStage = function (a) {
  new mxMedianHybridCrossingReduction(this).execute(a);
};
mxSwimlaneLayout.prototype.placementStage = function (a, b) {
  var c = new mxCoordinateAssignment(
    this,
    this.intraCellSpacing,
    this.interRankCellSpacing,
    this.orientation,
    a,
    this.parallelEdgeSpacing
  );
  c.fineTuning = this.fineTuning;
  c.execute(b);
  return c.limitX + this.interHierarchySpacing;
};
function mxGraphModel(a) {
  this.currentEdit = this.createUndoableEdit();
  null != a ? this.setRoot(a) : this.clear();
}
mxGraphModel.prototype = new mxEventSource();
mxGraphModel.prototype.constructor = mxGraphModel;
mxGraphModel.prototype.root = null;
mxGraphModel.prototype.cells = null;
mxGraphModel.prototype.maintainEdgeParent = !0;
mxGraphModel.prototype.ignoreRelativeEdgeParent = !0;
mxGraphModel.prototype.createIds = !0;
mxGraphModel.prototype.prefix = '';
mxGraphModel.prototype.postfix = '';
mxGraphModel.prototype.nextId = 0;
mxGraphModel.prototype.currentEdit = null;
mxGraphModel.prototype.updateLevel = 0;
mxGraphModel.prototype.endingUpdate = !1;
mxGraphModel.prototype.clear = function () {
  this.setRoot(this.createRoot());
};
mxGraphModel.prototype.isCreateIds = function () {
  return this.createIds;
};
mxGraphModel.prototype.setCreateIds = function (a) {
  this.createIds = a;
};
mxGraphModel.prototype.createRoot = function () {
  var a = new mxCell();
  a.insert(new mxCell());
  return a;
};
mxGraphModel.prototype.getCell = function (a) {
  return null != this.cells ? this.cells[a] : null;
};
mxGraphModel.prototype.filterCells = function (a, b) {
  var c = null;
  if (null != a) for (var c = [], d = 0; d < a.length; d++) b(a[d]) && c.push(a[d]);
  return c;
};
mxGraphModel.prototype.getDescendants = function (a) {
  return this.filterDescendants(null, a);
};
mxGraphModel.prototype.filterDescendants = function (a, b) {
  var c = [];
  b = b || this.getRoot();
  (null == a || a(b)) && c.push(b);
  for (var d = this.getChildCount(b), e = 0; e < d; e++)
    var f = this.getChildAt(b, e), c = c.concat(this.filterDescendants(a, f));
  return c;
};
mxGraphModel.prototype.getRoot = function (a) {
  var b = a || this.root;
  if (null != a) for (; null != a; ) (b = a), (a = this.getParent(a));
  return b;
};
mxGraphModel.prototype.setRoot = function (a) {
  this.execute(new mxRootChange(this, a));
  return a;
};
mxGraphModel.prototype.rootChanged = function (a) {
  var b = this.root;
  this.root = a;
  this.nextId = 0;
  this.cells = null;
  this.cellAdded(a);
  return b;
};
mxGraphModel.prototype.isRoot = function (a) {
  return null != a && this.root == a;
};
mxGraphModel.prototype.isLayer = function (a) {
  return this.isRoot(this.getParent(a));
};
mxGraphModel.prototype.isAncestor = function (a, b) {
  for (; null != b && b != a; ) b = this.getParent(b);
  return b == a;
};
mxGraphModel.prototype.contains = function (a) {
  return this.isAncestor(this.root, a);
};
mxGraphModel.prototype.getParent = function (a) {
  return null != a ? a.getParent() : null;
};
mxGraphModel.prototype.add = function (a, b, c) {
  if (b != a && null != a && null != b) {
    null == c && (c = this.getChildCount(a));
    var d = a != this.getParent(b);
    this.execute(new mxChildChange(this, a, b, c));
    this.maintainEdgeParent && d && this.updateEdgeParents(b);
  }
  return b;
};
mxGraphModel.prototype.cellAdded = function (a) {
  if (null != a) {
    null == a.getId() && this.createIds && a.setId(this.createId(a));
    if (null != a.getId()) {
      var b = this.getCell(a.getId());
      if (b != a) {
        for (; null != b; ) a.setId(this.createId(a)), (b = this.getCell(a.getId()));
        null == this.cells && (this.cells = {});
        this.cells[a.getId()] = a;
      }
    }
    mxUtils.isNumeric(a.getId()) && (this.nextId = Math.max(this.nextId, a.getId()));
    for (var b = this.getChildCount(a), c = 0; c < b; c++) this.cellAdded(this.getChildAt(a, c));
  }
};
mxGraphModel.prototype.createId = function (a) {
  a = this.nextId;
  this.nextId++;
  return this.prefix + a + this.postfix;
};
mxGraphModel.prototype.updateEdgeParents = function (a, b) {
  b = b || this.getRoot(a);
  for (var c = this.getChildCount(a), d = 0; d < c; d++) {
    var e = this.getChildAt(a, d);
    this.updateEdgeParents(e, b);
  }
  e = this.getEdgeCount(a);
  c = [];
  for (d = 0; d < e; d++) c.push(this.getEdgeAt(a, d));
  for (d = 0; d < c.length; d++) (e = c[d]), this.isAncestor(b, e) && this.updateEdgeParent(e, b);
};
mxGraphModel.prototype.updateEdgeParent = function (a, b) {
  for (
    var c = this.getTerminal(a, !0), d = this.getTerminal(a, !1);
    null != c && !this.isEdge(c) && null != c.geometry && c.geometry.relative;

  )
    c = this.getParent(c);
  for (; null != d && this.ignoreRelativeEdgeParent && !this.isEdge(d) && null != d.geometry && d.geometry.relative; )
    d = this.getParent(d);
  if (
    this.isAncestor(b, c) &&
    this.isAncestor(b, d) &&
    ((c = c == d ? this.getParent(c) : this.getNearestCommonAncestor(c, d)),
    null != c && (this.getParent(c) != this.root || this.isAncestor(c, a)) && this.getParent(a) != c)
  ) {
    d = this.getGeometry(a);
    if (null != d) {
      var e = this.getOrigin(this.getParent(a)),
        f = this.getOrigin(c),
        g = f.x - e.x,
        e = f.y - e.y,
        d = d.clone();
      d.translate(-g, -e);
      this.setGeometry(a, d);
    }
    this.add(c, a, this.getChildCount(c));
  }
};
mxGraphModel.prototype.getOrigin = function (a) {
  var b;
  null != a
    ? ((b = this.getOrigin(this.getParent(a))),
      this.isEdge(a) || ((a = this.getGeometry(a)), null != a && ((b.x += a.x), (b.y += a.y))))
    : (b = new mxPoint());
  return b;
};
mxGraphModel.prototype.getNearestCommonAncestor = function (a, b) {
  if (null != a && null != b) {
    var c = mxCellPath.create(b);
    if (null != c && 0 < c.length) {
      var d = a,
        e = mxCellPath.create(d);
      if (c.length < e.length)
        var d = b,
          f = e,
          e = c,
          c = f;
      for (; null != d; ) {
        f = this.getParent(d);
        if (0 == c.indexOf(e + mxCellPath.PATH_SEPARATOR) && null != f) return d;
        e = mxCellPath.getParentPath(e);
        d = f;
      }
    }
  }
  return null;
};
mxGraphModel.prototype.remove = function (a) {
  a == this.root ? this.setRoot(null) : null != this.getParent(a) && this.execute(new mxChildChange(this, null, a));
  return a;
};
mxGraphModel.prototype.cellRemoved = function (a) {
  if (null != a && null != this.cells) {
    for (var b = this.getChildCount(a) - 1; 0 <= b; b--) this.cellRemoved(this.getChildAt(a, b));
    null != this.cells && null != a.getId() && delete this.cells[a.getId()];
  }
};
mxGraphModel.prototype.parentForCellChanged = function (a, b, c) {
  var d = this.getParent(a);
  null != b ? (b == d && d.getIndex(a) == c) || b.insert(a, c) : null != d && ((c = d.getIndex(a)), d.remove(c));
  b = this.contains(b);
  c = this.contains(d);
  b && !c ? this.cellAdded(a) : c && !b && this.cellRemoved(a);
  return d;
};
mxGraphModel.prototype.getChildCount = function (a) {
  return null != a ? a.getChildCount() : 0;
};
mxGraphModel.prototype.getChildAt = function (a, b) {
  return null != a ? a.getChildAt(b) : null;
};
mxGraphModel.prototype.getChildren = function (a) {
  return null != a ? a.children : null;
};
mxGraphModel.prototype.getChildVertices = function (a) {
  return this.getChildCells(a, !0, !1);
};
mxGraphModel.prototype.getChildEdges = function (a) {
  return this.getChildCells(a, !1, !0);
};
mxGraphModel.prototype.getChildCells = function (a, b, c) {
  b = null != b ? b : !1;
  c = null != c ? c : !1;
  for (var d = this.getChildCount(a), e = [], f = 0; f < d; f++) {
    var g = this.getChildAt(a, f);
    ((!c && !b) || (c && this.isEdge(g)) || (b && this.isVertex(g))) && e.push(g);
  }
  return e;
};
mxGraphModel.prototype.getTerminal = function (a, b) {
  return null != a ? a.getTerminal(b) : null;
};
mxGraphModel.prototype.setTerminal = function (a, b, c) {
  var d = b != this.getTerminal(a, c);
  this.execute(new mxTerminalChange(this, a, b, c));
  this.maintainEdgeParent && d && this.updateEdgeParent(a, this.getRoot());
  return b;
};
mxGraphModel.prototype.setTerminals = function (a, b, c) {
  this.beginUpdate();
  try {
    this.setTerminal(a, b, !0), this.setTerminal(a, c, !1);
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.terminalForCellChanged = function (a, b, c) {
  var d = this.getTerminal(a, c);
  null != b ? b.insertEdge(a, c) : null != d && d.removeEdge(a, c);
  return d;
};
mxGraphModel.prototype.getEdgeCount = function (a) {
  return null != a ? a.getEdgeCount() : 0;
};
mxGraphModel.prototype.getEdgeAt = function (a, b) {
  return null != a ? a.getEdgeAt(b) : null;
};
mxGraphModel.prototype.getDirectedEdgeCount = function (a, b, c) {
  for (var d = 0, e = this.getEdgeCount(a), f = 0; f < e; f++) {
    var g = this.getEdgeAt(a, f);
    g != c && this.getTerminal(g, b) == a && d++;
  }
  return d;
};
mxGraphModel.prototype.getConnections = function (a) {
  return this.getEdges(a, !0, !0, !1);
};
mxGraphModel.prototype.getIncomingEdges = function (a) {
  return this.getEdges(a, !0, !1, !1);
};
mxGraphModel.prototype.getOutgoingEdges = function (a) {
  return this.getEdges(a, !1, !0, !1);
};
mxGraphModel.prototype.getEdges = function (a, b, c, d) {
  b = null != b ? b : !0;
  c = null != c ? c : !0;
  d = null != d ? d : !0;
  for (var e = this.getEdgeCount(a), f = [], g = 0; g < e; g++) {
    var k = this.getEdgeAt(a, g),
      h = this.getTerminal(k, !0),
      l = this.getTerminal(k, !1);
    ((d && h == l) || (h != l && ((b && l == a) || (c && h == a)))) && f.push(k);
  }
  return f;
};
mxGraphModel.prototype.getEdgesBetween = function (a, b, c) {
  c = null != c ? c : !1;
  var d = this.getEdgeCount(a),
    e = this.getEdgeCount(b),
    f = a,
    g = d;
  e < d && ((g = e), (f = b));
  d = [];
  for (e = 0; e < g; e++) {
    var k = this.getEdgeAt(f, e),
      h = this.getTerminal(k, !0),
      l = this.getTerminal(k, !1),
      m = l == a && h == b;
    ((h == a && l == b) || (!c && m)) && d.push(k);
  }
  return d;
};
mxGraphModel.prototype.getOpposites = function (a, b, c, d) {
  c = null != c ? c : !0;
  d = null != d ? d : !0;
  var e = [];
  if (null != a)
    for (var f = 0; f < a.length; f++) {
      var g = this.getTerminal(a[f], !0),
        k = this.getTerminal(a[f], !1);
      g == b && null != k && k != b && d ? e.push(k) : k == b && null != g && g != b && c && e.push(g);
    }
  return e;
};
mxGraphModel.prototype.getTopmostCells = function (a) {
  for (var b = new mxDictionary(), c = [], d = 0; d < a.length; d++) b.put(a[d], !0);
  for (d = 0; d < a.length; d++) {
    for (var e = a[d], f = !0, g = this.getParent(e); null != g; ) {
      if (b.get(g)) {
        f = !1;
        break;
      }
      g = this.getParent(g);
    }
    f && c.push(e);
  }
  return c;
};
mxGraphModel.prototype.isVertex = function (a) {
  return null != a ? a.isVertex() : !1;
};
mxGraphModel.prototype.isEdge = function (a) {
  return null != a ? a.isEdge() : !1;
};
mxGraphModel.prototype.isConnectable = function (a) {
  return null != a ? a.isConnectable() : !1;
};
mxGraphModel.prototype.getValue = function (a) {
  return null != a ? a.getValue() : null;
};
mxGraphModel.prototype.setValue = function (a, b) {
  this.execute(new mxValueChange(this, a, b));
  return b;
};
mxGraphModel.prototype.valueForCellChanged = function (a, b) {
  return a.valueChanged(b);
};
mxGraphModel.prototype.getGeometry = function (a) {
  return null != a ? a.getGeometry() : null;
};
mxGraphModel.prototype.setGeometry = function (a, b) {
  b != this.getGeometry(a) && this.execute(new mxGeometryChange(this, a, b));
  return b;
};
mxGraphModel.prototype.geometryForCellChanged = function (a, b) {
  var c = this.getGeometry(a);
  a.setGeometry(b);
  return c;
};
mxGraphModel.prototype.getStyle = function (a) {
  return null != a ? a.getStyle() : null;
};
mxGraphModel.prototype.setStyle = function (a, b) {
  b != this.getStyle(a) && this.execute(new mxStyleChange(this, a, b));
  return b;
};
mxGraphModel.prototype.styleForCellChanged = function (a, b) {
  var c = this.getStyle(a);
  a.setStyle(b);
  return c;
};
mxGraphModel.prototype.isCollapsed = function (a) {
  return null != a ? a.isCollapsed() : !1;
};
mxGraphModel.prototype.setCollapsed = function (a, b) {
  b != this.isCollapsed(a) && this.execute(new mxCollapseChange(this, a, b));
  return b;
};
mxGraphModel.prototype.collapsedStateForCellChanged = function (a, b) {
  var c = this.isCollapsed(a);
  a.setCollapsed(b);
  return c;
};
mxGraphModel.prototype.isVisible = function (a) {
  return null != a ? a.isVisible() : !1;
};
mxGraphModel.prototype.setVisible = function (a, b) {
  b != this.isVisible(a) && this.execute(new mxVisibleChange(this, a, b));
  return b;
};
mxGraphModel.prototype.visibleStateForCellChanged = function (a, b) {
  var c = this.isVisible(a);
  a.setVisible(b);
  return c;
};
mxGraphModel.prototype.execute = function (a) {
  a.execute();
  this.beginUpdate();
  this.currentEdit.add(a);
  this.fireEvent(new mxEventObject(mxEvent.EXECUTE, 'change', a));
  this.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', a));
  this.endUpdate();
};
mxGraphModel.prototype.beginUpdate = function () {
  this.updateLevel++;
  this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));
  1 == this.updateLevel && this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
};
mxGraphModel.prototype.endUpdate = function () {
  this.updateLevel--;
  0 == this.updateLevel && this.fireEvent(new mxEventObject(mxEvent.END_EDIT));
  if (!this.endingUpdate) {
    this.endingUpdate = 0 == this.updateLevel;
    this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, 'edit', this.currentEdit));
    try {
      if (this.endingUpdate && !this.currentEdit.isEmpty()) {
        this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, 'edit', this.currentEdit));
        var a = this.currentEdit;
        this.currentEdit = this.createUndoableEdit();
        a.notify();
        this.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', a));
      }
    } finally {
      this.endingUpdate = !1;
    }
  }
};
mxGraphModel.prototype.createUndoableEdit = function (a) {
  var b = new mxUndoableEdit(this, null != a ? a : !0);
  b.notify = function () {
    b.source.fireEvent(new mxEventObject(mxEvent.CHANGE, 'edit', b, 'changes', b.changes));
    b.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, 'edit', b, 'changes', b.changes));
  };
  return b;
};
mxGraphModel.prototype.mergeChildren = function (a, b, c) {
  c = null != c ? c : !0;
  this.beginUpdate();
  try {
    var d = {};
    this.mergeChildrenImpl(a, b, c, d);
    for (var e in d) {
      var f = d[e],
        g = this.getTerminal(f, !0);
      null != g && ((g = d[mxCellPath.create(g)]), this.setTerminal(f, g, !0));
      g = this.getTerminal(f, !1);
      null != g && ((g = d[mxCellPath.create(g)]), this.setTerminal(f, g, !1));
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.mergeChildrenImpl = function (a, b, c, d) {
  this.beginUpdate();
  try {
    for (var e = a.getChildCount(), f = 0; f < e; f++) {
      var g = a.getChildAt(f);
      if ('function' == typeof g.getId) {
        var k = g.getId(),
          h = null == k || (this.isEdge(g) && c) ? null : this.getCell(k);
        if (null == h) {
          var l = g.clone();
          l.setId(k);
          l.setTerminal(g.getTerminal(!0), !0);
          l.setTerminal(g.getTerminal(!1), !1);
          h = b.insert(l);
          this.cellAdded(h);
        }
        d[mxCellPath.create(g)] = h;
        this.mergeChildrenImpl(g, h, c, d);
      }
    }
  } finally {
    this.endUpdate();
  }
};
mxGraphModel.prototype.getParents = function (a) {
  var b = [];
  if (null != a)
    for (var c = new mxDictionary(), d = 0; d < a.length; d++) {
      var e = this.getParent(a[d]);
      null == e || c.get(e) || (c.put(e, !0), b.push(e));
    }
  return b;
};
mxGraphModel.prototype.cloneCell = function (a, b, c) {
  return null != a ? this.cloneCells([a], b, null, c)[0] : null;
};
mxGraphModel.prototype.cloneCells = function (a, b, c, d) {
  b = null != b ? b : !0;
  c = null != c ? c : {};
  d = null != d ? d : !1;
  for (var e = [], f = 0; f < a.length; f++) null != a[f] ? e.push(this.cloneCellImpl(a[f], c, b, d)) : e.push(null);
  for (f = 0; f < e.length; f++) null != e[f] && this.restoreClone(e[f], a[f], c);
  return e;
};
mxGraphModel.prototype.cloneCellImpl = function (a, b, c, d) {
  var e = mxObjectIdentity.get(a),
    f = b[e];
  if (null == f && ((f = this.cellCloned(a)), (b[e] = f), d && (f.id = a.id), c))
    for (c = this.getChildCount(a), e = 0; e < c; e++) {
      var g = this.cloneCellImpl(this.getChildAt(a, e), b, !0, d);
      f.insert(g);
    }
  return f;
};
mxGraphModel.prototype.cellCloned = function (a) {
  return a.clone();
};
mxGraphModel.prototype.restoreClone = function (a, b, c) {
  var d = this.getTerminal(b, !0);
  null != d && ((d = c[mxObjectIdentity.get(d)]), null != d && d.insertEdge(a, !0));
  d = this.getTerminal(b, !1);
  null != d && ((d = c[mxObjectIdentity.get(d)]), null != d && d.insertEdge(a, !1));
  for (var d = this.getChildCount(a), e = 0; e < d; e++)
    this.restoreClone(this.getChildAt(a, e), this.getChildAt(b, e), c);
};
function mxRootChange(a, b) {
  this.model = a;
  this.previous = this.root = b;
}
mxRootChange.prototype.execute = function () {
  this.root = this.previous;
  this.previous = this.model.rootChanged(this.previous);
};
function mxChildChange(a, b, c, d) {
  this.model = a;
  this.previous = this.parent = b;
  this.child = c;
  this.previousIndex = this.index = d;
}
mxChildChange.prototype.execute = function () {
  if (null != this.child) {
    var a = this.model.getParent(this.child),
      b = null != a ? a.getIndex(this.child) : 0;
    null == this.previous && this.connect(this.child, !1);
    a = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    null != this.previous && this.connect(this.child, !0);
    this.parent = this.previous;
    this.previous = a;
    this.index = this.previousIndex;
    this.previousIndex = b;
  }
};
mxChildChange.prototype.connect = function (a, b) {
  b = null != b ? b : !0;
  var c = a.getTerminal(!0),
    d = a.getTerminal(!1);
  null != c && (b ? this.model.terminalForCellChanged(a, c, !0) : this.model.terminalForCellChanged(a, null, !0));
  null != d && (b ? this.model.terminalForCellChanged(a, d, !1) : this.model.terminalForCellChanged(a, null, !1));
  a.setTerminal(c, !0);
  a.setTerminal(d, !1);
  c = this.model.getChildCount(a);
  for (d = 0; d < c; d++) this.connect(this.model.getChildAt(a, d), b);
};
function mxTerminalChange(a, b, c, d) {
  this.model = a;
  this.cell = b;
  this.previous = this.terminal = c;
  this.source = d;
}
mxTerminalChange.prototype.execute = function () {
  null != this.cell &&
    ((this.terminal = this.previous),
    (this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source)));
};
function mxValueChange(a, b, c) {
  this.model = a;
  this.cell = b;
  this.previous = this.value = c;
}
mxValueChange.prototype.execute = function () {
  null != this.cell &&
    ((this.value = this.previous), (this.previous = this.model.valueForCellChanged(this.cell, this.previous)));
};
function mxStyleChange(a, b, c) {
  this.model = a;
  this.cell = b;
  this.previous = this.style = c;
}
mxStyleChange.prototype.execute = function () {
  null != this.cell &&
    ((this.style = this.previous), (this.previous = this.model.styleForCellChanged(this.cell, this.previous)));
};
function mxGeometryChange(a, b, c) {
  this.model = a;
  this.cell = b;
  this.previous = this.geometry = c;
}
mxGeometryChange.prototype.execute = function () {
  null != this.cell &&
    ((this.geometry = this.previous), (this.previous = this.model.geometryForCellChanged(this.cell, this.previous)));
};
function mxCollapseChange(a, b, c) {
  this.model = a;
  this.cell = b;
  this.previous = this.collapsed = c;
}
mxCollapseChange.prototype.execute = function () {
  null != this.cell &&
    ((this.collapsed = this.previous),
    (this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous)));
};
function mxVisibleChange(a, b, c) {
  this.model = a;
  this.cell = b;
  this.previous = this.visible = c;
}
mxVisibleChange.prototype.execute = function () {
  null != this.cell &&
    ((this.visible = this.previous), (this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous)));
};
function mxCellAttributeChange(a, b, c) {
  this.cell = a;
  this.attribute = b;
  this.previous = this.value = c;
}
mxCellAttributeChange.prototype.execute = function () {
  if (null != this.cell) {
    var a = this.cell.getAttribute(this.attribute);
    null == this.previous
      ? this.cell.value.removeAttribute(this.attribute)
      : this.cell.setAttribute(this.attribute, this.previous);
    this.previous = a;
  }
};
function mxCell(a, b, c) {
  this.value = a;
  this.setGeometry(b);
  this.setStyle(c);
  if (null != this.onInit) this.onInit();
}
mxCell.prototype.id = null;
mxCell.prototype.value = null;
mxCell.prototype.geometry = null;
mxCell.prototype.style = null;
mxCell.prototype.vertex = !1;
mxCell.prototype.edge = !1;
mxCell.prototype.connectable = !0;
mxCell.prototype.visible = !0;
mxCell.prototype.collapsed = !1;
mxCell.prototype.parent = null;
mxCell.prototype.source = null;
mxCell.prototype.target = null;
mxCell.prototype.children = null;
mxCell.prototype.edges = null;
mxCell.prototype.mxTransient = 'id value parent source target children edges'.split(' ');
mxCell.prototype.getId = function () {
  return this.id;
};
mxCell.prototype.setId = function (a) {
  this.id = a;
};
mxCell.prototype.getValue = function () {
  return this.value;
};
mxCell.prototype.setValue = function (a) {
  this.value = a;
};
mxCell.prototype.valueChanged = function (a) {
  var b = this.getValue();
  this.setValue(a);
  return b;
};
mxCell.prototype.getGeometry = function () {
  return this.geometry;
};
mxCell.prototype.setGeometry = function (a) {
  this.geometry = a;
};
mxCell.prototype.getStyle = function () {
  return this.style;
};
mxCell.prototype.setStyle = function (a) {
  this.style = a;
};
mxCell.prototype.isVertex = function () {
  return 0 != this.vertex;
};
mxCell.prototype.setVertex = function (a) {
  this.vertex = a;
};
mxCell.prototype.isEdge = function () {
  return 0 != this.edge;
};
mxCell.prototype.setEdge = function (a) {
  this.edge = a;
};
mxCell.prototype.isConnectable = function () {
  return 0 != this.connectable;
};
mxCell.prototype.setConnectable = function (a) {
  this.connectable = a;
};
mxCell.prototype.isVisible = function () {
  return 0 != this.visible;
};
mxCell.prototype.setVisible = function (a) {
  this.visible = a;
};
mxCell.prototype.isCollapsed = function () {
  return 0 != this.collapsed;
};
mxCell.prototype.setCollapsed = function (a) {
  this.collapsed = a;
};
mxCell.prototype.getParent = function () {
  return this.parent;
};
mxCell.prototype.setParent = function (a) {
  this.parent = a;
};
mxCell.prototype.getTerminal = function (a) {
  return a ? this.source : this.target;
};
mxCell.prototype.setTerminal = function (a, b) {
  b ? (this.source = a) : (this.target = a);
  return a;
};
mxCell.prototype.getChildCount = function () {
  return null == this.children ? 0 : this.children.length;
};
mxCell.prototype.getIndex = function (a) {
  return mxUtils.indexOf(this.children, a);
};
mxCell.prototype.getChildAt = function (a) {
  return null == this.children ? null : this.children[a];
};
mxCell.prototype.insert = function (a, b) {
  null != a &&
    (null == b && ((b = this.getChildCount()), a.getParent() == this && b--),
    a.removeFromParent(),
    a.setParent(this),
    null == this.children ? ((this.children = []), this.children.push(a)) : this.children.splice(b, 0, a));
  return a;
};
mxCell.prototype.remove = function (a) {
  var b = null;
  null != this.children &&
    0 <= a &&
    ((b = this.getChildAt(a)), null != b && (this.children.splice(a, 1), b.setParent(null)));
  return b;
};
mxCell.prototype.removeFromParent = function () {
  if (null != this.parent) {
    var a = this.parent.getIndex(this);
    this.parent.remove(a);
  }
};
mxCell.prototype.getEdgeCount = function () {
  return null == this.edges ? 0 : this.edges.length;
};
mxCell.prototype.getEdgeIndex = function (a) {
  return mxUtils.indexOf(this.edges, a);
};
mxCell.prototype.getEdgeAt = function (a) {
  return null == this.edges ? null : this.edges[a];
};
mxCell.prototype.insertEdge = function (a, b) {
  null != a &&
    (a.removeFromTerminal(b),
    a.setTerminal(this, b),
    null == this.edges || a.getTerminal(!b) != this || 0 > mxUtils.indexOf(this.edges, a)) &&
    (null == this.edges && (this.edges = []), this.edges.push(a));
  return a;
};
mxCell.prototype.removeEdge = function (a, b) {
  if (null != a) {
    if (a.getTerminal(!b) != this && null != this.edges) {
      var c = this.getEdgeIndex(a);
      0 <= c && this.edges.splice(c, 1);
    }
    a.setTerminal(null, b);
  }
  return a;
};
mxCell.prototype.removeFromTerminal = function (a) {
  var b = this.getTerminal(a);
  null != b && b.removeEdge(this, a);
};
mxCell.prototype.hasAttribute = function (a) {
  var b = this.getValue();
  return null != b && b.nodeType == mxConstants.NODETYPE_ELEMENT && b.hasAttribute
    ? b.hasAttribute(a)
    : null != b.getAttribute(a);
};
mxCell.prototype.getAttribute = function (a, b) {
  var c = this.getValue(),
    c = null != c && c.nodeType == mxConstants.NODETYPE_ELEMENT ? c.getAttribute(a) : null;
  return null != c ? c : b;
};
mxCell.prototype.setAttribute = function (a, b) {
  var c = this.getValue();
  null != c && c.nodeType == mxConstants.NODETYPE_ELEMENT && c.setAttribute(a, b);
};
mxCell.prototype.clone = function () {
  var a = mxUtils.clone(this, this.mxTransient);
  a.setValue(this.cloneValue());
  return a;
};
mxCell.prototype.cloneValue = function (a) {
  a = null != a ? a : this.getValue();
  null != a && ('function' == typeof a.clone ? (a = a.clone()) : isNaN(a.nodeType) || (a = a.cloneNode(!0)));
  return a;
};
function mxGeometry(a, b, c, d) {
  mxRectangle.call(this, a, b, c, d);
}
mxGeometry.prototype = new mxRectangle();
mxGeometry.prototype.constructor = mxGeometry;
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = !0;
mxGeometry.prototype.alternateBounds = null;
mxGeometry.prototype.sourcePoint = null;
mxGeometry.prototype.targetPoint = null;
mxGeometry.prototype.points = null;
mxGeometry.prototype.offset = null;
mxGeometry.prototype.relative = !1;
mxGeometry.prototype.swap = function () {
  if (null != this.alternateBounds) {
    var a = new mxRectangle(this.x, this.y, this.width, this.height);
    this.x = this.alternateBounds.x;
    this.y = this.alternateBounds.y;
    this.width = this.alternateBounds.width;
    this.height = this.alternateBounds.height;
    this.alternateBounds = a;
  }
};
mxGeometry.prototype.getTerminalPoint = function (a) {
  return a ? this.sourcePoint : this.targetPoint;
};
mxGeometry.prototype.setTerminalPoint = function (a, b) {
  b ? (this.sourcePoint = a) : (this.targetPoint = a);
  return a;
};
mxGeometry.prototype.rotate = function (a, b) {
  var c = mxUtils.toRadians(a),
    d = Math.cos(c),
    c = Math.sin(c);
  if (!this.relative) {
    var e = new mxPoint(this.getCenterX(), this.getCenterY()),
      e = mxUtils.getRotatedPoint(e, d, c, b);
    this.x = Math.round(e.x - this.width / 2);
    this.y = Math.round(e.y - this.height / 2);
  }
  null != this.sourcePoint &&
    ((e = mxUtils.getRotatedPoint(this.sourcePoint, d, c, b)),
    (this.sourcePoint.x = Math.round(e.x)),
    (this.sourcePoint.y = Math.round(e.y)));
  null != this.targetPoint &&
    ((e = mxUtils.getRotatedPoint(this.targetPoint, d, c, b)),
    (this.targetPoint.x = Math.round(e.x)),
    (this.targetPoint.y = Math.round(e.y)));
  if (null != this.points)
    for (var f = 0; f < this.points.length; f++)
      null != this.points[f] &&
        ((e = mxUtils.getRotatedPoint(this.points[f], d, c, b)),
        (this.points[f].x = Math.round(e.x)),
        (this.points[f].y = Math.round(e.y)));
};
mxGeometry.prototype.translate = function (a, b) {
  a = parseFloat(a);
  b = parseFloat(b);
  this.relative || ((this.x = parseFloat(this.x) + a), (this.y = parseFloat(this.y) + b));
  null != this.sourcePoint &&
    ((this.sourcePoint.x = parseFloat(this.sourcePoint.x) + a),
    (this.sourcePoint.y = parseFloat(this.sourcePoint.y) + b));
  null != this.targetPoint &&
    ((this.targetPoint.x = parseFloat(this.targetPoint.x) + a),
    (this.targetPoint.y = parseFloat(this.targetPoint.y) + b));
  if (this.TRANSLATE_CONTROL_POINTS && null != this.points)
    for (var c = 0; c < this.points.length; c++)
      null != this.points[c] &&
        ((this.points[c].x = parseFloat(this.points[c].x) + a), (this.points[c].y = parseFloat(this.points[c].y) + b));
};
mxGeometry.prototype.scale = function (a, b, c) {
  a = parseFloat(a);
  b = parseFloat(b);
  null != this.sourcePoint &&
    ((this.sourcePoint.x = parseFloat(this.sourcePoint.x) * a),
    (this.sourcePoint.y = parseFloat(this.sourcePoint.y) * b));
  null != this.targetPoint &&
    ((this.targetPoint.x = parseFloat(this.targetPoint.x) * a),
    (this.targetPoint.y = parseFloat(this.targetPoint.y) * b));
  if (null != this.points)
    for (var d = 0; d < this.points.length; d++)
      null != this.points[d] &&
        ((this.points[d].x = parseFloat(this.points[d].x) * a), (this.points[d].y = parseFloat(this.points[d].y) * b));
  this.relative ||
    ((this.x = parseFloat(this.x) * a),
    (this.y = parseFloat(this.y) * b),
    c && (b = a = Math.min(a, b)),
    (this.width = parseFloat(this.width) * a),
    (this.height = parseFloat(this.height) * b));
};
mxGeometry.prototype.equals = function (a) {
  return (
    mxRectangle.prototype.equals.apply(this, arguments) &&
    this.relative == a.relative &&
    ((null == this.sourcePoint && null == a.sourcePoint) ||
      (null != this.sourcePoint && this.sourcePoint.equals(a.sourcePoint))) &&
    ((null == this.targetPoint && null == a.targetPoint) ||
      (null != this.targetPoint && this.targetPoint.equals(a.targetPoint))) &&
    ((null == this.points && null == a.points) ||
      (null != this.points && mxUtils.equalPoints(this.points, a.points))) &&
    ((null == this.alternateBounds && null == a.alternateBounds) ||
      (null != this.alternateBounds && this.alternateBounds.equals(a.alternateBounds))) &&
    ((null == this.offset && null == a.offset) || (null != this.offset && this.offset.equals(a.offset)))
  );
};
var mxCellPath = {
    PATH_SEPARATOR: '.',
    create: function (a) {
      var b = '';
      if (null != a)
        for (var c = a.getParent(); null != c; )
          (b = c.getIndex(a) + mxCellPath.PATH_SEPARATOR + b), (a = c), (c = a.getParent());
      a = b.length;
      1 < a && (b = b.substring(0, a - 1));
      return b;
    },
    getParentPath: function (a) {
      if (null != a) {
        var b = a.lastIndexOf(mxCellPath.PATH_SEPARATOR);
        if (0 <= b) return a.substring(0, b);
        if (0 < a.length) return '';
      }
      return null;
    },
    resolve: function (a, b) {
      var c = a;
      if (null != b)
        for (var d = b.split(mxCellPath.PATH_SEPARATOR), e = 0; e < d.length; e++) c = c.getChildAt(parseInt(d[e]));
      return c;
    },
    compare: function (a, b) {
      for (var c = Math.min(a.length, b.length), d = 0, e = 0; e < c; e++)
        if (a[e] != b[e]) {
          0 == a[e].length || 0 == b[e].length
            ? (d = a[e] == b[e] ? 0 : a[e] > b[e] ? 1 : -1)
            : ((c = parseInt(a[e])), (e = parseInt(b[e])), (d = c == e ? 0 : c > e ? 1 : -1));
          break;
        }
      0 == d && ((c = a.length), (e = b.length), c != e && (d = c > e ? 1 : -1));
      return d;
    },
  },
  mxPerimeter = {
    RectanglePerimeter: function (a, b, c, d) {
      b = a.getCenterX();
      var e = a.getCenterY(),
        f = Math.atan2(c.y - e, c.x - b),
        g = new mxPoint(0, 0),
        k = Math.PI,
        h = Math.PI / 2 - f,
        l = Math.atan2(a.height, a.width);
      f < -k + l || f > k - l
        ? ((g.x = a.x), (g.y = e - (a.width * Math.tan(f)) / 2))
        : f < -l
        ? ((g.y = a.y), (g.x = b - (a.height * Math.tan(h)) / 2))
        : f < l
        ? ((g.x = a.x + a.width), (g.y = e + (a.width * Math.tan(f)) / 2))
        : ((g.y = a.y + a.height), (g.x = b + (a.height * Math.tan(h)) / 2));
      d &&
        (c.x >= a.x && c.x <= a.x + a.width ? (g.x = c.x) : c.y >= a.y && c.y <= a.y + a.height && (g.y = c.y),
        c.x < a.x ? (g.x = a.x) : c.x > a.x + a.width && (g.x = a.x + a.width),
        c.y < a.y ? (g.y = a.y) : c.y > a.y + a.height && (g.y = a.y + a.height));
      return g;
    },
    EllipsePerimeter: function (a, b, c, d) {
      var e = a.x,
        f = a.y,
        g = a.width / 2,
        k = a.height / 2,
        h = e + g,
        l = f + k;
      b = c.x;
      c = c.y;
      var m = parseInt(b - h),
        n = parseInt(c - l);
      if (0 == m && 0 != n) return new mxPoint(h, l + (k * n) / Math.abs(n));
      if (0 == m && 0 == n) return new mxPoint(b, c);
      if (d) {
        if (c >= f && c <= f + a.height)
          return (
            (a = c - l),
            (a = Math.sqrt(g * g * (1 - (a * a) / (k * k))) || 0),
            b <= e && (a = -a),
            new mxPoint(h + a, c)
          );
        if (b >= e && b <= e + a.width)
          return (
            (a = b - h),
            (a = Math.sqrt(k * k * (1 - (a * a) / (g * g))) || 0),
            c <= f && (a = -a),
            new mxPoint(b, l + a)
          );
      }
      e = n / m;
      l -= e * h;
      f = g * g * e * e + k * k;
      a = -2 * h * f;
      k = Math.sqrt(a * a - 4 * f * (g * g * e * e * h * h + k * k * h * h - g * g * k * k));
      g = (-a + k) / (2 * f);
      h = (-a - k) / (2 * f);
      k = e * g + l;
      l = e * h + l;
      Math.sqrt(Math.pow(g - b, 2) + Math.pow(k - c, 2)) < Math.sqrt(Math.pow(h - b, 2) + Math.pow(l - c, 2))
        ? ((b = g), (c = k))
        : ((b = h), (c = l));
      return new mxPoint(b, c);
    },
    RhombusPerimeter: function (a, b, c, d) {
      b = a.x;
      var e = a.y,
        f = a.width;
      a = a.height;
      var g = b + f / 2,
        k = e + a / 2,
        h = c.x;
      c = c.y;
      if (g == h) return k > c ? new mxPoint(g, e) : new mxPoint(g, e + a);
      if (k == c) return g > h ? new mxPoint(b, k) : new mxPoint(b + f, k);
      var l = g,
        m = k;
      d && (h >= b && h <= b + f ? (l = h) : c >= e && c <= e + a && (m = c));
      return h < g
        ? c < k
          ? mxUtils.intersection(h, c, l, m, g, e, b, k)
          : mxUtils.intersection(h, c, l, m, g, e + a, b, k)
        : c < k
        ? mxUtils.intersection(h, c, l, m, g, e, b + f, k)
        : mxUtils.intersection(h, c, l, m, g, e + a, b + f, k);
    },
    TrianglePerimeter: function (a, b, c, d) {
      b = null != b ? b.style[mxConstants.STYLE_DIRECTION] : null;
      var e = b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_SOUTH,
        f = a.x,
        g = a.y,
        k = a.width,
        h = a.height;
      a = f + k / 2;
      var l = g + h / 2,
        m = new mxPoint(f, g),
        n = new mxPoint(f + k, l),
        p = new mxPoint(f, g + h);
      b == mxConstants.DIRECTION_NORTH
        ? ((m = p), (n = new mxPoint(a, g)), (p = new mxPoint(f + k, g + h)))
        : b == mxConstants.DIRECTION_SOUTH
        ? ((n = new mxPoint(a, g + h)), (p = new mxPoint(f + k, g)))
        : b == mxConstants.DIRECTION_WEST &&
          ((m = new mxPoint(f + k, g)), (n = new mxPoint(f, l)), (p = new mxPoint(f + k, g + h)));
      var r = c.x - a,
        t = c.y - l,
        r = e ? Math.atan2(r, t) : Math.atan2(t, r),
        t = e ? Math.atan2(k, h) : Math.atan2(h, k);
      (
        b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_WEST
          ? r > -t && r < t
          : r < -Math.PI + t || r > Math.PI - t
      )
        ? (c =
            d && ((e && c.x >= m.x && c.x <= p.x) || (!e && c.y >= m.y && c.y <= p.y))
              ? e
                ? new mxPoint(c.x, m.y)
                : new mxPoint(m.x, c.y)
              : b == mxConstants.DIRECTION_NORTH
              ? new mxPoint(f + k / 2 + (h * Math.tan(r)) / 2, g + h)
              : b == mxConstants.DIRECTION_SOUTH
              ? new mxPoint(f + k / 2 - (h * Math.tan(r)) / 2, g)
              : b == mxConstants.DIRECTION_WEST
              ? new mxPoint(f + k, g + h / 2 + (k * Math.tan(r)) / 2)
              : new mxPoint(f, g + h / 2 - (k * Math.tan(r)) / 2))
        : (d &&
            ((d = new mxPoint(a, l)),
            c.y >= g && c.y <= g + h
              ? ((d.x = e ? a : b == mxConstants.DIRECTION_WEST ? f + k : f), (d.y = c.y))
              : c.x >= f &&
                c.x <= f + k &&
                ((d.x = c.x), (d.y = e ? (b == mxConstants.DIRECTION_NORTH ? g + h : g) : l)),
            (a = d.x),
            (l = d.y)),
          (c =
            (e && c.x <= f + k / 2) || (!e && c.y <= g + h / 2)
              ? mxUtils.intersection(c.x, c.y, a, l, m.x, m.y, n.x, n.y)
              : mxUtils.intersection(c.x, c.y, a, l, n.x, n.y, p.x, p.y)));
      null == c && (c = new mxPoint(a, l));
      return c;
    },
    HexagonPerimeter: function (a, b, c, d) {
      var e = a.x,
        f = a.y,
        g = a.width,
        k = a.height,
        h = a.getCenterX();
      a = a.getCenterY();
      var l = c.x,
        m = c.y,
        n = -Math.atan2(m - a, l - h),
        p = Math.PI,
        r = Math.PI / 2;
      new mxPoint(h, a);
      b =
        null != b
          ? mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST)
          : mxConstants.DIRECTION_EAST;
      var t = b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_SOUTH;
      b = new mxPoint();
      var u = new mxPoint();
      if ((l < e && m < f) || (l < e && m > f + k) || (l > e + g && m < f) || (l > e + g && m > f + k)) d = !1;
      if (d) {
        if (t) {
          if (l == h) {
            if (m <= f) return new mxPoint(h, f);
            if (m >= f + k) return new mxPoint(h, f + k);
          } else if (l < e) {
            if (m == f + k / 4) return new mxPoint(e, f + k / 4);
            if (m == f + (3 * k) / 4) return new mxPoint(e, f + (3 * k) / 4);
          } else if (l > e + g) {
            if (m == f + k / 4) return new mxPoint(e + g, f + k / 4);
            if (m == f + (3 * k) / 4) return new mxPoint(e + g, f + (3 * k) / 4);
          } else if (l == e) {
            if (m < a) return new mxPoint(e, f + k / 4);
            if (m > a) return new mxPoint(e, f + (3 * k) / 4);
          } else if (l == e + g) {
            if (m < a) return new mxPoint(e + g, f + k / 4);
            if (m > a) return new mxPoint(e + g, f + (3 * k) / 4);
          }
          if (m == f) return new mxPoint(h, f);
          if (m == f + k) return new mxPoint(h, f + k);
          l < h
            ? m > f + k / 4 && m < f + (3 * k) / 4
              ? ((b = new mxPoint(e, f)), (u = new mxPoint(e, f + k)))
              : m < f + k / 4
              ? ((b = new mxPoint(e - Math.floor(0.5 * g), f + Math.floor(0.5 * k))),
                (u = new mxPoint(e + g, f - Math.floor(0.25 * k))))
              : m > f + (3 * k) / 4 &&
                ((b = new mxPoint(e - Math.floor(0.5 * g), f + Math.floor(0.5 * k))),
                (u = new mxPoint(e + g, f + Math.floor(1.25 * k))))
            : l > h &&
              (m > f + k / 4 && m < f + (3 * k) / 4
                ? ((b = new mxPoint(e + g, f)), (u = new mxPoint(e + g, f + k)))
                : m < f + k / 4
                ? ((b = new mxPoint(e, f - Math.floor(0.25 * k))),
                  (u = new mxPoint(e + Math.floor(1.5 * g), f + Math.floor(0.5 * k))))
                : m > f + (3 * k) / 4 &&
                  ((b = new mxPoint(e + Math.floor(1.5 * g), f + Math.floor(0.5 * k))),
                  (u = new mxPoint(e, f + Math.floor(1.25 * k)))));
        } else {
          if (m == a) {
            if (l <= e) return new mxPoint(e, f + k / 2);
            if (l >= e + g) return new mxPoint(e + g, f + k / 2);
          } else if (m < f) {
            if (l == e + g / 4) return new mxPoint(e + g / 4, f);
            if (l == e + (3 * g) / 4) return new mxPoint(e + (3 * g) / 4, f);
          } else if (m > f + k) {
            if (l == e + g / 4) return new mxPoint(e + g / 4, f + k);
            if (l == e + (3 * g) / 4) return new mxPoint(e + (3 * g) / 4, f + k);
          } else if (m == f) {
            if (l < h) return new mxPoint(e + g / 4, f);
            if (l > h) return new mxPoint(e + (3 * g) / 4, f);
          } else if (m == f + k) {
            if (l < h) return new mxPoint(e + g / 4, f + k);
            if (m > a) return new mxPoint(e + (3 * g) / 4, f + k);
          }
          if (l == e) return new mxPoint(e, a);
          if (l == e + g) return new mxPoint(e + g, a);
          m < a
            ? l > e + g / 4 && l < e + (3 * g) / 4
              ? ((b = new mxPoint(e, f)), (u = new mxPoint(e + g, f)))
              : l < e + g / 4
              ? ((b = new mxPoint(e - Math.floor(0.25 * g), f + k)),
                (u = new mxPoint(e + Math.floor(0.5 * g), f - Math.floor(0.5 * k))))
              : l > e + (3 * g) / 4 &&
                ((b = new mxPoint(e + Math.floor(0.5 * g), f - Math.floor(0.5 * k))),
                (u = new mxPoint(e + Math.floor(1.25 * g), f + k)))
            : m > a &&
              (l > e + g / 4 && l < e + (3 * g) / 4
                ? ((b = new mxPoint(e, f + k)), (u = new mxPoint(e + g, f + k)))
                : l < e + g / 4
                ? ((b = new mxPoint(e - Math.floor(0.25 * g), f)),
                  (u = new mxPoint(e + Math.floor(0.5 * g), f + Math.floor(1.5 * k))))
                : l > e + (3 * g) / 4 &&
                  ((b = new mxPoint(e + Math.floor(0.5 * g), f + Math.floor(1.5 * k))),
                  (u = new mxPoint(e + Math.floor(1.25 * g), f))));
        }
        d = h;
        n = a;
        l >= e && l <= e + g
          ? ((d = l), (n = m < a ? f + k : f))
          : m >= f && m <= f + k && ((n = m), (d = l < h ? e + g : e));
        c = mxUtils.intersection(d, n, c.x, c.y, b.x, b.y, u.x, u.y);
      } else {
        if (t) {
          l = Math.atan2(k / 4, g / 2);
          if (n == l) return new mxPoint(e + g, f + Math.floor(0.25 * k));
          if (n == r) return new mxPoint(e + Math.floor(0.5 * g), f);
          if (n == p - l) return new mxPoint(e, f + Math.floor(0.25 * k));
          if (n == -l) return new mxPoint(e + g, f + Math.floor(0.75 * k));
          if (n == -r) return new mxPoint(e + Math.floor(0.5 * g), f + k);
          if (n == -p + l) return new mxPoint(e, f + Math.floor(0.75 * k));
          n < l && n > -l
            ? ((b = new mxPoint(e + g, f)), (u = new mxPoint(e + g, f + k)))
            : n > l && n < r
            ? ((b = new mxPoint(e, f - Math.floor(0.25 * k))),
              (u = new mxPoint(e + Math.floor(1.5 * g), f + Math.floor(0.5 * k))))
            : n > r && n < p - l
            ? ((b = new mxPoint(e - Math.floor(0.5 * g), f + Math.floor(0.5 * k))),
              (u = new mxPoint(e + g, f - Math.floor(0.25 * k))))
            : (n > p - l && n <= p) || (n < -p + l && n >= -p)
            ? ((b = new mxPoint(e, f)), (u = new mxPoint(e, f + k)))
            : n < -l && n > -r
            ? ((b = new mxPoint(e + Math.floor(1.5 * g), f + Math.floor(0.5 * k))),
              (u = new mxPoint(e, f + Math.floor(1.25 * k))))
            : n < -r &&
              n > -p + l &&
              ((b = new mxPoint(e - Math.floor(0.5 * g), f + Math.floor(0.5 * k))),
              (u = new mxPoint(e + g, f + Math.floor(1.25 * k))));
        } else {
          l = Math.atan2(k / 2, g / 4);
          if (n == l) return new mxPoint(e + Math.floor(0.75 * g), f);
          if (n == p - l) return new mxPoint(e + Math.floor(0.25 * g), f);
          if (n == p || n == -p) return new mxPoint(e, f + Math.floor(0.5 * k));
          if (0 == n) return new mxPoint(e + g, f + Math.floor(0.5 * k));
          if (n == -l) return new mxPoint(e + Math.floor(0.75 * g), f + k);
          if (n == -p + l) return new mxPoint(e + Math.floor(0.25 * g), f + k);
          0 < n && n < l
            ? ((b = new mxPoint(e + Math.floor(0.5 * g), f - Math.floor(0.5 * k))),
              (u = new mxPoint(e + Math.floor(1.25 * g), f + k)))
            : n > l && n < p - l
            ? ((b = new mxPoint(e, f)), (u = new mxPoint(e + g, f)))
            : n > p - l && n < p
            ? ((b = new mxPoint(e - Math.floor(0.25 * g), f + k)),
              (u = new mxPoint(e + Math.floor(0.5 * g), f - Math.floor(0.5 * k))))
            : 0 > n && n > -l
            ? ((b = new mxPoint(e + Math.floor(0.5 * g), f + Math.floor(1.5 * k))),
              (u = new mxPoint(e + Math.floor(1.25 * g), f)))
            : n < -l && n > -p + l
            ? ((b = new mxPoint(e, f + k)), (u = new mxPoint(e + g, f + k)))
            : n < -p + l &&
              n > -p &&
              ((b = new mxPoint(e - Math.floor(0.25 * g), f)),
              (u = new mxPoint(e + Math.floor(0.5 * g), f + Math.floor(1.5 * k))));
        }
        c = mxUtils.intersection(h, a, c.x, c.y, b.x, b.y, u.x, u.y);
      }
      return null == c ? new mxPoint(h, a) : c;
    },
  };
function mxStylesheet() {
  this.styles = {};
  this.putDefaultVertexStyle(this.createDefaultVertexStyle());
  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}
mxStylesheet.prototype.createDefaultVertexStyle = function () {
  var a = {};
  a[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
  a[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
  a[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  a[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  a[mxConstants.STYLE_FILLCOLOR] = '#C3D9FF';
  a[mxConstants.STYLE_STROKECOLOR] = '#6482B9';
  a[mxConstants.STYLE_FONTCOLOR] = '#774400';
  return a;
};
mxStylesheet.prototype.createDefaultEdgeStyle = function () {
  var a = {};
  a[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
  a[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
  a[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
  a[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
  a[mxConstants.STYLE_STROKECOLOR] = '#6482B9';
  a[mxConstants.STYLE_FONTCOLOR] = '#446299';
  return a;
};
mxStylesheet.prototype.putDefaultVertexStyle = function (a) {
  this.putCellStyle('defaultVertex', a);
};
mxStylesheet.prototype.putDefaultEdgeStyle = function (a) {
  this.putCellStyle('defaultEdge', a);
};
mxStylesheet.prototype.getDefaultVertexStyle = function () {
  return this.styles.defaultVertex;
};
mxStylesheet.prototype.getDefaultEdgeStyle = function () {
  return this.styles.defaultEdge;
};
mxStylesheet.prototype.putCellStyle = function (a, b) {
  this.styles[a] = b;
};
mxStylesheet.prototype.getCellStyle = function (a, b, c) {
  c = null != c ? c : !0;
  if (null != a && 0 < a.length) {
    var d = a.split(';');
    b = null != b && ';' != a.charAt(0) ? mxUtils.clone(b) : {};
    for (a = 0; a < d.length; a++) {
      var e = d[a],
        f = e.indexOf('=');
      if (0 <= f) {
        var g = e.substring(0, f),
          e = e.substring(f + 1);
        e == mxConstants.NONE && c ? delete b[g] : mxUtils.isNumeric(e) ? (b[g] = parseFloat(e)) : (b[g] = e);
      } else if (((e = this.styles[e]), null != e)) for (g in e) b[g] = e[g];
    }
  }
  return b;
};
function mxCellState(a, b, c) {
  this.view = a;
  this.cell = b;
  this.style = null != c ? c : {};
  this.origin = new mxPoint();
  this.absoluteOffset = new mxPoint();
}
mxCellState.prototype = new mxRectangle();
mxCellState.prototype.constructor = mxCellState;
mxCellState.prototype.view = null;
mxCellState.prototype.cell = null;
mxCellState.prototype.style = null;
mxCellState.prototype.invalidStyle = !1;
mxCellState.prototype.invalid = !0;
mxCellState.prototype.origin = null;
mxCellState.prototype.absolutePoints = null;
mxCellState.prototype.absoluteOffset = null;
mxCellState.prototype.visibleSourceState = null;
mxCellState.prototype.visibleTargetState = null;
mxCellState.prototype.terminalDistance = 0;
mxCellState.prototype.length = 0;
mxCellState.prototype.segments = null;
mxCellState.prototype.shape = null;
mxCellState.prototype.text = null;
mxCellState.prototype.unscaledWidth = null;
mxCellState.prototype.unscaledHeight = null;
mxCellState.prototype.getPerimeterBounds = function (a, b) {
  a = a || 0;
  b = null != b ? b : new mxRectangle(this.x, this.y, this.width, this.height);
  if (null != this.shape && null != this.shape.stencil && 'fixed' == this.shape.stencil.aspect) {
    var c = this.shape.stencil.computeAspect(this.style, b.x, b.y, b.width, b.height);
    b.x = c.x;
    b.y = c.y;
    b.width = this.shape.stencil.w0 * c.width;
    b.height = this.shape.stencil.h0 * c.height;
  }
  0 != a && b.grow(a);
  return b;
};
mxCellState.prototype.setAbsoluteTerminalPoint = function (a, b) {
  b
    ? (null == this.absolutePoints && (this.absolutePoints = []),
      0 == this.absolutePoints.length ? this.absolutePoints.push(a) : (this.absolutePoints[0] = a))
    : null == this.absolutePoints
    ? ((this.absolutePoints = []), this.absolutePoints.push(null), this.absolutePoints.push(a))
    : 1 == this.absolutePoints.length
    ? this.absolutePoints.push(a)
    : (this.absolutePoints[this.absolutePoints.length - 1] = a);
};
mxCellState.prototype.setCursor = function (a) {
  null != this.shape && this.shape.setCursor(a);
  null != this.text && this.text.setCursor(a);
};
mxCellState.prototype.isFloatingTerminalPoint = function (a) {
  var b = this.getVisibleTerminalState(a);
  if (null == b) return !1;
  a = this.view.graph.getConnectionConstraint(this, b, a);
  return null == a || null == a.point;
};
mxCellState.prototype.getVisibleTerminal = function (a) {
  a = this.getVisibleTerminalState(a);
  return null != a ? a.cell : null;
};
mxCellState.prototype.getVisibleTerminalState = function (a) {
  return a ? this.visibleSourceState : this.visibleTargetState;
};
mxCellState.prototype.setVisibleTerminalState = function (a, b) {
  b ? (this.visibleSourceState = a) : (this.visibleTargetState = a);
};
mxCellState.prototype.getCellBounds = function () {
  return this.cellBounds;
};
mxCellState.prototype.getPaintBounds = function () {
  return this.paintBounds;
};
mxCellState.prototype.updateCachedBounds = function () {
  var a = this.view.translate,
    b = this.view.scale;
  this.cellBounds = new mxRectangle(this.x / b - a.x, this.y / b - a.y, this.width / b, this.height / b);
  this.paintBounds = mxRectangle.fromRectangle(this.cellBounds);
  null != this.shape && this.shape.isPaintBoundsInverted() && this.paintBounds.rotate90();
};
mxCellState.prototype.setState = function (a) {
  this.view = a.view;
  this.cell = a.cell;
  this.style = a.style;
  this.absolutePoints = a.absolutePoints;
  this.origin = a.origin;
  this.absoluteOffset = a.absoluteOffset;
  this.boundingBox = a.boundingBox;
  this.terminalDistance = a.terminalDistance;
  this.segments = a.segments;
  this.length = a.length;
  this.x = a.x;
  this.y = a.y;
  this.width = a.width;
  this.height = a.height;
  this.unscaledWidth = a.unscaledWidth;
  this.unscaledHeight = a.unscaledHeight;
};
mxCellState.prototype.clone = function () {
  var a = new mxCellState(this.view, this.cell, this.style);
  if (null != this.absolutePoints) {
    a.absolutePoints = [];
    for (var b = 0; b < this.absolutePoints.length; b++) a.absolutePoints[b] = this.absolutePoints[b].clone();
  }
  null != this.origin && (a.origin = this.origin.clone());
  null != this.absoluteOffset && (a.absoluteOffset = this.absoluteOffset.clone());
  null != this.boundingBox && (a.boundingBox = this.boundingBox.clone());
  a.terminalDistance = this.terminalDistance;
  a.segments = this.segments;
  a.length = this.length;
  a.x = this.x;
  a.y = this.y;
  a.width = this.width;
  a.height = this.height;
  a.unscaledWidth = this.unscaledWidth;
  a.unscaledHeight = this.unscaledHeight;
  return a;
};
mxCellState.prototype.destroy = function () {
  this.view.graph.cellRenderer.destroy(this);
};
function mxGraphSelectionModel(a) {
  this.graph = a;
  this.cells = [];
}
mxGraphSelectionModel.prototype = new mxEventSource();
mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;
mxGraphSelectionModel.prototype.doneResource = 'none' != mxClient.language ? 'done' : '';
mxGraphSelectionModel.prototype.updatingSelectionResource = 'none' != mxClient.language ? 'updatingSelection' : '';
mxGraphSelectionModel.prototype.graph = null;
mxGraphSelectionModel.prototype.singleSelection = !1;
mxGraphSelectionModel.prototype.isSingleSelection = function () {
  return this.singleSelection;
};
mxGraphSelectionModel.prototype.setSingleSelection = function (a) {
  this.singleSelection = a;
};
mxGraphSelectionModel.prototype.isSelected = function (a) {
  return null != a ? 0 <= mxUtils.indexOf(this.cells, a) : !1;
};
mxGraphSelectionModel.prototype.isEmpty = function () {
  return 0 == this.cells.length;
};
mxGraphSelectionModel.prototype.clear = function () {
  this.changeSelection(null, this.cells);
};
mxGraphSelectionModel.prototype.setCell = function (a) {
  null != a && this.setCells([a]);
};
mxGraphSelectionModel.prototype.setCells = function (a) {
  if (null != a) {
    this.singleSelection && (a = [this.getFirstSelectableCell(a)]);
    for (var b = [], c = 0; c < a.length; c++) this.graph.isCellSelectable(a[c]) && b.push(a[c]);
    this.changeSelection(b, this.cells);
  }
};
mxGraphSelectionModel.prototype.getFirstSelectableCell = function (a) {
  if (null != a) for (var b = 0; b < a.length; b++) if (this.graph.isCellSelectable(a[b])) return a[b];
  return null;
};
mxGraphSelectionModel.prototype.addCell = function (a) {
  null != a && this.addCells([a]);
};
mxGraphSelectionModel.prototype.addCells = function (a) {
  if (null != a) {
    var b = null;
    this.singleSelection && ((b = this.cells), (a = [this.getFirstSelectableCell(a)]));
    for (var c = [], d = 0; d < a.length; d++)
      !this.isSelected(a[d]) && this.graph.isCellSelectable(a[d]) && c.push(a[d]);
    this.changeSelection(c, b);
  }
};
mxGraphSelectionModel.prototype.removeCell = function (a) {
  null != a && this.removeCells([a]);
};
mxGraphSelectionModel.prototype.removeCells = function (a) {
  if (null != a) {
    for (var b = [], c = 0; c < a.length; c++) this.isSelected(a[c]) && b.push(a[c]);
    this.changeSelection(null, b);
  }
};
mxGraphSelectionModel.prototype.changeSelection = function (a, b) {
  if ((null != a && 0 < a.length && null != a[0]) || (null != b && 0 < b.length && null != b[0])) {
    var c = new mxSelectionChange(this, a, b);
    c.execute();
    var d = new mxUndoableEdit(this, !1);
    d.add(c);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', d));
  }
};
mxGraphSelectionModel.prototype.cellAdded = function (a) {
  null == a || this.isSelected(a) || this.cells.push(a);
};
mxGraphSelectionModel.prototype.cellRemoved = function (a) {
  null != a && ((a = mxUtils.indexOf(this.cells, a)), 0 <= a && this.cells.splice(a, 1));
};
function mxSelectionChange(a, b, c) {
  this.selectionModel = a;
  this.added = null != b ? b.slice() : null;
  this.removed = null != c ? c.slice() : null;
}
mxSelectionChange.prototype.execute = function () {
  var a = mxLog.enter('mxSelectionChange.execute');
  window.status =
    mxResources.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;
  if (null != this.removed)
    for (var b = 0; b < this.removed.length; b++) this.selectionModel.cellRemoved(this.removed[b]);
  if (null != this.added) for (b = 0; b < this.added.length; b++) this.selectionModel.cellAdded(this.added[b]);
  b = this.added;
  this.added = this.removed;
  this.removed = b;
  window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource;
  mxLog.leave('mxSelectionChange.execute', a);
  this.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE, 'added', this.added, 'removed', this.removed));
};
function mxCellEditor(a) {
  this.graph = a;
  this.zoomHandler = mxUtils.bind(this, function () {
    this.graph.isEditing() && this.resize();
  });
  this.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
  this.changeHandler = mxUtils.bind(this, function (a) {
    null != this.editingCell &&
      ((a = this.graph.getView().getState(this.editingCell)),
      null == a ? this.stopEditing(!0) : this.updateTextAreaStyle(a));
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
}
mxCellEditor.prototype.graph = null;
mxCellEditor.prototype.textarea = null;
mxCellEditor.prototype.editingCell = null;
mxCellEditor.prototype.trigger = null;
mxCellEditor.prototype.modified = !1;
mxCellEditor.prototype.autoSize = !0;
mxCellEditor.prototype.selectText = !0;
mxCellEditor.prototype.emptyLabelText = mxClient.IS_FF ? '<br>' : '';
mxCellEditor.prototype.escapeCancelsEditing = !0;
mxCellEditor.prototype.textNode = '';
mxCellEditor.prototype.zIndex = 5;
mxCellEditor.prototype.minResize = new mxRectangle(0, 20);
mxCellEditor.prototype.wordWrapPadding = mxClient.IS_IE11 ? 0 : 1;
mxCellEditor.prototype.blurEnabled = !1;
mxCellEditor.prototype.initialValue = null;
mxCellEditor.prototype.align = null;
mxCellEditor.prototype.init = function () {
  this.textarea = document.createElement('div');
  this.textarea.className = 'mxCellEditor mxPlainTextEditor';
  this.textarea.contentEditable = !0;
  mxClient.IS_GC && (this.textarea.style.minHeight = '1em');
  this.textarea.style.position = this.isLegacyEditor() ? 'absolute' : 'relative';
  this.installListeners(this.textarea);
};
mxCellEditor.prototype.applyValue = function (a, b) {
  this.graph.labelChanged(a.cell, b, this.trigger);
};
mxCellEditor.prototype.setAlign = function (a) {
  null != this.textarea && (this.textarea.style.textAlign = a);
  this.align = a;
  this.resize();
};
mxCellEditor.prototype.getInitialValue = function (a, b) {
  var c = mxUtils.htmlEntities(this.graph.getEditingValue(a.cell, b), !1);
  8 != document.documentMode &&
    9 != document.documentMode &&
    10 != document.documentMode &&
    (c = mxUtils.replaceTrailingNewlines(c, '<div><br></div>'));
  return c.replace(/\n/g, '<br>');
};
mxCellEditor.prototype.getCurrentValue = function (a) {
  return mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
};
mxCellEditor.prototype.isCancelEditingKeyEvent = function (a) {
  return this.escapeCancelsEditing || mxEvent.isShiftDown(a) || mxEvent.isControlDown(a) || mxEvent.isMetaDown(a);
};
mxCellEditor.prototype.installListeners = function (a) {
  mxEvent.addListener(
    a,
    'dragstart',
    mxUtils.bind(this, function (a) {
      this.graph.stopEditing(!1);
      mxEvent.consume(a);
    })
  );
  mxEvent.addListener(
    a,
    'blur',
    mxUtils.bind(this, function (a) {
      this.blurEnabled && this.focusLost(a);
    })
  );
  mxEvent.addListener(
    a,
    'keydown',
    mxUtils.bind(this, function (a) {
      mxEvent.isConsumed(a) ||
        (this.isStopEditingEvent(a)
          ? (this.graph.stopEditing(!1), mxEvent.consume(a))
          : 27 == a.keyCode && (this.graph.stopEditing(this.isCancelEditingKeyEvent(a)), mxEvent.consume(a)));
    })
  );
  var b = mxUtils.bind(this, function (b) {
    null != this.editingCell &&
      this.clearOnChange &&
      a.innerHTML == this.getEmptyLabelText() &&
      (!mxClient.IS_FF || (8 != b.keyCode && 46 != b.keyCode)) &&
      ((this.clearOnChange = !1), (a.innerHTML = ''));
  });
  mxEvent.addListener(a, 'keypress', b);
  mxEvent.addListener(a, 'paste', b);
  b = mxUtils.bind(this, function (a) {
    null != this.editingCell &&
      (0 == this.textarea.innerHTML.length || '<br>' == this.textarea.innerHTML
        ? ((this.textarea.innerHTML = this.getEmptyLabelText()),
          (this.clearOnChange = 0 < this.textarea.innerHTML.length))
        : (this.clearOnChange = !1));
  });
  mxEvent.addListener(a, mxClient.IS_IE11 || mxClient.IS_IE ? 'keyup' : 'input', b);
  mxEvent.addListener(a, 'cut', b);
  mxEvent.addListener(a, 'paste', b);
  var b = mxClient.IS_IE11 || mxClient.IS_IE ? 'keydown' : 'input',
    c = mxUtils.bind(this, function (a) {
      null != this.editingCell &&
        this.autoSize &&
        !mxEvent.isConsumed(a) &&
        (null != this.resizeThread && window.clearTimeout(this.resizeThread),
        (this.resizeThread = window.setTimeout(
          mxUtils.bind(this, function () {
            this.resizeThread = null;
            this.resize();
          }),
          0
        )));
    });
  mxEvent.addListener(a, b, c);
  mxEvent.addListener(window, 'resize', c);
  9 <= document.documentMode
    ? (mxEvent.addListener(a, 'DOMNodeRemoved', c), mxEvent.addListener(a, 'DOMNodeInserted', c))
    : (mxEvent.addListener(a, 'cut', c), mxEvent.addListener(a, 'paste', c));
};
mxCellEditor.prototype.isStopEditingEvent = function (a) {
  return (
    113 == a.keyCode ||
    (this.graph.isEnterStopsCellEditing() && 13 == a.keyCode && !mxEvent.isControlDown(a) && !mxEvent.isShiftDown(a))
  );
};
mxCellEditor.prototype.isEventSource = function (a) {
  return mxEvent.getSource(a) == this.textarea;
};
mxCellEditor.prototype.resize = function () {
  var a = this.graph.getView().getState(this.editingCell);
  if (null == a) this.stopEditing(!0);
  else if (null != this.textarea) {
    var b = this.graph.getModel().isEdge(a.cell),
      c = this.graph.getView().scale,
      d = null;
    if (this.autoSize && 'fill' != a.style[mxConstants.STYLE_OVERFLOW]) {
      var e = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_WIDTH, null),
        d = null != a.text && null == this.align ? a.text.margin : null;
      null == d &&
        (d = mxUtils.getAlignmentAsPoint(
          this.align || mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),
          mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE)
        ));
      if (b)
        (this.bounds = new mxRectangle(a.absoluteOffset.x, a.absoluteOffset.y, 0, 0)),
          null != e && ((e = (parseFloat(e) + 2) * c), (this.bounds.width = e), (this.bounds.x += d.x * e));
      else {
        var b = mxRectangle.fromRectangle(a),
          f = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER),
          g = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE),
          b =
            null != a.shape && f == mxConstants.ALIGN_CENTER && g == mxConstants.ALIGN_MIDDLE
              ? a.shape.getLabelBounds(b)
              : b;
        null != e && (b.width = parseFloat(e) * c);
        if (
          !a.view.graph.cellRenderer.legacySpacing ||
          ('width' != a.style[mxConstants.STYLE_OVERFLOW] && 'block' != a.style[mxConstants.STYLE_OVERFLOW])
        )
          var f = parseInt(a.style[mxConstants.STYLE_SPACING] || 2) * c,
            k = (parseInt(a.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * c + f,
            h = (parseInt(a.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * c + f,
            l = (parseInt(a.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * c + f,
            m = (parseInt(a.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * c + f,
            f = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER),
            g = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE),
            b = new mxRectangle(
              b.x + m,
              b.y + k,
              b.width - (f == mxConstants.ALIGN_CENTER && null == e ? m + h : 0),
              b.height - (g == mxConstants.ALIGN_MIDDLE ? k + l : 0)
            );
        this.bounds = new mxRectangle(b.x + a.absoluteOffset.x, b.y + a.absoluteOffset.y, b.width, b.height);
      }
      if (
        this.graph.isWrapping(a.cell) &&
        (2 <= this.bounds.width || 2 <= this.bounds.height) &&
        this.textarea.innerHTML != this.getEmptyLabelText()
      )
        if (
          ((this.textarea.style.wordWrap = mxConstants.WORD_WRAP),
          (this.textarea.style.whiteSpace = 'normal'),
          (e = Math.round(this.bounds.width / c) + this.wordWrapPadding),
          'relative' != this.textarea.style.position)
        )
          (this.textarea.style.width = e + 'px'),
            this.textarea.scrollWidth > e && (this.textarea.style.width = this.textarea.scrollWidth + 'px');
        else if ('block' == a.style[mxConstants.STYLE_OVERFLOW] || 'width' == a.style[mxConstants.STYLE_OVERFLOW]) {
          if (-0.5 == d.y || 'width' == a.style[mxConstants.STYLE_OVERFLOW])
            this.textarea.style.maxHeight = this.bounds.height + 'px';
          this.textarea.style.width = e + 'px';
        } else this.textarea.style.maxWidth = e + 'px';
      else (this.textarea.style.whiteSpace = 'nowrap'), (this.textarea.style.width = '');
      8 == document.documentMode && ((this.textarea.style.zoom = '1'), (this.textarea.style.height = 'auto'));
      8 == document.documentMode
        ? ((a = this.textarea.scrollWidth),
          (e = this.textarea.scrollHeight),
          (this.textarea.style.left =
            Math.max(
              0,
              Math.ceil(
                (this.bounds.x - d.x * (this.bounds.width - (a + 1) * c) + a * (c - 1) * 0 + 2 * (d.x + 0.5)) / c
              )
            ) + 'px'),
          (this.textarea.style.top =
            Math.max(
              0,
              Math.ceil(
                (this.bounds.y -
                  d.y * (this.bounds.height - (e + 0.5) * c) +
                  e * (c - 1) * 0 +
                  1 * Math.abs(d.y + 0.5)) /
                  c
              )
            ) + 'px'),
          (this.textarea.style.width = Math.round(a * c) + 'px'),
          (this.textarea.style.height = Math.round(e * c) + 'px'))
        : ((this.textarea.style.left =
            Math.max(0, Math.round(this.bounds.x - d.x * (this.bounds.width - 2)) + 1) + 'px'),
          (this.textarea.style.top =
            Math.max(0, Math.round(this.bounds.y - d.y * (this.bounds.height - 4) + (-1 == d.y ? 3 : 0)) + 1) + 'px'));
    } else
      (this.bounds = this.getEditorBounds(a)),
        (this.textarea.style.width = Math.round(this.bounds.width / c) + 'px'),
        (this.textarea.style.height = Math.round(this.bounds.height / c) + 'px'),
        8 == document.documentMode
          ? ((this.textarea.style.left = Math.round(this.bounds.x) + 'px'),
            (this.textarea.style.top = Math.round(this.bounds.y) + 'px'))
          : ((this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + 'px'),
            (this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + 'px')),
        this.graph.isWrapping(a.cell) &&
        (2 <= this.bounds.width || 2 <= this.bounds.height) &&
        this.textarea.innerHTML != this.getEmptyLabelText()
          ? ((this.textarea.style.wordWrap = mxConstants.WORD_WRAP),
            (this.textarea.style.whiteSpace = 'normal'),
            'fill' != a.style[mxConstants.STYLE_OVERFLOW] &&
              (this.textarea.style.width = Math.round(this.bounds.width / c) + this.wordWrapPadding + 'px'))
          : ((this.textarea.style.whiteSpace = 'nowrap'),
            'fill' != a.style[mxConstants.STYLE_OVERFLOW] && (this.textarea.style.width = ''));
    mxUtils.setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');
    mxUtils.setPrefixedStyle(
      this.textarea.style,
      'transform',
      'scale(' + c + ',' + c + ')' + (null == d ? '' : ' translate(' + 100 * d.x + '%,' + 100 * d.y + '%)')
    );
  }
};
mxCellEditor.prototype.focusLost = function () {
  this.stopEditing(!this.graph.isInvokesStopCellEditing());
};
mxCellEditor.prototype.getBackgroundColor = function (a) {
  return null;
};
mxCellEditor.prototype.getBorderColor = function (a) {
  return null;
};
mxCellEditor.prototype.isLegacyEditor = function () {
  var a = !1;
  if (mxClient.IS_SVG) {
    var b = this.graph.view.getDrawPane().ownerSVGElement;
    null != b && ((b = mxUtils.getCurrentStyle(b)), null != b && (a = 'absolute' == b.position));
  }
  return !a;
};
mxCellEditor.prototype.updateTextAreaStyle = function (a) {
  this.graph.getView();
  var b = mxUtils.getValue(a.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE),
    c = mxUtils.getValue(a.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY),
    d = mxUtils.getValue(a.style, mxConstants.STYLE_FONTCOLOR, 'black'),
    e = mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT),
    f = (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD,
    g =
      (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC,
    k = [];
  (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) ==
    mxConstants.FONT_UNDERLINE && k.push('underline');
  (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) ==
    mxConstants.FONT_STRIKETHROUGH && k.push('line-through');
  this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT
    ? Math.round(b * mxConstants.LINE_HEIGHT) + 'px'
    : mxConstants.LINE_HEIGHT;
  this.textarea.style.backgroundColor = this.getBackgroundColor(a);
  this.textarea.style.textDecoration = k.join(' ');
  this.textarea.style.fontWeight = f ? 'bold' : 'normal';
  this.textarea.style.fontStyle = g ? 'italic' : '';
  this.textarea.style.fontSize = Math.round(b) + 'px';
  this.textarea.style.zIndex = this.zIndex;
  this.textarea.style.fontFamily = c;
  this.textarea.style.textAlign = e;
  this.textarea.style.outline = 'none';
  this.textarea.style.color = d;
  b = this.getBorderColor(a);
  this.textarea.style.border = null != b ? '1px solid ' + b : 'none';
  b = this.textDirection = mxUtils.getValue(
    a.style,
    mxConstants.STYLE_TEXT_DIRECTION,
    mxConstants.DEFAULT_TEXT_DIRECTION
  );
  b == mxConstants.TEXT_DIRECTION_AUTO &&
    (null == a ||
      null == a.text ||
      a.text.dialect == mxConstants.DIALECT_STRICTHTML ||
      mxUtils.isNode(a.text.value) ||
      (b = a.text.getAutoDirection()));
  b == mxConstants.TEXT_DIRECTION_LTR || b == mxConstants.TEXT_DIRECTION_RTL
    ? this.textarea.setAttribute('dir', b)
    : this.textarea.removeAttribute('dir');
};
mxCellEditor.prototype.startEditing = function (a, b) {
  this.stopEditing(!0);
  this.align = null;
  null == this.textarea && this.init();
  null != this.graph.tooltipHandler && this.graph.tooltipHandler.hideTooltip();
  var c = this.graph.getView().getState(a);
  if (null != c) {
    this.updateTextAreaStyle(c);
    this.textarea.innerHTML = this.getInitialValue(c, b) || '';
    this.initialValue = this.textarea.innerHTML;
    0 == this.textarea.innerHTML.length || '<br>' == this.textarea.innerHTML
      ? ((this.textarea.innerHTML = this.getEmptyLabelText()), (this.clearOnChange = !0))
      : (this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText());
    this.graph.container.appendChild(this.textarea);
    this.editingCell = a;
    this.trigger = b;
    this.textNode = null;
    null != c.text &&
      this.isHideLabel(c) &&
      ((this.textNode = c.text.node), (this.textNode.style.visibility = 'hidden'));
    this.autoSize &&
      (this.graph.model.isEdge(c.cell) || 'fill' != c.style[mxConstants.STYLE_OVERFLOW]) &&
      window.setTimeout(
        mxUtils.bind(this, function () {
          this.resize();
        }),
        0
      );
    this.resize();
    try {
      this.textarea.focus(),
        this.isSelectText() &&
          0 < this.textarea.innerHTML.length &&
          (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange) &&
          document.execCommand('selectAll', !1, null);
    } catch (d) {}
  }
};
mxCellEditor.prototype.isSelectText = function () {
  return this.selectText;
};
mxCellEditor.prototype.clearSelection = function () {
  var a = null;
  window.getSelection ? (a = window.getSelection()) : document.selection && (a = document.selection);
  null != a && (a.empty ? a.empty() : a.removeAllRanges && a.removeAllRanges());
};
mxCellEditor.prototype.stopEditing = function (a) {
  if (null != this.editingCell) {
    null != this.textNode && ((this.textNode.style.visibility = 'visible'), (this.textNode = null));
    a = a ? null : this.graph.view.getState(this.editingCell);
    var b = this.initialValue;
    this.bounds = this.trigger = this.editingCell = this.initialValue = null;
    this.textarea.blur();
    this.clearSelection();
    null != this.textarea.parentNode && this.textarea.parentNode.removeChild(this.textarea);
    this.clearOnChange &&
      this.textarea.innerHTML == this.getEmptyLabelText() &&
      ((this.textarea.innerHTML = ''), (this.clearOnChange = !1));
    if (null != a && (this.textarea.innerHTML != b || null != this.align)) {
      this.prepareTextarea();
      b = this.getCurrentValue(a);
      this.graph.getModel().beginUpdate();
      try {
        null != b && this.applyValue(a, b),
          null != this.align && this.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [a.cell]);
      } finally {
        this.graph.getModel().endUpdate();
      }
    }
    mxEvent.release(this.textarea);
    this.align = this.textarea = null;
  }
};
mxCellEditor.prototype.prepareTextarea = function () {
  null != this.textarea.lastChild &&
    'BR' == this.textarea.lastChild.nodeName &&
    this.textarea.removeChild(this.textarea.lastChild);
};
mxCellEditor.prototype.isHideLabel = function (a) {
  return !0;
};
mxCellEditor.prototype.getMinimumSize = function (a) {
  var b = this.graph.getView().scale;
  return new mxRectangle(
    0,
    0,
    null == a.text ? 30 : a.text.size * b + 20,
    'left' == this.textarea.style.textAlign ? 120 : 40
  );
};
mxCellEditor.prototype.getEditorBounds = function (a) {
  var b = this.graph.getModel().isEdge(a.cell),
    c = this.graph.getView().scale,
    d = this.getMinimumSize(a),
    e = d.width,
    d = d.height;
  if (!b && a.view.graph.cellRenderer.legacySpacing && 'fill' == a.style[mxConstants.STYLE_OVERFLOW])
    c = a.shape.getLabelBounds(mxRectangle.fromRectangle(a));
  else {
    var f = parseInt(a.style[mxConstants.STYLE_SPACING] || 0) * c,
      g = (parseInt(a.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * c + f,
      k = (parseInt(a.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * c + f,
      h = (parseInt(a.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * c + f,
      f = (parseInt(a.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * c + f,
      c = new mxRectangle(a.x, a.y, Math.max(e, a.width - f - k), Math.max(d, a.height - g - h)),
      k = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER),
      h = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE),
      c =
        null != a.shape && k == mxConstants.ALIGN_CENTER && h == mxConstants.ALIGN_MIDDLE
          ? a.shape.getLabelBounds(c)
          : c;
    b
      ? ((c.x = a.absoluteOffset.x),
        (c.y = a.absoluteOffset.y),
        null != a.text &&
          null != a.text.boundingBox &&
          (0 < a.text.boundingBox.x && (c.x = a.text.boundingBox.x),
          0 < a.text.boundingBox.y && (c.y = a.text.boundingBox.y)))
      : null != a.text &&
        null != a.text.boundingBox &&
        ((c.x = Math.min(c.x, a.text.boundingBox.x)), (c.y = Math.min(c.y, a.text.boundingBox.y)));
    c.x += f;
    c.y += g;
    null != a.text &&
      null != a.text.boundingBox &&
      (b
        ? ((c.width = Math.max(e, a.text.boundingBox.width)), (c.height = Math.max(d, a.text.boundingBox.height)))
        : ((c.width = Math.max(c.width, a.text.boundingBox.width)),
          (c.height = Math.max(c.height, a.text.boundingBox.height))));
    this.graph.getModel().isVertex(a.cell) &&
      ((b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER)),
      b == mxConstants.ALIGN_LEFT ? (c.x -= a.width) : b == mxConstants.ALIGN_RIGHT && (c.x += a.width),
      (b = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE)),
      b == mxConstants.ALIGN_TOP ? (c.y -= a.height) : b == mxConstants.ALIGN_BOTTOM && (c.y += a.height));
  }
  return new mxRectangle(Math.round(c.x), Math.round(c.y), Math.round(c.width), Math.round(c.height));
};
mxCellEditor.prototype.getEmptyLabelText = function (a) {
  return this.emptyLabelText;
};
mxCellEditor.prototype.getEditingCell = function () {
  return this.editingCell;
};
mxCellEditor.prototype.destroy = function () {
  null != this.textarea &&
    (mxEvent.release(this.textarea),
    null != this.textarea.parentNode && this.textarea.parentNode.removeChild(this.textarea),
    (this.textarea = null));
  null != this.changeHandler && (this.graph.getModel().removeListener(this.changeHandler), (this.changeHandler = null));
  this.zoomHandler && (this.graph.view.removeListener(this.zoomHandler), (this.zoomHandler = null));
};
function mxCellRenderer() {}
mxCellRenderer.defaultShapes = {};
mxCellRenderer.prototype.defaultEdgeShape = mxConnector;
mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;
mxCellRenderer.prototype.defaultTextShape = mxText;
mxCellRenderer.prototype.legacyControlPosition = !0;
mxCellRenderer.prototype.legacySpacing = !0;
mxCellRenderer.prototype.antiAlias = !0;
mxCellRenderer.prototype.minSvgStrokeWidth = 1;
mxCellRenderer.prototype.forceControlClickHandler = !1;
mxCellRenderer.registerShape = function (a, b) {
  mxCellRenderer.defaultShapes[a] = b;
};
mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);
mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);
mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);
mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);
mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);
mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);
mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);
mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);
mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);
mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);
mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);
mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);
mxCellRenderer.prototype.initializeShape = function (a) {
  a.shape.dialect = a.view.graph.dialect;
  this.configureShape(a);
  a.shape.init(a.view.getDrawPane());
};
mxCellRenderer.prototype.createShape = function (a) {
  var b = null;
  null != a.style &&
    ((b = a.style[mxConstants.STYLE_SHAPE]),
    (b = null == mxCellRenderer.defaultShapes[b] ? mxStencilRegistry.getStencil(b) : null),
    (b = null != b ? new mxShape(b) : new (this.getShapeConstructor(a))()));
  return b;
};
mxCellRenderer.prototype.createIndicatorShape = function (a) {
  a.shape.indicatorShape = this.getShape(a.view.graph.getIndicatorShape(a));
};
mxCellRenderer.prototype.getShape = function (a) {
  return null != a ? mxCellRenderer.defaultShapes[a] : null;
};
mxCellRenderer.prototype.getShapeConstructor = function (a) {
  var b = this.getShape(a.style[mxConstants.STYLE_SHAPE]);
  null == b && (b = a.view.graph.getModel().isEdge(a.cell) ? this.defaultEdgeShape : this.defaultVertexShape);
  return b;
};
mxCellRenderer.prototype.configureShape = function (a) {
  a.shape.apply(a);
  a.shape.image = a.view.graph.getImage(a);
  a.shape.indicatorColor = a.view.graph.getIndicatorColor(a);
  a.shape.indicatorStrokeColor = a.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];
  a.shape.indicatorGradientColor = a.view.graph.getIndicatorGradientColor(a);
  a.shape.indicatorDirection = a.style[mxConstants.STYLE_INDICATOR_DIRECTION];
  a.shape.indicatorImage = a.view.graph.getIndicatorImage(a);
  this.postConfigureShape(a);
};
mxCellRenderer.prototype.postConfigureShape = function (a) {
  null != a.shape &&
    (this.resolveColor(a, 'indicatorGradientColor', mxConstants.STYLE_GRADIENTCOLOR),
    this.resolveColor(a, 'indicatorColor', mxConstants.STYLE_FILLCOLOR),
    this.resolveColor(a, 'gradient', mxConstants.STYLE_GRADIENTCOLOR),
    this.resolveColor(a, 'stroke', mxConstants.STYLE_STROKECOLOR),
    this.resolveColor(a, 'fill', mxConstants.STYLE_FILLCOLOR));
};
mxCellRenderer.prototype.checkPlaceholderStyles = function (a) {
  if (null != a.style)
    for (
      var b = ['inherit', 'swimlane', 'indicated'],
        c = [
          mxConstants.STYLE_FILLCOLOR,
          mxConstants.STYLE_STROKECOLOR,
          mxConstants.STYLE_GRADIENTCOLOR,
          mxConstants.STYLE_FONTCOLOR,
        ],
        d = 0;
      d < c.length;
      d++
    )
      if (0 <= mxUtils.indexOf(b, a.style[c[d]])) return !0;
  return !1;
};
mxCellRenderer.prototype.resolveColor = function (a, b, c) {
  var d = c == mxConstants.STYLE_FONTCOLOR ? a.text : a.shape;
  if (null != d) {
    var e = a.view.graph,
      f = d[b],
      g = null;
    'inherit' == f
      ? (g = e.model.getParent(a.cell))
      : 'swimlane' == f
      ? ((d[b] = c == mxConstants.STYLE_STROKECOLOR || c == mxConstants.STYLE_FONTCOLOR ? '#000000' : '#ffffff'),
        (g = null != e.model.getTerminal(a.cell, !1) ? e.model.getTerminal(a.cell, !1) : a.cell),
        (g = e.getSwimlane(g)),
        (c = e.swimlaneIndicatorColorAttribute))
      : 'indicated' == f && null != a.shape
      ? (d[b] = a.shape.indicatorColor)
      : c != mxConstants.STYLE_FILLCOLOR && f == mxConstants.STYLE_FILLCOLOR && null != a.shape
      ? (d[b] = a.style[mxConstants.STYLE_FILLCOLOR])
      : c != mxConstants.STYLE_STROKECOLOR &&
        f == mxConstants.STYLE_STROKECOLOR &&
        null != a.shape &&
        (d[b] = a.style[mxConstants.STYLE_STROKECOLOR]);
    null != g &&
      ((a = e.getView().getState(g)),
      (d[b] = null),
      null != a &&
        ((e = c == mxConstants.STYLE_FONTCOLOR ? a.text : a.shape),
        (d[b] = null != e && 'indicatorColor' != b ? e[b] : a.style[c])));
  }
};
mxCellRenderer.prototype.getLabelValue = function (a) {
  return a.view.graph.getLabel(a.cell);
};
mxCellRenderer.prototype.createLabel = function (a, b) {
  var c = a.view.graph;
  c.getModel().isEdge(a.cell);
  if (0 < a.style[mxConstants.STYLE_FONTSIZE] || null == a.style[mxConstants.STYLE_FONTSIZE]) {
    var d = c.isHtmlLabel(a.cell) || (null != b && mxUtils.isNode(b));
    a.text = new this.defaultTextShape(
      b,
      new mxRectangle(),
      a.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER,
      c.getVerticalAlign(a),
      a.style[mxConstants.STYLE_FONTCOLOR],
      a.style[mxConstants.STYLE_FONTFAMILY],
      a.style[mxConstants.STYLE_FONTSIZE],
      a.style[mxConstants.STYLE_FONTSTYLE],
      a.style[mxConstants.STYLE_SPACING],
      a.style[mxConstants.STYLE_SPACING_TOP],
      a.style[mxConstants.STYLE_SPACING_RIGHT],
      a.style[mxConstants.STYLE_SPACING_BOTTOM],
      a.style[mxConstants.STYLE_SPACING_LEFT],
      a.style[mxConstants.STYLE_HORIZONTAL],
      a.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR],
      a.style[mxConstants.STYLE_LABEL_BORDERCOLOR],
      c.isWrapping(a.cell) && c.isHtmlLabel(a.cell),
      c.isLabelClipped(a.cell),
      a.style[mxConstants.STYLE_OVERFLOW],
      a.style[mxConstants.STYLE_LABEL_PADDING],
      mxUtils.getValue(a.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION)
    );
    a.text.opacity = mxUtils.getValue(a.style, mxConstants.STYLE_TEXT_OPACITY, 100);
    a.text.dialect = d ? mxConstants.DIALECT_STRICTHTML : a.view.graph.dialect;
    a.text.style = a.style;
    a.text.state = a;
    this.initializeLabel(a, a.text);
    this.configureShape(a);
    var e = !1,
      f = function (b) {
        var d = a;
        if (mxClient.IS_TOUCH || e)
          (d = mxEvent.getClientX(b)),
            (b = mxEvent.getClientY(b)),
            (b = mxUtils.convertPoint(c.container, d, b)),
            (d = c.view.getState(c.getCellAt(b.x, b.y)));
        return d;
      };
    mxEvent.addGestureListeners(
      a.text.node,
      mxUtils.bind(this, function (b) {
        this.isLabelEvent(a, b) &&
          (c.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b, a)),
          (e = c.dialect != mxConstants.DIALECT_SVG && 'IMG' == mxEvent.getSource(b).nodeName));
      }),
      mxUtils.bind(this, function (b) {
        this.isLabelEvent(a, b) && c.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, f(b)));
      }),
      mxUtils.bind(this, function (b) {
        this.isLabelEvent(a, b) && (c.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b, f(b))), (e = !1));
      })
    );
    c.nativeDblClickEnabled &&
      mxEvent.addListener(
        a.text.node,
        'dblclick',
        mxUtils.bind(this, function (b) {
          this.isLabelEvent(a, b) && (c.dblClick(b, a.cell), mxEvent.consume(b));
        })
      );
  }
};
mxCellRenderer.prototype.initializeLabel = function (a, b) {
  mxClient.IS_SVG && mxClient.NO_FO && b.dialect != mxConstants.DIALECT_SVG
    ? b.init(a.view.graph.container)
    : b.init(a.view.getDrawPane());
};
mxCellRenderer.prototype.createCellOverlays = function (a) {
  var b = a.view.graph.getCellOverlays(a.cell),
    c = null;
  if (null != b)
    for (var c = new mxDictionary(), d = 0; d < b.length; d++) {
      var e = null != a.overlays ? a.overlays.remove(b[d]) : null;
      null == e &&
        ((e = new mxImageShape(new mxRectangle(), b[d].image.src)),
        (e.dialect = a.view.graph.dialect),
        (e.preserveImageAspect = !1),
        (e.overlay = b[d]),
        this.initializeOverlay(a, e),
        this.installCellOverlayListeners(a, b[d], e),
        null != b[d].cursor && (e.node.style.cursor = b[d].cursor));
      c.put(b[d], e);
    }
  null != a.overlays &&
    a.overlays.visit(function (a, b) {
      b.destroy();
    });
  a.overlays = c;
};
mxCellRenderer.prototype.initializeOverlay = function (a, b) {
  b.init(a.view.getOverlayPane());
};
mxCellRenderer.prototype.installCellOverlayListeners = function (a, b, c) {
  var d = a.view.graph;
  mxEvent.addListener(c.node, 'click', function (c) {
    d.isEditing() && d.stopEditing(!d.isInvokesStopCellEditing());
    b.fireEvent(new mxEventObject(mxEvent.CLICK, 'event', c, 'cell', a.cell));
  });
  mxEvent.addGestureListeners(
    c.node,
    function (a) {
      mxEvent.consume(a);
    },
    function (b) {
      d.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, a));
    }
  );
  mxClient.IS_TOUCH &&
    mxEvent.addListener(c.node, 'touchend', function (c) {
      b.fireEvent(new mxEventObject(mxEvent.CLICK, 'event', c, 'cell', a.cell));
    });
};
mxCellRenderer.prototype.createControl = function (a) {
  var b = a.view.graph,
    c = b.getFoldingImage(a);
  if (b.foldingEnabled && null != c) {
    if (null == a.control) {
      var d = new mxRectangle(0, 0, c.width, c.height);
      a.control = new mxImageShape(d, c.src);
      a.control.preserveImageAspect = !1;
      a.control.dialect = b.dialect;
      this.initControl(a, a.control, !0, this.createControlClickHandler(a));
    }
  } else null != a.control && (a.control.destroy(), (a.control = null));
};
mxCellRenderer.prototype.createControlClickHandler = function (a) {
  var b = a.view.graph;
  return mxUtils.bind(this, function (c) {
    if (this.forceControlClickHandler || b.isEnabled()) {
      var d = !b.isCellCollapsed(a.cell);
      b.foldCells(d, !1, [a.cell], null, c);
      mxEvent.consume(c);
    }
  });
};
mxCellRenderer.prototype.initControl = function (a, b, c, d) {
  var e = a.view.graph;
  e.isHtmlLabel(a.cell) && mxClient.NO_FO && e.dialect == mxConstants.DIALECT_SVG
    ? ((b.dialect = mxConstants.DIALECT_PREFERHTML), b.init(e.container), (b.node.style.zIndex = 1))
    : b.init(a.view.getOverlayPane());
  b = b.innerNode || b.node;
  null == d || mxClient.IS_IOS || (e.isEnabled() && (b.style.cursor = 'pointer'), mxEvent.addListener(b, 'click', d));
  if (c) {
    var f = null;
    mxEvent.addGestureListeners(
      b,
      function (b) {
        f = new mxPoint(mxEvent.getClientX(b), mxEvent.getClientY(b));
        e.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b, a));
        mxEvent.consume(b);
      },
      function (b) {
        e.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, a));
      },
      function (b) {
        e.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b, a));
        mxEvent.consume(b);
      }
    );
    null != d &&
      mxClient.IS_IOS &&
      b.addEventListener(
        'touchend',
        function (a) {
          if (null != f) {
            var b = e.tolerance;
            Math.abs(f.x - mxEvent.getClientX(a)) < b &&
              Math.abs(f.y - mxEvent.getClientY(a)) < b &&
              (d.call(d, a), mxEvent.consume(a));
          }
        },
        !0
      );
  }
  return b;
};
mxCellRenderer.prototype.isShapeEvent = function (a, b) {
  return !0;
};
mxCellRenderer.prototype.isLabelEvent = function (a, b) {
  return !0;
};
mxCellRenderer.prototype.installListeners = function (a) {
  var b = a.view.graph,
    c = function (c) {
      var d = a;
      if ((b.dialect != mxConstants.DIALECT_SVG && 'IMG' == mxEvent.getSource(c).nodeName) || mxClient.IS_TOUCH)
        (d = mxEvent.getClientX(c)),
          (c = mxEvent.getClientY(c)),
          (c = mxUtils.convertPoint(b.container, d, c)),
          (d = b.view.getState(b.getCellAt(c.x, c.y)));
      return d;
    };
  mxEvent.addGestureListeners(
    a.shape.node,
    mxUtils.bind(this, function (c) {
      this.isShapeEvent(a, c) && b.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(c, a));
    }),
    mxUtils.bind(this, function (d) {
      this.isShapeEvent(a, d) && b.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(d, c(d)));
    }),
    mxUtils.bind(this, function (d) {
      this.isShapeEvent(a, d) && b.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(d, c(d)));
    })
  );
  b.nativeDblClickEnabled &&
    mxEvent.addListener(
      a.shape.node,
      'dblclick',
      mxUtils.bind(this, function (c) {
        this.isShapeEvent(a, c) && (b.dblClick(c, a.cell), mxEvent.consume(c));
      })
    );
};
mxCellRenderer.prototype.redrawLabel = function (a, b) {
  var c = a.view.graph,
    d = this.getLabelValue(a),
    e = c.isWrapping(a.cell),
    f = c.isLabelClipped(a.cell),
    g =
      a.view.graph.isHtmlLabel(a.cell) || (null != d && mxUtils.isNode(d))
        ? mxConstants.DIALECT_STRICTHTML
        : a.view.graph.dialect,
    k = a.style[mxConstants.STYLE_OVERFLOW] || 'visible';
  null == a.text ||
    (a.text.wrap == e && a.text.clipped == f && a.text.overflow == k && a.text.dialect == g) ||
    (a.text.destroy(), (a.text = null));
  null == a.text && null != d && (mxUtils.isNode(d) || 0 < d.length)
    ? this.createLabel(a, d)
    : null == a.text || (null != d && 0 != d.length) || (a.text.destroy(), (a.text = null));
  if (null != a.text) {
    b &&
      (null != a.text.lastValue && this.isTextShapeInvalid(a, a.text) && (a.text.lastValue = null),
      a.text.resetStyles(),
      a.text.apply(a),
      this.configureShape(a),
      (a.text.valign = c.getVerticalAlign(a)));
    var c = this.getLabelBounds(a),
      h = this.getTextScale(a);
    this.resolveColor(a, 'color', mxConstants.STYLE_FONTCOLOR);
    if (
      b ||
      a.text.value != d ||
      a.text.isWrapping != e ||
      a.text.overflow != k ||
      a.text.isClipping != f ||
      a.text.scale != h ||
      a.text.dialect != g ||
      null == a.text.bounds ||
      !a.text.bounds.equals(c)
    )
      (a.text.dialect = g),
        (a.text.value = d),
        (a.text.bounds = c),
        (a.text.scale = h),
        (a.text.wrap = e),
        (a.text.clipped = f),
        (a.text.overflow = k),
        (d = a.text.node.style.visibility),
        this.redrawLabelShape(a.text),
        (a.text.node.style.visibility = d);
  }
};
mxCellRenderer.prototype.isTextShapeInvalid = function (a, b) {
  function c(c, e, f) {
    return 'spacingTop' == e || 'spacingRight' == e || 'spacingBottom' == e || 'spacingLeft' == e
      ? parseFloat(b[c]) - parseFloat(b.spacing) != (a.style[e] || f)
      : b[c] != (a.style[e] || f);
  }
  return (
    c('fontStyle', mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) ||
    c('family', mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) ||
    c('size', mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) ||
    c('color', mxConstants.STYLE_FONTCOLOR, 'black') ||
    c('align', mxConstants.STYLE_ALIGN, '') ||
    c('valign', mxConstants.STYLE_VERTICAL_ALIGN, '') ||
    c('spacing', mxConstants.STYLE_SPACING, 2) ||
    c('spacingTop', mxConstants.STYLE_SPACING_TOP, 0) ||
    c('spacingRight', mxConstants.STYLE_SPACING_RIGHT, 0) ||
    c('spacingBottom', mxConstants.STYLE_SPACING_BOTTOM, 0) ||
    c('spacingLeft', mxConstants.STYLE_SPACING_LEFT, 0) ||
    c('horizontal', mxConstants.STYLE_HORIZONTAL, !0) ||
    c('background', mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) ||
    c('border', mxConstants.STYLE_LABEL_BORDERCOLOR) ||
    c('opacity', mxConstants.STYLE_TEXT_OPACITY, 100) ||
    c('textDirection', mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION)
  );
};
mxCellRenderer.prototype.redrawLabelShape = function (a) {
  a.redraw();
};
mxCellRenderer.prototype.getTextScale = function (a) {
  return a.view.scale;
};
mxCellRenderer.prototype.getLabelBounds = function (a) {
  var b = a.view.graph,
    c = a.view.scale,
    d = b.getModel().isEdge(a.cell),
    e = new mxRectangle(a.absoluteOffset.x, a.absoluteOffset.y);
  if (d) {
    var f = a.text.getSpacing();
    e.x += f.x * c;
    e.y += f.y * c;
    b = b.getCellGeometry(a.cell);
    null != b && ((e.width = Math.max(0, b.width * c)), (e.height = Math.max(0, b.height * c)));
  } else
    a.text.isPaintBoundsInverted() && ((b = e.x), (e.x = e.y), (e.y = b)),
      (e.x += a.x),
      (e.y += a.y),
      (e.width = Math.max(1, a.width)),
      (e.height = Math.max(1, a.height));
  a.text.isPaintBoundsInverted() &&
    ((b = (a.width - a.height) / 2), (e.x += b), (e.y -= b), (b = e.width), (e.width = e.height), (e.height = b));
  null != a.shape &&
    ((b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER)),
    (f = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE)),
    b == mxConstants.ALIGN_CENTER && f == mxConstants.ALIGN_MIDDLE && (e = a.shape.getLabelBounds(e)));
  b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_WIDTH, null);
  null != b && (e.width = parseFloat(b) * c);
  d || this.rotateLabelBounds(a, e);
  return e;
};
mxCellRenderer.prototype.rotateLabelBounds = function (a, b) {
  b.y -= a.text.margin.y * b.height;
  b.x -= a.text.margin.x * b.width;
  if (
    !this.legacySpacing ||
    ('fill' != a.style[mxConstants.STYLE_OVERFLOW] &&
      'width' != a.style[mxConstants.STYLE_OVERFLOW] &&
      ('block' != a.style[mxConstants.STYLE_OVERFLOW] || '1' == a.style[mxConstants.STYLE_BLOCK_SPACING]))
  ) {
    var c = a.view.scale,
      d = a.text.getSpacing('1' == a.style[mxConstants.STYLE_BLOCK_SPACING]);
    b.x += d.x * c;
    b.y += d.y * c;
    var d = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER),
      e = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE),
      f = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_WIDTH, null);
    b.width = Math.max(
      0,
      b.width - (d == mxConstants.ALIGN_CENTER && null == f ? a.text.spacingLeft * c + a.text.spacingRight * c : 0)
    );
    b.height = Math.max(
      0,
      b.height - (e == mxConstants.ALIGN_MIDDLE ? a.text.spacingTop * c + a.text.spacingBottom * c : 0)
    );
  }
  e = a.text.getTextRotation();
  0 != e &&
    null != a &&
    a.view.graph.model.isVertex(a.cell) &&
    ((c = a.getCenterX()), (d = a.getCenterY()), b.x != c || b.y != d) &&
    ((e *= Math.PI / 180),
    (c = mxUtils.getRotatedPoint(new mxPoint(b.x, b.y), Math.cos(e), Math.sin(e), new mxPoint(c, d))),
    (b.x = c.x),
    (b.y = c.y));
};
mxCellRenderer.prototype.redrawCellOverlays = function (a, b) {
  this.createCellOverlays(a);
  if (null != a.overlays) {
    var c = mxUtils.mod(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0), 90),
      d = mxUtils.toRadians(c),
      e = Math.cos(d),
      f = Math.sin(d);
    a.overlays.visit(function (d, k) {
      var g = k.overlay.getBounds(a);
      if (!a.view.graph.getModel().isEdge(a.cell) && null != a.shape && 0 != c) {
        var l = g.getCenterX(),
          m = g.getCenterY(),
          m = mxUtils.getRotatedPoint(new mxPoint(l, m), e, f, new mxPoint(a.getCenterX(), a.getCenterY())),
          l = m.x,
          m = m.y;
        g.x = Math.round(l - g.width / 2);
        g.y = Math.round(m - g.height / 2);
      }
      if (b || null == k.bounds || k.scale != a.view.scale || !k.bounds.equals(g))
        (k.bounds = g), (k.scale = a.view.scale), k.redraw();
    });
  }
};
mxCellRenderer.prototype.redrawControl = function (a, b) {
  var c = a.view.graph.getFoldingImage(a);
  if (null != a.control && null != c) {
    var c = this.getControlBounds(a, c.width, c.height),
      d = this.legacyControlPosition
        ? mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0)
        : a.shape.getTextRotation(),
      e = a.view.scale;
    if (b || a.control.scale != e || !a.control.bounds.equals(c) || a.control.rotation != d)
      (a.control.rotation = d), (a.control.bounds = c), (a.control.scale = e), a.control.redraw();
  }
};
mxCellRenderer.prototype.getControlBounds = function (a, b, c) {
  if (null != a.control) {
    var d = a.view.scale,
      e = a.getCenterX(),
      f = a.getCenterY();
    if (!a.view.graph.getModel().isEdge(a.cell) && ((e = a.x + b * d), (f = a.y + c * d), null != a.shape)) {
      var g = a.shape.getShapeRotation();
      if (this.legacyControlPosition) g = mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0);
      else if (a.shape.isPaintBoundsInverted())
        var k = (a.width - a.height) / 2,
          e = e + k,
          f = f - k;
      0 != g &&
        ((k = mxUtils.toRadians(g)),
        (g = Math.cos(k)),
        (k = Math.sin(k)),
        (f = mxUtils.getRotatedPoint(new mxPoint(e, f), g, k, new mxPoint(a.getCenterX(), a.getCenterY()))),
        (e = f.x),
        (f = f.y));
    }
    return (
      a.view.graph.getModel().isEdge(a.cell),
      new mxRectangle(Math.round(e - (b / 2) * d), Math.round(f - (c / 2) * d), Math.round(b * d), Math.round(c * d))
    );
  }
  return null;
};
mxCellRenderer.prototype.insertStateAfter = function (a, b, c) {
  for (var d = this.getShapesForState(a), e = 0; e < d.length; e++)
    if (null != d[e] && null != d[e].node) {
      var f = d[e].node.parentNode != a.view.getDrawPane() && d[e].node.parentNode != a.view.getOverlayPane(),
        g = f ? c : b;
      if (null != g && g.nextSibling != d[e].node)
        null == g.nextSibling
          ? g.parentNode.appendChild(d[e].node)
          : g.parentNode.insertBefore(d[e].node, g.nextSibling);
      else if (null == g)
        if (d[e].node.parentNode == a.view.graph.container) {
          for (g = a.view.canvas; null != g && g.parentNode != a.view.graph.container; ) g = g.parentNode;
          null != g && null != g.nextSibling
            ? g.nextSibling != d[e].node && d[e].node.parentNode.insertBefore(d[e].node, g.nextSibling)
            : d[e].node.parentNode.appendChild(d[e].node);
        } else
          null != d[e].node.parentNode &&
            null != d[e].node.parentNode.firstChild &&
            d[e].node.parentNode.firstChild != d[e].node &&
            d[e].node.parentNode.insertBefore(d[e].node, d[e].node.parentNode.firstChild);
      f ? (c = d[e].node) : (b = d[e].node);
    }
  return [b, c];
};
mxCellRenderer.prototype.getShapesForState = function (a) {
  return [a.shape, a.text, a.control];
};
mxCellRenderer.prototype.redraw = function (a, b, c) {
  b = this.redrawShape(a, b, c);
  null == a.shape ||
    (null != c && !c) ||
    (this.redrawLabel(a, b), this.redrawCellOverlays(a, b), this.redrawControl(a, b));
};
mxCellRenderer.prototype.redrawShape = function (a, b, c) {
  var d = a.view.graph.model,
    e = !1;
  null != a.shape &&
    null != a.shape.style &&
    null != a.style &&
    a.shape.style[mxConstants.STYLE_SHAPE] != a.style[mxConstants.STYLE_SHAPE] &&
    (a.shape.destroy(), (a.shape = null));
  null == a.shape &&
  null != a.view.graph.container &&
  a.cell != a.view.currentRoot &&
  (d.isVertex(a.cell) || d.isEdge(a.cell))
    ? ((a.shape = this.createShape(a)),
      null != a.shape &&
        ((a.shape.minSvgStrokeWidth = this.minSvgStrokeWidth),
        (a.shape.antiAlias = this.antiAlias),
        this.createIndicatorShape(a),
        this.initializeShape(a),
        this.createCellOverlays(a),
        this.installListeners(a),
        a.view.graph.selectionCellsHandler.updateHandler(a)))
    : b ||
      null == a.shape ||
      (mxUtils.equalEntries(a.shape.style, a.style) && !this.checkPlaceholderStyles(a)) ||
      (a.shape.resetStyles(), this.configureShape(a), a.view.graph.selectionCellsHandler.updateHandler(a), (b = !0));
  null != a.shape &&
    a.shape.indicatorShape != this.getShape(a.view.graph.getIndicatorShape(a)) &&
    (null != a.shape.indicator && (a.shape.indicator.destroy(), (a.shape.indicator = null)),
    this.createIndicatorShape(a),
    null != a.shape.indicatorShape &&
      ((a.shape.indicator = new a.shape.indicatorShape()),
      (a.shape.indicator.dialect = a.shape.dialect),
      a.shape.indicator.init(a.node),
      (b = !0)));
  null != a.shape &&
    (this.createControl(a), b || this.isShapeInvalid(a, a.shape)) &&
    (null != a.absolutePoints
      ? ((a.shape.points = a.absolutePoints.slice()), (a.shape.bounds = null))
      : ((a.shape.points = null), (a.shape.bounds = new mxRectangle(a.x, a.y, a.width, a.height))),
    (a.shape.scale = a.view.scale),
    null == c || c ? this.doRedrawShape(a) : a.shape.updateBoundingBox(),
    (e = !0));
  return e;
};
mxCellRenderer.prototype.doRedrawShape = function (a) {
  a.shape.redraw();
};
mxCellRenderer.prototype.isShapeInvalid = function (a, b) {
  return (
    null == b.bounds ||
    b.scale != a.view.scale ||
    (null == a.absolutePoints && !b.bounds.equals(a)) ||
    (null != a.absolutePoints && !mxUtils.equalPoints(b.points, a.absolutePoints))
  );
};
mxCellRenderer.prototype.destroy = function (a) {
  null != a.shape &&
    (null != a.text && (a.text.destroy(), (a.text = null)),
    null != a.overlays &&
      (a.overlays.visit(function (a, c) {
        c.destroy();
      }),
      (a.overlays = null)),
    null != a.control && (a.control.destroy(), (a.control = null)),
    a.shape.destroy(),
    (a.shape = null));
};
var mxEdgeStyle = {
    EntityRelation: function (a, b, c, d, e) {
      var f = a.view,
        g = f.graph;
      d = mxUtils.getValue(a.style, mxConstants.STYLE_SEGMENT, mxConstants.ENTITY_SEGMENT) * f.scale;
      var k = a.absolutePoints,
        h = k[0],
        l = k[k.length - 1],
        k = !1;
      if (null != b) {
        var m = g.getCellGeometry(b.cell);
        m.relative ? (k = 0.5 >= m.x) : null != c && (k = (null != l ? l.x : c.x + c.width) < (null != h ? h.x : b.x));
      }
      if (null != h) (b = new mxCellState()), (b.x = h.x), (b.y = h.y);
      else if (null != b) {
        var n = mxUtils.getPortConstraints(b, a, !0, mxConstants.DIRECTION_MASK_NONE);
        n != mxConstants.DIRECTION_MASK_NONE &&
          n != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST &&
          (k = n == mxConstants.DIRECTION_MASK_WEST);
      } else return;
      m = !0;
      null != c &&
        ((g = g.getCellGeometry(c.cell)),
        g.relative ? (m = 0.5 >= g.x) : null != b && (m = (null != h ? h.x : b.x + b.width) < (null != l ? l.x : c.x)));
      null != l
        ? ((c = new mxCellState()), (c.x = l.x), (c.y = l.y))
        : null != c &&
          ((n = mxUtils.getPortConstraints(c, a, !1, mxConstants.DIRECTION_MASK_NONE)),
          n != mxConstants.DIRECTION_MASK_NONE &&
            n != mxConstants.DIRECTION_MASK_WEST + mxConstants.DIRECTION_MASK_EAST &&
            (m = n == mxConstants.DIRECTION_MASK_WEST));
      null != b &&
        null != c &&
        ((a = k ? b.x : b.x + b.width),
        (b = f.getRoutingCenterY(b)),
        (h = m ? c.x : c.x + c.width),
        (c = f.getRoutingCenterY(c)),
        (f = new mxPoint(a + (k ? -d : d), b)),
        (g = new mxPoint(h + (m ? -d : d), c)),
        k == m
          ? ((d = k ? Math.min(a, h) - d : Math.max(a, h) + d), e.push(new mxPoint(d, b)), e.push(new mxPoint(d, c)))
          : (f.x < g.x == k
              ? ((d = b + (c - b) / 2), e.push(f), e.push(new mxPoint(f.x, d)), e.push(new mxPoint(g.x, d)))
              : e.push(f),
            e.push(g)));
    },
    Loop: function (a, b, c, d, e) {
      c = a.absolutePoints;
      var f = c[c.length - 1];
      if (null != c[0] && null != f) {
        if (null != d && 0 < d.length)
          for (b = 0; b < d.length; b++)
            (c = d[b]), (c = a.view.transformControlPoint(a, c)), e.push(new mxPoint(c.x, c.y));
      } else if (null != b) {
        var f = a.view,
          g = f.graph;
        c = null != d && 0 < d.length ? d[0] : null;
        null != c && ((c = f.transformControlPoint(a, c)), mxUtils.contains(b, c.x, c.y) && (c = null));
        var k = (d = 0),
          h = 0,
          l = 0,
          g = mxUtils.getValue(a.style, mxConstants.STYLE_SEGMENT, g.gridSize) * f.scale;
        a = mxUtils.getValue(a.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_WEST);
        a == mxConstants.DIRECTION_NORTH || a == mxConstants.DIRECTION_SOUTH
          ? ((d = f.getRoutingCenterX(b)), (k = g))
          : ((h = f.getRoutingCenterY(b)), (l = g));
        null == c || c.x < b.x || c.x > b.x + b.width
          ? null != c
            ? ((d = c.x), (l = Math.max(Math.abs(h - c.y), l)))
            : a == mxConstants.DIRECTION_NORTH
            ? (h = b.y - 2 * k)
            : a == mxConstants.DIRECTION_SOUTH
            ? (h = b.y + b.height + 2 * k)
            : (d = a == mxConstants.DIRECTION_EAST ? b.x - 2 * l : b.x + b.width + 2 * l)
          : null != c && ((d = f.getRoutingCenterX(b)), (k = Math.max(Math.abs(d - c.x), l)), (h = c.y), (l = 0));
        e.push(new mxPoint(d - k, h - l));
        e.push(new mxPoint(d + k, h + l));
      }
    },
    ElbowConnector: function (a, b, c, d, e) {
      var f = null != d && 0 < d.length ? d[0] : null,
        g = !1,
        k = !1;
      if (null != b && null != c)
        if (null != f)
          var h = Math.min(b.x, c.x),
            l = Math.max(b.x + b.width, c.x + c.width),
            k = Math.min(b.y, c.y),
            m = Math.max(b.y + b.height, c.y + c.height),
            f = a.view.transformControlPoint(a, f),
            g = f.y < k || f.y > m,
            k = f.x < h || f.x > l;
        else
          (h = Math.max(b.x, c.x)),
            (l = Math.min(b.x + b.width, c.x + c.width)),
            (g = h == l),
            g || ((k = Math.max(b.y, c.y)), (m = Math.min(b.y + b.height, c.y + c.height)), (k = k == m));
      k || (!g && a.style[mxConstants.STYLE_ELBOW] != mxConstants.ELBOW_VERTICAL)
        ? mxEdgeStyle.SideToSide(a, b, c, d, e)
        : mxEdgeStyle.TopToBottom(a, b, c, d, e);
    },
    SideToSide: function (a, b, c, d, e) {
      var f = a.view;
      d = null != d && 0 < d.length ? d[0] : null;
      var g = a.absolutePoints,
        k = g[0],
        g = g[g.length - 1];
      null != d && (d = f.transformControlPoint(a, d));
      null != k && ((b = new mxCellState()), (b.x = k.x), (b.y = k.y));
      null != g && ((c = new mxCellState()), (c.x = g.x), (c.y = g.y));
      null != b &&
        null != c &&
        ((a = Math.max(b.x, c.x)),
        (k = Math.min(b.x + b.width, c.x + c.width)),
        (a = null != d ? d.x : Math.round(k + (a - k) / 2)),
        (k = f.getRoutingCenterY(b)),
        (f = f.getRoutingCenterY(c)),
        null != d &&
          (d.y >= b.y && d.y <= b.y + b.height && (k = d.y), d.y >= c.y && d.y <= c.y + c.height && (f = d.y)),
        mxUtils.contains(c, a, k) || mxUtils.contains(b, a, k) || e.push(new mxPoint(a, k)),
        mxUtils.contains(c, a, f) || mxUtils.contains(b, a, f) || e.push(new mxPoint(a, f)),
        1 == e.length &&
          (null != d
            ? mxUtils.contains(c, a, d.y) || mxUtils.contains(b, a, d.y) || e.push(new mxPoint(a, d.y))
            : ((f = Math.max(b.y, c.y)),
              e.push(new mxPoint(a, f + (Math.min(b.y + b.height, c.y + c.height) - f) / 2)))));
    },
    TopToBottom: function (a, b, c, d, e) {
      var f = a.view;
      d = null != d && 0 < d.length ? d[0] : null;
      var g = a.absolutePoints,
        k = g[0],
        g = g[g.length - 1];
      null != d && (d = f.transformControlPoint(a, d));
      null != k && ((b = new mxCellState()), (b.x = k.x), (b.y = k.y));
      null != g && ((c = new mxCellState()), (c.x = g.x), (c.y = g.y));
      null != b &&
        null != c &&
        ((k = Math.max(b.y, c.y)),
        (g = Math.min(b.y + b.height, c.y + c.height)),
        (a = f.getRoutingCenterX(b)),
        null != d && d.x >= b.x && d.x <= b.x + b.width && (a = d.x),
        (k = null != d ? d.y : Math.round(g + (k - g) / 2)),
        mxUtils.contains(c, a, k) || mxUtils.contains(b, a, k) || e.push(new mxPoint(a, k)),
        (a = null != d && d.x >= c.x && d.x <= c.x + c.width ? d.x : f.getRoutingCenterX(c)),
        mxUtils.contains(c, a, k) || mxUtils.contains(b, a, k) || e.push(new mxPoint(a, k)),
        1 == e.length &&
          (null != d && 1 == e.length
            ? mxUtils.contains(c, d.x, k) || mxUtils.contains(b, d.x, k) || e.push(new mxPoint(d.x, k))
            : ((f = Math.max(b.x, c.x)),
              e.push(new mxPoint(f + (Math.min(b.x + b.width, c.x + c.width) - f) / 2, k)))));
    },
    SegmentConnector: function (a, b, c, d, e) {
      var f = mxEdgeStyle.scalePointArray(a.absolutePoints, a.view.scale);
      b = mxEdgeStyle.scaleCellState(b, a.view.scale);
      var g = mxEdgeStyle.scaleCellState(c, a.view.scale);
      c = [];
      var k = 0 < e.length ? e[0] : null,
        h = !0,
        l = f[0];
      null == l && null != b
        ? (l = new mxPoint(a.view.getRoutingCenterX(b), a.view.getRoutingCenterY(b)))
        : null != l && (l = l.clone());
      var m = f.length - 1;
      if (null != d && 0 < d.length) {
        for (var n = [], p = 0; p < d.length; p++) {
          var r = a.view.transformControlPoint(a, d[p], !0);
          null != r && n.push(r);
        }
        if (0 == n.length) return;
        null != l &&
          null != n[0] &&
          (1 > Math.abs(n[0].x - l.x) && (n[0].x = l.x), 1 > Math.abs(n[0].y - l.y) && (n[0].y = l.y));
        r = f[m];
        null != r &&
          null != n[n.length - 1] &&
          (1 > Math.abs(n[n.length - 1].x - r.x) && (n[n.length - 1].x = r.x),
          1 > Math.abs(n[n.length - 1].y - r.y) && (n[n.length - 1].y = r.y));
        d = n[0];
        var t = b,
          u = f[0],
          x;
        x = d;
        null != u && (t = null);
        for (p = 0; 2 > p; p++) {
          var z = null != u && u.x == x.x,
            D = null != u && u.y == x.y,
            B = null != t && x.y >= t.y && x.y <= t.y + t.height,
            C = null != t && x.x >= t.x && x.x <= t.x + t.width,
            t = D || (null == u && B);
          x = z || (null == u && C);
          if (0 != p || !((t && x) || (z && D))) {
            if (null != u && !D && !z && (B || C)) {
              h = B ? !1 : !0;
              break;
            }
            if (x || t) {
              h = t;
              1 == p && (h = 0 == n.length % 2 ? t : x);
              break;
            }
          }
          t = g;
          u = f[m];
          null != u && (t = null);
          x = n[n.length - 1];
          z && D && (n = n.slice(1));
        }
        h && ((null != f[0] && f[0].y != d.y) || (null == f[0] && null != b && (d.y < b.y || d.y > b.y + b.height)))
          ? c.push(new mxPoint(l.x, d.y))
          : !h &&
            ((null != f[0] && f[0].x != d.x) || (null == f[0] && null != b && (d.x < b.x || d.x > b.x + b.width))) &&
            c.push(new mxPoint(d.x, l.y));
        h ? (l.y = d.y) : (l.x = d.x);
        for (p = 0; p < n.length; p++) (h = !h), (d = n[p]), h ? (l.y = d.y) : (l.x = d.x), c.push(l.clone());
      } else (d = l), (h = !0);
      l = f[m];
      null == l && null != g && (l = new mxPoint(a.view.getRoutingCenterX(g), a.view.getRoutingCenterY(g)));
      null != l &&
        null != d &&
        (h && ((null != f[m] && f[m].y != d.y) || (null == f[m] && null != g && (d.y < g.y || d.y > g.y + g.height)))
          ? c.push(new mxPoint(l.x, d.y))
          : !h &&
            ((null != f[m] && f[m].x != d.x) || (null == f[m] && null != g && (d.x < g.x || d.x > g.x + g.width))) &&
            c.push(new mxPoint(d.x, l.y)));
      if (null == f[0] && null != b)
        for (; 0 < c.length && null != c[0] && mxUtils.contains(b, c[0].x, c[0].y); ) c.splice(0, 1);
      if (null == f[m] && null != g)
        for (; 0 < c.length && null != c[c.length - 1] && mxUtils.contains(g, c[c.length - 1].x, c[c.length - 1].y); )
          c.splice(c.length - 1, 1);
      for (p = 0; p < c.length; p++)
        if (
          ((f = c[p]),
          (f.x = Math.round(f.x * a.view.scale * 10) / 10),
          (f.y = Math.round(f.y * a.view.scale * 10) / 10),
          null == k || 1 <= Math.abs(k.x - f.x) || Math.abs(k.y - f.y) >= Math.max(1, a.view.scale))
        )
          e.push(f), (k = f);
      null != r &&
        null != e[e.length - 1] &&
        1 >= Math.abs(r.x - e[e.length - 1].x) &&
        1 >= Math.abs(r.y - e[e.length - 1].y) &&
        (e.splice(e.length - 1, 1),
        null != e[e.length - 1] &&
          (1 > Math.abs(e[e.length - 1].x - r.x) && (e[e.length - 1].x = r.x),
          1 > Math.abs(e[e.length - 1].y - r.y) && (e[e.length - 1].y = r.y)));
    },
    orthBuffer: 10,
    orthPointsFallback: !0,
    dirVectors: [
      [-1, 0],
      [0, -1],
      [1, 0],
      [0, 1],
      [-1, 0],
      [0, -1],
      [1, 0],
    ],
    wayPoints1: [
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
      [0, 0],
    ],
    routePatterns: [
      [
        [513, 2308, 2081, 2562],
        [513, 1090, 514, 2184, 2114, 2561],
        [513, 1090, 514, 2564, 2184, 2562],
        [513, 2308, 2561, 1090, 514, 2568, 2308],
      ],
      [
        [514, 1057, 513, 2308, 2081, 2562],
        [514, 2184, 2114, 2561],
        [514, 2184, 2562, 1057, 513, 2564, 2184],
        [514, 1057, 513, 2568, 2308, 2561],
      ],
      [
        [1090, 514, 1057, 513, 2308, 2081, 2562],
        [2114, 2561],
        [1090, 2562, 1057, 513, 2564, 2184],
        [1090, 514, 1057, 513, 2308, 2561, 2568],
      ],
      [
        [2081, 2562],
        [1057, 513, 1090, 514, 2184, 2114, 2561],
        [1057, 513, 1090, 514, 2184, 2562, 2564],
        [1057, 2561, 1090, 514, 2568, 2308],
      ],
    ],
    inlineRoutePatterns: [
      [null, [2114, 2568], null, null],
      [null, [514, 2081, 2114, 2568], null, null],
      [null, [2114, 2561], null, null],
      [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null],
    ],
    vertexSeperations: [],
    limits: [
      [0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ],
    LEFT_MASK: 32,
    TOP_MASK: 64,
    RIGHT_MASK: 128,
    BOTTOM_MASK: 256,
    LEFT: 1,
    TOP: 2,
    RIGHT: 4,
    BOTTOM: 8,
    SIDE_MASK: 480,
    CENTER_MASK: 512,
    SOURCE_MASK: 1024,
    TARGET_MASK: 2048,
    VERTEX_MASK: 3072,
    getJettySize: function (a, b) {
      var c = mxUtils.getValue(
        a.style,
        b ? mxConstants.STYLE_SOURCE_JETTY_SIZE : mxConstants.STYLE_TARGET_JETTY_SIZE,
        mxUtils.getValue(a.style, mxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer)
      );
      'auto' == c &&
        (mxUtils.getValue(a.style, b ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE) !=
        mxConstants.NONE
          ? ((c = mxUtils.getNumber(
              a.style,
              b ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE,
              mxConstants.DEFAULT_MARKERSIZE
            )),
            (c =
              Math.max(2, Math.ceil((c + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer))
          : (c = 2 * mxEdgeStyle.orthBuffer));
      return c;
    },
    scalePointArray: function (a, b) {
      var c = [];
      if (null != a)
        for (var d = 0; d < a.length; d++)
          if (null != a[d]) {
            var e = new mxPoint(Math.round((a[d].x / b) * 10) / 10, Math.round((a[d].y / b) * 10) / 10);
            c[d] = e;
          } else c[d] = null;
      else c = null;
      return c;
    },
    scaleCellState: function (a, b) {
      var c;
      null != a
        ? ((c = a.clone()),
          c.setRect(
            Math.round((a.x / b) * 10) / 10,
            Math.round((a.y / b) * 10) / 10,
            Math.round((a.width / b) * 10) / 10,
            Math.round((a.height / b) * 10) / 10
          ))
        : (c = null);
      return c;
    },
    OrthConnector: function (a, b, c, d, e) {
      var f = a.view.graph,
        g = null == h ? !1 : f.getModel().isEdge(h.cell),
        k = null == l ? !1 : f.getModel().isEdge(l.cell),
        f = mxEdgeStyle.scalePointArray(a.absolutePoints, a.view.scale),
        h = mxEdgeStyle.scaleCellState(b, a.view.scale),
        l = mxEdgeStyle.scaleCellState(c, a.view.scale),
        m = f[0],
        n = f[f.length - 1],
        p = null != h ? h.x : m.x,
        r = null != h ? h.y : m.y,
        t = null != h ? h.width : 0,
        u = null != h ? h.height : 0,
        x = null != l ? l.x : n.x,
        z = null != l ? l.y : n.y,
        D = null != l ? l.width : 0,
        B = null != l ? l.height : 0,
        f = mxEdgeStyle.getJettySize(a, !0),
        C = mxEdgeStyle.getJettySize(a, !1);
      null != h && l == h && (f = C = Math.max(f, C));
      var J = C + f,
        v = !1;
      if (null != m && null != n)
        var v = n.x - m.x,
          K = n.y - m.y,
          v = v * v + K * K < J * J;
      if (v || (mxEdgeStyle.orthPointsFallback && null != d && 0 < d.length) || g || k)
        mxEdgeStyle.SegmentConnector(a, b, c, d, e);
      else {
        c = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];
        null != h &&
          ((c[0] = mxUtils.getPortConstraints(h, a, !0, mxConstants.DIRECTION_MASK_ALL)),
          (b = mxUtils.getValue(h.style, mxConstants.STYLE_ROTATION, 0)),
          0 != b &&
            ((b = mxUtils.getBoundingBox(new mxRectangle(p, r, t, u), b)),
            (p = b.x),
            (r = b.y),
            (t = b.width),
            (u = b.height)));
        null != l &&
          ((c[1] = mxUtils.getPortConstraints(l, a, !1, mxConstants.DIRECTION_MASK_ALL)),
          (b = mxUtils.getValue(l.style, mxConstants.STYLE_ROTATION, 0)),
          0 != b &&
            ((b = mxUtils.getBoundingBox(new mxRectangle(x, z, D, B), b)),
            (x = b.x),
            (z = b.y),
            (D = b.width),
            (B = b.height)));
        b = [0, 0];
        p = [
          [p, r, t, u],
          [x, z, D, B],
        ];
        C = [f, C];
        for (v = 0; 2 > v; v++)
          (mxEdgeStyle.limits[v][1] = p[v][0] - C[v]),
            (mxEdgeStyle.limits[v][2] = p[v][1] - C[v]),
            (mxEdgeStyle.limits[v][4] = p[v][0] + p[v][2] + C[v]),
            (mxEdgeStyle.limits[v][8] = p[v][1] + p[v][3] + C[v]);
        C = p[0][1] + p[0][3] / 2;
        r = p[1][1] + p[1][3] / 2;
        v = p[0][0] + p[0][2] / 2 - (p[1][0] + p[1][2] / 2);
        K = C - r;
        C = 0;
        0 > v ? (C = 0 > K ? 2 : 1) : 0 >= K && ((C = 3), 0 == v && (C = 2));
        r = null;
        null != h && (r = m);
        h = [
          [0.5, 0.5],
          [0.5, 0.5],
        ];
        for (v = 0; 2 > v; v++)
          null != r &&
            ((h[v][0] = (r.x - p[v][0]) / p[v][2]),
            1 >= Math.abs(r.x - p[v][0])
              ? (b[v] = mxConstants.DIRECTION_MASK_WEST)
              : 1 >= Math.abs(r.x - p[v][0] - p[v][2]) && (b[v] = mxConstants.DIRECTION_MASK_EAST),
            (h[v][1] = (r.y - p[v][1]) / p[v][3]),
            1 >= Math.abs(r.y - p[v][1])
              ? (b[v] = mxConstants.DIRECTION_MASK_NORTH)
              : 1 >= Math.abs(r.y - p[v][1] - p[v][3]) && (b[v] = mxConstants.DIRECTION_MASK_SOUTH)),
            (r = null),
            null != l && (r = n);
        v = p[0][1] - (p[1][1] + p[1][3]);
        n = p[0][0] - (p[1][0] + p[1][2]);
        r = p[1][1] - (p[0][1] + p[0][3]);
        t = p[1][0] - (p[0][0] + p[0][2]);
        mxEdgeStyle.vertexSeperations[1] = Math.max(n - J, 0);
        mxEdgeStyle.vertexSeperations[2] = Math.max(v - J, 0);
        mxEdgeStyle.vertexSeperations[4] = Math.max(r - J, 0);
        mxEdgeStyle.vertexSeperations[3] = Math.max(t - J, 0);
        J = [];
        l = [];
        m = [];
        l[0] = n >= t ? mxConstants.DIRECTION_MASK_WEST : mxConstants.DIRECTION_MASK_EAST;
        m[0] = v >= r ? mxConstants.DIRECTION_MASK_NORTH : mxConstants.DIRECTION_MASK_SOUTH;
        l[1] = mxUtils.reversePortConstraints(l[0]);
        m[1] = mxUtils.reversePortConstraints(m[0]);
        n = n >= t ? n : t;
        r = v >= r ? v : r;
        t = [
          [0, 0],
          [0, 0],
        ];
        u = !1;
        for (v = 0; 2 > v; v++)
          0 == b[v] &&
            (0 == (l[v] & c[v]) && (l[v] = mxUtils.reversePortConstraints(l[v])),
            0 == (m[v] & c[v]) && (m[v] = mxUtils.reversePortConstraints(m[v])),
            (t[v][0] = m[v]),
            (t[v][1] = l[v]));
        0 < r &&
          0 < n &&
          (0 < (l[0] & c[0]) && 0 < (m[1] & c[1])
            ? ((t[0][0] = l[0]), (t[0][1] = m[0]), (t[1][0] = m[1]), (t[1][1] = l[1]), (u = !0))
            : 0 < (m[0] & c[0]) &&
              0 < (l[1] & c[1]) &&
              ((t[0][0] = m[0]), (t[0][1] = l[0]), (t[1][0] = l[1]), (t[1][1] = m[1]), (u = !0)));
        0 < r && !u && ((t[0][0] = m[0]), (t[0][1] = l[0]), (t[1][0] = m[1]), (t[1][1] = l[1]), (u = !0));
        0 < n && !u && ((t[0][0] = l[0]), (t[0][1] = m[0]), (t[1][0] = l[1]), (t[1][1] = m[1]));
        for (v = 0; 2 > v; v++)
          0 == b[v] &&
            (0 == (t[v][0] & c[v]) && (t[v][0] = t[v][1]),
            (J[v] = t[v][0] & c[v]),
            (J[v] |= (t[v][1] & c[v]) << 8),
            (J[v] |= (t[1 - v][v] & c[v]) << 16),
            (J[v] |= (t[1 - v][1 - v] & c[v]) << 24),
            0 == (J[v] & 15) && (J[v] <<= 8),
            0 == (J[v] & 3840) && (J[v] = (J[v] & 15) | (J[v] >> 8)),
            0 == (J[v] & 983040) && (J[v] = (J[v] & 65535) | ((J[v] & 251658240) >> 8)),
            (b[v] = J[v] & 15),
            c[v] == mxConstants.DIRECTION_MASK_WEST ||
              c[v] == mxConstants.DIRECTION_MASK_NORTH ||
              c[v] == mxConstants.DIRECTION_MASK_EAST ||
              c[v] == mxConstants.DIRECTION_MASK_SOUTH) &&
            (b[v] = c[v]);
        c = b[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : b[0];
        J = b[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : b[1];
        c -= C;
        J -= C;
        1 > c && (c += 4);
        1 > J && (J += 4);
        c = mxEdgeStyle.routePatterns[c - 1][J - 1];
        mxEdgeStyle.wayPoints1[0][0] = p[0][0];
        mxEdgeStyle.wayPoints1[0][1] = p[0][1];
        switch (b[0]) {
          case mxConstants.DIRECTION_MASK_WEST:
            mxEdgeStyle.wayPoints1[0][0] -= f;
            mxEdgeStyle.wayPoints1[0][1] += h[0][1] * p[0][3];
            break;
          case mxConstants.DIRECTION_MASK_SOUTH:
            mxEdgeStyle.wayPoints1[0][0] += h[0][0] * p[0][2];
            mxEdgeStyle.wayPoints1[0][1] += p[0][3] + f;
            break;
          case mxConstants.DIRECTION_MASK_EAST:
            mxEdgeStyle.wayPoints1[0][0] += p[0][2] + f;
            mxEdgeStyle.wayPoints1[0][1] += h[0][1] * p[0][3];
            break;
          case mxConstants.DIRECTION_MASK_NORTH:
            (mxEdgeStyle.wayPoints1[0][0] += h[0][0] * p[0][2]), (mxEdgeStyle.wayPoints1[0][1] -= f);
        }
        f = 0;
        l = J = 0 < (b[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1;
        for (v = 0; v < c.length; v++)
          (m = c[v] & 15),
            (u = m == mxConstants.DIRECTION_MASK_EAST ? 3 : m),
            (u += C),
            4 < u && (u -= 4),
            (n = mxEdgeStyle.dirVectors[u - 1]),
            (m = 0 < u % 2 ? 0 : 1),
            m != J &&
              (f++,
              (mxEdgeStyle.wayPoints1[f][0] = mxEdgeStyle.wayPoints1[f - 1][0]),
              (mxEdgeStyle.wayPoints1[f][1] = mxEdgeStyle.wayPoints1[f - 1][1])),
            (x = 0 < (c[v] & mxEdgeStyle.TARGET_MASK)),
            (z = 0 < (c[v] & mxEdgeStyle.SOURCE_MASK)),
            (r = (c[v] & mxEdgeStyle.SIDE_MASK) >> 5),
            (r <<= C),
            15 < r && (r >>= 4),
            (t = 0 < (c[v] & mxEdgeStyle.CENTER_MASK)),
            (z || x) && 9 > r
              ? ((u = z ? 0 : 1),
                (r =
                  t && 0 == m
                    ? p[u][0] + h[u][0] * p[u][2]
                    : t
                    ? p[u][1] + h[u][1] * p[u][3]
                    : mxEdgeStyle.limits[u][r]),
                0 == m
                  ? ((r = (r - mxEdgeStyle.wayPoints1[f][0]) * n[0]),
                    0 < r && (mxEdgeStyle.wayPoints1[f][0] += n[0] * r))
                  : ((r = (r - mxEdgeStyle.wayPoints1[f][1]) * n[1]),
                    0 < r && (mxEdgeStyle.wayPoints1[f][1] += n[1] * r)))
              : t &&
                ((mxEdgeStyle.wayPoints1[f][0] += n[0] * Math.abs(mxEdgeStyle.vertexSeperations[u] / 2)),
                (mxEdgeStyle.wayPoints1[f][1] += n[1] * Math.abs(mxEdgeStyle.vertexSeperations[u] / 2))),
            0 < f && mxEdgeStyle.wayPoints1[f][m] == mxEdgeStyle.wayPoints1[f - 1][m] ? f-- : (J = m);
        for (
          v = 0;
          v <= f &&
          (v != f ||
            ((0 < (b[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 : 1) == l ? 0 : 1) ==
              (f + 1) % 2);
          v++
        )
          e.push(
            new mxPoint(
              Math.round(mxEdgeStyle.wayPoints1[v][0] * a.view.scale * 10) / 10,
              Math.round(mxEdgeStyle.wayPoints1[v][1] * a.view.scale * 10) / 10
            )
          );
        for (a = 1; a < e.length; )
          null == e[a - 1] || null == e[a] || e[a - 1].x != e[a].x || e[a - 1].y != e[a].y ? a++ : e.splice(a, 1);
      }
    },
    getRoutePattern: function (a, b, c, d) {
      var e = a[0] == mxConstants.DIRECTION_MASK_EAST ? 3 : a[0];
      a = a[1] == mxConstants.DIRECTION_MASK_EAST ? 3 : a[1];
      e -= b;
      a -= b;
      1 > e && (e += 4);
      1 > a && (a += 4);
      b = routePatterns[e - 1][a - 1];
      (0 != c && 0 != d) || null == inlineRoutePatterns[e - 1][a - 1] || (b = inlineRoutePatterns[e - 1][a - 1]);
      return b;
    },
  },
  mxStyleRegistry = {
    values: [],
    putValue: function (a, b) {
      mxStyleRegistry.values[a] = b;
    },
    getValue: function (a) {
      return mxStyleRegistry.values[a];
    },
    getName: function (a) {
      for (var b in mxStyleRegistry.values) if (mxStyleRegistry.values[b] == a) return b;
      return null;
    },
  };
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);
mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);
mxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);
function mxGraphView(a) {
  this.graph = a;
  this.translate = new mxPoint();
  this.graphBounds = new mxRectangle();
  this.states = new mxDictionary();
}
mxGraphView.prototype = new mxEventSource();
mxGraphView.prototype.constructor = mxGraphView;
mxGraphView.prototype.EMPTY_POINT = new mxPoint();
mxGraphView.prototype.doneResource = 'none' != mxClient.language ? 'done' : '';
mxGraphView.prototype.updatingDocumentResource = 'none' != mxClient.language ? 'updatingDocument' : '';
mxGraphView.prototype.allowEval = !1;
mxGraphView.prototype.captureDocumentGesture = !0;
mxGraphView.prototype.rendering = !0;
mxGraphView.prototype.graph = null;
mxGraphView.prototype.currentRoot = null;
mxGraphView.prototype.graphBounds = null;
mxGraphView.prototype.scale = 1;
mxGraphView.prototype.translate = null;
mxGraphView.prototype.states = null;
mxGraphView.prototype.updateStyle = !1;
mxGraphView.prototype.lastNode = null;
mxGraphView.prototype.lastHtmlNode = null;
mxGraphView.prototype.lastForegroundNode = null;
mxGraphView.prototype.lastForegroundHtmlNode = null;
mxGraphView.prototype.getGraphBounds = function () {
  return this.graphBounds;
};
mxGraphView.prototype.setGraphBounds = function (a) {
  this.graphBounds = a;
};
mxGraphView.prototype.getBounds = function (a) {
  var b = null;
  if (null != a && 0 < a.length)
    for (var c = this.graph.getModel(), d = 0; d < a.length; d++)
      if (c.isVertex(a[d]) || c.isEdge(a[d])) {
        var e = this.getState(a[d]);
        null != e && (null == b ? (b = mxRectangle.fromRectangle(e)) : b.add(e));
      }
  return b;
};
mxGraphView.prototype.setCurrentRoot = function (a) {
  if (this.currentRoot != a) {
    var b = new mxCurrentRootChange(this, a);
    b.execute();
    var c = new mxUndoableEdit(this, !0);
    c.add(b);
    this.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', c));
    this.graph.sizeDidChange();
  }
  return a;
};
mxGraphView.prototype.scaleAndTranslate = function (a, b, c) {
  var d = this.scale,
    e = new mxPoint(this.translate.x, this.translate.y);
  if (this.scale != a || this.translate.x != b || this.translate.y != c)
    (this.scale = a), (this.translate.x = b), (this.translate.y = c), this.isEventsEnabled() && this.viewStateChanged();
  this.fireEvent(
    new mxEventObject(
      mxEvent.SCALE_AND_TRANSLATE,
      'scale',
      a,
      'previousScale',
      d,
      'translate',
      this.translate,
      'previousTranslate',
      e
    )
  );
};
mxGraphView.prototype.getScale = function () {
  return this.scale;
};
mxGraphView.prototype.setScale = function (a) {
  var b = this.scale;
  this.scale != a && ((this.scale = a), this.isEventsEnabled() && this.viewStateChanged());
  this.fireEvent(new mxEventObject(mxEvent.SCALE, 'scale', a, 'previousScale', b));
};
mxGraphView.prototype.getTranslate = function () {
  return this.translate;
};
mxGraphView.prototype.setTranslate = function (a, b) {
  var c = new mxPoint(this.translate.x, this.translate.y);
  if (this.translate.x != a || this.translate.y != b)
    (this.translate.x = a), (this.translate.y = b), this.isEventsEnabled() && this.viewStateChanged();
  this.fireEvent(new mxEventObject(mxEvent.TRANSLATE, 'translate', this.translate, 'previousTranslate', c));
};
mxGraphView.prototype.viewStateChanged = function () {
  this.revalidate();
  this.graph.sizeDidChange();
};
mxGraphView.prototype.refresh = function () {
  null != this.currentRoot && this.clear();
  this.revalidate();
};
mxGraphView.prototype.revalidate = function () {
  this.invalidate();
  this.validate();
};
mxGraphView.prototype.clear = function (a, b, c) {
  var d = this.graph.getModel();
  a = a || d.getRoot();
  b = null != b ? b : !1;
  c = null != c ? c : !0;
  this.removeState(a);
  if (c && (b || a != this.currentRoot)) {
    c = d.getChildCount(a);
    for (var e = 0; e < c; e++) this.clear(d.getChildAt(a, e), b);
  } else this.invalidate(a);
};
mxGraphView.prototype.invalidate = function (a, b, c) {
  var d = this.graph.getModel();
  a = a || d.getRoot();
  b = null != b ? b : !0;
  c = null != c ? c : !0;
  var e = this.getState(a);
  null != e && (e.invalid = !0);
  if (!a.invalidating) {
    a.invalidating = !0;
    if (b)
      for (var f = d.getChildCount(a), e = 0; e < f; e++) {
        var g = d.getChildAt(a, e);
        this.invalidate(g, b, c);
      }
    if (c) for (f = d.getEdgeCount(a), e = 0; e < f; e++) this.invalidate(d.getEdgeAt(a, e), b, c);
    delete a.invalidating;
  }
};
mxGraphView.prototype.validate = function (a) {
  var b = mxLog.enter('mxGraphView.validate');
  window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
  this.resetValidationState();
  var c = null;
  null == this.canvas ||
    null != this.textDiv ||
    8 != document.documentMode ||
    mxClient.IS_EM ||
    ((this.placeholder = document.createElement('div')),
    (this.placeholder.style.position = 'absolute'),
    (this.placeholder.style.width = this.canvas.clientWidth + 'px'),
    (this.placeholder.style.height = this.canvas.clientHeight + 'px'),
    this.canvas.parentNode.appendChild(this.placeholder),
    (c = this.drawPane.style.display),
    (this.canvas.style.display = 'none'),
    (this.textDiv = document.createElement('div')),
    (this.textDiv.style.position = 'absolute'),
    (this.textDiv.style.whiteSpace = 'nowrap'),
    (this.textDiv.style.visibility = 'hidden'),
    (this.textDiv.style.display = 'inline-block'),
    (this.textDiv.style.zoom = '1'),
    document.body.appendChild(this.textDiv));
  a = this.getBoundingBox(
    this.validateCellState(
      this.validateCell(a || (null != this.currentRoot ? this.currentRoot : this.graph.getModel().getRoot()))
    )
  );
  this.setGraphBounds(null != a ? a : this.getEmptyBounds());
  this.validateBackground();
  null != c &&
    ((this.canvas.style.display = c),
    this.textDiv.parentNode.removeChild(this.textDiv),
    null != this.placeholder && this.placeholder.parentNode.removeChild(this.placeholder),
    (this.textDiv = null));
  this.resetValidationState();
  window.status = mxResources.get(this.doneResource) || this.doneResource;
  mxLog.leave('mxGraphView.validate', b);
};
mxGraphView.prototype.getEmptyBounds = function () {
  return new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);
};
mxGraphView.prototype.getBoundingBox = function (a, b) {
  b = null != b ? b : !0;
  var c = null;
  if (
    null != a &&
    (null != a.shape && null != a.shape.boundingBox && (c = a.shape.boundingBox.clone()),
    null != a.text &&
      null != a.text.boundingBox &&
      (null != c ? c.add(a.text.boundingBox) : (c = a.text.boundingBox.clone())),
    b)
  )
    for (var d = this.graph.getModel(), e = d.getChildCount(a.cell), f = 0; f < e; f++) {
      var g = this.getBoundingBox(this.getState(d.getChildAt(a.cell, f)));
      null != g && (null == c ? (c = g) : c.add(g));
    }
  return c;
};
mxGraphView.prototype.createBackgroundPageShape = function (a) {
  return new mxRectangleShape(a, 'white', 'black');
};
mxGraphView.prototype.validateBackground = function () {
  this.validateBackgroundImage();
  this.validateBackgroundPage();
};
mxGraphView.prototype.validateBackgroundImage = function () {
  var a = this.graph.getBackgroundImage();
  if (null != a) {
    if (null == this.backgroundImage || this.backgroundImage.image != a.src) {
      null != this.backgroundImage && this.backgroundImage.destroy();
      var b = new mxRectangle(0, 0, 1, 1);
      this.backgroundImage = new mxImageShape(b, a.src);
      this.backgroundImage.dialect = this.graph.dialect;
      this.backgroundImage.init(this.backgroundPane);
      this.backgroundImage.redraw();
      8 != document.documentMode ||
        mxClient.IS_EM ||
        mxEvent.addGestureListeners(
          this.backgroundImage.node,
          mxUtils.bind(this, function (a) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a));
          }),
          mxUtils.bind(this, function (a) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a));
          }),
          mxUtils.bind(this, function (a) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a));
          })
        );
    }
    this.redrawBackgroundImage(this.backgroundImage, a);
  } else null != this.backgroundImage && (this.backgroundImage.destroy(), (this.backgroundImage = null));
};
mxGraphView.prototype.validateBackgroundPage = function () {
  if (this.graph.pageVisible) {
    var a = this.getBackgroundPageBounds();
    null == this.backgroundPageShape
      ? ((this.backgroundPageShape = this.createBackgroundPageShape(a)),
        (this.backgroundPageShape.scale = this.scale),
        (this.backgroundPageShape.isShadow = !0),
        (this.backgroundPageShape.dialect = this.graph.dialect),
        this.backgroundPageShape.init(this.backgroundPane),
        this.backgroundPageShape.redraw(),
        this.graph.nativeDblClickEnabled &&
          mxEvent.addListener(
            this.backgroundPageShape.node,
            'dblclick',
            mxUtils.bind(this, function (a) {
              this.graph.dblClick(a);
            })
          ),
        mxEvent.addGestureListeners(
          this.backgroundPageShape.node,
          mxUtils.bind(this, function (a) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a));
          }),
          mxUtils.bind(this, function (a) {
            null != this.graph.tooltipHandler &&
              this.graph.tooltipHandler.isHideOnHover() &&
              this.graph.tooltipHandler.hide();
            this.graph.isMouseDown &&
              !mxEvent.isConsumed(a) &&
              this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a));
          }),
          mxUtils.bind(this, function (a) {
            this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a));
          })
        ))
      : ((this.backgroundPageShape.scale = this.scale),
        (this.backgroundPageShape.bounds = a),
        this.backgroundPageShape.redraw());
  } else null != this.backgroundPageShape && (this.backgroundPageShape.destroy(), (this.backgroundPageShape = null));
};
mxGraphView.prototype.getBackgroundPageBounds = function () {
  var a = this.graph.pageFormat,
    b = this.scale * this.graph.pageScale;
  return new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, a.width * b, a.height * b);
};
mxGraphView.prototype.redrawBackgroundImage = function (a, b) {
  a.scale = this.scale;
  a.bounds.x = this.scale * (this.translate.x + b.x);
  a.bounds.y = this.scale * (this.translate.y + b.y);
  a.bounds.width = this.scale * b.width;
  a.bounds.height = this.scale * b.height;
  a.redraw();
};
mxGraphView.prototype.validateCell = function (a, b) {
  if (null != a)
    if (((b = (null != b ? b : !0) && this.graph.isCellVisible(a)), null == this.getState(a, b) || b))
      for (var c = this.graph.getModel(), d = c.getChildCount(a), e = 0; e < d; e++)
        this.validateCell(c.getChildAt(a, e), b && (!this.isCellCollapsed(a) || a == this.currentRoot));
    else this.removeState(a);
  return a;
};
mxGraphView.prototype.validateCellState = function (a, b) {
  b = null != b ? b : !0;
  var c = null;
  if (null != a && ((c = this.getState(a)), null != c)) {
    var d = this.graph.getModel();
    if (c.invalid) {
      c.invalid = !1;
      if (null == c.style || c.invalidStyle) (c.style = this.graph.getCellStyle(c.cell)), (c.invalidStyle = !1);
      a != this.currentRoot && this.validateCellState(d.getParent(a), !1);
      c.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(a, !0), !1), !0);
      c.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(a, !1), !1), !1);
      this.updateCellState(c);
      a == this.currentRoot ||
        c.invalid ||
        (this.graph.cellRenderer.redraw(c, !1, this.isRendering()), c.updateCachedBounds());
    }
    if (b && !c.invalid) {
      null != c.shape && this.stateValidated(c);
      for (var e = d.getChildCount(a), f = 0; f < e; f++) this.validateCellState(d.getChildAt(a, f));
    }
  }
  return c;
};
mxGraphView.prototype.updateCellState = function (a) {
  a.absoluteOffset.x = 0;
  a.absoluteOffset.y = 0;
  a.origin.x = 0;
  a.origin.y = 0;
  a.length = 0;
  if (a.cell != this.currentRoot) {
    var b = this.graph.getModel(),
      c = this.getState(b.getParent(a.cell));
    null != c && c.cell != this.currentRoot && ((a.origin.x += c.origin.x), (a.origin.y += c.origin.y));
    var d = this.graph.getChildOffsetForCell(a.cell);
    null != d && ((a.origin.x += d.x), (a.origin.y += d.y));
    var e = this.graph.getCellGeometry(a.cell);
    null != e &&
      (b.isEdge(a.cell) ||
        ((d = null != e.offset ? e.offset : this.EMPTY_POINT),
        e.relative && null != c
          ? b.isEdge(c.cell)
            ? ((d = this.getPoint(c, e)),
              null != d &&
                ((a.origin.x += d.x / this.scale - c.origin.x - this.translate.x),
                (a.origin.y += d.y / this.scale - c.origin.y - this.translate.y)))
            : ((a.origin.x += e.x * c.unscaledWidth + d.x), (a.origin.y += e.y * c.unscaledHeight + d.y))
          : ((a.absoluteOffset.x = this.scale * d.x),
            (a.absoluteOffset.y = this.scale * d.y),
            (a.origin.x += e.x),
            (a.origin.y += e.y))),
      (a.x = this.scale * (this.translate.x + a.origin.x)),
      (a.y = this.scale * (this.translate.y + a.origin.y)),
      (a.width = this.scale * e.width),
      (a.unscaledWidth = e.width),
      (a.height = this.scale * e.height),
      (a.unscaledHeight = e.height),
      b.isVertex(a.cell) && this.updateVertexState(a, e),
      b.isEdge(a.cell) && this.updateEdgeState(a, e));
  }
  a.updateCachedBounds();
};
mxGraphView.prototype.isCellCollapsed = function (a) {
  return this.graph.isCellCollapsed(a);
};
mxGraphView.prototype.updateVertexState = function (a, b) {
  var c = this.graph.getModel(),
    d = this.getState(c.getParent(a.cell));
  if (b.relative && null != d && !c.isEdge(d.cell)) {
    var e = mxUtils.toRadians(d.style[mxConstants.STYLE_ROTATION] || '0');
    if (0 != e) {
      var c = Math.cos(e),
        e = Math.sin(e),
        f = new mxPoint(a.getCenterX(), a.getCenterY()),
        d = new mxPoint(d.getCenterX(), d.getCenterY()),
        d = mxUtils.getRotatedPoint(f, c, e, d);
      a.x = d.x - a.width / 2;
      a.y = d.y - a.height / 2;
    }
  }
  this.updateVertexLabelOffset(a);
};
mxGraphView.prototype.updateEdgeState = function (a, b) {
  var c = a.getVisibleTerminalState(!0),
    d = a.getVisibleTerminalState(!1);
  (null != this.graph.model.getTerminal(a.cell, !0) && null == c) ||
  (null == c && null == b.getTerminalPoint(!0)) ||
  (null != this.graph.model.getTerminal(a.cell, !1) && null == d) ||
  (null == d && null == b.getTerminalPoint(!1))
    ? this.clear(a.cell, !0)
    : (this.updateFixedTerminalPoints(a, c, d),
      this.updatePoints(a, b.points, c, d),
      this.updateFloatingTerminalPoints(a, c, d),
      (c = a.absolutePoints),
      a.cell != this.currentRoot && (null == c || 2 > c.length || null == c[0] || null == c[c.length - 1])
        ? this.clear(a.cell, !0)
        : (this.updateEdgeBounds(a), this.updateEdgeLabelOffset(a)));
};
mxGraphView.prototype.updateVertexLabelOffset = function (a) {
  var b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
  if (b == mxConstants.ALIGN_LEFT)
    (b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_WIDTH, null)),
      (b = null != b ? b * this.scale : a.width),
      (a.absoluteOffset.x -= b);
  else if (b == mxConstants.ALIGN_RIGHT) a.absoluteOffset.x += a.width;
  else if (
    b == mxConstants.ALIGN_CENTER &&
    ((b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_WIDTH, null)), null != b)
  ) {
    var c = mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),
      d = 0;
    c == mxConstants.ALIGN_CENTER ? (d = 0.5) : c == mxConstants.ALIGN_RIGHT && (d = 1);
    0 != d && (a.absoluteOffset.x -= (b * this.scale - a.width) * d);
  }
  b = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);
  b == mxConstants.ALIGN_TOP
    ? (a.absoluteOffset.y -= a.height)
    : b == mxConstants.ALIGN_BOTTOM && (a.absoluteOffset.y += a.height);
};
mxGraphView.prototype.resetValidationState = function () {
  this.lastForegroundHtmlNode = this.lastForegroundNode = this.lastHtmlNode = this.lastNode = null;
};
mxGraphView.prototype.stateValidated = function (a) {
  var b =
    (this.graph.getModel().isEdge(a.cell) && this.graph.keepEdgesInForeground) ||
    (this.graph.getModel().isVertex(a.cell) && this.graph.keepEdgesInBackground);
  a = this.graph.cellRenderer.insertStateAfter(
    a,
    b ? this.lastForegroundNode || this.lastNode : this.lastNode,
    b ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode
  );
  b
    ? ((this.lastForegroundHtmlNode = a[1]), (this.lastForegroundNode = a[0]))
    : ((this.lastHtmlNode = a[1]), (this.lastNode = a[0]));
};
mxGraphView.prototype.updateFixedTerminalPoints = function (a, b, c) {
  this.updateFixedTerminalPoint(a, b, !0, this.graph.getConnectionConstraint(a, b, !0));
  this.updateFixedTerminalPoint(a, c, !1, this.graph.getConnectionConstraint(a, c, !1));
};
mxGraphView.prototype.updateFixedTerminalPoint = function (a, b, c, d) {
  a.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(a, b, c, d), c);
};
mxGraphView.prototype.getFixedTerminalPoint = function (a, b, c, d) {
  var e = null;
  null != d && (e = this.graph.getConnectionPoint(b, d, !1));
  if (null == e && null == b) {
    b = this.scale;
    d = this.translate;
    var f = a.origin,
      e = this.graph.getCellGeometry(a.cell).getTerminalPoint(c);
    null != e && (e = new mxPoint(b * (d.x + e.x + f.x), b * (d.y + e.y + f.y)));
  }
  return e;
};
mxGraphView.prototype.updateBoundsFromStencil = function (a) {
  var b = null;
  if (null != a && null != a.shape && null != a.shape.stencil && 'fixed' == a.shape.stencil.aspect) {
    var b = mxRectangle.fromRectangle(a),
      c = a.shape.stencil.computeAspect(a.style, a.x, a.y, a.width, a.height);
    a.setRect(c.x, c.y, a.shape.stencil.w0 * c.width, a.shape.stencil.h0 * c.height);
  }
  return b;
};
mxGraphView.prototype.updatePoints = function (a, b, c, d) {
  if (null != a) {
    var e = [];
    e.push(a.absolutePoints[0]);
    var f = this.getEdgeStyle(a, b, c, d);
    if (null != f) {
      c = this.getTerminalPort(a, c, !0);
      d = this.getTerminalPort(a, d, !1);
      var g = this.updateBoundsFromStencil(c),
        k = this.updateBoundsFromStencil(d);
      f(a, c, d, b, e);
      null != g && c.setRect(g.x, g.y, g.width, g.height);
      null != k && d.setRect(k.x, k.y, k.width, k.height);
    } else if (null != b)
      for (f = 0; f < b.length; f++)
        null != b[f] && ((c = mxUtils.clone(b[f])), e.push(this.transformControlPoint(a, c)));
    b = a.absolutePoints;
    e.push(b[b.length - 1]);
    a.absolutePoints = e;
  }
};
mxGraphView.prototype.transformControlPoint = function (a, b, c) {
  return null != a && null != b
    ? ((a = a.origin),
      (c = c ? 1 : this.scale),
      new mxPoint(c * (b.x + this.translate.x + a.x), c * (b.y + this.translate.y + a.y)))
    : null;
};
mxGraphView.prototype.isLoopStyleEnabled = function (a, b, c, d) {
  var e = this.graph.getConnectionConstraint(a, c, !0),
    f = this.graph.getConnectionConstraint(a, d, !1);
  return !(null == b || 2 > b.length) ||
    (mxUtils.getValue(a.style, mxConstants.STYLE_ORTHOGONAL_LOOP, !1) &&
      ((null != e && null != e.point) || (null != f && null != f.point)))
    ? !1
    : null != c && c == d;
};
mxGraphView.prototype.getEdgeStyle = function (a, b, c, d) {
  a = this.isLoopStyleEnabled(a, b, c, d)
    ? mxUtils.getValue(a.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle)
    : mxUtils.getValue(a.style, mxConstants.STYLE_NOEDGESTYLE, !1)
    ? null
    : a.style[mxConstants.STYLE_EDGE];
  'string' == typeof a &&
    ((b = mxStyleRegistry.getValue(a)), null == b && this.isAllowEval() && (b = mxUtils.eval(a)), (a = b));
  return 'function' == typeof a ? a : null;
};
mxGraphView.prototype.updateFloatingTerminalPoints = function (a, b, c) {
  var d = a.absolutePoints,
    e = d[0];
  null == d[d.length - 1] && null != c && this.updateFloatingTerminalPoint(a, c, b, !1);
  null == e && null != b && this.updateFloatingTerminalPoint(a, b, c, !0);
};
mxGraphView.prototype.updateFloatingTerminalPoint = function (a, b, c, d) {
  a.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(a, b, c, d), d);
};
mxGraphView.prototype.getFloatingTerminalPoint = function (a, b, c, d) {
  b = this.getTerminalPort(a, b, d);
  var e = this.getNextPoint(a, c, d),
    f = this.graph.isOrthogonal(a);
  c = mxUtils.toRadians(Number(b.style[mxConstants.STYLE_ROTATION] || '0'));
  var g = new mxPoint(b.getCenterX(), b.getCenterY());
  if (0 != c)
    var k = Math.cos(-c),
      h = Math.sin(-c),
      e = mxUtils.getRotatedPoint(e, k, h, g);
  k = parseFloat(a.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
  k += parseFloat(
    a.style[d ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0
  );
  a = this.getPerimeterPoint(b, e, 0 == c && f, k);
  0 != c && ((k = Math.cos(c)), (h = Math.sin(c)), (a = mxUtils.getRotatedPoint(a, k, h, g)));
  return a;
};
mxGraphView.prototype.getTerminalPort = function (a, b, c) {
  a = mxUtils.getValue(a.style, c ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT);
  null != a && ((a = this.getState(this.graph.getModel().getCell(a))), null != a && (b = a));
  return b;
};
mxGraphView.prototype.getPerimeterPoint = function (a, b, c, d) {
  var e = null;
  if (null != a) {
    var f = this.getPerimeterFunction(a);
    if (null != f && null != b && ((d = this.getPerimeterBounds(a, d)), 0 < d.width || 0 < d.height)) {
      var e = new mxPoint(b.x, b.y),
        g = (b = !1);
      this.graph.model.isVertex(a.cell) &&
        ((b = 1 == mxUtils.getValue(a.style, mxConstants.STYLE_FLIPH, 0)),
        (g = 1 == mxUtils.getValue(a.style, mxConstants.STYLE_FLIPV, 0)),
        null != a.shape &&
          null != a.shape.stencil &&
          ((b = 1 == mxUtils.getValue(a.style, 'stencilFlipH', 0) || b),
          (g = 1 == mxUtils.getValue(a.style, 'stencilFlipV', 0) || g)),
        b && (e.x = 2 * d.getCenterX() - e.x),
        g && (e.y = 2 * d.getCenterY() - e.y));
      e = f(d, a, e, c);
      null != e && (b && (e.x = 2 * d.getCenterX() - e.x), g && (e.y = 2 * d.getCenterY() - e.y));
    }
    null == e && (e = this.getPoint(a));
  }
  return e;
};
mxGraphView.prototype.getRoutingCenterX = function (a) {
  var b = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;
  return a.getCenterX() + b * a.width;
};
mxGraphView.prototype.getRoutingCenterY = function (a) {
  var b = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;
  return a.getCenterY() + b * a.height;
};
mxGraphView.prototype.getPerimeterBounds = function (a, b) {
  b = null != b ? b : 0;
  null != a && (b += parseFloat(a.style[mxConstants.STYLE_PERIMETER_SPACING] || 0));
  return a.getPerimeterBounds(b * this.scale);
};
mxGraphView.prototype.getPerimeterFunction = function (a) {
  a = a.style[mxConstants.STYLE_PERIMETER];
  if ('string' == typeof a) {
    var b = mxStyleRegistry.getValue(a);
    null == b && this.isAllowEval() && (b = mxUtils.eval(a));
    a = b;
  }
  return 'function' == typeof a ? a : null;
};
mxGraphView.prototype.getNextPoint = function (a, b, c) {
  a = a.absolutePoints;
  var d = null;
  null != a && 2 <= a.length && ((d = a.length), (d = a[c ? Math.min(1, d - 1) : Math.max(0, d - 2)]));
  null == d && null != b && (d = new mxPoint(b.getCenterX(), b.getCenterY()));
  return d;
};
mxGraphView.prototype.getVisibleTerminal = function (a, b) {
  for (var c = this.graph.getModel(), d = c.getTerminal(a, b), e = d; null != d && d != this.currentRoot; ) {
    if (!this.graph.isCellVisible(e) || this.isCellCollapsed(d)) e = d;
    d = c.getParent(d);
  }
  null == e || (c.contains(e) && c.getParent(e) != c.getRoot() && e != this.currentRoot) || (e = null);
  return e;
};
mxGraphView.prototype.updateEdgeBounds = function (a) {
  var b = a.absolutePoints,
    c = b[0],
    d = b[b.length - 1];
  if (c.x != d.x || c.y != d.y) {
    var e = d.x - c.x,
      f = d.y - c.y;
    a.terminalDistance = Math.sqrt(e * e + f * f);
  } else a.terminalDistance = 0;
  var d = 0,
    g = [],
    f = c;
  if (null != f) {
    for (var c = f.x, k = f.y, h = c, l = k, m = 1; m < b.length; m++) {
      var n = b[m];
      null != n &&
        ((e = f.x - n.x),
        (f = f.y - n.y),
        (e = Math.sqrt(e * e + f * f)),
        g.push(e),
        (d += e),
        (f = n),
        (c = Math.min(f.x, c)),
        (k = Math.min(f.y, k)),
        (h = Math.max(f.x, h)),
        (l = Math.max(f.y, l)));
    }
    a.length = d;
    a.segments = g;
    a.x = c;
    a.y = k;
    a.width = Math.max(1, h - c);
    a.height = Math.max(1, l - k);
  }
};
mxGraphView.prototype.getPoint = function (a, b) {
  var c = a.getCenterX(),
    d = a.getCenterY();
  if (null == a.segments || (null != b && !b.relative))
    null != b && ((l = b.offset), null != l && ((c += l.x), (d += l.y)));
  else {
    for (
      var e = a.absolutePoints.length,
        f = Math.round(((null != b ? b.x / 2 : 0) + 0.5) * a.length),
        g = a.segments[0],
        k = 0,
        h = 1;
      f >= Math.round(k + g) && h < e - 1;

    )
      (k += g), (g = a.segments[h++]);
    e = 0 == g ? 0 : (f - k) / g;
    f = a.absolutePoints[h - 1];
    h = a.absolutePoints[h];
    if (null != f && null != h) {
      k = c = d = 0;
      if (null != b) {
        var d = b.y,
          l = b.offset;
        null != l && ((c = l.x), (k = l.y));
      }
      l = h.x - f.x;
      h = h.y - f.y;
      c = f.x + l * e + ((0 == g ? 0 : h / g) * d + c) * this.scale;
      d = f.y + h * e - ((0 == g ? 0 : l / g) * d - k) * this.scale;
    }
  }
  return new mxPoint(c, d);
};
mxGraphView.prototype.getRelativePoint = function (a, b, c) {
  var d = this.graph.getModel().getGeometry(a.cell);
  if (null != d) {
    var e = a.absolutePoints.length;
    if (d.relative && 1 < e) {
      for (
        var d = a.length,
          f = a.segments,
          g = a.absolutePoints[0],
          k = a.absolutePoints[1],
          h = mxUtils.ptSegDistSq(g.x, g.y, k.x, k.y, b, c),
          l = 0,
          m = 0,
          n = 0,
          p = 2;
        p < e;
        p++
      )
        (g = k),
          (k = a.absolutePoints[p]),
          (g = mxUtils.ptSegDistSq(g.x, g.y, k.x, k.y, b, c)),
          (n += f[p - 2]),
          g <= h && ((h = g), (m = p - 1), (l = n));
      e = f[m];
      g = a.absolutePoints[m];
      k = a.absolutePoints[m + 1];
      h = k.x;
      f = k.y;
      a = g.x - h;
      m = g.y - f;
      h = a - (b - h);
      f = m - (c - f);
      f = h * a + f * m;
      a = Math.sqrt(0 >= f ? 0 : (f * f) / (a * a + m * m));
      a > e && (a = e);
      e = Math.sqrt(mxUtils.ptSegDistSq(g.x, g.y, k.x, k.y, b, c));
      -1 == mxUtils.relativeCcw(g.x, g.y, k.x, k.y, b, c) && (e = -e);
      return new mxPoint(((d / 2 - l - a) / d) * -2, e / this.scale);
    }
  }
  return new mxPoint();
};
mxGraphView.prototype.updateEdgeLabelOffset = function (a) {
  var b = a.absolutePoints;
  a.absoluteOffset.x = a.getCenterX();
  a.absoluteOffset.y = a.getCenterY();
  if (null != b && 0 < b.length && null != a.segments) {
    var c = this.graph.getCellGeometry(a.cell);
    if (c.relative) {
      var d = this.getPoint(a, c);
      null != d && (a.absoluteOffset = d);
    } else {
      var d = b[0],
        e = b[b.length - 1];
      if (null != d && null != e) {
        var b = e.x - d.x,
          f = e.y - d.y,
          g = (e = 0),
          c = c.offset;
        null != c && ((e = c.x), (g = c.y));
        c = d.y + f / 2 + g * this.scale;
        a.absoluteOffset.x = d.x + b / 2 + e * this.scale;
        a.absoluteOffset.y = c;
      }
    }
  }
};
mxGraphView.prototype.getState = function (a, b) {
  b = b || !1;
  var c = null;
  null != a &&
    ((c = this.states.get(a)),
    b &&
      (null == c || this.updateStyle) &&
      this.graph.isCellVisible(a) &&
      (null == c ? ((c = this.createState(a)), this.states.put(a, c)) : (c.style = this.graph.getCellStyle(a))));
  return c;
};
mxGraphView.prototype.isRendering = function () {
  return this.rendering;
};
mxGraphView.prototype.setRendering = function (a) {
  this.rendering = a;
};
mxGraphView.prototype.isAllowEval = function () {
  return this.allowEval;
};
mxGraphView.prototype.setAllowEval = function (a) {
  this.allowEval = a;
};
mxGraphView.prototype.getStates = function () {
  return this.states;
};
mxGraphView.prototype.setStates = function (a) {
  this.states = a;
};
mxGraphView.prototype.getCellStates = function (a) {
  if (null == a) return this.states;
  for (var b = [], c = 0; c < a.length; c++) {
    var d = this.getState(a[c]);
    null != d && b.push(d);
  }
  return b;
};
mxGraphView.prototype.removeState = function (a) {
  var b = null;
  null != a &&
    ((b = this.states.remove(a)), null != b && (this.graph.cellRenderer.destroy(b), (b.invalid = !0), b.destroy()));
  return b;
};
mxGraphView.prototype.createState = function (a) {
  return new mxCellState(this, a, this.graph.getCellStyle(a));
};
mxGraphView.prototype.getCanvas = function () {
  return this.canvas;
};
mxGraphView.prototype.getBackgroundPane = function () {
  return this.backgroundPane;
};
mxGraphView.prototype.getDrawPane = function () {
  return this.drawPane;
};
mxGraphView.prototype.getOverlayPane = function () {
  return this.overlayPane;
};
mxGraphView.prototype.getDecoratorPane = function () {
  return this.decoratorPane;
};
mxGraphView.prototype.isContainerEvent = function (a) {
  a = mxEvent.getSource(a);
  return (
    a == this.graph.container ||
    a.parentNode == this.backgroundPane ||
    (null != a.parentNode && a.parentNode.parentNode == this.backgroundPane) ||
    a == this.canvas.parentNode ||
    a == this.canvas ||
    a == this.backgroundPane ||
    a == this.drawPane ||
    a == this.overlayPane ||
    a == this.decoratorPane
  );
};
mxGraphView.prototype.isScrollEvent = function (a) {
  var b = mxUtils.getOffset(this.graph.container);
  a = new mxPoint(a.clientX - b.x, a.clientY - b.y);
  var b = this.graph.container.offsetWidth,
    c = this.graph.container.clientWidth;
  if (b > c && a.x > c + 2 && a.x <= b) return !0;
  b = this.graph.container.offsetHeight;
  c = this.graph.container.clientHeight;
  return b > c && a.y > c + 2 && a.y <= b ? !0 : !1;
};
mxGraphView.prototype.init = function () {
  this.installListeners();
  this.graph.dialect == mxConstants.DIALECT_SVG ? this.createSvg() : this.createHtml();
};
mxGraphView.prototype.installListeners = function () {
  var a = this.graph,
    b = a.container;
  if (null != b) {
    mxClient.IS_TOUCH &&
      (mxEvent.addListener(
        b,
        'gesturestart',
        mxUtils.bind(this, function (b) {
          a.fireGestureEvent(b);
          mxEvent.consume(b);
        })
      ),
      mxEvent.addListener(
        b,
        'gesturechange',
        mxUtils.bind(this, function (b) {
          a.fireGestureEvent(b);
          mxEvent.consume(b);
        })
      ),
      mxEvent.addListener(
        b,
        'gestureend',
        mxUtils.bind(this, function (b) {
          a.fireGestureEvent(b);
          mxEvent.consume(b);
        })
      ));
    mxEvent.addGestureListeners(
      b,
      mxUtils.bind(this, function (b) {
        !this.isContainerEvent(b) ||
          ((mxClient.IS_IE || mxClient.IS_IE11 || mxClient.IS_GC || mxClient.IS_OP || mxClient.IS_SF) &&
            this.isScrollEvent(b)) ||
          a.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b));
      }),
      mxUtils.bind(this, function (b) {
        this.isContainerEvent(b) && a.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b));
      }),
      mxUtils.bind(this, function (b) {
        this.isContainerEvent(b) && a.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b));
      })
    );
    mxEvent.addListener(
      b,
      'dblclick',
      mxUtils.bind(this, function (b) {
        this.isContainerEvent(b) && a.dblClick(b);
      })
    );
    var c = function (c) {
      var d = null;
      mxClient.IS_TOUCH &&
        ((d = mxEvent.getClientX(c)),
        (c = mxEvent.getClientY(c)),
        (c = mxUtils.convertPoint(b, d, c)),
        (d = a.view.getState(a.getCellAt(c.x, c.y))));
      return d;
    };
    a.addMouseListener({
      mouseDown: function (b, c) {
        a.popupMenuHandler.hideMenu();
      },
      mouseMove: function () {},
      mouseUp: function () {},
    });
    this.moveHandler = mxUtils.bind(this, function (b) {
      null != a.tooltipHandler && a.tooltipHandler.isHideOnHover() && a.tooltipHandler.hide();
      this.captureDocumentGesture &&
        a.isMouseDown &&
        null != a.container &&
        !this.isContainerEvent(b) &&
        'none' != a.container.style.display &&
        'hidden' != a.container.style.visibility &&
        !mxEvent.isConsumed(b) &&
        a.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, c(b)));
    });
    this.endHandler = mxUtils.bind(this, function (b) {
      this.captureDocumentGesture &&
        a.isMouseDown &&
        null != a.container &&
        !this.isContainerEvent(b) &&
        'none' != a.container.style.display &&
        'hidden' != a.container.style.visibility &&
        a.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b));
    });
    mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
};
mxGraphView.prototype.createHtml = function () {
  var a = this.graph.container;
  null != a &&
    ((this.canvas = this.createHtmlPane('100%', '100%')),
    (this.canvas.style.overflow = 'hidden'),
    (this.backgroundPane = this.createHtmlPane('1px', '1px')),
    (this.drawPane = this.createHtmlPane('1px', '1px')),
    (this.overlayPane = this.createHtmlPane('1px', '1px')),
    (this.decoratorPane = this.createHtmlPane('1px', '1px')),
    this.canvas.appendChild(this.backgroundPane),
    this.canvas.appendChild(this.drawPane),
    this.canvas.appendChild(this.overlayPane),
    this.canvas.appendChild(this.decoratorPane),
    a.appendChild(this.canvas),
    this.updateContainerStyle(a));
};
mxGraphView.prototype.updateHtmlCanvasSize = function (a, b) {
  if (null != this.graph.container) {
    var c = this.graph.container.offsetHeight;
    this.canvas.style.width = this.graph.container.offsetWidth < a ? a + 'px' : '100%';
    this.canvas.style.height = c < b ? b + 'px' : '100%';
  }
};
mxGraphView.prototype.createHtmlPane = function (a, b) {
  var c = document.createElement('DIV');
  null != a && null != b
    ? ((c.style.position = 'absolute'),
      (c.style.left = '0px'),
      (c.style.top = '0px'),
      (c.style.width = a),
      (c.style.height = b))
    : (c.style.position = 'relative');
  return c;
};
mxGraphView.prototype.createSvg = function () {
  var a = this.graph.container;
  this.canvas = document.createElementNS(mxConstants.NS_SVG, 'g');
  this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, 'g');
  this.canvas.appendChild(this.backgroundPane);
  this.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g');
  this.canvas.appendChild(this.drawPane);
  this.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g');
  this.canvas.appendChild(this.overlayPane);
  this.decoratorPane = document.createElementNS(mxConstants.NS_SVG, 'g');
  this.canvas.appendChild(this.decoratorPane);
  var b = document.createElementNS(mxConstants.NS_SVG, 'svg');
  b.style.left = '0px';
  b.style.top = '0px';
  b.style.width = '100%';
  b.style.height = '100%';
  b.style.display = 'block';
  b.appendChild(this.canvas);
  if (mxClient.IS_IE || mxClient.IS_IE11) b.style.overflow = 'hidden';
  null != a && (a.appendChild(b), this.updateContainerStyle(a));
};
mxGraphView.prototype.updateContainerStyle = function (a) {
  var b = mxUtils.getCurrentStyle(a);
  null != b && 'static' == b.position && (a.style.position = 'relative');
  mxClient.IS_POINTER && (a.style.touchAction = 'none');
};
mxGraphView.prototype.destroy = function () {
  var a = null != this.canvas ? this.canvas.ownerSVGElement : null;
  null == a && (a = this.canvas);
  null != a &&
    null != a.parentNode &&
    (this.clear(this.currentRoot, !0),
    mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler),
    mxEvent.release(this.graph.container),
    a.parentNode.removeChild(a),
    (this.decoratorPane =
      this.overlayPane =
      this.drawPane =
      this.backgroundPane =
      this.canvas =
      this.endHandler =
      this.moveHandler =
        null));
};
function mxCurrentRootChange(a, b) {
  this.view = a;
  this.previous = this.root = b;
  this.isUp = null == b;
  if (!this.isUp)
    for (var c = this.view.currentRoot, d = this.view.graph.getModel(); null != c; ) {
      if (c == b) {
        this.isUp = !0;
        break;
      }
      c = d.getParent(c);
    }
}
mxCurrentRootChange.prototype.execute = function () {
  var a = this.view.currentRoot;
  this.view.currentRoot = this.previous;
  this.previous = a;
  a = this.view.graph.getTranslateForRoot(this.view.currentRoot);
  null != a && (this.view.translate = new mxPoint(-a.x, -a.y));
  this.isUp ? (this.view.clear(this.view.currentRoot, !0), this.view.validate()) : this.view.refresh();
  this.view.fireEvent(
    new mxEventObject(this.isUp ? mxEvent.UP : mxEvent.DOWN, 'root', this.view.currentRoot, 'previous', this.previous)
  );
  this.isUp = !this.isUp;
};
function mxGraph(a, b, c, d, e) {
  this.mouseListeners = null;
  this.renderHint = c;
  this.dialect = mxClient.IS_SVG
    ? mxConstants.DIALECT_SVG
    : c == mxConstants.RENDERING_HINT_FASTEST
    ? mxConstants.DIALECT_STRICTHTML
    : c == mxConstants.RENDERING_HINT_FASTER
    ? mxConstants.DIALECT_PREFERHTML
    : mxConstants.DIALECT_MIXEDHTML;
  this.model = null != b ? b : new mxGraphModel();
  this.multiplicities = [];
  this.imageBundles = [];
  this.cellRenderer = this.createCellRenderer();
  this.setSelectionModel(this.createSelectionModel());
  this.setStylesheet(null != d ? d : this.createStylesheet());
  this.view = this.createGraphView();
  this.view.rendering = null != e ? e : this.view.rendering;
  this.graphModelChangeListener = mxUtils.bind(this, function (a, b) {
    this.graphModelChanged(b.getProperty('edit').changes);
  });
  this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);
  this.createHandlers();
  null != a && this.init(a);
  this.view.rendering && this.view.revalidate();
}
mxLoadResources
  ? mxResources.add(mxClient.basePath + '/resources/graph')
  : mxClient.defaultBundles.push(mxClient.basePath + '/resources/graph');
mxGraph.prototype = new mxEventSource();
mxGraph.prototype.constructor = mxGraph;
mxGraph.prototype.mouseListeners = null;
mxGraph.prototype.isMouseDown = !1;
mxGraph.prototype.model = null;
mxGraph.prototype.view = null;
mxGraph.prototype.stylesheet = null;
mxGraph.prototype.selectionModel = null;
mxGraph.prototype.cellEditor = null;
mxGraph.prototype.cellRenderer = null;
mxGraph.prototype.multiplicities = null;
mxGraph.prototype.renderHint = null;
mxGraph.prototype.dialect = null;
mxGraph.prototype.gridSize = 10;
mxGraph.prototype.gridEnabled = !0;
mxGraph.prototype.portsEnabled = !0;
mxGraph.prototype.nativeDblClickEnabled = !0;
mxGraph.prototype.doubleTapEnabled = !0;
mxGraph.prototype.doubleTapTimeout = 500;
mxGraph.prototype.doubleTapTolerance = 25;
mxGraph.prototype.lastTouchY = 0;
mxGraph.prototype.lastTouchY = 0;
mxGraph.prototype.lastTouchTime = 0;
mxGraph.prototype.tapAndHoldEnabled = !0;
mxGraph.prototype.tapAndHoldDelay = 500;
mxGraph.prototype.tapAndHoldInProgress = !1;
mxGraph.prototype.tapAndHoldValid = !1;
mxGraph.prototype.initialTouchX = 0;
mxGraph.prototype.initialTouchY = 0;
mxGraph.prototype.tolerance = 4;
mxGraph.prototype.defaultOverlap = 0.5;
mxGraph.prototype.defaultParent = null;
mxGraph.prototype.alternateEdgeStyle = null;
mxGraph.prototype.backgroundImage = null;
mxGraph.prototype.pageVisible = !1;
mxGraph.prototype.pageBreaksVisible = !1;
mxGraph.prototype.pageBreakColor = 'gray';
mxGraph.prototype.pageBreakDashed = !0;
mxGraph.prototype.minPageBreakDist = 20;
mxGraph.prototype.preferPageSize = !1;
mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;
mxGraph.prototype.pageScale = 1.5;
mxGraph.prototype.enabled = !0;
mxGraph.prototype.escapeEnabled = !0;
mxGraph.prototype.invokesStopCellEditing = !0;
mxGraph.prototype.enterStopsCellEditing = !1;
mxGraph.prototype.useScrollbarsForPanning = !0;
mxGraph.prototype.exportEnabled = !0;
mxGraph.prototype.importEnabled = !0;
mxGraph.prototype.cellsLocked = !1;
mxGraph.prototype.cellsCloneable = !0;
mxGraph.prototype.foldingEnabled = !0;
mxGraph.prototype.cellsEditable = !0;
mxGraph.prototype.cellsDeletable = !0;
mxGraph.prototype.cellsMovable = !0;
mxGraph.prototype.edgeLabelsMovable = !0;
mxGraph.prototype.vertexLabelsMovable = !1;
mxGraph.prototype.dropEnabled = !1;
mxGraph.prototype.splitEnabled = !0;
mxGraph.prototype.cellsResizable = !0;
mxGraph.prototype.cellsBendable = !0;
mxGraph.prototype.cellsSelectable = !0;
mxGraph.prototype.cellsDisconnectable = !0;
mxGraph.prototype.autoSizeCells = !1;
mxGraph.prototype.autoSizeCellsOnAdd = !1;
mxGraph.prototype.autoScroll = !0;
mxGraph.prototype.ignoreScrollbars = !1;
mxGraph.prototype.translateToScrollPosition = !1;
mxGraph.prototype.timerAutoScroll = !1;
mxGraph.prototype.allowAutoPanning = !1;
mxGraph.prototype.autoExtend = !0;
mxGraph.prototype.maximumGraphBounds = null;
mxGraph.prototype.minimumGraphSize = null;
mxGraph.prototype.minimumContainerSize = null;
mxGraph.prototype.maximumContainerSize = null;
mxGraph.prototype.resizeContainer = !1;
mxGraph.prototype.border = 0;
mxGraph.prototype.keepEdgesInForeground = !1;
mxGraph.prototype.keepEdgesInBackground = !1;
mxGraph.prototype.allowNegativeCoordinates = !0;
mxGraph.prototype.constrainChildren = !0;
mxGraph.prototype.constrainRelativeChildren = !1;
mxGraph.prototype.extendParents = !0;
mxGraph.prototype.extendParentsOnAdd = !0;
mxGraph.prototype.extendParentsOnMove = !1;
mxGraph.prototype.recursiveResize = !1;
mxGraph.prototype.collapseToPreferredSize = !0;
mxGraph.prototype.zoomFactor = 1.2;
mxGraph.prototype.keepSelectionVisibleOnZoom = !1;
mxGraph.prototype.centerZoom = !0;
mxGraph.prototype.resetViewOnRootChange = !0;
mxGraph.prototype.resetEdgesOnResize = !1;
mxGraph.prototype.resetEdgesOnMove = !1;
mxGraph.prototype.resetEdgesOnConnect = !0;
mxGraph.prototype.allowLoops = !1;
mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;
mxGraph.prototype.multigraph = !0;
mxGraph.prototype.connectableEdges = !1;
mxGraph.prototype.allowDanglingEdges = !0;
mxGraph.prototype.cloneInvalidEdges = !1;
mxGraph.prototype.disconnectOnMove = !0;
mxGraph.prototype.labelsVisible = !0;
mxGraph.prototype.htmlLabels = !1;
mxGraph.prototype.swimlaneSelectionEnabled = !0;
mxGraph.prototype.swimlaneNesting = !0;
mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;
mxGraph.prototype.imageBundles = null;
mxGraph.prototype.minFitScale = 0.1;
mxGraph.prototype.maxFitScale = 8;
mxGraph.prototype.panDx = 0;
mxGraph.prototype.panDy = 0;
mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + '/collapsed.gif', 9, 9);
mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + '/expanded.gif', 9, 9);
mxGraph.prototype.warningImage = new mxImage(
  mxClient.imageBasePath + '/warning' + (mxClient.IS_MAC ? '.png' : '.gif'),
  16,
  16
);
mxGraph.prototype.alreadyConnectedResource = 'none' != mxClient.language ? 'alreadyConnected' : '';
mxGraph.prototype.containsValidationErrorsResource = 'none' != mxClient.language ? 'containsValidationErrors' : '';
mxGraph.prototype.collapseExpandResource = 'none' != mxClient.language ? 'collapse-expand' : '';
mxGraph.prototype.init = function (a) {
  this.container = a;
  this.cellEditor = this.createCellEditor();
  this.view.init();
  this.sizeDidChange();
  mxEvent.addListener(
    a,
    'mouseleave',
    mxUtils.bind(this, function (a) {
      null != this.tooltipHandler &&
        null != this.tooltipHandler.div &&
        this.tooltipHandler.div != a.relatedTarget &&
        this.tooltipHandler.hide();
    })
  );
  mxClient.IS_IE &&
    (mxEvent.addListener(
      window,
      'unload',
      mxUtils.bind(this, function () {
        this.destroy();
      })
    ),
    mxEvent.addListener(
      a,
      'selectstart',
      mxUtils.bind(this, function (a) {
        return this.isEditing() || (!this.isMouseDown && !mxEvent.isShiftDown(a));
      })
    ));
};
mxGraph.prototype.createHandlers = function () {
  this.tooltipHandler = this.createTooltipHandler();
  this.tooltipHandler.setEnabled(!1);
  this.selectionCellsHandler = this.createSelectionCellsHandler();
  this.connectionHandler = this.createConnectionHandler();
  this.connectionHandler.setEnabled(!1);
  this.graphHandler = this.createGraphHandler();
  this.panningHandler = this.createPanningHandler();
  this.panningHandler.panningEnabled = !1;
  this.popupMenuHandler = this.createPopupMenuHandler();
};
mxGraph.prototype.createTooltipHandler = function () {
  return new mxTooltipHandler(this);
};
mxGraph.prototype.createSelectionCellsHandler = function () {
  return new mxSelectionCellsHandler(this);
};
mxGraph.prototype.createConnectionHandler = function () {
  return new mxConnectionHandler(this);
};
mxGraph.prototype.createGraphHandler = function () {
  return new mxGraphHandler(this);
};
mxGraph.prototype.createPanningHandler = function () {
  return new mxPanningHandler(this);
};
mxGraph.prototype.createPopupMenuHandler = function () {
  return new mxPopupMenuHandler(this);
};
mxGraph.prototype.createSelectionModel = function () {
  return new mxGraphSelectionModel(this);
};
mxGraph.prototype.createStylesheet = function () {
  return new mxStylesheet();
};
mxGraph.prototype.createGraphView = function () {
  return new mxGraphView(this);
};
mxGraph.prototype.createCellRenderer = function () {
  return new mxCellRenderer();
};
mxGraph.prototype.createCellEditor = function () {
  return new mxCellEditor(this);
};
mxGraph.prototype.getModel = function () {
  return this.model;
};
mxGraph.prototype.getView = function () {
  return this.view;
};
mxGraph.prototype.getStylesheet = function () {
  return this.stylesheet;
};
mxGraph.prototype.setStylesheet = function (a) {
  this.stylesheet = a;
};
mxGraph.prototype.getSelectionModel = function () {
  return this.selectionModel;
};
mxGraph.prototype.setSelectionModel = function (a) {
  this.selectionModel = a;
};
mxGraph.prototype.getSelectionCellsForChanges = function (a, b) {
  for (
    var c = new mxDictionary(),
      d = [],
      e = mxUtils.bind(this, function (a) {
        if (!c.get(a) && this.model.contains(a))
          if (this.model.isEdge(a) || this.model.isVertex(a)) c.put(a, !0), d.push(a);
          else for (var b = this.model.getChildCount(a), f = 0; f < b; f++) e(this.model.getChildAt(a, f));
      }),
      f = 0;
    f < a.length;
    f++
  ) {
    var g = a[f];
    if (g.constructor != mxRootChange && (null == b || !b(g))) {
      var k = null;
      g instanceof mxChildChange ? (k = g.child) : null != g.cell && g.cell instanceof mxCell && (k = g.cell);
      null != k && e(k);
    }
  }
  return d;
};
mxGraph.prototype.graphModelChanged = function (a) {
  for (var b = 0; b < a.length; b++) this.processChange(a[b]);
  this.updateSelection();
  this.view.validate();
  this.sizeDidChange();
};
mxGraph.prototype.updateSelection = function () {
  for (var a = this.getSelectionCells(), b = [], c = 0; c < a.length; c++)
    if (this.model.contains(a[c]) && this.isCellVisible(a[c]))
      for (var d = this.model.getParent(a[c]); null != d && d != this.view.currentRoot; ) {
        if (this.isCellCollapsed(d) || !this.isCellVisible(d)) {
          b.push(a[c]);
          break;
        }
        d = this.model.getParent(d);
      }
    else b.push(a[c]);
  this.removeSelectionCells(b);
};
mxGraph.prototype.processChange = function (a) {
  if (a instanceof mxRootChange)
    this.clearSelection(),
      this.setDefaultParent(null),
      this.removeStateForCell(a.previous),
      this.resetViewOnRootChange && ((this.view.scale = 1), (this.view.translate.x = 0), (this.view.translate.y = 0)),
      this.fireEvent(new mxEventObject(mxEvent.ROOT));
  else if (a instanceof mxChildChange) {
    var b = this.model.getParent(a.child);
    this.view.invalidate(a.child, !0, !0);
    if (!this.model.contains(b) || this.isCellCollapsed(b))
      this.view.invalidate(a.child, !0, !0),
        this.removeStateForCell(a.child),
        this.view.currentRoot == a.child && this.home();
    b != a.previous &&
      (null != b && this.view.invalidate(b, !1, !1), null != a.previous && this.view.invalidate(a.previous, !1, !1));
  } else
    a instanceof mxTerminalChange || a instanceof mxGeometryChange
      ? (a instanceof mxTerminalChange ||
          (null == a.previous && null != a.geometry) ||
          (null != a.previous && !a.previous.equals(a.geometry))) &&
        this.view.invalidate(a.cell)
      : a instanceof mxValueChange
      ? this.view.invalidate(a.cell, !1, !1)
      : a instanceof mxStyleChange
      ? (this.view.invalidate(a.cell, !0, !0), (a = this.view.getState(a.cell)), null != a && (a.invalidStyle = !0))
      : null != a.cell && a.cell instanceof mxCell && this.removeStateForCell(a.cell);
};
mxGraph.prototype.removeStateForCell = function (a) {
  for (var b = this.model.getChildCount(a), c = 0; c < b; c++) this.removeStateForCell(this.model.getChildAt(a, c));
  this.view.invalidate(a, !1, !0);
  this.view.removeState(a);
};
mxGraph.prototype.addCellOverlay = function (a, b) {
  null == a.overlays && (a.overlays = []);
  a.overlays.push(b);
  var c = this.view.getState(a);
  null != c && this.cellRenderer.redraw(c);
  this.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY, 'cell', a, 'overlay', b));
  return b;
};
mxGraph.prototype.getCellOverlays = function (a) {
  return a.overlays;
};
mxGraph.prototype.removeCellOverlay = function (a, b) {
  if (null == b) this.removeCellOverlays(a);
  else {
    var c = mxUtils.indexOf(a.overlays, b);
    0 <= c
      ? (a.overlays.splice(c, 1),
        0 == a.overlays.length && (a.overlays = null),
        (c = this.view.getState(a)),
        null != c && this.cellRenderer.redraw(c),
        this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, 'cell', a, 'overlay', b)))
      : (b = null);
  }
  return b;
};
mxGraph.prototype.removeCellOverlays = function (a) {
  var b = a.overlays;
  if (null != b) {
    a.overlays = null;
    var c = this.view.getState(a);
    null != c && this.cellRenderer.redraw(c);
    for (c = 0; c < b.length; c++)
      this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, 'cell', a, 'overlay', b[c]));
  }
  return b;
};
mxGraph.prototype.clearCellOverlays = function (a) {
  a = null != a ? a : this.model.getRoot();
  this.removeCellOverlays(a);
  for (var b = this.model.getChildCount(a), c = 0; c < b; c++) {
    var d = this.model.getChildAt(a, c);
    this.clearCellOverlays(d);
  }
};
mxGraph.prototype.setCellWarning = function (a, b, c, d) {
  if (null != b && 0 < b.length)
    return (
      (c = null != c ? c : this.warningImage),
      (b = new mxCellOverlay(c, '<font color=red>' + b + '</font>')),
      d &&
        b.addListener(
          mxEvent.CLICK,
          mxUtils.bind(this, function (b, c) {
            this.isEnabled() && this.setSelectionCell(a);
          })
        ),
      this.addCellOverlay(a, b)
    );
  this.removeCellOverlays(a);
  return null;
};
mxGraph.prototype.startEditing = function (a) {
  this.startEditingAtCell(null, a);
};
mxGraph.prototype.startEditingAtCell = function (a, b) {
  (null != b && mxEvent.isMultiTouchEvent(b)) ||
    (null == a && ((a = this.getSelectionCell()), null == a || this.isCellEditable(a) || (a = null)),
    null != a &&
      (this.fireEvent(new mxEventObject(mxEvent.START_EDITING, 'cell', a, 'event', b)),
      this.cellEditor.startEditing(a, b),
      this.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED, 'cell', a, 'event', b))));
};
mxGraph.prototype.getEditingValue = function (a, b) {
  return this.convertValueToString(a);
};
mxGraph.prototype.stopEditing = function (a) {
  this.cellEditor.stopEditing(a);
  this.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, 'cancel', a));
};
mxGraph.prototype.labelChanged = function (a, b, c) {
  this.model.beginUpdate();
  try {
    var d = a.value;
    this.cellLabelChanged(a, b, this.isAutoSizeCell(a));
    this.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED, 'cell', a, 'value', b, 'old', d, 'event', c));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellLabelChanged = function (a, b, c) {
  this.model.beginUpdate();
  try {
    this.model.setValue(a, b), c && this.cellSizeUpdated(a, !1);
  } finally {
    this.model.endUpdate();
  }
};
mxGraph.prototype.escape = function (a) {
  this.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', a));
};
mxGraph.prototype.click = function (a) {
  var b = a.getEvent(),
    c = a.getCell(),
    d = new mxEventObject(mxEvent.CLICK, 'event', b, 'cell', c);
  a.isConsumed() && d.consume();
  this.fireEvent(d);
  if (this.isEnabled() && !mxEvent.isConsumed(b) && !d.isConsumed()) {
    if (null != c) {
      if (this.isTransparentClickEvent(b)) {
        var e = !1;
        a = this.getCellAt(
          a.graphX,
          a.graphY,
          null,
          null,
          null,
          mxUtils.bind(this, function (a) {
            var b = this.isCellSelected(a.cell);
            e = e || b;
            return !e || b || (a.cell != c && this.model.isAncestor(a.cell, c));
          })
        );
        null != a && (c = a);
      }
    } else if (
      this.isSwimlaneSelectionEnabled() &&
      ((c = this.getSwimlaneAt(a.getGraphX(), a.getGraphY())),
      !(null == c || (this.isToggleEvent(b) && mxEvent.isAltDown(b))))
    ) {
      d = c;
      for (a = []; null != d; ) {
        var d = this.model.getParent(d),
          f = this.view.getState(d);
        this.isSwimlane(d) && null != f && a.push(d);
      }
      if (0 < a.length)
        for (a = a.reverse(), a.splice(0, 0, c), a.push(c), d = 0; d < a.length - 1; d++)
          this.isCellSelected(a[d]) && (c = a[this.isToggleEvent(b) ? d : d + 1]);
    }
    null != c ? this.selectCellForEvent(c, b) : this.isToggleEvent(b) || this.clearSelection();
  }
};
mxGraph.prototype.isSiblingSelected = function (a) {
  for (var b = this.model, c = b.getParent(a), d = b.getChildCount(c), e = 0; e < d; e++) {
    var f = b.getChildAt(c, e);
    if (a != f && this.isCellSelected(f)) return !0;
  }
  return !1;
};
mxGraph.prototype.dblClick = function (a, b) {
  var c = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', a, 'cell', b);
  this.fireEvent(c);
  !this.isEnabled() ||
    mxEvent.isConsumed(a) ||
    c.isConsumed() ||
    null == b ||
    !this.isCellEditable(b) ||
    this.isEditing(b) ||
    (this.startEditingAtCell(b, a), mxEvent.consume(a));
};
mxGraph.prototype.tapAndHold = function (a) {
  var b = a.getEvent(),
    c = new mxEventObject(mxEvent.TAP_AND_HOLD, 'event', b, 'cell', a.getCell());
  this.fireEvent(c);
  c.isConsumed() && (this.panningHandler.panningTrigger = !1);
  this.isEnabled() &&
    !mxEvent.isConsumed(b) &&
    !c.isConsumed() &&
    this.connectionHandler.isEnabled() &&
    ((b = this.view.getState(this.connectionHandler.marker.getCell(a))),
    null != b &&
      ((this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor),
      (this.connectionHandler.marker.markedState = b),
      this.connectionHandler.marker.mark(),
      (this.connectionHandler.first = new mxPoint(a.getGraphX(), a.getGraphY())),
      (this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(a)),
      (this.connectionHandler.previous = b),
      this.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, 'state', this.connectionHandler.previous))));
};
mxGraph.prototype.scrollPointToVisible = function (a, b, c, d) {
  if (this.timerAutoScroll || (!this.ignoreScrollbars && !mxUtils.hasScrollbars(this.container)))
    this.allowAutoPanning &&
      !this.panningHandler.isActive() &&
      (null == this.panningManager && (this.panningManager = this.createPanningManager()),
      this.panningManager.panTo(a + this.panDx, b + this.panDy));
  else {
    var e = this.container;
    d = null != d ? d : 20;
    if (
      a >= e.scrollLeft &&
      b >= e.scrollTop &&
      a <= e.scrollLeft + e.clientWidth &&
      b <= e.scrollTop + e.clientHeight
    ) {
      var f = e.scrollLeft + e.clientWidth - a;
      if (f < d) {
        if (((a = e.scrollLeft), (e.scrollLeft += d - f), c && a == e.scrollLeft)) {
          if (this.dialect == mxConstants.DIALECT_SVG) {
            a = this.view.getDrawPane().ownerSVGElement;
            var g = this.container.scrollWidth + d - f;
          } else (g = Math.max(e.clientWidth, e.scrollWidth) + d - f), (a = this.view.getCanvas());
          a.style.width = g + 'px';
          e.scrollLeft += d - f;
        }
      } else (f = a - e.scrollLeft), f < d && (e.scrollLeft -= d - f);
      f = e.scrollTop + e.clientHeight - b;
      f < d
        ? ((a = e.scrollTop),
          (e.scrollTop += d - f),
          a == e.scrollTop &&
            c &&
            (this.dialect == mxConstants.DIALECT_SVG
              ? ((a = this.view.getDrawPane().ownerSVGElement), (b = this.container.scrollHeight + d - f))
              : ((b = Math.max(e.clientHeight, e.scrollHeight) + d - f), (a = this.view.getCanvas())),
            (a.style.height = b + 'px'),
            (e.scrollTop += d - f)))
        : ((f = b - e.scrollTop), f < d && (e.scrollTop -= d - f));
    }
  }
};
mxGraph.prototype.createPanningManager = function () {
  return new mxPanningManager(this);
};
mxGraph.prototype.getBorderSizes = function () {
  var a = mxUtils.getCurrentStyle(this.container);
  return new mxRectangle(
    mxUtils.parseCssNumber(a.paddingLeft) +
      ('none' != a.borderLeftStyle ? mxUtils.parseCssNumber(a.borderLeftWidth) : 0),
    mxUtils.parseCssNumber(a.paddingTop) + ('none' != a.borderTopStyle ? mxUtils.parseCssNumber(a.borderTopWidth) : 0),
    mxUtils.parseCssNumber(a.paddingRight) +
      ('none' != a.borderRightStyle ? mxUtils.parseCssNumber(a.borderRightWidth) : 0),
    mxUtils.parseCssNumber(a.paddingBottom) +
      ('none' != a.borderBottomStyle ? mxUtils.parseCssNumber(a.borderBottomWidth) : 0)
  );
};
mxGraph.prototype.getPreferredPageSize = function (a, b, c) {
  a = this.view.translate;
  var d = this.pageFormat,
    e = this.pageScale,
    d = new mxRectangle(0, 0, Math.ceil(d.width * e), Math.ceil(d.height * e));
  return new mxRectangle(
    0,
    0,
    (this.pageBreaksVisible ? Math.ceil(b / d.width) : 1) * d.width + 2 + a.x,
    (this.pageBreaksVisible ? Math.ceil(c / d.height) : 1) * d.height + 2 + a.y
  );
};
mxGraph.prototype.fit = function (a, b, c, d, e, f, g) {
  if (null != this.container) {
    a = null != a ? a : this.getBorder();
    b = null != b ? b : !1;
    c = null != c ? c : 0;
    d = null != d ? d : !0;
    e = null != e ? e : !1;
    f = null != f ? f : !1;
    var k = this.getBorderSizes(),
      h = this.container.offsetWidth - k.x - k.width - 1,
      l = null != g ? g : this.container.offsetHeight - k.y - k.height - 1;
    g = this.view.getGraphBounds();
    if (0 < g.width && 0 < g.height) {
      b && null != g.x && null != g.y && ((g = g.clone()), (g.width += g.x), (g.height += g.y), (g.x = 0), (g.y = 0));
      var k = this.view.scale,
        m = g.width / k,
        n = g.height / k;
      null != this.backgroundImage &&
        null != this.backgroundImage.width &&
        null != this.backgroundImage.height &&
        ((m = Math.max(m, this.backgroundImage.width - g.x / k)),
        (n = Math.max(n, this.backgroundImage.height - g.y / k)));
      var p = (b ? a : 2 * a) + c + 1,
        h = h - p,
        l = l - p;
      e = e ? l / n : f ? h / m : Math.min(h / m, l / n);
      null != this.minFitScale && (e = Math.max(e, this.minFitScale));
      null != this.maxFitScale && (e = Math.min(e, this.maxFitScale));
      if (d)
        b
          ? this.view.scale != e && this.view.setScale(e)
          : mxUtils.hasScrollbars(this.container)
          ? (this.view.setScale(e),
            (a = this.getGraphBounds()),
            null != a.x && (this.container.scrollLeft = a.x),
            null != a.y && (this.container.scrollTop = a.y))
          : this.view.scaleAndTranslate(
              e,
              null != g.x ? Math.floor(this.view.translate.x - g.x / k + a / e + c / 2) : a,
              null != g.y ? Math.floor(this.view.translate.y - g.y / k + a / e + c / 2) : a
            );
      else return e;
    }
  }
  return this.view.scale;
};
mxGraph.prototype.sizeDidChange = function () {
  var a = this.getGraphBounds();
  if (null != this.container) {
    var b = this.getBorder(),
      c = Math.max(0, a.x) + a.width + 2 * b,
      b = Math.max(0, a.y) + a.height + 2 * b;
    null != this.minimumContainerSize &&
      ((c = Math.max(c, this.minimumContainerSize.width)), (b = Math.max(b, this.minimumContainerSize.height)));
    this.resizeContainer && this.doResizeContainer(c, b);
    if (this.preferPageSize || (!mxClient.IS_IE && this.pageVisible)) {
      var d = this.getPreferredPageSize(a, Math.max(1, c), Math.max(1, b));
      null != d && ((c = d.width * this.view.scale), (b = d.height * this.view.scale));
    }
    null != this.minimumGraphSize &&
      ((c = Math.max(c, this.minimumGraphSize.width * this.view.scale)),
      (b = Math.max(b, this.minimumGraphSize.height * this.view.scale)));
    c = Math.ceil(c);
    b = Math.ceil(b);
    this.dialect == mxConstants.DIALECT_SVG
      ? ((d = this.view.getDrawPane().ownerSVGElement),
        null != d &&
          ((d.style.minWidth = Math.max(1, c) + 'px'),
          (d.style.minHeight = Math.max(1, b) + 'px'),
          (d.style.width = '100%'),
          (d.style.height = '100%')))
      : ((this.view.canvas.style.minWidth = Math.max(1, c) + 'px'),
        (this.view.canvas.style.minHeight = Math.max(1, b) + 'px'));
    this.updatePageBreaks(this.pageBreaksVisible, c, b);
  }
  this.fireEvent(new mxEventObject(mxEvent.SIZE, 'bounds', a));
};
mxGraph.prototype.doResizeContainer = function (a, b) {
  null != this.maximumContainerSize &&
    ((a = Math.min(this.maximumContainerSize.width, a)), (b = Math.min(this.maximumContainerSize.height, b)));
  this.container.style.width = Math.ceil(a) + 'px';
  this.container.style.height = Math.ceil(b) + 'px';
};
mxGraph.prototype.updatePageBreaks = function (a, b, c) {
  b = this.view.scale;
  c = this.view.translate;
  var d = this.pageFormat,
    e = b * this.pageScale,
    f = new mxRectangle(0, 0, d.width * e, d.height * e),
    d = mxRectangle.fromRectangle(this.getGraphBounds());
  d.width = Math.max(1, d.width);
  d.height = Math.max(1, d.height);
  f.x = Math.floor((d.x - c.x * b) / f.width) * f.width + c.x * b;
  f.y = Math.floor((d.y - c.y * b) / f.height) * f.height + c.y * b;
  d.width = Math.ceil((d.width + (d.x - f.x)) / f.width) * f.width;
  d.height = Math.ceil((d.height + (d.y - f.y)) / f.height) * f.height;
  var g = (a = a && Math.min(f.width, f.height) > this.minPageBreakDist) ? Math.ceil(d.height / f.height) + 1 : 0,
    k = a ? Math.ceil(d.width / f.width) + 1 : 0,
    h = (k - 1) * f.width,
    l = (g - 1) * f.height;
  null == this.horizontalPageBreaks && 0 < g && (this.horizontalPageBreaks = []);
  null == this.verticalPageBreaks && 0 < k && (this.verticalPageBreaks = []);
  a = mxUtils.bind(this, function (a) {
    if (null != a) {
      for (var b = a == this.horizontalPageBreaks ? g : k, c = 0; c <= b; c++) {
        var d =
          a == this.horizontalPageBreaks
            ? [
                new mxPoint(Math.round(f.x), Math.round(f.y + c * f.height)),
                new mxPoint(Math.round(f.x + h), Math.round(f.y + c * f.height)),
              ]
            : [
                new mxPoint(Math.round(f.x + c * f.width), Math.round(f.y)),
                new mxPoint(Math.round(f.x + c * f.width), Math.round(f.y + l)),
              ];
        null != a[c]
          ? ((a[c].points = d), a[c].redraw())
          : ((d = new mxPolyline(d, this.pageBreakColor)),
            (d.dialect = this.dialect),
            (d.pointerEvents = !1),
            (d.isDashed = this.pageBreakDashed),
            d.init(this.view.backgroundPane),
            d.redraw(),
            (a[c] = d));
      }
      for (c = b; c < a.length; c++) a[c].destroy();
      a.splice(b, a.length - b);
    }
  });
  a(this.horizontalPageBreaks);
  a(this.verticalPageBreaks);
};
mxGraph.prototype.getCurrentCellStyle = function (a, b) {
  var c = b ? null : this.view.getState(a);
  return null != c ? c.style : this.getCellStyle(a);
};
mxGraph.prototype.getCellStyle = function (a, b) {
  b = null != b ? b : !0;
  var c = this.model.getStyle(a),
    d;
  d = this.model.isEdge(a) ? this.stylesheet.getDefaultEdgeStyle() : this.stylesheet.getDefaultVertexStyle();
  null != c ? (d = this.stylesheet.getCellStyle(c, d, b)) : null != d && (d = mxUtils.clone(d));
  null == d ? (d = {}) : b && (d = this.postProcessCellStyle(a, d));
  return d;
};
mxGraph.prototype.postProcessCellStyle = function (a, b) {
  if (null != b) {
    var c = b[mxConstants.STYLE_IMAGE],
      d = this.getImageFromBundles(c);
    null != d ? (b[mxConstants.STYLE_IMAGE] = d) : (d = c);
    null != d &&
      'data:image/' == d.substring(0, 11) &&
      ('data:image/svg+xml,<' == d.substring(0, 20)
        ? (d = d.substring(0, 19) + encodeURIComponent(d.substring(19)))
        : 'data:image/svg+xml,%3C' != d.substring(0, 22) &&
          ((c = d.indexOf(',')),
          0 < c &&
            ';base64,' != d.substring(c - 7, c + 1) &&
            (d = d.substring(0, c) + ';base64,' + d.substring(c + 1))),
      (b[mxConstants.STYLE_IMAGE] = d));
  }
  return b;
};
mxGraph.prototype.setCellStyle = function (a, b) {
  b = b || this.getSelectionCells();
  if (null != b) {
    this.model.beginUpdate();
    try {
      for (var c = 0; c < b.length; c++) this.model.setStyle(b[c], a);
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.toggleCellStyle = function (a, b, c) {
  c = c || this.getSelectionCell();
  return this.toggleCellStyles(a, b, [c]);
};
mxGraph.prototype.toggleCellStyles = function (a, b, c) {
  b = null != b ? b : !1;
  c = c || this.getEditableCells(this.getSelectionCells());
  var d = null;
  null != c &&
    0 < c.length &&
    ((d = this.getCurrentCellStyle(c[0])), (d = mxUtils.getValue(d, a, b) ? 0 : 1), this.setCellStyles(a, d, c));
  return d;
};
mxGraph.prototype.setCellStyles = function (a, b, c) {
  c = c || this.getEditableCells(this.getSelectionCells());
  mxUtils.setCellStyles(this.model, c, a, b);
};
mxGraph.prototype.toggleCellStyleFlags = function (a, b, c) {
  this.setCellStyleFlags(a, b, null, c);
};
mxGraph.prototype.setCellStyleFlags = function (a, b, c, d) {
  d = d || this.getEditableCells(this.getSelectionCells());
  null != d &&
    0 < d.length &&
    (null == c && ((c = this.getCurrentCellStyle(d[0])), (c = (parseInt(c[a] || 0) & b) != b)),
    mxUtils.setCellStyleFlags(this.model, d, a, b, c));
};
mxGraph.prototype.getOriginForCell = function (a) {
  a = this.model.getParent(a);
  for (var b = new mxPoint(); null != a; ) {
    var c = this.getCellGeometry(a);
    null == c || c.relative || ((b.x += c.x), (b.y += c.y));
    a = this.model.getParent(a);
  }
  return b;
};
mxGraph.prototype.alignCells = function (a, b, c) {
  null == b && (b = this.getMovableCells(this.getSelectionCells()));
  if (null != b && 1 < b.length) {
    if (null == c)
      for (var d = 0; d < b.length; d++) {
        var e = this.getOriginForCell(b[d]),
          f = this.getCellGeometry(b[d]);
        if (!this.model.isEdge(b[d]) && null != f && !f.relative)
          if (null == c)
            if (a == mxConstants.ALIGN_CENTER) {
              c = e.x + f.x + f.width / 2;
              break;
            } else if (a == mxConstants.ALIGN_RIGHT) c = e.x + f.x + f.width;
            else if (a == mxConstants.ALIGN_TOP) c = e.y + f.y;
            else if (a == mxConstants.ALIGN_MIDDLE) {
              c = e.y + f.y + f.height / 2;
              break;
            } else c = a == mxConstants.ALIGN_BOTTOM ? e.y + f.y + f.height : e.x + f.x;
          else
            c =
              a == mxConstants.ALIGN_RIGHT
                ? Math.max(c, e.x + f.x + f.width)
                : a == mxConstants.ALIGN_TOP
                ? Math.min(c, e.y + f.y)
                : a == mxConstants.ALIGN_BOTTOM
                ? Math.max(c, e.y + f.y + f.height)
                : Math.min(c, e.x + f.x);
      }
    if (null != c) {
      b = mxUtils.sortCells(b);
      this.model.beginUpdate();
      try {
        for (d = 0; d < b.length; d++)
          (e = this.getOriginForCell(b[d])),
            (f = this.getCellGeometry(b[d])),
            this.model.isEdge(b[d]) ||
              null == f ||
              f.relative ||
              ((f = f.clone()),
              a == mxConstants.ALIGN_CENTER
                ? (f.x = c - e.x - f.width / 2)
                : a == mxConstants.ALIGN_RIGHT
                ? (f.x = c - e.x - f.width)
                : a == mxConstants.ALIGN_TOP
                ? (f.y = c - e.y)
                : a == mxConstants.ALIGN_MIDDLE
                ? (f.y = c - e.y - f.height / 2)
                : a == mxConstants.ALIGN_BOTTOM
                ? (f.y = c - e.y - f.height)
                : (f.x = c - e.x),
              this.resizeCell(b[d], f));
        this.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS, 'align', a, 'cells', b));
      } finally {
        this.model.endUpdate();
      }
    }
  }
  return b;
};
mxGraph.prototype.flipEdge = function (a) {
  if (null != a && null != this.alternateEdgeStyle) {
    this.model.beginUpdate();
    try {
      var b = this.model.getStyle(a);
      null == b || 0 == b.length ? this.model.setStyle(a, this.alternateEdgeStyle) : this.model.setStyle(a, null);
      this.resetEdge(a);
      this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, 'edge', a));
    } finally {
      this.model.endUpdate();
    }
  }
  return a;
};
mxGraph.prototype.addImageBundle = function (a) {
  this.imageBundles.push(a);
};
mxGraph.prototype.removeImageBundle = function (a) {
  for (var b = [], c = 0; c < this.imageBundles.length; c++) this.imageBundles[c] != a && b.push(this.imageBundles[c]);
  this.imageBundles = b;
};
mxGraph.prototype.getImageFromBundles = function (a) {
  if (null != a)
    for (var b = 0; b < this.imageBundles.length; b++) {
      var c = this.imageBundles[b].getImage(a);
      if (null != c) return c;
    }
  return null;
};
mxGraph.prototype.orderCells = function (a, b, c) {
  null == b && (b = mxUtils.sortCells(this.getEditableCells(this.getSelectionCells()), !0));
  this.model.beginUpdate();
  try {
    this.cellsOrdered(b, a, c),
      this.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS, 'back', a, 'cells', b, 'increment', c));
  } finally {
    this.model.endUpdate();
  }
  return b;
};
mxGraph.prototype.cellsOrdered = function (a, b, c) {
  if (null != a) {
    this.model.beginUpdate();
    try {
      for (var d = 0; d < a.length; d++) {
        var e = this.model.getParent(a[d]);
        b
          ? c
            ? this.model.add(e, a[d], Math.max(0, e.getIndex(a[d]) - 1))
            : this.model.add(e, a[d], d)
          : c
          ? this.model.add(e, a[d], Math.min(this.model.getChildCount(e) - 1, e.getIndex(a[d]) + 1))
          : this.model.add(e, a[d], this.model.getChildCount(e) - 1);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED, 'back', b, 'cells', a, 'increment', c));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.groupCells = function (a, b, c) {
  null == c && (c = mxUtils.sortCells(this.getSelectionCells(), !0));
  c = this.getCellsForGroup(c);
  null == a && (a = this.createGroupCell(c));
  var d = this.getBoundsForGroup(a, c, b);
  if (1 < c.length && null != d) {
    var e = this.model.getParent(a);
    null == e && (e = this.model.getParent(c[0]));
    this.model.beginUpdate();
    try {
      null == this.getCellGeometry(a) && this.model.setGeometry(a, new mxGeometry());
      var f = this.model.getChildCount(e);
      this.cellsAdded([a], e, f, null, null, !1, !1, !1);
      f = this.model.getChildCount(a);
      this.cellsAdded(c, a, f, null, null, !1, !1, !1);
      this.cellsMoved(c, -d.x, -d.y, !1, !1, !1);
      this.cellsResized([a], [d], !1);
      this.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS, 'group', a, 'border', b, 'cells', c));
    } finally {
      this.model.endUpdate();
    }
  }
  return a;
};
mxGraph.prototype.getCellsForGroup = function (a) {
  var b = [];
  if (null != a && 0 < a.length) {
    var c = this.model.getParent(a[0]);
    b.push(a[0]);
    for (var d = 1; d < a.length; d++) this.model.getParent(a[d]) == c && b.push(a[d]);
  }
  return b;
};
mxGraph.prototype.getBoundsForGroup = function (a, b, c) {
  b = this.getBoundingBoxFromGeometry(b, !0);
  null != b &&
    (this.isSwimlane(a) &&
      ((a = this.getStartSize(a)), (b.x -= a.width), (b.y -= a.height), (b.width += a.width), (b.height += a.height)),
    null != c && ((b.x -= c), (b.y -= c), (b.width += 2 * c), (b.height += 2 * c)));
  return b;
};
mxGraph.prototype.createGroupCell = function (a) {
  a = new mxCell('');
  a.setVertex(!0);
  a.setConnectable(!1);
  return a;
};
mxGraph.prototype.ungroupCells = function (a) {
  var b = [];
  null == a && (a = this.getCellsForUngroup());
  if (null != a && 0 < a.length) {
    this.model.beginUpdate();
    try {
      for (var c = 0; c < a.length; c++) {
        var d = this.model.getChildren(a[c]);
        if (null != d && 0 < d.length) {
          var d = d.slice(),
            e = this.model.getParent(a[c]),
            f = this.model.getChildCount(e);
          this.cellsAdded(d, e, f, null, null, !0);
          for (var b = b.concat(d), g = 0; g < d.length; g++)
            if (this.model.isVertex(d[g])) {
              var k = this.view.getState(d[g]),
                h = this.getCellGeometry(d[g]);
              null != k &&
                null != h &&
                h.relative &&
                ((h = h.clone()),
                (h.x = k.origin.x),
                (h.y = k.origin.y),
                (h.relative = !1),
                this.model.setGeometry(d[g], h));
            }
        }
      }
      this.removeCellsAfterUngroup(a);
      this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, 'cells', a));
    } finally {
      this.model.endUpdate();
    }
  }
  return b;
};
mxGraph.prototype.getCellsForUngroup = function () {
  for (var a = this.getEditableCells(this.getSelectionCells()), b = [], c = 0; c < a.length; c++)
    this.model.isVertex(a[c]) && 0 < this.model.getChildCount(a[c]) && b.push(a[c]);
  return b;
};
mxGraph.prototype.removeCellsAfterUngroup = function (a) {
  this.cellsRemoved(this.addAllEdges(a));
};
mxGraph.prototype.removeCellsFromParent = function (a) {
  null == a && (a = this.getSelectionCells());
  this.model.beginUpdate();
  try {
    var b = this.getDefaultParent(),
      c = this.model.getChildCount(b);
    this.cellsAdded(a, b, c, null, null, !0);
    this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, 'cells', a));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.updateGroupBounds = function (a, b, c, d, e, f, g) {
  null == a && (a = this.getSelectionCells());
  b = null != b ? b : 0;
  c = null != c ? c : !1;
  d = null != d ? d : 0;
  e = null != e ? e : 0;
  f = null != f ? f : 0;
  g = null != g ? g : 0;
  this.model.beginUpdate();
  try {
    for (var k = a.length - 1; 0 <= k; k--) {
      var h = this.getCellGeometry(a[k]);
      if (null != h) {
        var l = this.getChildCells(a[k]);
        if (null != l && 0 < l.length) {
          var m = this.getBoundingBoxFromGeometry(l, !0);
          if (null != m && 0 < m.width && 0 < m.height) {
            var n = this.isSwimlane(a[k]) ? this.getActualStartSize(a[k], !0) : new mxRectangle(),
              h = h.clone();
            c && ((h.x = Math.round(h.x + m.x - b - n.x - g)), (h.y = Math.round(h.y + m.y - b - n.y - d)));
            h.width = Math.round(m.width + 2 * b + n.x + g + e + n.width);
            h.height = Math.round(m.height + 2 * b + n.y + d + f + n.height);
            this.model.setGeometry(a[k], h);
            this.moveCells(l, b + n.x - m.x + g, b + n.y - m.y + d);
          }
        }
      }
    }
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.getBoundingBox = function (a) {
  var b = null;
  if (null != a && 0 < a.length)
    for (var c = 0; c < a.length; c++)
      if (this.model.isVertex(a[c]) || this.model.isEdge(a[c])) {
        var d = this.view.getBoundingBox(this.view.getState(a[c]), !0);
        null != d && (null == b ? (b = mxRectangle.fromRectangle(d)) : b.add(d));
      }
  return b;
};
mxGraph.prototype.cloneCell = function (a, b, c, d) {
  return this.cloneCells([a], b, c, d)[0];
};
mxGraph.prototype.cloneCells = function (a, b, c, d) {
  b = null != b ? b : !0;
  var e = null;
  if (null != a) {
    for (var f = new mxDictionary(), e = [], g = 0; g < a.length; g++) f.put(a[g], !0), e.push(a[g]);
    if (0 < e.length)
      for (
        var k = this.view.scale, h = this.view.translate, e = this.model.cloneCells(a, !0, c), g = 0;
        g < a.length;
        g++
      )
        if (
          !b &&
          this.model.isEdge(e[g]) &&
          null != this.getEdgeValidationError(e[g], this.model.getTerminal(e[g], !0), this.model.getTerminal(e[g], !1))
        )
          e[g] = null;
        else {
          var l = this.model.getGeometry(e[g]);
          if (null != l) {
            var m = this.view.getState(a[g]),
              n = this.view.getState(this.model.getParent(a[g]));
            if (null != m && null != n)
              if (((c = d ? 0 : n.origin.x), (n = d ? 0 : n.origin.y), this.model.isEdge(e[g]))) {
                if (((m = m.absolutePoints), null != m)) {
                  for (var p = this.model.getTerminal(a[g], !0); null != p && !f.get(p); ) p = this.model.getParent(p);
                  null == p && null != m[0] && l.setTerminalPoint(new mxPoint(m[0].x / k - h.x, m[0].y / k - h.y), !0);
                  for (p = this.model.getTerminal(a[g], !1); null != p && !f.get(p); ) p = this.model.getParent(p);
                  var r = m.length - 1;
                  null == p && null != m[r] && l.setTerminalPoint(new mxPoint(m[r].x / k - h.x, m[r].y / k - h.y), !1);
                  l = l.points;
                  if (null != l) for (m = 0; m < l.length; m++) (l[m].x += c), (l[m].y += n);
                }
              } else l.translate(c, n);
          }
        }
    else e = [];
  }
  return e;
};
mxGraph.prototype.insertVertex = function (a, b, c, d, e, f, g, k, h) {
  b = this.createVertex(a, b, c, d, e, f, g, k, h);
  return this.addCell(b, a);
};
mxGraph.prototype.createVertex = function (a, b, c, d, e, f, g, k, h) {
  a = new mxGeometry(d, e, f, g);
  a.relative = null != h ? h : !1;
  c = new mxCell(c, a, k);
  c.setId(b);
  c.setVertex(!0);
  c.setConnectable(!0);
  return c;
};
mxGraph.prototype.insertEdge = function (a, b, c, d, e, f) {
  b = this.createEdge(a, b, c, d, e, f);
  return this.addEdge(b, a, d, e);
};
mxGraph.prototype.createEdge = function (a, b, c, d, e, f) {
  a = new mxCell(c, new mxGeometry(), f);
  a.setId(b);
  a.setEdge(!0);
  a.geometry.relative = !0;
  return a;
};
mxGraph.prototype.addEdge = function (a, b, c, d, e) {
  return this.addCell(a, b, e, c, d);
};
mxGraph.prototype.addCell = function (a, b, c, d, e) {
  return this.addCells([a], b, c, d, e)[0];
};
mxGraph.prototype.addCells = function (a, b, c, d, e, f) {
  null == b && (b = this.getDefaultParent());
  null == c && (c = this.model.getChildCount(b));
  this.model.beginUpdate();
  try {
    this.cellsAdded(a, b, c, d, e, null != f ? f : !1, !0),
      this.fireEvent(
        new mxEventObject(mxEvent.ADD_CELLS, 'cells', a, 'parent', b, 'index', c, 'source', d, 'target', e)
      );
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellsAdded = function (a, b, c, d, e, f, g, k) {
  if (null != a && null != b && null != c) {
    this.model.beginUpdate();
    try {
      for (
        var h = f ? this.view.getState(b) : null, l = null != h ? h.origin : null, m = new mxPoint(0, 0), h = 0;
        h < a.length;
        h++
      )
        if (null == a[h]) c--;
        else {
          var n = this.model.getParent(a[h]);
          if (null != l && a[h] != b && b != n) {
            var p = this.view.getState(n),
              r = null != p ? p.origin : m,
              t = this.model.getGeometry(a[h]);
            if (null != t) {
              var u = r.x - l.x,
                x = r.y - l.y,
                t = t.clone();
              t.translate(u, x);
              t.relative ||
                !this.model.isVertex(a[h]) ||
                this.isAllowNegativeCoordinates() ||
                ((t.x = Math.max(0, t.x)), (t.y = Math.max(0, t.y)));
              this.model.setGeometry(a[h], t);
            }
          }
          b == n && c + h > this.model.getChildCount(b) && c--;
          this.model.add(b, a[h], c + h);
          this.autoSizeCellsOnAdd && this.autoSizeCell(a[h], !0);
          (null == k || k) && this.isExtendParentsOnAdd(a[h]) && this.isExtendParent(a[h]) && this.extendParent(a[h]);
          (null == g || g) && this.constrainChild(a[h]);
          null != d && this.cellConnected(a[h], d, !0);
          null != e && this.cellConnected(a[h], e, !1);
        }
      this.fireEvent(
        new mxEventObject(
          mxEvent.CELLS_ADDED,
          'cells',
          a,
          'parent',
          b,
          'index',
          c,
          'source',
          d,
          'target',
          e,
          'absolute',
          f
        )
      );
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.autoSizeCell = function (a, b) {
  if (null != b ? b : 1)
    for (var c = this.model.getChildCount(a), d = 0; d < c; d++) this.autoSizeCell(this.model.getChildAt(a, d));
  this.getModel().isVertex(a) && this.isAutoSizeCell(a) && this.updateCellSize(a);
};
mxGraph.prototype.removeCells = function (a, b) {
  b = null != b ? b : !0;
  null == a && (a = this.getDeletableCells(this.getSelectionCells()));
  if (b) a = this.getDeletableCells(this.addAllEdges(a));
  else {
    a = a.slice();
    for (var c = this.getDeletableCells(this.getAllEdges(a)), d = new mxDictionary(), e = 0; e < a.length; e++)
      d.put(a[e], !0);
    for (e = 0; e < c.length; e++) null != this.view.getState(c[e]) || d.get(c[e]) || (d.put(c[e], !0), a.push(c[e]));
  }
  this.model.beginUpdate();
  try {
    this.cellsRemoved(a), this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, 'cells', a, 'includeEdges', b));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellsRemoved = function (a) {
  if (null != a && 0 < a.length) {
    var b = this.view.scale,
      c = this.view.translate;
    this.model.beginUpdate();
    try {
      for (var d = new mxDictionary(), e = 0; e < a.length; e++) d.put(a[e], !0);
      for (e = 0; e < a.length; e++) {
        for (
          var f = this.getAllEdges([a[e]]),
            g = mxUtils.bind(this, function (d, f) {
              var g = this.model.getGeometry(d);
              if (null != g) {
                for (var k = this.model.getTerminal(d, f), h = !1, l = k; null != l; ) {
                  if (a[e] == l) {
                    h = !0;
                    break;
                  }
                  l = this.model.getParent(l);
                }
                h &&
                  ((g = g.clone()),
                  (h = this.view.getState(d)),
                  null != h && null != h.absolutePoints
                    ? ((k = h.absolutePoints),
                      (l = f ? 0 : k.length - 1),
                      g.setTerminalPoint(new mxPoint(k[l].x / b - c.x - h.origin.x, k[l].y / b - c.y - h.origin.y), f))
                    : ((k = this.view.getState(k)),
                      null != k &&
                        g.setTerminalPoint(new mxPoint(k.getCenterX() / b - c.x, k.getCenterY() / b - c.y), f)),
                  this.model.setGeometry(d, g),
                  this.model.setTerminal(d, null, f));
              }
            }),
            k = 0;
          k < f.length;
          k++
        )
          d.get(f[k]) || (d.put(f[k], !0), g(f[k], !0), g(f[k], !1));
        this.model.remove(a[e]);
      }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, 'cells', a));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.splitEdge = function (a, b, c, d, e, f, g, k) {
  d = d || 0;
  e = e || 0;
  k = null != k ? k : this.model.getParent(a);
  f = this.model.getTerminal(a, !0);
  this.model.beginUpdate();
  try {
    if (null == c) {
      c = this.cloneCell(a);
      var h = this.view.getState(a),
        l = this.getCellGeometry(c);
      if (null != l && null != l.points && null != h) {
        var m = this.view.translate,
          n = this.view.scale,
          p = mxUtils.findNearestSegment(h, (d + m.x) * n, (e + m.y) * n);
        l.points = l.points.slice(0, p);
        l = this.getCellGeometry(a);
        null != l &&
          null != l.points &&
          ((l = l.clone()), (l.points = l.points.slice(p)), this.model.setGeometry(a, l));
      }
    }
    this.cellsMoved(b, d, e, !1, !1);
    this.cellsAdded(b, k, this.model.getChildCount(k), null, null, !0);
    this.cellsAdded([c], k, this.model.getChildCount(k), f, b[0], !1);
    this.cellConnected(a, b[0], !0);
    this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, 'edge', a, 'cells', b, 'newEdge', c, 'dx', d, 'dy', e));
  } finally {
    this.model.endUpdate();
  }
  return c;
};
mxGraph.prototype.toggleCells = function (a, b, c) {
  null == b && (b = this.getSelectionCells());
  c && (b = this.addAllEdges(b));
  this.model.beginUpdate();
  try {
    this.cellsToggled(b, a),
      this.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS, 'show', a, 'cells', b, 'includeEdges', c));
  } finally {
    this.model.endUpdate();
  }
  return b;
};
mxGraph.prototype.cellsToggled = function (a, b) {
  if (null != a && 0 < a.length) {
    this.model.beginUpdate();
    try {
      for (var c = 0; c < a.length; c++) this.model.setVisible(a[c], b);
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.foldCells = function (a, b, c, d, e) {
  b = null != b ? b : !1;
  null == c && (c = this.getFoldableCells(this.getSelectionCells(), a));
  this.stopEditing(!1);
  this.model.beginUpdate();
  try {
    this.cellsFolded(c, a, b, d),
      this.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS, 'collapse', a, 'recurse', b, 'cells', c));
  } finally {
    this.model.endUpdate();
  }
  return c;
};
mxGraph.prototype.cellsFolded = function (a, b, c, d) {
  if (null != a && 0 < a.length) {
    this.model.beginUpdate();
    try {
      for (var e = 0; e < a.length; e++)
        if ((!d || this.isCellFoldable(a[e], b)) && b != this.isCellCollapsed(a[e])) {
          this.model.setCollapsed(a[e], b);
          this.swapBounds(a[e], b);
          this.isExtendParent(a[e]) && this.extendParent(a[e]);
          if (c) {
            var f = this.model.getChildren(a[e]);
            this.cellsFolded(f, b, c);
          }
          this.constrainChild(a[e]);
        }
      this.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED, 'cells', a, 'collapse', b, 'recurse', c));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.swapBounds = function (a, b) {
  if (null != a) {
    var c = this.model.getGeometry(a);
    null != c && ((c = c.clone()), this.updateAlternateBounds(a, c, b), c.swap(), this.model.setGeometry(a, c));
  }
};
mxGraph.prototype.updateAlternateBounds = function (a, b, c) {
  if (null != a && null != b) {
    c = this.getCurrentCellStyle(a);
    if (null == b.alternateBounds) {
      var d = b;
      this.collapseToPreferredSize &&
        ((a = this.getPreferredSizeForCell(a)),
        null != a &&
          ((d = a),
          (a = mxUtils.getValue(c, mxConstants.STYLE_STARTSIZE)),
          0 < a && (d.height = Math.max(d.height, a))));
      b.alternateBounds = new mxRectangle(0, 0, d.width, d.height);
    }
    if (null != b.alternateBounds) {
      b.alternateBounds.x = b.x;
      b.alternateBounds.y = b.y;
      var e = mxUtils.toRadians(c[mxConstants.STYLE_ROTATION] || 0);
      0 != e &&
        ((c = b.alternateBounds.getCenterX() - b.getCenterX()),
        (d = b.alternateBounds.getCenterY() - b.getCenterY()),
        (a = Math.cos(e)),
        (e = Math.sin(e)),
        (b.alternateBounds.x += a * c - e * d - c),
        (b.alternateBounds.y += e * c + a * d - d));
    }
  }
};
mxGraph.prototype.addAllEdges = function (a) {
  var b = a.slice();
  return mxUtils.removeDuplicates(b.concat(this.getAllEdges(a)));
};
mxGraph.prototype.getAllEdges = function (a) {
  var b = [];
  if (null != a)
    for (var c = 0; c < a.length; c++) {
      for (var d = this.model.getEdgeCount(a[c]), e = 0; e < d; e++) b.push(this.model.getEdgeAt(a[c], e));
      d = this.model.getChildren(a[c]);
      b = b.concat(this.getAllEdges(d));
    }
  return b;
};
mxGraph.prototype.updateCellSize = function (a, b) {
  b = null != b ? b : !1;
  this.model.beginUpdate();
  try {
    this.cellSizeUpdated(a, b),
      this.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, 'cell', a, 'ignoreChildren', b));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellSizeUpdated = function (a, b) {
  if (null != a) {
    this.model.beginUpdate();
    try {
      var c = this.getPreferredSizeForCell(a),
        d = this.model.getGeometry(a);
      if (null != c && null != d) {
        var e = this.isCellCollapsed(a),
          d = d.clone();
        if (this.isSwimlane(a)) {
          var f = this.getCellStyle(a),
            g = this.model.getStyle(a);
          null == g && (g = '');
          mxUtils.getValue(f, mxConstants.STYLE_HORIZONTAL, !0)
            ? ((g = mxUtils.setStyle(g, mxConstants.STYLE_STARTSIZE, c.height + 8)),
              e && (d.height = c.height + 8),
              (d.width = c.width))
            : ((g = mxUtils.setStyle(g, mxConstants.STYLE_STARTSIZE, c.width + 8)),
              e && (d.width = c.width + 8),
              (d.height = c.height));
          this.model.setStyle(a, g);
        } else {
          var k = this.view.createState(a),
            h = k.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER,
            l = this.getVerticalAlign(k);
          'fixed' == k.style[mxConstants.STYLE_ASPECT] &&
            (c.height = Math.round((d.height * c.width * 100) / d.width) / 100);
          h == mxConstants.ALIGN_RIGHT
            ? (d.x += d.width - c.width)
            : h == mxConstants.ALIGN_CENTER && (d.x += Math.round((d.width - c.width) / 2));
          l == mxConstants.ALIGN_BOTTOM
            ? (d.y += d.height - c.height)
            : l == mxConstants.ALIGN_MIDDLE && (d.y += Math.round((d.height - c.height) / 2));
          d.width = c.width;
          d.height = c.height;
        }
        if (!b && !e) {
          var m = this.view.getBounds(this.model.getChildren(a));
          if (null != m) {
            var n = this.view.translate,
              p = this.view.scale,
              r = (m.y + m.height) / p - d.y - n.y;
            d.width = Math.max(d.width, (m.x + m.width) / p - d.x - n.x);
            d.height = Math.max(d.height, r);
          }
        }
        this.cellsResized([a], [d], !1);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getPreferredSizeForCell = function (a, b) {
  var c = null;
  if (null != a) {
    var d = this.view.createState(a),
      e = d.style;
    if (!this.model.isEdge(a)) {
      var f = e[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE,
        g = 0,
        c = 0;
      (null == this.getImage(d) && null == e[mxConstants.STYLE_IMAGE]) ||
        e[mxConstants.STYLE_SHAPE] != mxConstants.SHAPE_LABEL ||
        (e[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE &&
          (g += parseFloat(e[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize),
        e[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER &&
          (c += parseFloat(e[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize));
      var g = g + 2 * (e[mxConstants.STYLE_SPACING] || 0),
        g = g + (e[mxConstants.STYLE_SPACING_LEFT] || 0),
        g = g + (e[mxConstants.STYLE_SPACING_RIGHT] || 0),
        c = c + 2 * (e[mxConstants.STYLE_SPACING] || 0),
        c = c + (e[mxConstants.STYLE_SPACING_TOP] || 0),
        c = c + (e[mxConstants.STYLE_SPACING_BOTTOM] || 0),
        k = this.getFoldingImage(d);
      null != k && (g += k.width + 8);
      k = this.cellRenderer.getLabelValue(d);
      null != k && 0 < k.length
        ? (this.isHtmlLabel(d.cell) || (k = mxUtils.htmlEntities(k, !1)),
          (k = k.replace(/\n/g, '<br>')),
          (f = mxUtils.getSizeForString(k, f, e[mxConstants.STYLE_FONTFAMILY], b, e[mxConstants.STYLE_FONTSTYLE])),
          (d = f.width + g),
          (c = f.height + c),
          mxUtils.getValue(e, mxConstants.STYLE_HORIZONTAL, !0) || ((e = c), (c = d), (d = e)),
          this.gridEnabled && ((d = this.snap(d + this.gridSize / 2)), (c = this.snap(c + this.gridSize / 2))),
          (c = new mxRectangle(0, 0, d, c)))
        : ((e = 4 * this.gridSize), (c = new mxRectangle(0, 0, e, e)));
    }
  }
  return c;
};
mxGraph.prototype.resizeCell = function (a, b, c) {
  return this.resizeCells([a], [b], c)[0];
};
mxGraph.prototype.resizeCells = function (a, b, c) {
  c = null != c ? c : this.isRecursiveResize();
  this.model.beginUpdate();
  try {
    var d = this.cellsResized(a, b, c);
    this.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS, 'cells', a, 'bounds', b, 'previous', d));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellsResized = function (a, b, c) {
  c = null != c ? c : !1;
  var d = [];
  if (null != a && null != b && a.length == b.length) {
    this.model.beginUpdate();
    try {
      for (var e = 0; e < a.length; e++)
        d.push(this.cellResized(a[e], b[e], !1, c)),
          this.isExtendParent(a[e]) && this.extendParent(a[e]),
          this.constrainChild(a[e]);
      this.resetEdgesOnResize && this.resetEdges(a);
      this.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED, 'cells', a, 'bounds', b, 'previous', d));
    } finally {
      this.model.endUpdate();
    }
  }
  return d;
};
mxGraph.prototype.cellResized = function (a, b, c, d) {
  var e = this.model.getGeometry(a);
  if (null != e && (e.x != b.x || e.y != b.y || e.width != b.width || e.height != b.height)) {
    var f = e.clone();
    !c && f.relative
      ? ((c = f.offset), null != c && ((c.x += b.x - f.x), (c.y += b.y - f.y)))
      : ((f.x = b.x), (f.y = b.y));
    f.width = b.width;
    f.height = b.height;
    f.relative ||
      !this.model.isVertex(a) ||
      this.isAllowNegativeCoordinates() ||
      ((f.x = Math.max(0, f.x)), (f.y = Math.max(0, f.y)));
    this.model.beginUpdate();
    try {
      d && this.resizeChildCells(a, f), this.model.setGeometry(a, f), this.constrainChildCells(a);
    } finally {
      this.model.endUpdate();
    }
  }
  return e;
};
mxGraph.prototype.resizeChildCells = function (a, b) {
  for (
    var c = this.model.getGeometry(a),
      d = 0 != c.width ? b.width / c.width : 1,
      c = 0 != c.height ? b.height / c.height : 1,
      e = this.model.getChildCount(a),
      f = 0;
    f < e;
    f++
  )
    this.scaleCell(this.model.getChildAt(a, f), d, c, !0);
};
mxGraph.prototype.constrainChildCells = function (a) {
  for (var b = this.model.getChildCount(a), c = 0; c < b; c++) this.constrainChild(this.model.getChildAt(a, c));
};
mxGraph.prototype.scaleCell = function (a, b, c, d) {
  var e = this.model.getGeometry(a);
  if (null != e) {
    var f = this.getCurrentCellStyle(a),
      e = e.clone(),
      g = e.x,
      k = e.y,
      h = e.width,
      l = e.height;
    e.scale(b, c, 'fixed' == f[mxConstants.STYLE_ASPECT]);
    '1' == f[mxConstants.STYLE_RESIZE_WIDTH]
      ? (e.width = h * b)
      : '0' == f[mxConstants.STYLE_RESIZE_WIDTH] && (e.width = h);
    '1' == f[mxConstants.STYLE_RESIZE_HEIGHT]
      ? (e.height = l * c)
      : '0' == f[mxConstants.STYLE_RESIZE_HEIGHT] && (e.height = l);
    this.isCellMovable(a) || ((e.x = g), (e.y = k));
    this.isCellResizable(a) || ((e.width = h), (e.height = l));
    this.model.isVertex(a) ? this.cellResized(a, e, !0, d) : this.model.setGeometry(a, e);
  }
};
mxGraph.prototype.extendParent = function (a) {
  if (null != a) {
    var b = this.model.getParent(a),
      c = this.getCellGeometry(b);
    null == b ||
      null == c ||
      this.isCellCollapsed(b) ||
      ((a = this.getCellGeometry(a)),
      null != a &&
        !a.relative &&
        (c.width < a.x + a.width || c.height < a.y + a.height) &&
        ((c = c.clone()),
        (c.width = Math.max(c.width, a.x + a.width)),
        (c.height = Math.max(c.height, a.y + a.height)),
        this.cellsResized([b], [c], !1)));
  }
};
mxGraph.prototype.importCells = function (a, b, c, d, e, f) {
  return this.moveCells(a, b, c, !0, d, e, f);
};
mxGraph.prototype.moveCells = function (a, b, c, d, e, f, g) {
  b = null != b ? b : 0;
  c = null != c ? c : 0;
  d = null != d ? d : !1;
  if (null != a && (0 != b || 0 != c || d || null != e)) {
    var k = (a = this.model.getTopmostCells(a));
    this.model.beginUpdate();
    try {
      for (var h = new mxDictionary(), l = 0; l < a.length; l++) h.put(a[l], !0);
      for (
        var m = mxUtils.bind(this, function (a) {
            for (; null != a; ) {
              if (h.get(a)) return !0;
              a = this.model.getParent(a);
            }
            return !1;
          }),
          n = [],
          l = 0;
        l < a.length;
        l++
      ) {
        var p = this.getCellGeometry(a[l]),
          r = this.model.getParent(a[l]);
        (null != p &&
          p.relative &&
          this.model.isEdge(r) &&
          (m(this.model.getTerminal(r, !0)) || m(this.model.getTerminal(r, !1)))) ||
          n.push(a[l]);
      }
      a = n;
      d && ((a = this.cloneCells(a, this.isCloneInvalidEdges(), g)), null == e && (e = this.getDefaultParent()));
      var t = this.isAllowNegativeCoordinates();
      null != e && this.setAllowNegativeCoordinates(!0);
      this.cellsMoved(
        a,
        b,
        c,
        !d && this.isDisconnectOnMove() && this.isAllowDanglingEdges(),
        null == e,
        this.isExtendParentsOnMove() && null == e
      );
      this.setAllowNegativeCoordinates(t);
      if (null != e) {
        var u = this.model.getChildCount(e);
        this.cellsAdded(a, e, u, null, null, !0);
        if (d)
          for (l = 0; l < a.length; l++)
            (p = this.getCellGeometry(a[l])),
              (r = this.model.getParent(k[l])),
              null != p && p.relative && this.model.isEdge(r) && this.model.contains(r) && this.model.add(r, a[l]);
      }
      this.fireEvent(
        new mxEventObject(mxEvent.MOVE_CELLS, 'cells', a, 'dx', b, 'dy', c, 'clone', d, 'target', e, 'event', f)
      );
    } finally {
      this.model.endUpdate();
    }
  }
  return a;
};
mxGraph.prototype.cellsMoved = function (a, b, c, d, e, f) {
  if (null != a && (0 != b || 0 != c)) {
    f = null != f ? f : !1;
    this.model.beginUpdate();
    try {
      d && this.disconnectGraph(a);
      for (var g = 0; g < a.length; g++)
        this.translateCell(a[g], b, c),
          f && this.isExtendParent(a[g]) ? this.extendParent(a[g]) : e && this.constrainChild(a[g]);
      this.resetEdgesOnMove && this.resetEdges(a);
      this.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED, 'cells', a, 'dx', b, 'dy', c, 'disconnect', d));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.translateCell = function (a, b, c) {
  var d = this.model.getGeometry(a);
  if (null != d) {
    b = parseFloat(b);
    c = parseFloat(c);
    d = d.clone();
    d.translate(b, c);
    d.relative ||
      !this.model.isVertex(a) ||
      this.isAllowNegativeCoordinates() ||
      ((d.x = Math.max(0, parseFloat(d.x))), (d.y = Math.max(0, parseFloat(d.y))));
    if (d.relative && !this.model.isEdge(a)) {
      var e = this.model.getParent(a),
        f = 0;
      this.model.isVertex(e) &&
        ((e = this.getCurrentCellStyle(e)), (f = mxUtils.getValue(e, mxConstants.STYLE_ROTATION, 0)));
      0 != f &&
        ((f = mxUtils.toRadians(-f)),
        (e = Math.cos(f)),
        (f = Math.sin(f)),
        (c = mxUtils.getRotatedPoint(new mxPoint(b, c), e, f, new mxPoint(0, 0))),
        (b = c.x),
        (c = c.y));
      null == d.offset
        ? (d.offset = new mxPoint(Math.round(b), Math.round(c)))
        : ((d.offset.x = Math.round(parseFloat(d.offset.x + b))),
          (d.offset.y = Math.round(parseFloat(d.offset.y + c))));
    }
    this.model.setGeometry(a, d);
  }
};
mxGraph.prototype.getCellContainmentArea = function (a) {
  if (null != a && !this.model.isEdge(a)) {
    var b = this.model.getParent(a);
    if (null != b && b != this.getDefaultParent()) {
      var c = this.model.getGeometry(b);
      if (null != c) {
        var d = (a = 0),
          e = c.width,
          c = c.height;
        if (this.isSwimlane(b)) {
          var f = this.getStartSize(b),
            g = this.getCurrentCellStyle(b),
            b = mxUtils.getValue(g, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST),
            k = 1 == mxUtils.getValue(g, mxConstants.STYLE_FLIPH, 0),
            g = 1 == mxUtils.getValue(g, mxConstants.STYLE_FLIPV, 0);
          if (b == mxConstants.DIRECTION_SOUTH || b == mxConstants.DIRECTION_NORTH) {
            var h = f.width;
            f.width = f.height;
            f.height = h;
          }
          if (
            (b == mxConstants.DIRECTION_EAST && !g) ||
            (b == mxConstants.DIRECTION_NORTH && !k) ||
            (b == mxConstants.DIRECTION_WEST && g) ||
            (b == mxConstants.DIRECTION_SOUTH && k)
          )
            (a = f.width), (d = f.height);
          e -= f.width;
          c -= f.height;
        }
        return new mxRectangle(a, d, e, c);
      }
    }
  }
  return null;
};
mxGraph.prototype.getMaximumGraphBounds = function () {
  return this.maximumGraphBounds;
};
mxGraph.prototype.constrainChild = function (a, b) {
  if (null != a) {
    var c = this.getCellGeometry(a);
    if (null != c && (this.isConstrainRelativeChildren() || !c.relative)) {
      var d = this.model.getParent(a);
      this.getCellGeometry(d);
      var e = this.getMaximumGraphBounds();
      null != e &&
        ((d = this.getBoundingBoxFromGeometry([d], !1)),
        null != d && ((e = mxRectangle.fromRectangle(e)), (e.x -= d.x), (e.y -= d.y)));
      if (this.isConstrainChild(a) && ((d = this.getCellContainmentArea(a)), null != d)) {
        var f = this.getOverlap(a);
        0 < f &&
          ((d = mxRectangle.fromRectangle(d)),
          (d.x -= d.width * f),
          (d.y -= d.height * f),
          (d.width += 2 * d.width * f),
          (d.height += 2 * d.height * f));
        null == e ? (e = d) : ((e = mxRectangle.fromRectangle(e)), e.intersect(d));
      }
      if (null != e) {
        d = [a];
        if (!this.isCellCollapsed(a))
          for (var f = this.model.getDescendants(a), g = 0; g < f.length; g++) this.isCellVisible(f[g]) && d.push(f[g]);
        d = this.getBoundingBoxFromGeometry(d, !1);
        if (null != d) {
          c = c.clone();
          f = 0;
          c.width > e.width && ((f = c.width - e.width), (c.width -= f));
          d.x + d.width > e.x + e.width && (f -= d.x + d.width - e.x - e.width - f);
          g = 0;
          c.height > e.height && ((g = c.height - e.height), (c.height -= g));
          d.y + d.height > e.y + e.height && (g -= d.y + d.height - e.y - e.height - g);
          d.x < e.x && (f -= d.x - e.x);
          d.y < e.y && (g -= d.y - e.y);
          if (0 != f || 0 != g)
            c.relative
              ? (null == c.offset && (c.offset = new mxPoint()), (c.offset.x += f), (c.offset.y += g))
              : ((c.x += f), (c.y += g));
          this.model.setGeometry(a, c);
        }
      }
    }
  }
};
mxGraph.prototype.resetEdges = function (a) {
  if (null != a) {
    for (var b = new mxDictionary(), c = 0; c < a.length; c++) b.put(a[c], !0);
    this.model.beginUpdate();
    try {
      for (c = 0; c < a.length; c++) {
        var d = this.model.getEdges(a[c]);
        if (null != d)
          for (var e = 0; e < d.length; e++) {
            var f = this.view.getState(d[e]),
              g = null != f ? f.getVisibleTerminal(!0) : this.view.getVisibleTerminal(d[e], !0),
              k = null != f ? f.getVisibleTerminal(!1) : this.view.getVisibleTerminal(d[e], !1);
            (b.get(g) && b.get(k)) || this.resetEdge(d[e]);
          }
        this.resetEdges(this.model.getChildren(a[c]));
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.resetEdge = function (a) {
  var b = this.model.getGeometry(a);
  null != b &&
    null != b.points &&
    0 < b.points.length &&
    ((b = b.clone()), (b.points = []), this.model.setGeometry(a, b));
  return a;
};
mxGraph.prototype.getOutlineConstraint = function (a, b, c) {
  if (null != b.shape) {
    c = this.view.getPerimeterBounds(b);
    var d = b.style[mxConstants.STYLE_DIRECTION];
    if (d == mxConstants.DIRECTION_NORTH || d == mxConstants.DIRECTION_SOUTH) {
      c.x += c.width / 2 - c.height / 2;
      c.y += c.height / 2 - c.width / 2;
      var e = c.width;
      c.width = c.height;
      c.height = e;
    }
    var f = mxUtils.toRadians(b.shape.getShapeRotation());
    if (0 != f) {
      var e = Math.cos(-f),
        f = Math.sin(-f),
        g = new mxPoint(c.getCenterX(), c.getCenterY());
      a = mxUtils.getRotatedPoint(a, e, f, g);
    }
    var g = (f = 1),
      k = 0,
      h = 0;
    if (this.getModel().isVertex(b.cell)) {
      var l = b.style[mxConstants.STYLE_FLIPH],
        m = b.style[mxConstants.STYLE_FLIPV];
      null != b.shape &&
        null != b.shape.stencil &&
        ((l = 1 == mxUtils.getValue(b.style, 'stencilFlipH', 0) || l),
        (m = 1 == mxUtils.getValue(b.style, 'stencilFlipV', 0) || m));
      if (d == mxConstants.DIRECTION_NORTH || d == mxConstants.DIRECTION_SOUTH) (e = l), (l = m), (m = e);
      l && ((f = -1), (k = -c.width));
      m && ((g = -1), (h = -c.height));
    }
    a = new mxPoint((a.x - c.x) * f - k + c.x, (a.y - c.y) * g - h + c.y);
    return new mxConnectionConstraint(
      new mxPoint(
        0 == c.width ? 0 : Math.round((1e3 * (a.x - c.x)) / c.width) / 1e3,
        0 == c.height ? 0 : Math.round((1e3 * (a.y - c.y)) / c.height) / 1e3
      ),
      !1
    );
  }
  return null;
};
mxGraph.prototype.getAllConnectionConstraints = function (a, b) {
  return null != a && null != a.shape && null != a.shape.stencil ? a.shape.stencil.constraints : null;
};
mxGraph.prototype.getConnectionConstraint = function (a, b, c) {
  b = null;
  var d = a.style[c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];
  if (null != d) {
    var e = a.style[c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];
    null != e && (b = new mxPoint(parseFloat(d), parseFloat(e)));
  }
  var d = !1,
    f = (e = 0);
  null != b &&
    ((d = mxUtils.getValue(a.style, c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, !0)),
    (e = parseFloat(a.style[c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX])),
    (f = parseFloat(a.style[c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY])),
    (e = isFinite(e) ? e : 0),
    (f = isFinite(f) ? f : 0));
  return new mxConnectionConstraint(b, d, null, e, f);
};
mxGraph.prototype.setConnectionConstraint = function (a, b, c, d) {
  if (null != d) {
    this.model.beginUpdate();
    try {
      null == d || null == d.point
        ? (this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, null, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, null, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, null, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, null, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [a]))
        : null != d.point &&
          (this.setCellStyles(c ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X, d.point.x, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y, d.point.y, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX, d.dx, [a]),
          this.setCellStyles(c ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY, d.dy, [a]),
          d.perimeter
            ? this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, null, [a])
            : this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER : mxConstants.STYLE_ENTRY_PERIMETER, '0', [a]));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getConnectionPoint = function (a, b, c) {
  c = null != c ? c : !0;
  var d = null;
  if (null != a && null != b.point) {
    var e = this.view.getPerimeterBounds(a),
      f = new mxPoint(e.getCenterX(), e.getCenterY()),
      g = a.style[mxConstants.STYLE_DIRECTION],
      k = 0;
    null != g &&
      1 == mxUtils.getValue(a.style, mxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1) &&
      (g == mxConstants.DIRECTION_NORTH
        ? (k += 270)
        : g == mxConstants.DIRECTION_WEST
        ? (k += 180)
        : g == mxConstants.DIRECTION_SOUTH && (k += 90),
      (g != mxConstants.DIRECTION_NORTH && g != mxConstants.DIRECTION_SOUTH) || e.rotate90());
    var d = this.view.scale,
      d = new mxPoint(e.x + b.point.x * e.width + b.dx * d, e.y + b.point.y * e.height + b.dy * d),
      h = a.style[mxConstants.STYLE_ROTATION] || 0;
    if (b.perimeter)
      0 != k &&
        ((g = e = 0),
        90 == k ? (g = 1) : 180 == k ? (e = -1) : 270 == k && (g = -1),
        (d = mxUtils.getRotatedPoint(d, e, g, f))),
        (d = this.view.getPerimeterPoint(a, d, !1));
    else if (((h += k), this.getModel().isVertex(a.cell))) {
      k = 1 == a.style[mxConstants.STYLE_FLIPH];
      b = 1 == a.style[mxConstants.STYLE_FLIPV];
      null != a.shape &&
        null != a.shape.stencil &&
        ((k = 1 == mxUtils.getValue(a.style, 'stencilFlipH', 0) || k),
        (b = 1 == mxUtils.getValue(a.style, 'stencilFlipV', 0) || b));
      if (g == mxConstants.DIRECTION_NORTH || g == mxConstants.DIRECTION_SOUTH) (a = k), (k = b), (b = a);
      k && (d.x = 2 * e.getCenterX() - d.x);
      b && (d.y = 2 * e.getCenterY() - d.y);
    }
    0 != h &&
      null != d &&
      ((a = mxUtils.toRadians(h)), (e = Math.cos(a)), (g = Math.sin(a)), (d = mxUtils.getRotatedPoint(d, e, g, f)));
  }
  c && null != d && ((d.x = Math.round(d.x)), (d.y = Math.round(d.y)));
  return d;
};
mxGraph.prototype.connectCell = function (a, b, c, d) {
  this.model.beginUpdate();
  try {
    var e = this.model.getTerminal(a, c);
    this.cellConnected(a, b, c, d);
    this.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL, 'edge', a, 'terminal', b, 'source', c, 'previous', e));
  } finally {
    this.model.endUpdate();
  }
  return a;
};
mxGraph.prototype.cellConnected = function (a, b, c, d) {
  if (null != a) {
    this.model.beginUpdate();
    try {
      var e = this.model.getTerminal(a, c);
      this.setConnectionConstraint(a, b, c, d);
      this.isPortsEnabled() &&
        ((d = null),
        this.isPort(b) && ((d = b.getId()), (b = this.getTerminalForPort(b, c))),
        this.setCellStyles(c ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT, d, [a]));
      this.model.setTerminal(a, b, c);
      this.resetEdgesOnConnect && this.resetEdge(a);
      this.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED, 'edge', a, 'terminal', b, 'source', c, 'previous', e));
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.disconnectGraph = function (a) {
  if (null != a) {
    this.model.beginUpdate();
    try {
      for (var b = this.view.scale, c = this.view.translate, d = new mxDictionary(), e = 0; e < a.length; e++)
        d.put(a[e], !0);
      for (e = 0; e < a.length; e++)
        if (this.model.isEdge(a[e])) {
          var f = this.model.getGeometry(a[e]);
          if (null != f) {
            var g = this.view.getState(a[e]),
              k = this.view.getState(this.model.getParent(a[e]));
            if (null != g && null != k) {
              var f = f.clone(),
                h = -k.origin.x,
                l = -k.origin.y,
                m = g.absolutePoints,
                n = this.model.getTerminal(a[e], !0);
              if (null != n && this.isCellDisconnectable(a[e], n, !0)) {
                for (; null != n && !d.get(n); ) n = this.model.getParent(n);
                null == n &&
                  (f.setTerminalPoint(new mxPoint(m[0].x / b - c.x + h, m[0].y / b - c.y + l), !0),
                  this.model.setTerminal(a[e], null, !0));
              }
              var p = this.model.getTerminal(a[e], !1);
              if (null != p && this.isCellDisconnectable(a[e], p, !1)) {
                for (; null != p && !d.get(p); ) p = this.model.getParent(p);
                if (null == p) {
                  var r = m.length - 1;
                  f.setTerminalPoint(new mxPoint(m[r].x / b - c.x + h, m[r].y / b - c.y + l), !1);
                  this.model.setTerminal(a[e], null, !1);
                }
              }
              this.model.setGeometry(a[e], f);
            }
          }
        }
    } finally {
      this.model.endUpdate();
    }
  }
};
mxGraph.prototype.getCurrentRoot = function () {
  return this.view.currentRoot;
};
mxGraph.prototype.getTranslateForRoot = function (a) {
  return null;
};
mxGraph.prototype.isPort = function (a) {
  return !1;
};
mxGraph.prototype.getTerminalForPort = function (a, b) {
  return this.model.getParent(a);
};
mxGraph.prototype.getChildOffsetForCell = function (a) {
  return null;
};
mxGraph.prototype.enterGroup = function (a) {
  a = a || this.getSelectionCell();
  null != a && this.isValidRoot(a) && (this.view.setCurrentRoot(a), this.clearSelection());
};
mxGraph.prototype.exitGroup = function () {
  var a = this.model.getRoot(),
    b = this.getCurrentRoot();
  if (null != b) {
    for (var c = this.model.getParent(b); c != a && !this.isValidRoot(c) && this.model.getParent(c) != a; )
      c = this.model.getParent(c);
    c == a || this.model.getParent(c) == a ? this.view.setCurrentRoot(null) : this.view.setCurrentRoot(c);
    null != this.view.getState(b) && this.setSelectionCell(b);
  }
};
mxGraph.prototype.home = function () {
  var a = this.getCurrentRoot();
  null != a && (this.view.setCurrentRoot(null), null != this.view.getState(a) && this.setSelectionCell(a));
};
mxGraph.prototype.isValidRoot = function (a) {
  return null != a;
};
mxGraph.prototype.getGraphBounds = function () {
  return this.view.getGraphBounds();
};
mxGraph.prototype.getCellBounds = function (a, b, c) {
  var d = [a];
  b && (d = d.concat(this.model.getEdges(a)));
  d = this.view.getBounds(d);
  if (c) {
    c = this.model.getChildCount(a);
    for (var e = 0; e < c; e++) {
      var f = this.getCellBounds(this.model.getChildAt(a, e), b, !0);
      null != d ? d.add(f) : (d = f);
    }
  }
  return d;
};
mxGraph.prototype.getBoundingBoxFromGeometry = function (a, b) {
  b = null != b ? b : !1;
  var c = null;
  if (null != a)
    for (var d = 0; d < a.length; d++)
      if (b || this.model.isVertex(a[d])) {
        var e = this.getCellGeometry(a[d]);
        if (null != e) {
          var f = null;
          if (this.model.isEdge(a[d])) {
            f = function (a) {
              null != a && (null == g ? (g = new mxRectangle(a.x, a.y, 0, 0)) : g.add(new mxRectangle(a.x, a.y, 0, 0)));
            };
            null == this.model.getTerminal(a[d], !0) && f(e.getTerminalPoint(!0));
            null == this.model.getTerminal(a[d], !1) && f(e.getTerminalPoint(!1));
            e = e.points;
            if (null != e && 0 < e.length)
              for (var g = new mxRectangle(e[0].x, e[0].y, 0, 0), k = 1; k < e.length; k++) f(e[k]);
            f = g;
          } else
            (k = this.model.getParent(a[d])),
              e.relative
                ? this.model.isVertex(k) &&
                  k != this.view.currentRoot &&
                  ((g = this.getBoundingBoxFromGeometry([k], !1)),
                  null != g &&
                    ((f = new mxRectangle(e.x * g.width, e.y * g.height, e.width, e.height)),
                    0 <= mxUtils.indexOf(a, k) && ((f.x += g.x), (f.y += g.y))))
                : ((f = mxRectangle.fromRectangle(e)),
                  this.model.isVertex(k) &&
                    0 <= mxUtils.indexOf(a, k) &&
                    ((g = this.getBoundingBoxFromGeometry([k], !1)), null != g && ((f.x += g.x), (f.y += g.y)))),
              null != f && null != e.offset && ((f.x += e.offset.x), (f.y += e.offset.y)),
              (e = this.getCurrentCellStyle(a[d])),
              null != f &&
                ((e = mxUtils.getValue(e, mxConstants.STYLE_ROTATION, 0)),
                0 != e && (f = mxUtils.getBoundingBox(f, e)));
          null != f && (null == c ? (c = mxRectangle.fromRectangle(f)) : c.add(f));
        }
      }
  return c;
};
mxGraph.prototype.refresh = function (a) {
  this.view.clear(a, null == a);
  this.view.validate();
  this.sizeDidChange();
  this.fireEvent(new mxEventObject(mxEvent.REFRESH));
};
mxGraph.prototype.snap = function (a) {
  this.gridEnabled && (a = Math.round(a / this.gridSize) * this.gridSize);
  return a;
};
mxGraph.prototype.snapDelta = function (a, b, c, d, e) {
  var f = this.view.translate,
    g = this.view.scale;
  !c && this.gridEnabled
    ? ((c = this.gridSize * g * 0.5),
      d ||
        ((d = b.x - (this.snap(b.x / g - f.x) + f.x) * g),
        (a.x = Math.abs(a.x - d) < c ? 0 : this.snap(a.x / g) * g - d)),
      e ||
        ((b = b.y - (this.snap(b.y / g - f.y) + f.y) * g),
        (a.y = Math.abs(a.y - b) < c ? 0 : this.snap(a.y / g) * g - b)))
    : ((c = 0.5 * g),
      d ||
        ((d = b.x - (Math.round(b.x / g - f.x) + f.x) * g),
        (a.x = Math.abs(a.x - d) < c ? 0 : Math.round(a.x / g) * g - d)),
      e ||
        ((b = b.y - (Math.round(b.y / g - f.y) + f.y) * g),
        (a.y = Math.abs(a.y - b) < c ? 0 : Math.round(a.y / g) * g - b)));
  return a;
};
mxGraph.prototype.panGraph = function (a, b) {
  if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container))
    (this.container.scrollLeft = -a), (this.container.scrollTop = -b);
  else {
    var c = this.view.getCanvas();
    if (this.dialect == mxConstants.DIALECT_SVG)
      if (0 == a && 0 == b) {
        if (
          (mxClient.IS_IE
            ? c.setAttribute('transform', 'translate(' + a + ',' + b + ')')
            : c.removeAttribute('transform'),
          null != this.shiftPreview1)
        ) {
          for (var d = this.shiftPreview1.firstChild; null != d; ) {
            var e = d.nextSibling;
            this.container.appendChild(d);
            d = e;
          }
          null != this.shiftPreview1.parentNode && this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          this.shiftPreview1 = null;
          this.container.appendChild(c.parentNode);
          for (d = this.shiftPreview2.firstChild; null != d; )
            (e = d.nextSibling), this.container.appendChild(d), (d = e);
          null != this.shiftPreview2.parentNode && this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);
          this.shiftPreview2 = null;
        }
      } else {
        c.setAttribute('transform', 'translate(' + a + ',' + b + ')');
        if (null == this.shiftPreview1) {
          this.shiftPreview1 = document.createElement('div');
          this.shiftPreview1.style.position = 'absolute';
          this.shiftPreview1.style.overflow = 'visible';
          this.shiftPreview2 = document.createElement('div');
          this.shiftPreview2.style.position = 'absolute';
          this.shiftPreview2.style.overflow = 'visible';
          for (var f = this.shiftPreview1, d = this.container.firstChild; null != d; )
            (e = d.nextSibling), d != c.parentNode ? f.appendChild(d) : (f = this.shiftPreview2), (d = e);
          null != this.shiftPreview1.firstChild && this.container.insertBefore(this.shiftPreview1, c.parentNode);
          null != this.shiftPreview2.firstChild && this.container.appendChild(this.shiftPreview2);
        }
        this.shiftPreview1.style.left = a + 'px';
        this.shiftPreview1.style.top = b + 'px';
        this.shiftPreview2.style.left = a + 'px';
        this.shiftPreview2.style.top = b + 'px';
      }
    else (c.style.left = a + 'px'), (c.style.top = b + 'px');
    this.panDx = a;
    this.panDy = b;
    this.fireEvent(new mxEventObject(mxEvent.PAN));
  }
};
mxGraph.prototype.zoomIn = function () {
  this.zoom(this.zoomFactor);
};
mxGraph.prototype.zoomOut = function () {
  this.zoom(1 / this.zoomFactor);
};
mxGraph.prototype.zoomActual = function () {
  1 == this.view.scale
    ? this.view.setTranslate(0, 0)
    : ((this.view.translate.x = 0), (this.view.translate.y = 0), this.view.setScale(1));
};
mxGraph.prototype.zoomTo = function (a, b) {
  this.zoom(a / this.view.scale, b);
};
mxGraph.prototype.center = function (a, b, c, d) {
  a = null != a ? a : !0;
  b = null != b ? b : !0;
  c = null != c ? c : 0.5;
  d = null != d ? d : 0.5;
  var e = mxUtils.hasScrollbars(this.container),
    f = 2 * this.getBorder(),
    g = this.container.clientWidth - f,
    f = this.container.clientHeight - f,
    k = this.getGraphBounds(),
    h = this.view.translate,
    l = this.view.scale,
    m = a ? g - k.width : 0,
    n = b ? f - k.height : 0;
  e
    ? ((k.x -= h.x),
      (k.y -= h.y),
      (a = this.container.scrollWidth),
      (b = this.container.scrollHeight),
      a > g && (m = 0),
      b > f && (n = 0),
      this.view.setTranslate(Math.floor(m / 2 - k.x), Math.floor(n / 2 - k.y)),
      (this.container.scrollLeft = (a - g) / 2),
      (this.container.scrollTop = (b - f) / 2))
    : this.view.setTranslate(
        a ? Math.floor(h.x - k.x / l + (m * c) / l) : h.x,
        b ? Math.floor(h.y - k.y / l + (n * d) / l) : h.y
      );
};
mxGraph.prototype.zoom = function (a, b, c) {
  b = null != b ? b : this.centerZoom;
  var d = Math.round(this.view.scale * a * 100) / 100;
  null != c && (d = Math.round(d * c) / c);
  c = this.view.getState(this.getSelectionCell());
  a = d / this.view.scale;
  if (this.keepSelectionVisibleOnZoom && null != c)
    (a = new mxRectangle(c.x * a, c.y * a, c.width * a, c.height * a)),
      (this.view.scale = d),
      this.scrollRectToVisible(a) || (this.view.revalidate(), this.view.setScale(d));
  else if (((c = mxUtils.hasScrollbars(this.container)), b && !c)) {
    c = this.container.offsetWidth;
    var e = this.container.offsetHeight;
    1 < a
      ? ((a = (a - 1) / (2 * d)), (c *= -a), (e *= -a))
      : ((a = (1 / a - 1) / (2 * this.view.scale)), (c *= a), (e *= a));
    this.view.scaleAndTranslate(d, this.view.translate.x + c, this.view.translate.y + e);
  } else {
    var f = this.view.translate.x,
      g = this.view.translate.y,
      k = this.container.scrollLeft,
      h = this.container.scrollTop;
    this.view.setScale(d);
    c &&
      ((e = c = 0),
      b && ((c = (this.container.offsetWidth * (a - 1)) / 2), (e = (this.container.offsetHeight * (a - 1)) / 2)),
      (this.container.scrollLeft = (this.view.translate.x - f) * this.view.scale + Math.round(k * a + c)),
      (this.container.scrollTop = (this.view.translate.y - g) * this.view.scale + Math.round(h * a + e)));
  }
};
mxGraph.prototype.zoomToRect = function (a) {
  var b = this.container.clientWidth / a.width / (this.container.clientHeight / a.height);
  a.x = Math.max(0, a.x);
  a.y = Math.max(0, a.y);
  var c = Math.min(this.container.scrollWidth, a.x + a.width),
    d = Math.min(this.container.scrollHeight, a.y + a.height);
  a.width = c - a.x;
  a.height = d - a.y;
  1 > b
    ? ((b = a.height / b),
      (c = (b - a.height) / 2),
      (a.height = b),
      (a.y -= Math.min(a.y, c)),
      (d = Math.min(this.container.scrollHeight, a.y + a.height)),
      (a.height = d - a.y))
    : ((b *= a.width),
      (c = (b - a.width) / 2),
      (a.width = b),
      (a.x -= Math.min(a.x, c)),
      (c = Math.min(this.container.scrollWidth, a.x + a.width)),
      (a.width = c - a.x));
  b = this.container.clientWidth / a.width;
  c = this.view.scale * b;
  mxUtils.hasScrollbars(this.container)
    ? (this.view.setScale(c),
      (this.container.scrollLeft = Math.round(a.x * b)),
      (this.container.scrollTop = Math.round(a.y * b)))
    : this.view.scaleAndTranslate(
        c,
        this.view.translate.x - a.x / this.view.scale,
        this.view.translate.y - a.y / this.view.scale
      );
};
mxGraph.prototype.scrollCellToVisible = function (a, b) {
  var c = -this.view.translate.x,
    d = -this.view.translate.y,
    e = this.view.getState(a);
  null != e &&
    ((c = new mxRectangle(c + e.x, d + e.y, e.width, e.height)),
    b &&
      null != this.container &&
      ((d = this.container.clientWidth),
      (e = this.container.clientHeight),
      (c.x = c.getCenterX() - d / 2),
      (c.width = d),
      (c.y = c.getCenterY() - e / 2),
      (c.height = e)),
    (d = new mxPoint(this.view.translate.x, this.view.translate.y)),
    this.scrollRectToVisible(c) &&
      ((c = new mxPoint(this.view.translate.x, this.view.translate.y)),
      (this.view.translate.x = d.x),
      (this.view.translate.y = d.y),
      this.view.setTranslate(c.x, c.y)));
};
mxGraph.prototype.scrollRectToVisible = function (a) {
  var b = !1;
  if (null != a) {
    var c = this.container.offsetWidth,
      d = this.container.offsetHeight,
      e = Math.min(c, a.width),
      f = Math.min(d, a.height);
    if (mxUtils.hasScrollbars(this.container)) {
      c = this.container;
      a.x += this.view.translate.x;
      a.y += this.view.translate.y;
      var g = c.scrollLeft - a.x,
        d = Math.max(g - c.scrollLeft, 0);
      0 < g
        ? (c.scrollLeft -= g + 2)
        : ((g = a.x + e - c.scrollLeft - c.clientWidth), 0 < g && (c.scrollLeft += g + 2));
      e = c.scrollTop - a.y;
      g = Math.max(0, e - c.scrollTop);
      0 < e ? (c.scrollTop -= e + 2) : ((e = a.y + f - c.scrollTop - c.clientHeight), 0 < e && (c.scrollTop += e + 2));
      this.useScrollbarsForPanning || (0 == d && 0 == g) || this.view.setTranslate(d, g);
    } else {
      var g = -this.view.translate.x,
        k = -this.view.translate.y,
        h = this.view.scale;
      a.x + e > g + c && ((this.view.translate.x -= (a.x + e - c - g) / h), (b = !0));
      a.y + f > k + d && ((this.view.translate.y -= (a.y + f - d - k) / h), (b = !0));
      a.x < g && ((this.view.translate.x += (g - a.x) / h), (b = !0));
      a.y < k && ((this.view.translate.y += (k - a.y) / h), (b = !0));
      b && (this.view.refresh(), null != this.selectionCellsHandler && this.selectionCellsHandler.refresh());
    }
  }
  return b;
};
mxGraph.prototype.getCellGeometry = function (a) {
  return this.model.getGeometry(a);
};
mxGraph.prototype.isCellVisible = function (a) {
  return this.model.isVisible(a);
};
mxGraph.prototype.isCellCollapsed = function (a) {
  return this.model.isCollapsed(a);
};
mxGraph.prototype.isCellConnectable = function (a) {
  return this.model.isConnectable(a);
};
mxGraph.prototype.isOrthogonal = function (a) {
  var b = a.style[mxConstants.STYLE_ORTHOGONAL];
  if (null != b) return b;
  a = this.view.getEdgeStyle(a);
  return (
    a == mxEdgeStyle.SegmentConnector ||
    a == mxEdgeStyle.ElbowConnector ||
    a == mxEdgeStyle.SideToSide ||
    a == mxEdgeStyle.TopToBottom ||
    a == mxEdgeStyle.EntityRelation ||
    a == mxEdgeStyle.OrthConnector
  );
};
mxGraph.prototype.isLoop = function (a) {
  var b = a.getVisibleTerminalState(!0);
  a = a.getVisibleTerminalState(!1);
  return null != b && b == a;
};
mxGraph.prototype.isCloneEvent = function (a) {
  return mxEvent.isControlDown(a);
};
mxGraph.prototype.isTransparentClickEvent = function (a) {
  return !1;
};
mxGraph.prototype.isToggleEvent = function (a) {
  return mxClient.IS_MAC ? mxEvent.isMetaDown(a) : mxEvent.isControlDown(a);
};
mxGraph.prototype.isGridEnabledEvent = function (a) {
  return null != a && !mxEvent.isAltDown(a);
};
mxGraph.prototype.isConstrainedEvent = function (a) {
  return mxEvent.isShiftDown(a);
};
mxGraph.prototype.isIgnoreTerminalEvent = function (a) {
  return !1;
};
mxGraph.prototype.validationAlert = function (a) {
  mxUtils.alert(a);
};
mxGraph.prototype.isEdgeValid = function (a, b, c) {
  return null == this.getEdgeValidationError(a, b, c);
};
mxGraph.prototype.getEdgeValidationError = function (a, b, c) {
  if (null != a && !this.isAllowDanglingEdges() && (null == b || null == c)) return '';
  if (null != a && null == this.model.getTerminal(a, !0) && null == this.model.getTerminal(a, !1)) return null;
  if ((!this.allowLoops && b == c && null != b) || !this.isValidConnection(b, c)) return '';
  if (null != b && null != c) {
    var d = '';
    if (!this.multigraph) {
      var e = this.model.getEdgesBetween(b, c, !0);
      if (1 < e.length || (1 == e.length && e[0] != a))
        d += (mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + '\n';
    }
    var e = this.model.getDirectedEdgeCount(b, !0, a),
      f = this.model.getDirectedEdgeCount(c, !1, a);
    if (null != this.multiplicities)
      for (var g = 0; g < this.multiplicities.length; g++) {
        var k = this.multiplicities[g].check(this, a, b, c, e, f);
        null != k && (d += k);
      }
    k = this.validateEdge(a, b, c);
    null != k && (d += k);
    return 0 < d.length ? d : null;
  }
  return this.allowDanglingEdges ? null : '';
};
mxGraph.prototype.validateEdge = function (a, b, c) {
  return null;
};
mxGraph.prototype.validateGraph = function (a, b) {
  a = null != a ? a : this.model.getRoot();
  b = null != b ? b : {};
  for (var c = !0, d = this.model.getChildCount(a), e = 0; e < d; e++) {
    var f = this.model.getChildAt(a, e),
      g = b;
    this.isValidRoot(f) && (g = {});
    g = this.validateGraph(f, g);
    null != g ? this.setCellWarning(f, g.replace(/\n/g, '<br>')) : this.setCellWarning(f, null);
    c = c && null == g;
  }
  d = '';
  this.isCellCollapsed(a) &&
    !c &&
    (d += (mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + '\n');
  d = this.model.isEdge(a)
    ? d + (this.getEdgeValidationError(a, this.model.getTerminal(a, !0), this.model.getTerminal(a, !1)) || '')
    : d + (this.getCellValidationError(a) || '');
  e = this.validateCell(a, b);
  null != e && (d += e);
  null == this.model.getParent(a) && this.view.validate();
  return 0 < d.length || !c ? d : null;
};
mxGraph.prototype.getCellValidationError = function (a) {
  var b = this.model.getDirectedEdgeCount(a, !0),
    c = this.model.getDirectedEdgeCount(a, !1);
  a = this.model.getValue(a);
  var d = '';
  if (null != this.multiplicities)
    for (var e = 0; e < this.multiplicities.length; e++) {
      var f = this.multiplicities[e];
      f.source && mxUtils.isNode(a, f.type, f.attr, f.value) && (b > f.max || b < f.min)
        ? (d += f.countError + '\n')
        : !f.source &&
          mxUtils.isNode(a, f.type, f.attr, f.value) &&
          (c > f.max || c < f.min) &&
          (d += f.countError + '\n');
    }
  return 0 < d.length ? d : null;
};
mxGraph.prototype.validateCell = function (a, b) {
  return null;
};
mxGraph.prototype.getBackgroundImage = function () {
  return this.backgroundImage;
};
mxGraph.prototype.setBackgroundImage = function (a) {
  this.backgroundImage = a;
};
mxGraph.prototype.getFoldingImage = function (a) {
  if (null != a && this.foldingEnabled && !this.getModel().isEdge(a.cell)) {
    var b = this.isCellCollapsed(a.cell);
    if (this.isCellFoldable(a.cell, !b)) return b ? this.collapsedImage : this.expandedImage;
  }
  return null;
};
mxGraph.prototype.convertValueToString = function (a) {
  a = this.model.getValue(a);
  if (null != a) {
    if (mxUtils.isNode(a)) return a.nodeName;
    if ('function' == typeof a.toString) return a.toString();
  }
  return '';
};
mxGraph.prototype.getLabel = function (a) {
  var b = '';
  if (this.labelsVisible && null != a) {
    var c = this.getCurrentCellStyle(a);
    mxUtils.getValue(c, mxConstants.STYLE_NOLABEL, !1) || (b = this.convertValueToString(a));
  }
  return b;
};
mxGraph.prototype.isHtmlLabel = function (a) {
  return this.isHtmlLabels();
};
mxGraph.prototype.isHtmlLabels = function () {
  return this.htmlLabels;
};
mxGraph.prototype.setHtmlLabels = function (a) {
  this.htmlLabels = a;
};
mxGraph.prototype.isWrapping = function (a) {
  return 'wrap' == this.getCurrentCellStyle(a)[mxConstants.STYLE_WHITE_SPACE];
};
mxGraph.prototype.isLabelClipped = function (a) {
  return 'hidden' == this.getCurrentCellStyle(a)[mxConstants.STYLE_OVERFLOW];
};
mxGraph.prototype.getTooltip = function (a, b, c, d) {
  var e = null;
  null != a &&
    (null == a.control ||
      (b != a.control.node && b.parentNode != a.control.node) ||
      ((e = this.collapseExpandResource), (e = mxUtils.htmlEntities(mxResources.get(e) || e).replace(/\\n/g, '<br>'))),
    null == e &&
      null != a.overlays &&
      a.overlays.visit(function (a, c) {
        null != e || (b != c.node && b.parentNode != c.node) || (e = c.overlay.toString());
      }),
    null == e &&
      ((c = this.selectionCellsHandler.getHandler(a.cell)),
      null != c && 'function' == typeof c.getTooltipForNode && (e = c.getTooltipForNode(b))),
    null == e && (e = this.getTooltipForCell(a.cell)));
  return e;
};
mxGraph.prototype.getTooltipForCell = function (a) {
  return null != a && null != a.getTooltip ? a.getTooltip() : this.convertValueToString(a);
};
mxGraph.prototype.getLinkForCell = function (a) {
  return null;
};
mxGraph.prototype.getLinkTargetForCell = function (a) {
  return null;
};
mxGraph.prototype.getCursorForMouseEvent = function (a) {
  return this.getCursorForCell(a.getCell());
};
mxGraph.prototype.getCursorForCell = function (a) {
  return null;
};
mxGraph.prototype.getStartSize = function (a, b) {
  var c = new mxRectangle(),
    d = this.getCurrentCellStyle(a, b),
    e = parseInt(mxUtils.getValue(d, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
  mxUtils.getValue(d, mxConstants.STYLE_HORIZONTAL, !0) ? (c.height = e) : (c.width = e);
  return c;
};
mxGraph.prototype.getSwimlaneDirection = function (a) {
  var b = mxUtils.getValue(a, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST),
    c = 1 == mxUtils.getValue(a, mxConstants.STYLE_FLIPH, 0),
    d = 1 == mxUtils.getValue(a, mxConstants.STYLE_FLIPV, 0);
  a = mxUtils.getValue(a, mxConstants.STYLE_HORIZONTAL, !0) ? 0 : 3;
  b == mxConstants.DIRECTION_NORTH
    ? a--
    : b == mxConstants.DIRECTION_WEST
    ? (a += 2)
    : b == mxConstants.DIRECTION_SOUTH && (a += 1);
  b = mxUtils.mod(a, 2);
  c && 1 == b && (a += 2);
  d && 0 == b && (a += 2);
  return [
    mxConstants.DIRECTION_NORTH,
    mxConstants.DIRECTION_EAST,
    mxConstants.DIRECTION_SOUTH,
    mxConstants.DIRECTION_WEST,
  ][mxUtils.mod(a, 4)];
};
mxGraph.prototype.getActualStartSize = function (a, b) {
  var c = new mxRectangle();
  if (this.isSwimlane(a, b)) {
    var d = this.getCurrentCellStyle(a, b),
      e = parseInt(mxUtils.getValue(d, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE)),
      d = this.getSwimlaneDirection(d);
    d == mxConstants.DIRECTION_NORTH
      ? (c.y = e)
      : d == mxConstants.DIRECTION_WEST
      ? (c.x = e)
      : d == mxConstants.DIRECTION_SOUTH
      ? (c.height = e)
      : (c.width = e);
  }
  return c;
};
mxGraph.prototype.getImage = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_IMAGE] : null;
};
mxGraph.prototype.isTransparentState = function (a) {
  var b = !1;
  if (null != a)
    var b = mxUtils.getValue(a.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE),
      c = mxUtils.getValue(a.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE),
      b = b == mxConstants.NONE && c == mxConstants.NONE && null == this.getImage(a);
  return b;
};
mxGraph.prototype.getVerticalAlign = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE : null;
};
mxGraph.prototype.getIndicatorColor = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_COLOR] : null;
};
mxGraph.prototype.getIndicatorGradientColor = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;
};
mxGraph.prototype.getIndicatorShape = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;
};
mxGraph.prototype.getIndicatorImage = function (a) {
  return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;
};
mxGraph.prototype.getBorder = function () {
  return this.border;
};
mxGraph.prototype.setBorder = function (a) {
  this.border = a;
};
mxGraph.prototype.isSwimlane = function (a, b) {
  return null == a || this.model.getParent(a) == this.model.getRoot() || this.model.isEdge(a)
    ? !1
    : this.getCurrentCellStyle(a, b)[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
};
mxGraph.prototype.isResizeContainer = function () {
  return this.resizeContainer;
};
mxGraph.prototype.setResizeContainer = function (a) {
  this.resizeContainer = a;
};
mxGraph.prototype.isEnabled = function () {
  return this.enabled;
};
mxGraph.prototype.setEnabled = function (a) {
  this.enabled = a;
  this.fireEvent(new mxEventObject('enabledChanged', 'enabled', a));
};
mxGraph.prototype.isEscapeEnabled = function () {
  return this.escapeEnabled;
};
mxGraph.prototype.setEscapeEnabled = function (a) {
  this.escapeEnabled = a;
};
mxGraph.prototype.isInvokesStopCellEditing = function () {
  return this.invokesStopCellEditing;
};
mxGraph.prototype.setInvokesStopCellEditing = function (a) {
  this.invokesStopCellEditing = a;
};
mxGraph.prototype.isEnterStopsCellEditing = function () {
  return this.enterStopsCellEditing;
};
mxGraph.prototype.setEnterStopsCellEditing = function (a) {
  this.enterStopsCellEditing = a;
};
mxGraph.prototype.isCellLocked = function (a) {
  var b = this.model.getGeometry(a);
  return this.isCellsLocked() || (null != b && this.model.isVertex(a) && b.relative);
};
mxGraph.prototype.isCellsLocked = function () {
  return this.cellsLocked;
};
mxGraph.prototype.setCellsLocked = function (a) {
  this.cellsLocked = a;
};
mxGraph.prototype.getCloneableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellCloneable(a);
    })
  );
};
mxGraph.prototype.isCellCloneable = function (a) {
  a = this.getCurrentCellStyle(a);
  return this.isCellsCloneable() && 0 != a[mxConstants.STYLE_CLONEABLE];
};
mxGraph.prototype.isCellsCloneable = function () {
  return this.cellsCloneable;
};
mxGraph.prototype.setCellsCloneable = function (a) {
  this.cellsCloneable = a;
};
mxGraph.prototype.getExportableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.canExportCell(a);
    })
  );
};
mxGraph.prototype.canExportCell = function (a) {
  return this.exportEnabled;
};
mxGraph.prototype.getImportableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.canImportCell(a);
    })
  );
};
mxGraph.prototype.canImportCell = function (a) {
  return this.importEnabled;
};
mxGraph.prototype.isCellSelectable = function (a) {
  return this.isCellsSelectable();
};
mxGraph.prototype.isCellsSelectable = function () {
  return this.cellsSelectable;
};
mxGraph.prototype.setCellsSelectable = function (a) {
  this.cellsSelectable = a;
};
mxGraph.prototype.getDeletableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellDeletable(a);
    })
  );
};
mxGraph.prototype.isCellDeletable = function (a) {
  a = this.getCurrentCellStyle(a);
  return this.isCellsDeletable() && 0 != a[mxConstants.STYLE_DELETABLE];
};
mxGraph.prototype.isCellsDeletable = function () {
  return this.cellsDeletable;
};
mxGraph.prototype.setCellsDeletable = function (a) {
  this.cellsDeletable = a;
};
mxGraph.prototype.isLabelMovable = function (a) {
  return (
    !this.isCellLocked(a) &&
    ((this.model.isEdge(a) && this.edgeLabelsMovable) || (this.model.isVertex(a) && this.vertexLabelsMovable))
  );
};
mxGraph.prototype.getRotatableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellRotatable(a);
    })
  );
};
mxGraph.prototype.isCellRotatable = function (a) {
  return 0 != this.getCurrentCellStyle(a)[mxConstants.STYLE_ROTATABLE];
};
mxGraph.prototype.getMovableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellMovable(a);
    })
  );
};
mxGraph.prototype.isCellMovable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return this.isCellsMovable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_MOVABLE];
};
mxGraph.prototype.isCellsMovable = function () {
  return this.cellsMovable;
};
mxGraph.prototype.setCellsMovable = function (a) {
  this.cellsMovable = a;
};
mxGraph.prototype.isGridEnabled = function () {
  return this.gridEnabled;
};
mxGraph.prototype.setGridEnabled = function (a) {
  this.gridEnabled = a;
};
mxGraph.prototype.isPortsEnabled = function () {
  return this.portsEnabled;
};
mxGraph.prototype.setPortsEnabled = function (a) {
  this.portsEnabled = a;
};
mxGraph.prototype.getGridSize = function () {
  return this.gridSize;
};
mxGraph.prototype.setGridSize = function (a) {
  this.gridSize = a;
};
mxGraph.prototype.getTolerance = function () {
  return this.tolerance;
};
mxGraph.prototype.setTolerance = function (a) {
  this.tolerance = a;
};
mxGraph.prototype.isVertexLabelsMovable = function () {
  return this.vertexLabelsMovable;
};
mxGraph.prototype.setVertexLabelsMovable = function (a) {
  this.vertexLabelsMovable = a;
};
mxGraph.prototype.isEdgeLabelsMovable = function () {
  return this.edgeLabelsMovable;
};
mxGraph.prototype.setEdgeLabelsMovable = function (a) {
  this.edgeLabelsMovable = a;
};
mxGraph.prototype.isSwimlaneNesting = function () {
  return this.swimlaneNesting;
};
mxGraph.prototype.setSwimlaneNesting = function (a) {
  this.swimlaneNesting = a;
};
mxGraph.prototype.isSwimlaneSelectionEnabled = function () {
  return this.swimlaneSelectionEnabled;
};
mxGraph.prototype.setSwimlaneSelectionEnabled = function (a) {
  this.swimlaneSelectionEnabled = a;
};
mxGraph.prototype.isMultigraph = function () {
  return this.multigraph;
};
mxGraph.prototype.setMultigraph = function (a) {
  this.multigraph = a;
};
mxGraph.prototype.isAllowLoops = function () {
  return this.allowLoops;
};
mxGraph.prototype.setAllowDanglingEdges = function (a) {
  this.allowDanglingEdges = a;
};
mxGraph.prototype.isAllowDanglingEdges = function () {
  return this.allowDanglingEdges;
};
mxGraph.prototype.setConnectableEdges = function (a) {
  this.connectableEdges = a;
};
mxGraph.prototype.isConnectableEdges = function () {
  return this.connectableEdges;
};
mxGraph.prototype.setCloneInvalidEdges = function (a) {
  this.cloneInvalidEdges = a;
};
mxGraph.prototype.isCloneInvalidEdges = function () {
  return this.cloneInvalidEdges;
};
mxGraph.prototype.setAllowLoops = function (a) {
  this.allowLoops = a;
};
mxGraph.prototype.isDisconnectOnMove = function () {
  return this.disconnectOnMove;
};
mxGraph.prototype.setDisconnectOnMove = function (a) {
  this.disconnectOnMove = a;
};
mxGraph.prototype.isDropEnabled = function () {
  return this.dropEnabled;
};
mxGraph.prototype.setDropEnabled = function (a) {
  this.dropEnabled = a;
};
mxGraph.prototype.isSplitEnabled = function () {
  return this.splitEnabled;
};
mxGraph.prototype.setSplitEnabled = function (a) {
  this.splitEnabled = a;
};
mxGraph.prototype.getResizableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellResizable(a);
    })
  );
};
mxGraph.prototype.isCellResizable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return (
    this.isCellsResizable() && !this.isCellLocked(a) && '0' != mxUtils.getValue(b, mxConstants.STYLE_RESIZABLE, '1')
  );
};
mxGraph.prototype.isCellsResizable = function () {
  return this.cellsResizable;
};
mxGraph.prototype.setCellsResizable = function (a) {
  this.cellsResizable = a;
};
mxGraph.prototype.isTerminalPointMovable = function (a, b) {
  return !0;
};
mxGraph.prototype.isCellBendable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return this.isCellsBendable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_BENDABLE];
};
mxGraph.prototype.isCellsBendable = function () {
  return this.cellsBendable;
};
mxGraph.prototype.setCellsBendable = function (a) {
  this.cellsBendable = a;
};
mxGraph.prototype.getEditableCells = function (a) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellEditable(a);
    })
  );
};
mxGraph.prototype.isCellEditable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return this.isCellsEditable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_EDITABLE];
};
mxGraph.prototype.isCellsEditable = function () {
  return this.cellsEditable;
};
mxGraph.prototype.setCellsEditable = function (a) {
  this.cellsEditable = a;
};
mxGraph.prototype.isCellDisconnectable = function (a, b, c) {
  return this.isCellsDisconnectable() && !this.isCellLocked(a);
};
mxGraph.prototype.isCellsDisconnectable = function () {
  return this.cellsDisconnectable;
};
mxGraph.prototype.setCellsDisconnectable = function (a) {
  this.cellsDisconnectable = a;
};
mxGraph.prototype.isValidSource = function (a) {
  return (
    (null == a && this.allowDanglingEdges) ||
    (null != a && (!this.model.isEdge(a) || this.connectableEdges) && this.isCellConnectable(a))
  );
};
mxGraph.prototype.isValidTarget = function (a) {
  return this.isValidSource(a);
};
mxGraph.prototype.isValidConnection = function (a, b) {
  return this.isValidSource(a) && this.isValidTarget(b);
};
mxGraph.prototype.setConnectable = function (a) {
  this.connectionHandler.setEnabled(a);
};
mxGraph.prototype.isConnectable = function () {
  return this.connectionHandler.isEnabled();
};
mxGraph.prototype.setTooltips = function (a) {
  this.tooltipHandler.setEnabled(a);
};
mxGraph.prototype.setPanning = function (a) {
  this.panningHandler.panningEnabled = a;
};
mxGraph.prototype.isEditing = function (a) {
  if (null != this.cellEditor) {
    var b = this.cellEditor.getEditingCell();
    return null == a ? null != b : a == b;
  }
  return !1;
};
mxGraph.prototype.isAutoSizeCell = function (a) {
  a = this.getCurrentCellStyle(a);
  return this.isAutoSizeCells() || 1 == a[mxConstants.STYLE_AUTOSIZE];
};
mxGraph.prototype.isAutoSizeCells = function () {
  return this.autoSizeCells;
};
mxGraph.prototype.setAutoSizeCells = function (a) {
  this.autoSizeCells = a;
};
mxGraph.prototype.isExtendParent = function (a) {
  return !this.getModel().isEdge(a) && this.isExtendParents();
};
mxGraph.prototype.isExtendParents = function () {
  return this.extendParents;
};
mxGraph.prototype.setExtendParents = function (a) {
  this.extendParents = a;
};
mxGraph.prototype.isExtendParentsOnAdd = function (a) {
  return this.extendParentsOnAdd;
};
mxGraph.prototype.setExtendParentsOnAdd = function (a) {
  this.extendParentsOnAdd = a;
};
mxGraph.prototype.isExtendParentsOnMove = function () {
  return this.extendParentsOnMove;
};
mxGraph.prototype.setExtendParentsOnMove = function (a) {
  this.extendParentsOnMove = a;
};
mxGraph.prototype.isRecursiveResize = function (a) {
  return this.recursiveResize;
};
mxGraph.prototype.setRecursiveResize = function (a) {
  this.recursiveResize = a;
};
mxGraph.prototype.isConstrainChild = function (a) {
  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(a));
};
mxGraph.prototype.isConstrainChildren = function () {
  return this.constrainChildren;
};
mxGraph.prototype.setConstrainChildren = function (a) {
  this.constrainChildren = a;
};
mxGraph.prototype.isConstrainRelativeChildren = function () {
  return this.constrainRelativeChildren;
};
mxGraph.prototype.setConstrainRelativeChildren = function (a) {
  this.constrainRelativeChildren = a;
};
mxGraph.prototype.isAllowNegativeCoordinates = function () {
  return this.allowNegativeCoordinates;
};
mxGraph.prototype.setAllowNegativeCoordinates = function (a) {
  this.allowNegativeCoordinates = a;
};
mxGraph.prototype.getOverlap = function (a) {
  return this.isAllowOverlapParent(a) ? this.defaultOverlap : 0;
};
mxGraph.prototype.isAllowOverlapParent = function (a) {
  return !1;
};
mxGraph.prototype.getFoldableCells = function (a, b) {
  return this.model.filterCells(
    a,
    mxUtils.bind(this, function (a) {
      return this.isCellFoldable(a, b);
    })
  );
};
mxGraph.prototype.isCellFoldable = function (a, b) {
  var c = this.getCurrentCellStyle(a);
  return 0 < this.model.getChildCount(a) && 0 != c[mxConstants.STYLE_FOLDABLE];
};
mxGraph.prototype.isValidDropTarget = function (a, b, c) {
  return (
    null != a &&
    ((this.isSplitEnabled() && this.isSplitTarget(a, b, c)) ||
      (!this.model.isEdge(a) && (this.isSwimlane(a) || (0 < this.model.getChildCount(a) && !this.isCellCollapsed(a)))))
  );
};
mxGraph.prototype.isSplitTarget = function (a, b, c) {
  return this.model.isEdge(a) &&
    null != b &&
    1 == b.length &&
    this.isCellConnectable(b[0]) &&
    null == this.getEdgeValidationError(a, this.model.getTerminal(a, !0), b[0])
    ? ((c = this.model.getTerminal(a, !0)),
      (a = this.model.getTerminal(a, !1)),
      !this.model.isAncestor(b[0], c) && !this.model.isAncestor(b[0], a))
    : !1;
};
mxGraph.prototype.getDropTarget = function (a, b, c, d) {
  if (!this.isSwimlaneNesting()) for (var e = 0; e < a.length; e++) if (this.isSwimlane(a[e])) return null;
  e = mxUtils.convertPoint(this.container, mxEvent.getClientX(b), mxEvent.getClientY(b));
  e.x -= this.panDx;
  e.y -= this.panDy;
  e = this.getSwimlaneAt(e.x, e.y);
  if (null == c) c = e;
  else if (null != e) {
    for (var f = this.model.getParent(e); null != f && this.isSwimlane(f) && f != c; ) f = this.model.getParent(f);
    f == c && (c = e);
  }
  for (; null != c && !this.isValidDropTarget(c, a, b) && !this.model.isLayer(c); ) c = this.model.getParent(c);
  if (null == d || !d) for (var g = c; null != g && 0 > mxUtils.indexOf(a, g); ) g = this.model.getParent(g);
  return this.model.isLayer(c) || null != g ? null : c;
};
mxGraph.prototype.getDefaultParent = function () {
  var a = this.getCurrentRoot();
  null == a && ((a = this.defaultParent), null == a && ((a = this.model.getRoot()), (a = this.model.getChildAt(a, 0))));
  return a;
};
mxGraph.prototype.setDefaultParent = function (a) {
  this.defaultParent = a;
};
mxGraph.prototype.getSwimlane = function (a) {
  for (; null != a && !this.isSwimlane(a); ) a = this.model.getParent(a);
  return a;
};
mxGraph.prototype.getSwimlaneAt = function (a, b, c) {
  null == c && ((c = this.getCurrentRoot()), null == c && (c = this.model.getRoot()));
  if (null != c)
    for (var d = this.model.getChildCount(c), e = 0; e < d; e++) {
      var f = this.model.getChildAt(c, e);
      if (null != f) {
        var g = this.getSwimlaneAt(a, b, f);
        if (null != g) return g;
        if (this.isCellVisible(f) && this.isSwimlane(f) && ((g = this.view.getState(f)), this.intersects(g, a, b)))
          return f;
      }
    }
  return null;
};
mxGraph.prototype.getCellAt = function (a, b, c, d, e, f) {
  d = null != d ? d : !0;
  e = null != e ? e : !0;
  null == c && ((c = this.getCurrentRoot()), null == c && (c = this.getModel().getRoot()));
  if (null != c)
    for (var g = this.model.getChildCount(c) - 1; 0 <= g; g--) {
      var k = this.model.getChildAt(c, g),
        h = this.getCellAt(a, b, k, d, e, f);
      if (null != h) return h;
      if (
        this.isCellVisible(k) &&
        ((e && this.model.isEdge(k)) || (d && this.model.isVertex(k))) &&
        ((h = this.view.getState(k)), null != h && (null == f || !f(h, a, b)) && this.intersects(h, a, b))
      )
        return k;
    }
  return null;
};
mxGraph.prototype.intersects = function (a, b, c) {
  if (null != a) {
    var d = a.absolutePoints;
    if (null != d) {
      a = this.tolerance * this.tolerance;
      for (var e = d[0], f = 1; f < d.length; f++) {
        var g = d[f];
        if (mxUtils.ptSegDistSq(e.x, e.y, g.x, g.y, b, c) <= a) return !0;
        e = g;
      }
    } else if (
      ((e = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0)),
      0 != e &&
        ((d = Math.cos(-e)),
        (e = Math.sin(-e)),
        (f = new mxPoint(a.getCenterX(), a.getCenterY())),
        (e = mxUtils.getRotatedPoint(new mxPoint(b, c), d, e, f)),
        (b = e.x),
        (c = e.y)),
      mxUtils.contains(a, b, c))
    )
      return !0;
  }
  return !1;
};
mxGraph.prototype.hitsSwimlaneContent = function (a, b, c) {
  var d = this.getView().getState(a);
  a = this.getStartSize(a);
  if (null != d) {
    var e = this.getView().getScale();
    b -= d.x;
    c -= d.y;
    if ((0 < a.width && 0 < b && b > a.width * e) || (0 < a.height && 0 < c && c > a.height * e)) return !0;
  }
  return !1;
};
mxGraph.prototype.getChildVertices = function (a) {
  return this.getChildCells(a, !0, !1);
};
mxGraph.prototype.getChildEdges = function (a) {
  return this.getChildCells(a, !1, !0);
};
mxGraph.prototype.getChildCells = function (a, b, c) {
  a = null != a ? a : this.getDefaultParent();
  a = this.model.getChildCells(a, null != b ? b : !1, null != c ? c : !1);
  b = [];
  for (c = 0; c < a.length; c++) this.isCellVisible(a[c]) && b.push(a[c]);
  return b;
};
mxGraph.prototype.getConnections = function (a, b) {
  return this.getEdges(a, b, !0, !0, !1);
};
mxGraph.prototype.getIncomingEdges = function (a, b) {
  return this.getEdges(a, b, !0, !1, !1);
};
mxGraph.prototype.getOutgoingEdges = function (a, b) {
  return this.getEdges(a, b, !1, !0, !1);
};
mxGraph.prototype.getEdges = function (a, b, c, d, e, f) {
  c = null != c ? c : !0;
  d = null != d ? d : !0;
  e = null != e ? e : !0;
  f = null != f ? f : !1;
  for (var g = [], k = this.isCellCollapsed(a), h = this.model.getChildCount(a), l = 0; l < h; l++) {
    var m = this.model.getChildAt(a, l);
    if (k || !this.isCellVisible(m)) g = g.concat(this.model.getEdges(m, c, d));
  }
  g = g.concat(this.model.getEdges(a, c, d));
  k = [];
  for (l = 0; l < g.length; l++)
    (m = this.view.getState(g[l])),
      (h = null != m ? m.getVisibleTerminal(!0) : this.view.getVisibleTerminal(g[l], !0)),
      (m = null != m ? m.getVisibleTerminal(!1) : this.view.getVisibleTerminal(g[l], !1)),
      ((e && h == m) ||
        (h != m &&
          ((c && m == a && (null == b || this.isValidAncestor(h, b, f))) ||
            (d && h == a && (null == b || this.isValidAncestor(m, b, f)))))) &&
        k.push(g[l]);
  return k;
};
mxGraph.prototype.isValidAncestor = function (a, b, c) {
  return c ? this.model.isAncestor(b, a) : this.model.getParent(a) == b;
};
mxGraph.prototype.getOpposites = function (a, b, c, d) {
  c = null != c ? c : !0;
  d = null != d ? d : !0;
  var e = [],
    f = new mxDictionary();
  if (null != a)
    for (var g = 0; g < a.length; g++) {
      var k = this.view.getState(a[g]),
        h = null != k ? k.getVisibleTerminal(!0) : this.view.getVisibleTerminal(a[g], !0),
        k = null != k ? k.getVisibleTerminal(!1) : this.view.getVisibleTerminal(a[g], !1);
      h == b && null != k && k != b && d
        ? f.get(k) || (f.put(k, !0), e.push(k))
        : k == b && null != h && h != b && c && !f.get(h) && (f.put(h, !0), e.push(h));
    }
  return e;
};
mxGraph.prototype.getEdgesBetween = function (a, b, c) {
  c = null != c ? c : !1;
  for (var d = this.getEdges(a), e = [], f = 0; f < d.length; f++) {
    var g = this.view.getState(d[f]),
      k = null != g ? g.getVisibleTerminal(!0) : this.view.getVisibleTerminal(d[f], !0),
      g = null != g ? g.getVisibleTerminal(!1) : this.view.getVisibleTerminal(d[f], !1);
    ((k == a && g == b) || (!c && k == b && g == a)) && e.push(d[f]);
  }
  return e;
};
mxGraph.prototype.getPointForEvent = function (a, b) {
  var c = mxUtils.convertPoint(this.container, mxEvent.getClientX(a), mxEvent.getClientY(a)),
    d = this.view.scale,
    e = this.view.translate,
    f = 0 != b ? this.gridSize / 2 : 0;
  c.x = this.snap(c.x / d - e.x - f);
  c.y = this.snap(c.y / d - e.y - f);
  return c;
};
mxGraph.prototype.getCells = function (a, b, c, d, e, f, g, k, h) {
  f = null != f ? f : [];
  if (0 < c || 0 < d || null != g) {
    var l = this.getModel(),
      m = a + c,
      n = b + d;
    null == e && ((e = this.getCurrentRoot()), null == e && (e = l.getRoot()));
    if (null != e)
      for (var p = l.getChildCount(e), r = 0; r < p; r++) {
        var t = l.getChildAt(e, r),
          u = this.view.getState(t);
        if (null != u && this.isCellVisible(t) && (null == k || !k(u))) {
          var x = mxUtils.getValue(u.style, mxConstants.STYLE_ROTATION) || 0;
          0 != x && (u = mxUtils.getBoundingBox(u, x));
          (x =
            (null != g && l.isVertex(t) && mxUtils.intersects(g, u)) ||
            (null != g && l.isEdge(t) && mxUtils.intersects(g, u)) ||
            (null == g &&
              (l.isEdge(t) || l.isVertex(t)) &&
              u.x >= a &&
              u.y + u.height <= n &&
              u.y >= b &&
              u.x + u.width <= m)) && f.push(t);
          (x && !h) || this.getCells(a, b, c, d, t, f, g, k, h);
        }
      }
  }
  return f;
};
mxGraph.prototype.getCellsBeyond = function (a, b, c, d, e) {
  var f = [];
  if (d || e)
    if ((null == c && (c = this.getDefaultParent()), null != c))
      for (var g = this.model.getChildCount(c), k = 0; k < g; k++) {
        var h = this.model.getChildAt(c, k),
          l = this.view.getState(h);
        this.isCellVisible(h) && null != l && (!d || l.x >= a) && (!e || l.y >= b) && f.push(h);
      }
  return f;
};
mxGraph.prototype.findTreeRoots = function (a, b, c) {
  b = null != b ? b : !1;
  c = null != c ? c : !1;
  var d = [];
  if (null != a) {
    for (var e = this.getModel(), f = e.getChildCount(a), g = null, k = 0, h = 0; h < f; h++) {
      var l = e.getChildAt(a, h);
      if (this.model.isVertex(l) && this.isCellVisible(l)) {
        for (var m = this.getConnections(l, b ? a : null), n = 0, p = 0, r = 0; r < m.length; r++)
          this.view.getVisibleTerminal(m[r], !0) == l ? n++ : p++;
        ((c && 0 == n && 0 < p) || (!c && 0 == p && 0 < n)) && d.push(l);
        m = c ? p - n : n - p;
        m > k && ((k = m), (g = l));
      }
    }
    0 == d.length && null != g && d.push(g);
  }
  return d;
};
mxGraph.prototype.traverse = function (a, b, c, d, e, f) {
  if (
    null != c &&
    null != a &&
    ((b = null != b ? b : !0), (f = null != f ? f : !1), (e = e || new mxDictionary()), null == d || !e.get(d)) &&
    (e.put(d, !0), (d = c(a, d)), null == d || d) &&
    ((d = this.model.getEdgeCount(a)), 0 < d)
  )
    for (var g = 0; g < d; g++) {
      var k = this.model.getEdgeAt(a, g),
        h = this.model.getTerminal(k, !0) == a;
      (b && !f != h) || ((h = this.model.getTerminal(k, !h)), this.traverse(h, b, c, k, e, f));
    }
};
mxGraph.prototype.isCellSelected = function (a) {
  return this.getSelectionModel().isSelected(a);
};
mxGraph.prototype.isSelectionEmpty = function () {
  return this.getSelectionModel().isEmpty();
};
mxGraph.prototype.clearSelection = function () {
  return this.getSelectionModel().clear();
};
mxGraph.prototype.getSelectionCount = function () {
  return this.getSelectionModel().cells.length;
};
mxGraph.prototype.getSelectionCell = function () {
  return this.getSelectionModel().cells[0];
};
mxGraph.prototype.getSelectionCells = function () {
  return this.getSelectionModel().cells.slice();
};
mxGraph.prototype.setSelectionCell = function (a) {
  this.getSelectionModel().setCell(a);
};
mxGraph.prototype.setSelectionCells = function (a) {
  this.getSelectionModel().setCells(a);
};
mxGraph.prototype.addSelectionCell = function (a) {
  this.getSelectionModel().addCell(a);
};
mxGraph.prototype.addSelectionCells = function (a) {
  this.getSelectionModel().addCells(a);
};
mxGraph.prototype.removeSelectionCell = function (a) {
  this.getSelectionModel().removeCell(a);
};
mxGraph.prototype.removeSelectionCells = function (a) {
  this.getSelectionModel().removeCells(a);
};
mxGraph.prototype.selectRegion = function (a, b) {
  var c = this.getCells(a.x, a.y, a.width, a.height);
  this.selectCellsForEvent(c, b);
  return c;
};
mxGraph.prototype.selectNextCell = function () {
  this.selectCell(!0);
};
mxGraph.prototype.selectPreviousCell = function () {
  this.selectCell();
};
mxGraph.prototype.selectParentCell = function () {
  this.selectCell(!1, !0);
};
mxGraph.prototype.selectChildCell = function () {
  this.selectCell(!1, !1, !0);
};
mxGraph.prototype.selectCell = function (a, b, c) {
  var d = this.selectionModel,
    e = 0 < d.cells.length ? d.cells[0] : null;
  1 < d.cells.length && d.clear();
  var d = null != e ? this.model.getParent(e) : this.getDefaultParent(),
    f = this.model.getChildCount(d);
  null == e && 0 < f
    ? ((a = this.model.getChildAt(d, 0)), this.setSelectionCell(a))
    : (null != e && !b) || null == this.view.getState(d) || null == this.model.getGeometry(d)
    ? null != e && c
      ? 0 < this.model.getChildCount(e) && ((a = this.model.getChildAt(e, 0)), this.setSelectionCell(a))
      : 0 < f &&
        ((b = d.getIndex(e)),
        a ? (b++, (a = this.model.getChildAt(d, b % f))) : (b--, (a = this.model.getChildAt(d, 0 > b ? f - 1 : b))),
        this.setSelectionCell(a))
    : this.getCurrentRoot() != d && this.setSelectionCell(d);
};
mxGraph.prototype.selectAll = function (a, b) {
  a = a || this.getDefaultParent();
  var c = b
    ? this.model.filterDescendants(
        mxUtils.bind(this, function (b) {
          return b != a && null != this.view.getState(b);
        }),
        a
      )
    : this.model.getChildren(a);
  null != c && this.setSelectionCells(c);
};
mxGraph.prototype.selectVertices = function (a, b) {
  this.selectCells(!0, !1, a, b);
};
mxGraph.prototype.selectEdges = function (a) {
  this.selectCells(!1, !0, a);
};
mxGraph.prototype.selectCells = function (a, b, c, d) {
  c = c || this.getDefaultParent();
  var e = mxUtils.bind(this, function (c) {
    return (
      null != this.view.getState(c) &&
      (((d || 0 == this.model.getChildCount(c)) &&
        this.model.isVertex(c) &&
        a &&
        !this.model.isEdge(this.model.getParent(c))) ||
        (this.model.isEdge(c) && b))
    );
  });
  c = this.model.filterDescendants(e, c);
  null != c && this.setSelectionCells(c);
};
mxGraph.prototype.selectCellForEvent = function (a, b) {
  var c = this.isCellSelected(a);
  this.isToggleEvent(b)
    ? c
      ? this.removeSelectionCell(a)
      : this.addSelectionCell(a)
    : (c && 1 == this.getSelectionCount()) || this.setSelectionCell(a);
};
mxGraph.prototype.selectCellsForEvent = function (a, b) {
  this.isToggleEvent(b) ? this.addSelectionCells(a) : this.setSelectionCells(a);
};
mxGraph.prototype.createHandler = function (a) {
  var b = null;
  if (null != a)
    if (this.model.isEdge(a.cell))
      var b = a.getVisibleTerminalState(!0),
        c = a.getVisibleTerminalState(!1),
        d = this.getCellGeometry(a.cell),
        b = this.view.getEdgeStyle(a, null != d ? d.points : null, b, c),
        b = this.createEdgeHandler(a, b);
    else b = this.createVertexHandler(a);
  return b;
};
mxGraph.prototype.createVertexHandler = function (a) {
  return new mxVertexHandler(a);
};
mxGraph.prototype.createEdgeHandler = function (a, b) {
  return b == mxEdgeStyle.Loop ||
    b == mxEdgeStyle.ElbowConnector ||
    b == mxEdgeStyle.SideToSide ||
    b == mxEdgeStyle.TopToBottom
    ? this.createElbowEdgeHandler(a)
    : b == mxEdgeStyle.SegmentConnector || b == mxEdgeStyle.OrthConnector
    ? this.createEdgeSegmentHandler(a)
    : new mxEdgeHandler(a);
};
mxGraph.prototype.createEdgeSegmentHandler = function (a) {
  return new mxEdgeSegmentHandler(a);
};
mxGraph.prototype.createElbowEdgeHandler = function (a) {
  return new mxElbowEdgeHandler(a);
};
mxGraph.prototype.addMouseListener = function (a) {
  null == this.mouseListeners && (this.mouseListeners = []);
  this.mouseListeners.push(a);
};
mxGraph.prototype.removeMouseListener = function (a) {
  if (null != this.mouseListeners)
    for (var b = 0; b < this.mouseListeners.length; b++)
      if (this.mouseListeners[b] == a) {
        this.mouseListeners.splice(b, 1);
        break;
      }
};
mxGraph.prototype.updateMouseEvent = function (a, b) {
  if (null == a.graphX || null == a.graphY) {
    var c = mxUtils.convertPoint(this.container, a.getX(), a.getY());
    a.graphX = c.x - this.panDx;
    a.graphY = c.y - this.panDy;
    null == a.getCell() &&
      this.isMouseDown &&
      b == mxEvent.MOUSE_MOVE &&
      (a.state = this.view.getState(
        this.getCellAt(c.x, c.y, null, null, null, function (a) {
          return (
            null == a.shape ||
            a.shape.paintBackground != mxRectangleShape.prototype.paintBackground ||
            '1' == mxUtils.getValue(a.style, mxConstants.STYLE_POINTER_EVENTS, '1') ||
            (null != a.shape.fill && a.shape.fill != mxConstants.NONE)
          );
        })
      ));
  }
  return a;
};
mxGraph.prototype.getStateForTouchEvent = function (a) {
  var b = mxEvent.getClientX(a);
  a = mxEvent.getClientY(a);
  b = mxUtils.convertPoint(this.container, b, a);
  return this.view.getState(this.getCellAt(b.x, b.y));
};
mxGraph.prototype.isEventIgnored = function (a, b, c) {
  var d = mxEvent.isMouseEvent(b.getEvent()),
    e = !1;
  b.getEvent() == this.lastEvent ? (e = !0) : (this.lastEvent = b.getEvent());
  if (null != this.eventSource && a != mxEvent.MOUSE_MOVE)
    mxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect),
      (this.eventSource = this.mouseUpRedirect = this.mouseMoveRedirect = null);
  else if (!mxClient.IS_GC && null != this.eventSource && b.getSource() != this.eventSource) e = !0;
  else if (mxClient.IS_TOUCH && a == mxEvent.MOUSE_DOWN && !d && !mxEvent.isPenEvent(b.getEvent())) {
    this.eventSource = b.getSource();
    var f = null;
    (!mxClient.IS_ANDROID && mxClient.IS_LINUX && mxClient.IS_GC) || (f = b.getEvent().pointerId);
    this.mouseMoveRedirect = mxUtils.bind(this, function (a) {
      (null != f && a.pointerId != f) ||
        this.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a, this.getStateForTouchEvent(a)));
    });
    this.mouseUpRedirect = mxUtils.bind(this, function (a) {
      this.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a, this.getStateForTouchEvent(a)));
      f = null;
    });
    mxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
  }
  this.isSyntheticEventIgnored(a, b, c) && (e = !0);
  if (!mxEvent.isPopupTrigger(this.lastEvent) && a != mxEvent.MOUSE_MOVE && 2 == this.lastEvent.detail) return !0;
  a == mxEvent.MOUSE_UP && this.isMouseDown
    ? (this.isMouseDown = !1)
    : a != mxEvent.MOUSE_DOWN || this.isMouseDown
    ? !e &&
      (((!mxClient.IS_FF || a != mxEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != d) ||
        (a == mxEvent.MOUSE_DOWN && this.isMouseDown) ||
        (a == mxEvent.MOUSE_UP && !this.isMouseDown)) &&
      (e = !0)
    : ((this.isMouseDown = !0), (this.isMouseTrigger = d));
  e || a != mxEvent.MOUSE_DOWN || ((this.lastMouseX = b.getX()), (this.lastMouseY = b.getY()));
  return e;
};
mxGraph.prototype.isSyntheticEventIgnored = function (a, b, c) {
  c = !1;
  b = mxEvent.isMouseEvent(b.getEvent());
  this.ignoreMouseEvents && b && a != mxEvent.MOUSE_MOVE
    ? ((this.ignoreMouseEvents = a != mxEvent.MOUSE_UP), (c = !0))
    : mxClient.IS_FF && !b && a == mxEvent.MOUSE_UP && (this.ignoreMouseEvents = !0);
  return c;
};
mxGraph.prototype.isEventSourceIgnored = function (a, b) {
  var c = b.getSource(),
    d = null != c.nodeName ? c.nodeName.toLowerCase() : '',
    e = !mxEvent.isMouseEvent(b.getEvent()) || mxEvent.isLeftMouseButton(b.getEvent());
  return (
    a == mxEvent.MOUSE_DOWN &&
    e &&
    ('select' == d ||
      'option' == d ||
      ('input' == d &&
        'checkbox' != c.type &&
        'radio' != c.type &&
        'button' != c.type &&
        'submit' != c.type &&
        'file' != c.type))
  );
};
mxGraph.prototype.getEventState = function (a) {
  return a;
};
mxGraph.prototype.isPointerEventIgnored = function (a, b) {
  var c = !1;
  if (mxClient.IS_ANDROID || !mxClient.IS_LINUX || !mxClient.IS_GC) {
    var d = b.getEvent().pointerId;
    a == mxEvent.MOUSE_DOWN
      ? null != this.currentPointerId && this.currentPointerId != d
        ? (c = !0)
        : null == this.currentPointerId && (this.currentPointerId = b.getEvent().pointerId)
      : a == mxEvent.MOUSE_MOVE
      ? null != this.currentPointerId && this.currentPointerId != d && (c = !0)
      : a == mxEvent.MOUSE_UP && (this.currentPointerId = null);
  }
  return c;
};
mxGraph.prototype.fireMouseEvent = function (a, b, c) {
  if (this.isEventSourceIgnored(a, b)) null != this.tooltipHandler && this.tooltipHandler.hide();
  else if (this.isPointerEventIgnored(a, b)) this.tapAndHoldValid = !1;
  else {
    null == c && (c = this);
    b = this.updateMouseEvent(b, a);
    if (
      (!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(b.getEvent())) ||
      (this.doubleTapEnabled &&
        mxClient.IS_TOUCH &&
        (mxEvent.isTouchEvent(b.getEvent()) || mxEvent.isPenEvent(b.getEvent())))
    ) {
      var d = new Date().getTime();
      if (a == mxEvent.MOUSE_DOWN)
        if (
          null != this.lastTouchEvent &&
          this.lastTouchEvent != b.getEvent() &&
          d - this.lastTouchTime < this.doubleTapTimeout &&
          Math.abs(this.lastTouchX - b.getX()) < this.doubleTapTolerance &&
          Math.abs(this.lastTouchY - b.getY()) < this.doubleTapTolerance &&
          2 > this.doubleClickCounter
        ) {
          if (
            (this.doubleClickCounter++,
            (d = !1),
            a == mxEvent.MOUSE_UP
              ? b.getCell() == this.lastTouchCell &&
                null != this.lastTouchCell &&
                ((this.lastTouchTime = 0),
                (d = this.lastTouchCell),
                (this.lastTouchCell = null),
                this.dblClick(b.getEvent(), d),
                (d = !0))
              : ((this.fireDoubleClick = !0), (this.lastTouchTime = 0)),
            d)
          ) {
            mxEvent.consume(b.getEvent());
            return;
          }
        } else {
          if (null == this.lastTouchEvent || this.lastTouchEvent != b.getEvent())
            (this.lastTouchCell = b.getCell()),
              (this.lastTouchX = b.getX()),
              (this.lastTouchY = b.getY()),
              (this.lastTouchTime = d),
              (this.lastTouchEvent = b.getEvent()),
              (this.doubleClickCounter = 0);
        }
      else if ((this.isMouseDown || a == mxEvent.MOUSE_UP) && this.fireDoubleClick) {
        this.fireDoubleClick = !1;
        d = this.lastTouchCell;
        this.lastTouchCell = null;
        this.isMouseDown = !1;
        (null != d ||
          ((mxEvent.isTouchEvent(b.getEvent()) || mxEvent.isPenEvent(b.getEvent())) &&
            (mxClient.IS_GC || mxClient.IS_SF))) &&
        Math.abs(this.lastTouchX - b.getX()) < this.doubleTapTolerance &&
        Math.abs(this.lastTouchY - b.getY()) < this.doubleTapTolerance
          ? this.dblClick(b.getEvent(), d)
          : mxEvent.consume(b.getEvent());
        return;
      }
    }
    if (!this.isEventIgnored(a, b, c)) {
      b.state = this.getEventState(b.getState());
      this.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, 'eventName', a, 'event', b));
      if (
        mxClient.IS_OP ||
        mxClient.IS_SF ||
        mxClient.IS_GC ||
        mxClient.IS_IE11 ||
        (mxClient.IS_IE && mxClient.IS_SVG) ||
        b.getEvent().target != this.container
      ) {
        if (a == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(b.getEvent))
          this.scrollPointToVisible(b.getGraphX(), b.getGraphY(), this.autoExtend);
        else if (
          a == mxEvent.MOUSE_UP &&
          this.ignoreScrollbars &&
          this.translateToScrollPosition &&
          (0 != this.container.scrollLeft || 0 != this.container.scrollTop)
        ) {
          var d = this.view.scale,
            e = this.view.translate;
          this.view.setTranslate(e.x - this.container.scrollLeft / d, e.y - this.container.scrollTop / d);
          this.container.scrollLeft = 0;
          this.container.scrollTop = 0;
        }
        if (null != this.mouseListeners)
          for (
            d = [c, b], b.getEvent().preventDefault || (b.getEvent().returnValue = !0), e = 0;
            e < this.mouseListeners.length;
            e++
          ) {
            var f = this.mouseListeners[e];
            a == mxEvent.MOUSE_DOWN
              ? f.mouseDown.apply(f, d)
              : a == mxEvent.MOUSE_MOVE
              ? f.mouseMove.apply(f, d)
              : a == mxEvent.MOUSE_UP && f.mouseUp.apply(f, d);
          }
        a == mxEvent.MOUSE_UP && this.click(b);
      }
      (mxEvent.isTouchEvent(b.getEvent()) || mxEvent.isPenEvent(b.getEvent())) &&
      a == mxEvent.MOUSE_DOWN &&
      this.tapAndHoldEnabled &&
      !this.tapAndHoldInProgress
        ? ((this.tapAndHoldInProgress = !0),
          (this.initialTouchX = b.getGraphX()),
          (this.initialTouchY = b.getGraphY()),
          this.tapAndHoldThread && window.clearTimeout(this.tapAndHoldThread),
          (this.tapAndHoldThread = window.setTimeout(
            mxUtils.bind(this, function () {
              this.tapAndHoldValid && this.tapAndHold(b);
              this.tapAndHoldValid = this.tapAndHoldInProgress = !1;
            }),
            this.tapAndHoldDelay
          )),
          (this.tapAndHoldValid = !0))
        : a == mxEvent.MOUSE_UP
        ? (this.tapAndHoldValid = this.tapAndHoldInProgress = !1)
        : this.tapAndHoldValid &&
          (this.tapAndHoldValid =
            Math.abs(this.initialTouchX - b.getGraphX()) < this.tolerance &&
            Math.abs(this.initialTouchY - b.getGraphY()) < this.tolerance);
      a == mxEvent.MOUSE_DOWN &&
        this.isEditing() &&
        !this.cellEditor.isEventSource(b.getEvent()) &&
        this.stopEditing(!this.isInvokesStopCellEditing());
      this.consumeMouseEvent(a, b, c);
    }
  }
};
mxGraph.prototype.consumeMouseEvent = function (a, b, c) {
  a == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(b.getEvent()) && b.consume(!1);
};
mxGraph.prototype.fireGestureEvent = function (a, b) {
  this.lastTouchTime = 0;
  this.fireEvent(new mxEventObject(mxEvent.GESTURE, 'event', a, 'cell', b));
};
mxGraph.prototype.destroy = function () {
  this.destroyed ||
    ((this.destroyed = !0),
    null != this.tooltipHandler && this.tooltipHandler.destroy(),
    null != this.selectionCellsHandler && this.selectionCellsHandler.destroy(),
    null != this.panningHandler && this.panningHandler.destroy(),
    null != this.popupMenuHandler && this.popupMenuHandler.destroy(),
    null != this.connectionHandler && this.connectionHandler.destroy(),
    null != this.graphHandler && this.graphHandler.destroy(),
    null != this.cellEditor && this.cellEditor.destroy(),
    null != this.view && this.view.destroy(),
    null != this.model &&
      null != this.graphModelChangeListener &&
      (this.model.removeListener(this.graphModelChangeListener), (this.graphModelChangeListener = null)),
    (this.container = null));
};
function mxLayoutManager(a) {
  this.undoHandler = mxUtils.bind(this, function (a, c) {
    this.isEnabled() && this.beforeUndo(c.getProperty('edit'));
  });
  this.moveHandler = mxUtils.bind(this, function (a, c) {
    this.isEnabled() && this.cellsMoved(c.getProperty('cells'), c.getProperty('event'));
  });
  this.resizeHandler = mxUtils.bind(this, function (a, c) {
    this.isEnabled() && this.cellsResized(c.getProperty('cells'), c.getProperty('bounds'), c.getProperty('previous'));
  });
  this.setGraph(a);
}
mxLayoutManager.prototype = new mxEventSource();
mxLayoutManager.prototype.constructor = mxLayoutManager;
mxLayoutManager.prototype.graph = null;
mxLayoutManager.prototype.bubbling = !0;
mxLayoutManager.prototype.enabled = !0;
mxLayoutManager.prototype.undoHandler = null;
mxLayoutManager.prototype.moveHandler = null;
mxLayoutManager.prototype.resizeHandler = null;
mxLayoutManager.prototype.isEnabled = function () {
  return this.enabled;
};
mxLayoutManager.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxLayoutManager.prototype.isBubbling = function () {
  return this.bubbling;
};
mxLayoutManager.prototype.setBubbling = function (a) {
  this.bubbling = a;
};
mxLayoutManager.prototype.getGraph = function () {
  return this.graph;
};
mxLayoutManager.prototype.setGraph = function (a) {
  if (null != this.graph) {
    var b = this.graph.getModel();
    b.removeListener(this.undoHandler);
    this.graph.removeListener(this.moveHandler);
    this.graph.removeListener(this.resizeHandler);
  }
  this.graph = a;
  null != this.graph &&
    ((b = this.graph.getModel()),
    b.addListener(mxEvent.BEFORE_UNDO, this.undoHandler),
    this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler),
    this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler));
};
mxLayoutManager.prototype.hasLayout = function (a) {
  return null != this.getLayout(a, mxEvent.LAYOUT_CELLS);
};
mxLayoutManager.prototype.getLayout = function (a, b) {
  return null;
};
mxLayoutManager.prototype.beforeUndo = function (a) {
  this.executeLayoutForCells(this.getCellsForChanges(a.changes));
};
mxLayoutManager.prototype.cellsMoved = function (a, b) {
  if (null != a && null != b)
    for (
      var c = mxUtils.convertPoint(this.getGraph().container, mxEvent.getClientX(b), mxEvent.getClientY(b)),
        d = this.getGraph().getModel(),
        e = 0;
      e < a.length;
      e++
    ) {
      var f = this.getLayout(d.getParent(a[e]), mxEvent.MOVE_CELLS);
      null != f && f.moveCell(a[e], c.x, c.y);
    }
};
mxLayoutManager.prototype.cellsResized = function (a, b, c) {
  if (null != a && null != b)
    for (var d = this.getGraph().getModel(), e = 0; e < a.length; e++) {
      var f = this.getLayout(d.getParent(a[e]), mxEvent.RESIZE_CELLS);
      null != f && f.resizeCell(a[e], b[e], c[e]);
    }
};
mxLayoutManager.prototype.getCellsForChanges = function (a) {
  for (var b = [], c = 0; c < a.length; c++) {
    var d = a[c];
    if (d instanceof mxRootChange) return [];
    b = b.concat(this.getCellsForChange(d));
  }
  return b;
};
mxLayoutManager.prototype.getCellsForChange = function (a) {
  return a instanceof mxChildChange
    ? this.addCellsWithLayout(a.child, this.addCellsWithLayout(a.previous))
    : a instanceof mxTerminalChange ||
      a instanceof mxGeometryChange ||
      a instanceof mxVisibleChange ||
      a instanceof mxStyleChange
    ? this.addCellsWithLayout(a.cell)
    : [];
};
mxLayoutManager.prototype.addCellsWithLayout = function (a, b) {
  return this.addDescendantsWithLayout(a, this.addAncestorsWithLayout(a, b));
};
mxLayoutManager.prototype.addAncestorsWithLayout = function (a, b) {
  b = null != b ? b : [];
  if (null != a && (this.hasLayout(a) && b.push(a), this.isBubbling())) {
    var c = this.getGraph().getModel();
    this.addAncestorsWithLayout(c.getParent(a), b);
  }
  return b;
};
mxLayoutManager.prototype.addDescendantsWithLayout = function (a, b) {
  b = null != b ? b : [];
  if (null != a && this.hasLayout(a))
    for (var c = this.getGraph().getModel(), d = 0; d < c.getChildCount(a); d++) {
      var e = c.getChildAt(a, d);
      this.hasLayout(e) && (b.push(e), this.addDescendantsWithLayout(e, b));
    }
  return b;
};
mxLayoutManager.prototype.executeLayoutForCells = function (a) {
  a = mxUtils.sortCells(a, !1);
  this.layoutCells(a, !0);
  this.layoutCells(a.reverse(), !1);
};
mxLayoutManager.prototype.layoutCells = function (a, b) {
  if (0 < a.length) {
    var c = this.getGraph().getModel();
    c.beginUpdate();
    try {
      for (var d = null, e = 0; e < a.length; e++)
        a[e] != c.getRoot() && a[e] != d && (this.executeLayout(a[e], b), (d = a[e]));
      this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, 'cells', a));
    } finally {
      c.endUpdate();
    }
  }
};
mxLayoutManager.prototype.executeLayout = function (a, b) {
  var c = this.getLayout(a, b ? mxEvent.BEGIN_UPDATE : mxEvent.END_UPDATE);
  null != c && c.execute(a);
};
mxLayoutManager.prototype.destroy = function () {
  this.setGraph(null);
};
function mxConnectionConstraint(a, b, c, d, e) {
  this.point = a;
  this.perimeter = null != b ? b : !0;
  this.name = c;
  this.dx = d ? d : 0;
  this.dy = e ? e : 0;
}
mxConnectionConstraint.prototype.point = null;
mxConnectionConstraint.prototype.perimeter = null;
mxConnectionConstraint.prototype.name = null;
mxConnectionConstraint.prototype.dx = null;
mxConnectionConstraint.prototype.dy = null;
function mxGraphHandler(a) {
  this.graph = a;
  this.graph.addMouseListener(this);
  this.panHandler = mxUtils.bind(this, function () {
    this.suspended || (this.updatePreview(), this.updateHint());
  });
  this.graph.addListener(mxEvent.PAN, this.panHandler);
  this.escapeHandler = mxUtils.bind(this, function (a, c) {
    this.reset();
  });
  this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);
  this.refreshHandler = mxUtils.bind(this, function (a, c) {
    this.refreshThread && window.clearTimeout(this.refreshThread);
    this.refreshThread = window.setTimeout(
      mxUtils.bind(this, function () {
        this.refreshThread = null;
        if (null != this.first && !this.suspended) {
          var a = this.currentDx,
            b = this.currentDy;
          this.currentDy = this.currentDx = 0;
          this.updatePreview();
          this.bounds = this.graph.getView().getBounds(this.cells);
          this.pBounds = this.getPreviewBounds(this.cells);
          null != this.pBounds || this.livePreviewUsed
            ? ((this.currentDx = a),
              (this.currentDy = b),
              this.updatePreview(),
              this.updateHint(),
              this.livePreviewUsed &&
                (this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), !1, !0),
                this.updatePreview()))
            : this.reset();
        }
      }),
      0
    );
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.addListener(mxEvent.REFRESH, this.refreshHandler);
  this.keyHandler = mxUtils.bind(this, function (a) {
    null == this.graph.container ||
      'hidden' == this.graph.container.style.visibility ||
      null == this.first ||
      this.suspended ||
      ((a = this.graph.isCloneEvent(a) && this.graph.isCellsCloneable() && this.isCloneEnabled()),
      a != this.cloning && ((this.cloning = a), this.checkPreview(), this.updatePreview()));
  });
  mxEvent.addListener(document, 'keydown', this.keyHandler);
  mxEvent.addListener(document, 'keyup', this.keyHandler);
}
mxGraphHandler.prototype.graph = null;
mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 : 50;
mxGraphHandler.prototype.enabled = !0;
mxGraphHandler.prototype.highlightEnabled = !0;
mxGraphHandler.prototype.cloneEnabled = !0;
mxGraphHandler.prototype.moveEnabled = !0;
mxGraphHandler.prototype.guidesEnabled = !1;
mxGraphHandler.prototype.handlesVisible = !0;
mxGraphHandler.prototype.guide = null;
mxGraphHandler.prototype.currentDx = null;
mxGraphHandler.prototype.currentDy = null;
mxGraphHandler.prototype.updateCursor = !0;
mxGraphHandler.prototype.selectEnabled = !0;
mxGraphHandler.prototype.removeCellsFromParent = !0;
mxGraphHandler.prototype.removeEmptyParents = !1;
mxGraphHandler.prototype.connectOnDrop = !1;
mxGraphHandler.prototype.scrollOnMove = !0;
mxGraphHandler.prototype.minimumSize = 6;
mxGraphHandler.prototype.previewColor = 'black';
mxGraphHandler.prototype.htmlPreview = !1;
mxGraphHandler.prototype.shape = null;
mxGraphHandler.prototype.scaleGrid = !1;
mxGraphHandler.prototype.rotationEnabled = !0;
mxGraphHandler.prototype.maxLivePreview = 0;
mxGraphHandler.prototype.allowLivePreview = mxClient.IS_SVG;
mxGraphHandler.prototype.isEnabled = function () {
  return this.enabled;
};
mxGraphHandler.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxGraphHandler.prototype.isCloneEnabled = function () {
  return this.cloneEnabled;
};
mxGraphHandler.prototype.setCloneEnabled = function (a) {
  this.cloneEnabled = a;
};
mxGraphHandler.prototype.isMoveEnabled = function () {
  return this.moveEnabled;
};
mxGraphHandler.prototype.setMoveEnabled = function (a) {
  this.moveEnabled = a;
};
mxGraphHandler.prototype.isSelectEnabled = function () {
  return this.selectEnabled;
};
mxGraphHandler.prototype.setSelectEnabled = function (a) {
  this.selectEnabled = a;
};
mxGraphHandler.prototype.isRemoveCellsFromParent = function () {
  return this.removeCellsFromParent;
};
mxGraphHandler.prototype.setRemoveCellsFromParent = function (a) {
  this.removeCellsFromParent = a;
};
mxGraphHandler.prototype.isPropagateSelectionCell = function (a, b, c) {
  var d = this.graph.model.getParent(a);
  return b
    ? ((b = this.graph.model.isEdge(a) ? null : this.graph.getCellGeometry(a)),
      !this.graph.isSiblingSelected(a) && ((null != b && b.relative) || !this.graph.isSwimlane(d)))
    : (!this.graph.isToggleEvent(c.getEvent()) ||
        (!this.graph.isSiblingSelected(a) && !this.graph.isCellSelected(a) && !this.graph.isSwimlane(d)) ||
        this.graph.isCellSelected(d)) &&
        (this.graph.isToggleEvent(c.getEvent()) || !this.graph.isCellSelected(d));
};
mxGraphHandler.prototype.getInitialCellForEvent = function (a) {
  var b = a.getState();
  if (
    !(
      (this.graph.isToggleEvent(a.getEvent()) && mxEvent.isAltDown(a.getEvent())) ||
      null == b ||
      this.graph.isCellSelected(b.cell)
    )
  )
    for (
      var c = this.graph.model, d = this.graph.view.getState(c.getParent(b.cell));
      null != d &&
      !this.graph.isCellSelected(d.cell) &&
      (c.isVertex(d.cell) || c.isEdge(d.cell)) &&
      this.isPropagateSelectionCell(b.cell, !0, a);

    )
      (b = d), (d = this.graph.view.getState(this.graph.getModel().getParent(b.cell)));
  return null != b ? b.cell : null;
};
mxGraphHandler.prototype.isDelayedSelection = function (a, b) {
  if (!this.graph.isToggleEvent(b.getEvent()) || !mxEvent.isAltDown(b.getEvent()))
    for (; null != a; ) {
      if (this.graph.selectionCellsHandler.isHandled(a)) return this.graph.cellEditor.getEditingCell() != a;
      a = this.graph.model.getParent(a);
    }
  return this.graph.isToggleEvent(b.getEvent()) && !mxEvent.isAltDown(b.getEvent());
};
mxGraphHandler.prototype.selectDelayed = function (a) {
  if (!this.graph.popupMenuHandler.isPopupTrigger(a)) {
    var b = a.getCell();
    null == b && (b = this.cell);
    this.selectCellForEvent(b, a);
  }
};
mxGraphHandler.prototype.selectCellForEvent = function (a, b) {
  var c = this.graph.view.getState(a);
  if (null != c) {
    if (!(b.isSource(c.control) || (this.graph.isToggleEvent(b.getEvent()) && mxEvent.isAltDown(b.getEvent()))))
      for (
        var c = this.graph.getModel(), d = c.getParent(a);
        null != this.graph.view.getState(d) &&
        (c.isVertex(d) || (c.isEdge(d) && !this.graph.isToggleEvent(b.getEvent()))) &&
        this.isPropagateSelectionCell(a, !1, b);

      )
        (a = d), (d = c.getParent(a));
    this.graph.selectCellForEvent(a, b.getEvent());
  }
  return a;
};
mxGraphHandler.prototype.consumeMouseEvent = function (a, b) {
  b.consume();
};
mxGraphHandler.prototype.mouseDown = function (a, b) {
  if (
    !b.isConsumed() &&
    this.isEnabled() &&
    this.graph.isEnabled() &&
    null != b.getState() &&
    !mxEvent.isMultiTouchEvent(b.getEvent())
  ) {
    var c = this.getInitialCellForEvent(b);
    this.delayedSelection = this.isDelayedSelection(c, b);
    this.cell = null;
    this.isSelectEnabled() && !this.delayedSelection && this.graph.selectCellForEvent(c, b.getEvent());
    if (this.isMoveEnabled()) {
      var d = this.graph.model,
        e = d.getGeometry(c);
      this.graph.isCellMovable(c) &&
      (!d.isEdge(c) ||
        1 < this.graph.getSelectionCount() ||
        (null != e.points && 0 < e.points.length) ||
        null == d.getTerminal(c, !0) ||
        null == d.getTerminal(c, !1) ||
        this.graph.allowDanglingEdges ||
        (this.graph.isCloneEvent(b.getEvent()) && this.graph.isCellsCloneable()))
        ? this.start(c, b.getX(), b.getY())
        : this.delayedSelection && (this.cell = c);
      this.cellWasClicked = !0;
      this.consumeMouseEvent(mxEvent.MOUSE_DOWN, b);
    }
  }
};
mxGraphHandler.prototype.getGuideStates = function () {
  var a = this.graph.getDefaultParent(),
    b = this.graph.getModel(),
    c = mxUtils.bind(this, function (a) {
      return (
        null != this.graph.view.getState(a) && b.isVertex(a) && null != b.getGeometry(a) && !b.getGeometry(a).relative
      );
    });
  return this.graph.view.getCellStates(b.filterDescendants(c, a));
};
mxGraphHandler.prototype.getCells = function (a) {
  return !this.delayedSelection && this.graph.isCellMovable(a)
    ? [a]
    : this.graph.getMovableCells(this.graph.getSelectionCells());
};
mxGraphHandler.prototype.getPreviewBounds = function (a) {
  a = this.getBoundingBox(a);
  null != a &&
    ((a.width = Math.max(0, a.width - 1)),
    (a.height = Math.max(0, a.height - 1)),
    a.width < this.minimumSize
      ? ((a.x -= (this.minimumSize - a.width) / 2), (a.width = this.minimumSize))
      : ((a.x = Math.round(a.x)), (a.width = Math.ceil(a.width))),
    a.height < this.minimumSize
      ? ((a.y -= (this.minimumSize - a.height) / 2), (a.height = this.minimumSize))
      : ((a.y = Math.round(a.y)), (a.height = Math.ceil(a.height))));
  return a;
};
mxGraphHandler.prototype.getBoundingBox = function (a) {
  var b = null;
  if (null != a && 0 < a.length)
    for (var c = this.graph.getModel(), d = 0; d < a.length; d++)
      if (c.isVertex(a[d]) || c.isEdge(a[d])) {
        var e = this.graph.view.getState(a[d]);
        if (null != e) {
          var f = e;
          c.isVertex(a[d]) && null != e.shape && null != e.shape.boundingBox && (f = e.shape.boundingBox);
          null == b ? (b = mxRectangle.fromRectangle(f)) : b.add(f);
        }
      }
  return b;
};
mxGraphHandler.prototype.createPreviewShape = function (a) {
  a = new mxRectangleShape(a, null, this.previewColor);
  a.isDashed = !0;
  this.htmlPreview
    ? ((a.dialect = mxConstants.DIALECT_STRICTHTML), a.init(this.graph.container))
    : ((a.dialect = mxConstants.DIALECT_SVG),
      a.init(this.graph.getView().getOverlayPane()),
      (a.pointerEvents = !1),
      mxClient.IS_IOS &&
        (a.getSvgScreenOffset = function () {
          return 0;
        }));
  return a;
};
mxGraphHandler.prototype.start = function (a, b, c, d) {
  this.cell = a;
  this.first = mxUtils.convertPoint(this.graph.container, b, c);
  this.cells = null != d ? d : this.getCells(this.cell);
  this.bounds = this.graph.getView().getBounds(this.cells);
  this.pBounds = this.getPreviewBounds(this.cells);
  this.allCells = new mxDictionary();
  this.cloning = !1;
  for (b = this.cellCount = 0; b < this.cells.length; b++)
    this.cellCount += this.addStates(this.cells[b], this.allCells);
  if (this.guidesEnabled) {
    this.guide = new mxGuide(this.graph, this.getGuideStates());
    var e = this.graph.model.getParent(a),
      f = 2 > this.graph.model.getChildCount(e),
      g = new mxDictionary();
    a = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
    for (b = 0; b < a.length; b++) (c = this.graph.view.getState(a[b])), null == c || g.get(c) || g.put(c, !0);
    this.guide.isStateIgnored = mxUtils.bind(this, function (a) {
      var b = this.graph.model.getParent(a.cell);
      return (
        null != a.cell &&
        ((!this.cloning && this.isCellMoving(a.cell)) ||
          (a.cell != (this.target || e) &&
            !f &&
            !g.get(a) &&
            (null == this.target || 2 <= this.graph.model.getChildCount(this.target)) &&
            b != (this.target || e)))
      );
    });
  }
};
mxGraphHandler.prototype.addStates = function (a, b) {
  var c = this.graph.view.getState(a),
    d = 0;
  if (null != c && null == b.get(a)) {
    b.put(a, c);
    d++;
    for (var c = this.graph.model.getChildCount(a), e = 0; e < c; e++)
      d += this.addStates(this.graph.model.getChildAt(a, e), b);
  }
  return d;
};
mxGraphHandler.prototype.isCellMoving = function (a) {
  return null != this.allCells.get(a);
};
mxGraphHandler.prototype.useGuidesForEvent = function (a) {
  return null != this.guide ? this.guide.isEnabledForEvent(a.getEvent()) && !this.isConstrainedEvent(a) : !0;
};
mxGraphHandler.prototype.snap = function (a) {
  var b = this.scaleGrid ? this.graph.view.scale : 1;
  a.x = this.graph.snap(a.x / b) * b;
  a.y = this.graph.snap(a.y / b) * b;
  return a;
};
mxGraphHandler.prototype.getDelta = function (a) {
  a = mxUtils.convertPoint(this.graph.container, a.getX(), a.getY());
  return new mxPoint(a.x - this.first.x - this.graph.panDx, a.y - this.first.y - this.graph.panDy);
};
mxGraphHandler.prototype.updateHint = function (a) {};
mxGraphHandler.prototype.removeHint = function () {};
mxGraphHandler.prototype.roundLength = function (a) {
  return Math.round(100 * a) / 100;
};
mxGraphHandler.prototype.isValidDropTarget = function (a, b) {
  return this.graph.model.getParent(this.cell) != a;
};
mxGraphHandler.prototype.checkPreview = function () {
  this.livePreviewActive && this.cloning
    ? (this.resetLivePreview(), (this.livePreviewActive = !1))
    : this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview
    ? (this.cloning && this.livePreviewActive) || (this.livePreviewUsed = this.livePreviewActive = !0)
    : this.livePreviewUsed || null != this.shape || (this.shape = this.createPreviewShape(this.bounds));
};
mxGraphHandler.prototype.mouseMove = function (a, b) {
  var c = this.graph;
  if (
    b.isConsumed() ||
    !c.isMouseDown ||
    null == this.cell ||
    null == this.first ||
    null == this.bounds ||
    this.suspended
  )
    (!this.isMoveEnabled() && !this.isCloneEnabled()) ||
      !this.updateCursor ||
      b.isConsumed() ||
      (null == b.getState() && null == b.sourceState) ||
      c.isMouseDown ||
      ((d = c.getCursorForMouseEvent(b)),
      null == d &&
        c.isEnabled() &&
        c.isCellMovable(b.getCell()) &&
        (d = c.getModel().isEdge(b.getCell()) ? mxConstants.CURSOR_MOVABLE_EDGE : mxConstants.CURSOR_MOVABLE_VERTEX),
      null != d && null != b.sourceState && b.sourceState.setCursor(d));
  else if (mxEvent.isMultiTouchEvent(b.getEvent())) this.reset();
  else {
    var d = this.getDelta(b),
      e = c.tolerance;
    if (null != this.shape || this.livePreviewActive || Math.abs(d.x) > e || Math.abs(d.y) > e) {
      null == this.highlight && (this.highlight = new mxCellHighlight(this.graph, mxConstants.DROP_TARGET_COLOR, 3));
      var e = c.isCloneEvent(b.getEvent()) && c.isCellsCloneable() && this.isCloneEnabled(),
        f = c.isGridEnabledEvent(b.getEvent()),
        g = b.getCell(),
        g =
          null != g && 0 > mxUtils.indexOf(this.cells, g)
            ? g
            : c.getCellAt(
                b.getGraphX(),
                b.getGraphY(),
                null,
                null,
                null,
                mxUtils.bind(this, function (a, b, c) {
                  return 0 <= mxUtils.indexOf(this.cells, a.cell);
                })
              ),
        k = !0,
        h = null;
      this.cloning = e;
      c.isDropEnabled() && this.highlightEnabled && (h = c.getDropTarget(this.cells, b.getEvent(), g, e));
      var l = c.getView().getState(h),
        m = !1;
      null != l && (e || this.isValidDropTarget(h, b))
        ? (this.target != h && ((this.target = h), this.setHighlightColor(mxConstants.DROP_TARGET_COLOR)), (m = !0))
        : ((this.target = null),
          this.connectOnDrop &&
            null != g &&
            1 == this.cells.length &&
            c.getModel().isVertex(g) &&
            c.isCellConnectable(g) &&
            ((l = c.getView().getState(g)),
            null != l &&
              ((c =
                null == c.getEdgeValidationError(null, this.cell, g)
                  ? mxConstants.VALID_COLOR
                  : mxConstants.INVALID_CONNECT_TARGET_COLOR),
              this.setHighlightColor(c),
              (m = !0))));
      null != l && m ? this.highlight.highlight(l) : this.highlight.hide();
      null != this.guide && this.useGuidesForEvent(b)
        ? ((d = this.guide.move(this.bounds, d, f, e)), (k = !1))
        : (d = this.graph.snapDelta(d, this.bounds, !f, !1, !1));
      null != this.guide && k && this.guide.hide();
      this.isConstrainedEvent(b) && (Math.abs(d.x) > Math.abs(d.y) ? (d.y = 0) : (d.x = 0));
      this.checkPreview();
      if (this.currentDx != d.x || this.currentDy != d.y)
        (this.currentDx = d.x), (this.currentDy = d.y), this.updatePreview();
    }
    this.updateHint(b);
    this.consumeMouseEvent(mxEvent.MOUSE_MOVE, b);
    mxEvent.consume(b.getEvent());
  }
};
mxGraphHandler.prototype.isConstrainedEvent = function (a) {
  return (null == this.target || this.graph.isCloneEvent(a.getEvent())) && this.graph.isConstrainedEvent(a.getEvent());
};
mxGraphHandler.prototype.updatePreview = function (a) {
  this.livePreviewUsed && !a
    ? null != this.cells &&
      (this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), !1),
      this.updateLivePreview(this.currentDx, this.currentDy))
    : this.updatePreviewShape();
};
mxGraphHandler.prototype.updatePreviewShape = function () {
  null != this.shape &&
    null != this.pBounds &&
    ((this.shape.bounds = new mxRectangle(
      Math.round(this.pBounds.x + this.currentDx),
      Math.round(this.pBounds.y + this.currentDy),
      this.pBounds.width,
      this.pBounds.height
    )),
    this.shape.redraw());
};
mxGraphHandler.prototype.updateLivePreview = function (a, b) {
  if (!this.suspended) {
    var c = [];
    null != this.allCells &&
      this.allCells.visit(
        mxUtils.bind(this, function (d, e) {
          var f = this.graph.view.getState(e.cell);
          f != e && (e.destroy(), null != f ? this.allCells.put(e.cell, f) : this.allCells.remove(e.cell), (e = f));
          null != e &&
            ((f = e.clone()),
            c.push([e, f]),
            null != e.shape &&
              (null == e.shape.originalPointerEvents && (e.shape.originalPointerEvents = e.shape.pointerEvents),
              (e.shape.pointerEvents = !1),
              null != e.text &&
                (null == e.text.originalPointerEvents && (e.text.originalPointerEvents = e.text.pointerEvents),
                (e.text.pointerEvents = !1))),
            this.graph.model.isVertex(e.cell)) &&
            (((e.x += a), (e.y += b), this.cloning)
              ? null != e.text &&
                (e.text.updateBoundingBox(),
                null != e.text.boundingBox && ((e.text.boundingBox.x += a), (e.text.boundingBox.y += b)),
                null != e.text.unrotatedBoundingBox &&
                  ((e.text.unrotatedBoundingBox.x += a), (e.text.unrotatedBoundingBox.y += b)))
              : (e.view.graph.cellRenderer.redraw(e, !0),
                e.view.invalidate(e.cell),
                (e.invalid = !1),
                null != e.control && null != e.control.node && (e.control.node.style.visibility = 'hidden')));
        })
      );
    if (0 == c.length) this.reset();
    else {
      for (var d = this.graph.view.scale, e = 0; e < c.length; e++) {
        var f = c[e][0];
        if (this.graph.model.isEdge(f.cell)) {
          var g = this.graph.getCellGeometry(f.cell),
            k = [];
          if (null != g && null != g.points)
            for (var h = 0; h < g.points.length; h++)
              null != g.points[h] && k.push(new mxPoint(g.points[h].x + a / d, g.points[h].y + b / d));
          var g = f.visibleSourceState,
            h = f.visibleTargetState,
            l = c[e][1].absolutePoints;
          null != g && this.isCellMoving(g.cell)
            ? f.view.updateFixedTerminalPoint(f, g, !0, this.graph.getConnectionConstraint(f, g, !0))
            : ((g = l[0]), f.setAbsoluteTerminalPoint(new mxPoint(g.x + a, g.y + b), !0), (g = null));
          null != h && this.isCellMoving(h.cell)
            ? f.view.updateFixedTerminalPoint(f, h, !1, this.graph.getConnectionConstraint(f, h, !1))
            : ((h = l[l.length - 1]), f.setAbsoluteTerminalPoint(new mxPoint(h.x + a, h.y + b), !1), (h = null));
          f.view.updatePoints(f, k, g, h);
          f.view.updateFloatingTerminalPoints(f, g, h);
          f.view.updateEdgeLabelOffset(f);
          f.invalid = !1;
          this.cloning || f.view.graph.cellRenderer.redraw(f, !0);
        }
      }
      this.graph.view.validate();
      this.redrawHandles(c);
      this.resetPreviewStates(c);
    }
  }
};
mxGraphHandler.prototype.redrawHandles = function (a) {
  for (var b = 0; b < a.length; b++) {
    var c = this.graph.selectionCellsHandler.getHandler(a[b][0].cell);
    null != c && c.redraw(!0);
  }
};
mxGraphHandler.prototype.resetPreviewStates = function (a) {
  for (var b = 0; b < a.length; b++) a[b][0].setState(a[b][1]);
};
mxGraphHandler.prototype.suspend = function () {
  this.suspended ||
    (this.livePreviewUsed && this.updateLivePreview(0, 0),
    null != this.shape && (this.shape.node.style.visibility = 'hidden'),
    null != this.guide && this.guide.setVisible(!1),
    (this.suspended = !0));
};
mxGraphHandler.prototype.resume = function () {
  this.suspended &&
    ((this.suspended = null),
    this.livePreviewUsed && (this.livePreviewActive = !0),
    null != this.shape && (this.shape.node.style.visibility = 'visible'),
    null != this.guide && this.guide.setVisible(!0));
};
mxGraphHandler.prototype.resetLivePreview = function () {
  null != this.allCells &&
    (this.allCells.visit(
      mxUtils.bind(this, function (a, b) {
        null != b.shape &&
          null != b.shape.originalPointerEvents &&
          ((b.shape.pointerEvents = b.shape.originalPointerEvents),
          (b.shape.originalPointerEvents = null),
          (b.shape.bounds = null),
          null != b.text &&
            ((b.text.pointerEvents = b.text.originalPointerEvents), (b.text.originalPointerEvents = null)));
        null != b.control &&
          null != b.control.node &&
          'hidden' == b.control.node.style.visibility &&
          (b.control.node.style.visibility = '');
        this.cloning || (null != b.text && b.text.updateBoundingBox());
        b.view.invalidate(b.cell);
      })
    ),
    this.graph.view.validate());
};
mxGraphHandler.prototype.setHandlesVisibleForCells = function (a, b, c) {
  if (c || this.handlesVisible != b)
    for (this.handlesVisible = b, c = 0; c < a.length; c++) {
      var d = this.graph.selectionCellsHandler.getHandler(a[c]);
      null != d && (d.setHandlesVisible(b), b && d.redraw());
    }
};
mxGraphHandler.prototype.setHighlightColor = function (a) {
  null != this.highlight && this.highlight.setHighlightColor(a);
};
mxGraphHandler.prototype.mouseUp = function (a, b) {
  if (!b.isConsumed())
    if (
      (this.livePreviewUsed && this.resetLivePreview(),
      null == this.cell ||
        null == this.first ||
        (null == this.shape && !this.livePreviewUsed) ||
        null == this.currentDx ||
        null == this.currentDy)
    )
      this.isSelectEnabled() && this.delayedSelection && null != this.cell && this.selectDelayed(b);
    else {
      var c = this.graph,
        d = b.getCell();
      if (
        this.connectOnDrop &&
        null == this.target &&
        null != d &&
        c.getModel().isVertex(d) &&
        c.isCellConnectable(d) &&
        c.isEdgeValid(null, this.cell, d)
      )
        c.connectionHandler.connect(this.cell, d, b.getEvent());
      else {
        var d = c.isCloneEvent(b.getEvent()) && c.isCellsCloneable() && this.isCloneEnabled(),
          e = c.getView().scale,
          f = this.roundLength(this.currentDx / e),
          e = this.roundLength(this.currentDy / e),
          g = this.target;
        c.isSplitEnabled() && c.isSplitTarget(g, this.cells, b.getEvent())
          ? c.splitEdge(g, this.cells, null, f, e, b.getGraphX(), b.getGraphY())
          : this.moveCells(this.cells, f, e, d, this.target, b.getEvent());
      }
    }
  this.cellWasClicked && this.consumeMouseEvent(mxEvent.MOUSE_UP, b);
  this.reset();
};
mxGraphHandler.prototype.reset = function () {
  this.livePreviewUsed &&
    (this.resetLivePreview(),
    this.setHandlesVisibleForCells(this.graph.selectionCellsHandler.getHandledSelectionCells(), !0));
  this.destroyShapes();
  this.removeHint();
  this.delayedSelection = !1;
  this.livePreviewUsed = this.livePreviewActive = null;
  this.cellWasClicked = !1;
  this.cellCount = this.currentDy = this.currentDx = this.suspended = null;
  this.cloning = !1;
  this.cell = this.cells = this.first = this.target = this.guides = this.pBounds = this.allCells = null;
};
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function (a, b, c) {
  if (this.graph.getModel().isVertex(a) && ((a = this.graph.getView().getState(a)), null != a)) {
    c = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(c), mxEvent.getClientY(c));
    var d = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != d) {
      b = Math.cos(-d);
      var d = Math.sin(-d),
        e = new mxPoint(a.getCenterX(), a.getCenterY());
      c = mxUtils.getRotatedPoint(c, b, d, e);
    }
    return !mxUtils.contains(a, c.x, c.y);
  }
  return !1;
};
mxGraphHandler.prototype.moveCells = function (a, b, c, d, e, f) {
  d && (a = this.graph.getCloneableCells(a));
  var g = this.graph.getModel().getParent(this.cell);
  null == e &&
    null != f &&
    this.isRemoveCellsFromParent() &&
    this.shouldRemoveCellsFromParent(g, a, f) &&
    (e = this.graph.getDefaultParent());
  d = d && !this.graph.isCellLocked(e || this.graph.getDefaultParent());
  this.graph.getModel().beginUpdate();
  try {
    g = [];
    if (!d && null != e && this.removeEmptyParents) {
      for (var k = new mxDictionary(), h = 0; h < a.length; h++) k.put(a[h], !0);
      for (h = 0; h < a.length; h++) {
        var l = this.graph.model.getParent(a[h]);
        null == l || k.get(l) || (k.put(l, !0), g.push(l));
      }
    }
    a = this.graph.moveCells(a, b, c, d, e, f);
    b = [];
    for (h = 0; h < g.length; h++) this.shouldRemoveParent(g[h]) && b.push(g[h]);
    this.graph.removeCells(b, !1);
  } finally {
    this.graph.getModel().endUpdate();
  }
  d && this.graph.setSelectionCells(a);
  this.isSelectEnabled() && this.scrollOnMove && this.graph.scrollCellToVisible(a[0]);
};
mxGraphHandler.prototype.shouldRemoveParent = function (a) {
  a = this.graph.view.getState(a);
  return (
    null != a &&
    (this.graph.model.isEdge(a.cell) || this.graph.model.isVertex(a.cell)) &&
    this.graph.isCellDeletable(a.cell) &&
    0 == this.graph.model.getChildCount(a.cell) &&
    this.graph.isTransparentState(a)
  );
};
mxGraphHandler.prototype.destroyShapes = function () {
  null != this.shape && (this.shape.destroy(), (this.shape = null));
  null != this.guide && (this.guide.destroy(), (this.guide = null));
  null != this.highlight && (this.highlight.destroy(), (this.highlight = null));
};
mxGraphHandler.prototype.destroy = function () {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.panHandler);
  null != this.escapeHandler && (this.graph.removeListener(this.escapeHandler), (this.escapeHandler = null));
  null != this.refreshHandler &&
    (this.graph.getModel().removeListener(this.refreshHandler),
    this.graph.removeListener(this.refreshHandler),
    (this.refreshHandler = null));
  mxEvent.removeListener(document, 'keydown', this.keyHandler);
  mxEvent.removeListener(document, 'keyup', this.keyHandler);
  this.destroyShapes();
  this.removeHint();
};
function mxPanningHandler(a) {
  null != a &&
    ((this.graph = a),
    this.graph.addMouseListener(this),
    (this.forcePanningHandler = mxUtils.bind(this, function (a, c) {
      var b = c.getProperty('eventName'),
        e = c.getProperty('event');
      b == mxEvent.MOUSE_DOWN &&
        this.isForcePanningEvent(e) &&
        (this.start(e),
        (this.active = !0),
        this.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', e)),
        e.consume());
    })),
    this.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler),
    (this.gestureHandler = mxUtils.bind(this, function (a, c) {
      if (this.isPinchEnabled()) {
        var b = c.getProperty('event');
        mxEvent.isConsumed(b) || 'gesturestart' != b.type
          ? 'gestureend' == b.type && null != this.initialScale && (this.initialScale = null)
          : ((this.initialScale = this.graph.view.scale),
            this.active ||
              null == this.mouseDownEvent ||
              (this.start(this.mouseDownEvent), (this.mouseDownEvent = null)));
        null != this.initialScale && this.zoomGraph(b);
      }
    })),
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler),
    (this.mouseUpListener = mxUtils.bind(this, function () {
      this.active && this.reset();
    })),
    mxEvent.addGestureListeners(document, null, null, this.mouseUpListener),
    mxEvent.addListener(document, 'mouseleave', this.mouseUpListener));
}
mxPanningHandler.prototype = new mxEventSource();
mxPanningHandler.prototype.constructor = mxPanningHandler;
mxPanningHandler.prototype.graph = null;
mxPanningHandler.prototype.useLeftButtonForPanning = !1;
mxPanningHandler.prototype.usePopupTrigger = !0;
mxPanningHandler.prototype.ignoreCell = !1;
mxPanningHandler.prototype.previewEnabled = !0;
mxPanningHandler.prototype.useGrid = !1;
mxPanningHandler.prototype.panningEnabled = !0;
mxPanningHandler.prototype.pinchEnabled = !0;
mxPanningHandler.prototype.maxScale = 8;
mxPanningHandler.prototype.minScale = 0.01;
mxPanningHandler.prototype.dx = null;
mxPanningHandler.prototype.dy = null;
mxPanningHandler.prototype.startX = 0;
mxPanningHandler.prototype.startY = 0;
mxPanningHandler.prototype.isActive = function () {
  return this.active || null != this.initialScale;
};
mxPanningHandler.prototype.isPanningEnabled = function () {
  return this.panningEnabled;
};
mxPanningHandler.prototype.setPanningEnabled = function (a) {
  this.panningEnabled = a;
};
mxPanningHandler.prototype.isPinchEnabled = function () {
  return this.pinchEnabled;
};
mxPanningHandler.prototype.setPinchEnabled = function (a) {
  this.pinchEnabled = a;
};
mxPanningHandler.prototype.isPanningTrigger = function (a) {
  var b = a.getEvent();
  return (
    (this.useLeftButtonForPanning && null == a.getState() && mxEvent.isLeftMouseButton(b)) ||
    (mxEvent.isControlDown(b) && mxEvent.isShiftDown(b)) ||
    (this.usePopupTrigger && mxEvent.isPopupTrigger(b))
  );
};
mxPanningHandler.prototype.isForcePanningEvent = function (a) {
  return this.ignoreCell || mxEvent.isMultiTouchEvent(a.getEvent());
};
mxPanningHandler.prototype.mouseDown = function (a, b) {
  this.mouseDownEvent = b;
  !b.isConsumed() &&
    this.isPanningEnabled() &&
    !this.active &&
    this.isPanningTrigger(b) &&
    (this.start(b), this.consumePanningTrigger(b));
};
mxPanningHandler.prototype.start = function (a) {
  this.dx0 = -this.graph.container.scrollLeft;
  this.dy0 = -this.graph.container.scrollTop;
  this.startX = a.getX();
  this.startY = a.getY();
  this.dy = this.dx = null;
  this.panningTrigger = !0;
};
mxPanningHandler.prototype.consumePanningTrigger = function (a) {
  a.consume();
};
mxPanningHandler.prototype.mouseMove = function (a, b) {
  this.dx = b.getX() - this.startX;
  this.dy = b.getY() - this.startY;
  if (this.active)
    this.previewEnabled &&
      (this.useGrid && ((this.dx = this.graph.snap(this.dx)), (this.dy = this.graph.snap(this.dy))),
      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0)),
      this.fireEvent(new mxEventObject(mxEvent.PAN, 'event', b));
  else if (this.panningTrigger) {
    var c = this.active;
    this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;
    !c && this.active && this.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', b));
  }
  (this.active || this.panningTrigger) && b.consume();
};
mxPanningHandler.prototype.mouseUp = function (a, b) {
  if (this.active) {
    if (null != this.dx && null != this.dy) {
      if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
        var c = this.graph.getView().scale,
          d = this.graph.getView().translate;
        this.graph.panGraph(0, 0);
        this.panGraph(d.x + this.dx / c, d.y + this.dy / c);
      }
      b.consume();
    }
    this.fireEvent(new mxEventObject(mxEvent.PAN_END, 'event', b));
  }
  this.reset();
};
mxPanningHandler.prototype.zoomGraph = function (a) {
  var b = Math.round(this.initialScale * a.scale * 100) / 100;
  null != this.minScale && (b = Math.max(this.minScale, b));
  null != this.maxScale && (b = Math.min(this.maxScale, b));
  this.graph.view.scale != b && (this.graph.zoomTo(b), mxEvent.consume(a));
};
mxPanningHandler.prototype.reset = function () {
  this.panningTrigger = this.graph.isMouseDown = !1;
  this.mouseDownEvent = null;
  this.active = !1;
  this.dy = this.dx = null;
};
mxPanningHandler.prototype.panGraph = function (a, b) {
  this.graph.getView().setTranslate(a, b);
};
mxPanningHandler.prototype.destroy = function () {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.forcePanningHandler);
  this.graph.removeListener(this.gestureHandler);
  mxEvent.removeGestureListeners(document, null, null, this.mouseUpListener);
  mxEvent.removeListener(document, 'mouseleave', this.mouseUpListener);
};
function mxPopupMenuHandler(a, b) {
  null != a &&
    ((this.graph = a),
    (this.factoryMethod = b),
    this.graph.addMouseListener(this),
    (this.gestureHandler = mxUtils.bind(this, function (a, b) {
      this.inTolerance = !1;
    })),
    this.graph.addListener(mxEvent.GESTURE, this.gestureHandler),
    this.init());
}
mxPopupMenuHandler.prototype = new mxPopupMenu();
mxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;
mxPopupMenuHandler.prototype.graph = null;
mxPopupMenuHandler.prototype.selectOnPopup = !0;
mxPopupMenuHandler.prototype.clearSelectionOnBackground = !0;
mxPopupMenuHandler.prototype.triggerX = null;
mxPopupMenuHandler.prototype.triggerY = null;
mxPopupMenuHandler.prototype.screenX = null;
mxPopupMenuHandler.prototype.screenY = null;
mxPopupMenuHandler.prototype.init = function () {
  mxPopupMenu.prototype.init.apply(this);
  mxEvent.addGestureListeners(
    this.div,
    mxUtils.bind(this, function (a) {
      this.graph.tooltipHandler.hide();
    })
  );
};
mxPopupMenuHandler.prototype.isSelectOnPopup = function (a) {
  return this.selectOnPopup;
};
mxPopupMenuHandler.prototype.mouseDown = function (a, b) {
  this.isEnabled() &&
    !mxEvent.isMultiTouchEvent(b.getEvent()) &&
    (this.hideMenu(),
    (this.triggerX = b.getGraphX()),
    (this.triggerY = b.getGraphY()),
    (this.screenX = mxEvent.getMainEvent(b.getEvent()).screenX),
    (this.screenY = mxEvent.getMainEvent(b.getEvent()).screenY),
    (this.popupTrigger = this.isPopupTrigger(b)),
    (this.inTolerance = !0));
};
mxPopupMenuHandler.prototype.mouseMove = function (a, b) {
  this.inTolerance &&
    null != this.screenX &&
    null != this.screenY &&
    (Math.abs(mxEvent.getMainEvent(b.getEvent()).screenX - this.screenX) > this.graph.tolerance ||
      Math.abs(mxEvent.getMainEvent(b.getEvent()).screenY - this.screenY) > this.graph.tolerance) &&
    (this.inTolerance = !1);
};
mxPopupMenuHandler.prototype.mouseUp = function (a, b, c) {
  a = null == c;
  c =
    null != c
      ? c
      : mxUtils.bind(this, function (a) {
          var c = mxUtils.getScrollOrigin();
          this.popup(b.getX() + c.x + 1, b.getY() + c.y + 1, a, b.getEvent());
        });
  if (this.popupTrigger && this.inTolerance && null != this.triggerX && null != this.triggerY) {
    var d = this.getCellForPopupEvent(b);
    this.graph.isEnabled() && this.isSelectOnPopup(b) && null != d && !this.graph.isCellSelected(d)
      ? this.graph.setSelectionCell(d)
      : this.clearSelectionOnBackground && null == d && this.graph.clearSelection();
    this.graph.tooltipHandler.hide();
    c(d);
    a && b.consume();
  }
  this.inTolerance = this.popupTrigger = !1;
};
mxPopupMenuHandler.prototype.getCellForPopupEvent = function (a) {
  return a.getCell();
};
mxPopupMenuHandler.prototype.destroy = function () {
  this.graph.removeMouseListener(this);
  this.graph.removeListener(this.gestureHandler);
  mxPopupMenu.prototype.destroy.apply(this);
};
function mxCellMarker(a, b, c, d) {
  mxEventSource.call(this);
  null != a &&
    ((this.graph = a),
    (this.validColor = null != b ? b : mxConstants.DEFAULT_VALID_COLOR),
    (this.invalidColor = null != c ? c : mxConstants.DEFAULT_INVALID_COLOR),
    (this.hotspot = null != d ? d : mxConstants.DEFAULT_HOTSPOT),
    (this.highlight = new mxCellHighlight(a)));
}
mxUtils.extend(mxCellMarker, mxEventSource);
mxCellMarker.prototype.graph = null;
mxCellMarker.prototype.enabled = !0;
mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;
mxCellMarker.prototype.hotspotEnabled = !1;
mxCellMarker.prototype.validColor = null;
mxCellMarker.prototype.invalidColor = null;
mxCellMarker.prototype.currentColor = null;
mxCellMarker.prototype.validState = null;
mxCellMarker.prototype.markedState = null;
mxCellMarker.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxCellMarker.prototype.isEnabled = function () {
  return this.enabled;
};
mxCellMarker.prototype.setHotspot = function (a) {
  this.hotspot = a;
};
mxCellMarker.prototype.getHotspot = function () {
  return this.hotspot;
};
mxCellMarker.prototype.setHotspotEnabled = function (a) {
  this.hotspotEnabled = a;
};
mxCellMarker.prototype.isHotspotEnabled = function () {
  return this.hotspotEnabled;
};
mxCellMarker.prototype.hasValidState = function () {
  return null != this.validState;
};
mxCellMarker.prototype.getValidState = function () {
  return this.validState;
};
mxCellMarker.prototype.getMarkedState = function () {
  return this.markedState;
};
mxCellMarker.prototype.reset = function () {
  this.validState = null;
  null != this.markedState && ((this.markedState = null), this.unmark());
};
mxCellMarker.prototype.process = function (a) {
  var b = null;
  this.isEnabled() && ((b = this.getState(a)), this.setCurrentState(b, a));
  return b;
};
mxCellMarker.prototype.setCurrentState = function (a, b, c) {
  var d = null != a ? this.isValidState(a) : !1;
  c = null != c ? c : this.getMarkerColor(b.getEvent(), a, d);
  this.validState = d ? a : null;
  if (a != this.markedState || c != this.currentColor)
    (this.currentColor = c),
      null != a && null != this.currentColor
        ? ((this.markedState = a), this.mark())
        : null != this.markedState && ((this.markedState = null), this.unmark());
};
mxCellMarker.prototype.markCell = function (a, b) {
  var c = this.graph.getView().getState(a);
  null != c && ((this.currentColor = null != b ? b : this.validColor), (this.markedState = c), this.mark());
};
mxCellMarker.prototype.mark = function () {
  this.highlight.setHighlightColor(this.currentColor);
  this.highlight.highlight(this.markedState);
  this.fireEvent(new mxEventObject(mxEvent.MARK, 'state', this.markedState));
};
mxCellMarker.prototype.unmark = function () {
  this.mark();
};
mxCellMarker.prototype.isValidState = function (a) {
  return !0;
};
mxCellMarker.prototype.getMarkerColor = function (a, b, c) {
  return c ? this.validColor : this.invalidColor;
};
mxCellMarker.prototype.getState = function (a) {
  var b = this.graph.getView(),
    c = this.getCell(a),
    b = this.getStateToMark(b.getState(c));
  return null != b && this.intersects(b, a) ? b : null;
};
mxCellMarker.prototype.getCell = function (a) {
  return a.getCell();
};
mxCellMarker.prototype.getStateToMark = function (a) {
  return a;
};
mxCellMarker.prototype.intersects = function (a, b) {
  return this.hotspotEnabled
    ? mxUtils.intersectsHotspot(
        a,
        b.getGraphX(),
        b.getGraphY(),
        this.hotspot,
        mxConstants.MIN_HOTSPOT_SIZE,
        mxConstants.MAX_HOTSPOT_SIZE
      )
    : !0;
};
mxCellMarker.prototype.destroy = function () {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getModel().removeListener(this.resetHandler);
  this.highlight.destroy();
};
function mxSelectionCellsHandler(a) {
  mxEventSource.call(this);
  this.graph = a;
  this.handlers = new mxDictionary();
  this.graph.addMouseListener(this);
  this.refreshHandler = mxUtils.bind(this, function (a, c) {
    this.isEnabled() && this.refresh();
  });
  this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);
  this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
}
mxUtils.extend(mxSelectionCellsHandler, mxEventSource);
mxSelectionCellsHandler.prototype.graph = null;
mxSelectionCellsHandler.prototype.enabled = !0;
mxSelectionCellsHandler.prototype.refreshHandler = null;
mxSelectionCellsHandler.prototype.maxHandlers = 100;
mxSelectionCellsHandler.prototype.handlers = null;
mxSelectionCellsHandler.prototype.isEnabled = function () {
  return this.enabled;
};
mxSelectionCellsHandler.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxSelectionCellsHandler.prototype.getHandler = function (a) {
  return this.handlers.get(a);
};
mxSelectionCellsHandler.prototype.isHandled = function (a) {
  return null != this.getHandler(a);
};
mxSelectionCellsHandler.prototype.reset = function () {
  this.handlers.visit(function (a, b) {
    b.reset.apply(b);
  });
};
mxSelectionCellsHandler.prototype.getHandledSelectionCells = function () {
  return this.graph.getSelectionCells();
};
mxSelectionCellsHandler.prototype.refresh = function () {
  var a = this.handlers;
  this.handlers = new mxDictionary();
  for (var b = mxUtils.sortCells(this.getHandledSelectionCells(), !1), c = 0; c < b.length; c++) {
    var d = this.graph.view.getState(b[c]);
    if (null != d) {
      var e = a.remove(b[c]);
      null != e &&
        (e.state != d
          ? (e.destroy(), (e = null))
          : this.isHandlerActive(e) || (null != e.refresh && e.refresh(), e.redraw()));
      null != e && this.handlers.put(b[c], e);
    }
  }
  a.visit(
    mxUtils.bind(this, function (a, b) {
      this.fireEvent(new mxEventObject(mxEvent.REMOVE, 'state', b.state));
      b.destroy();
    })
  );
  for (c = 0; c < b.length; c++)
    (d = this.graph.view.getState(b[c])),
      null != d &&
        ((e = this.handlers.get(b[c])),
        null == e
          ? ((e = this.graph.createHandler(d)),
            this.fireEvent(new mxEventObject(mxEvent.ADD, 'state', d)),
            this.handlers.put(b[c], e))
          : e.updateParentHighlight());
};
mxSelectionCellsHandler.prototype.isHandlerActive = function (a) {
  return null != a.index;
};
mxSelectionCellsHandler.prototype.updateHandler = function (a) {
  var b = this.handlers.remove(a.cell);
  if (null != b) {
    var c = b.index,
      d = b.startX,
      e = b.startY;
    b.destroy();
    b = this.graph.createHandler(a);
    null != b && (this.handlers.put(a.cell, b), null != c && null != d && null != e && b.start(d, e, c));
  }
};
mxSelectionCellsHandler.prototype.mouseDown = function (a, b) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var c = [a, b];
    this.handlers.visit(function (a, b) {
      b.mouseDown.apply(b, c);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseMove = function (a, b) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var c = [a, b];
    this.handlers.visit(function (a, b) {
      b.mouseMove.apply(b, c);
    });
  }
};
mxSelectionCellsHandler.prototype.mouseUp = function (a, b) {
  if (this.graph.isEnabled() && this.isEnabled()) {
    var c = [a, b];
    this.handlers.visit(function (a, b) {
      b.mouseUp.apply(b, c);
    });
  }
};
mxSelectionCellsHandler.prototype.destroy = function () {
  this.graph.removeMouseListener(this);
  null != this.refreshHandler &&
    (this.graph.getSelectionModel().removeListener(this.refreshHandler),
    this.graph.getModel().removeListener(this.refreshHandler),
    this.graph.getView().removeListener(this.refreshHandler),
    (this.refreshHandler = null));
};
function mxConnectionHandler(a, b) {
  mxEventSource.call(this);
  null != a &&
    ((this.graph = a),
    (this.factoryMethod = b),
    this.init(),
    (this.escapeHandler = mxUtils.bind(this, function (a, b) {
      this.reset();
    })),
    this.graph.addListener(mxEvent.ESCAPE, this.escapeHandler));
}
mxUtils.extend(mxConnectionHandler, mxEventSource);
mxConnectionHandler.prototype.graph = null;
mxConnectionHandler.prototype.factoryMethod = !0;
mxConnectionHandler.prototype.moveIconFront = !1;
mxConnectionHandler.prototype.moveIconBack = !1;
mxConnectionHandler.prototype.connectImage = null;
mxConnectionHandler.prototype.targetConnectImage = !1;
mxConnectionHandler.prototype.enabled = !0;
mxConnectionHandler.prototype.select = !0;
mxConnectionHandler.prototype.createTarget = !1;
mxConnectionHandler.prototype.marker = null;
mxConnectionHandler.prototype.constraintHandler = null;
mxConnectionHandler.prototype.error = null;
mxConnectionHandler.prototype.waypointsEnabled = !1;
mxConnectionHandler.prototype.ignoreMouseDown = !1;
mxConnectionHandler.prototype.first = null;
mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);
mxConnectionHandler.prototype.edgeState = null;
mxConnectionHandler.prototype.changeHandler = null;
mxConnectionHandler.prototype.drillHandler = null;
mxConnectionHandler.prototype.mouseDownCounter = 0;
mxConnectionHandler.prototype.movePreviewAway = !1;
mxConnectionHandler.prototype.outlineConnect = !1;
mxConnectionHandler.prototype.livePreview = !1;
mxConnectionHandler.prototype.cursor = null;
mxConnectionHandler.prototype.insertBeforeSource = !1;
mxConnectionHandler.prototype.isEnabled = function () {
  return this.enabled;
};
mxConnectionHandler.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxConnectionHandler.prototype.isInsertBefore = function (a, b, c, d, e) {
  return this.insertBeforeSource && b != c;
};
mxConnectionHandler.prototype.isCreateTarget = function (a) {
  return this.createTarget;
};
mxConnectionHandler.prototype.setCreateTarget = function (a) {
  this.createTarget = a;
};
mxConnectionHandler.prototype.createShape = function () {
  var a =
    this.livePreview && null != this.edgeState
      ? this.graph.cellRenderer.createShape(this.edgeState)
      : new mxPolyline([], mxConstants.INVALID_COLOR);
  a.dialect = mxConstants.DIALECT_SVG;
  a.scale = this.graph.view.scale;
  a.svgStrokeTolerance = 0;
  a.pointerEvents = !1;
  a.isDashed = !0;
  a.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(a.node, this.graph, null);
  return a;
};
mxConnectionHandler.prototype.init = function () {
  this.graph.addMouseListener(this);
  this.marker = this.createMarker();
  this.constraintHandler = new mxConstraintHandler(this.graph);
  this.changeHandler = mxUtils.bind(this, function (a) {
    null != this.iconState && (this.iconState = this.graph.getView().getState(this.iconState.cell));
    null != this.iconState
      ? (this.redrawIcons(this.icons, this.iconState), this.constraintHandler.reset())
      : null != this.previous && null == this.graph.view.getState(this.previous.cell) && this.reset();
  });
  this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);
  this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);
  this.drillHandler = mxUtils.bind(this, function (a) {
    this.reset();
  });
  this.graph.addListener(mxEvent.START_EDITING, this.drillHandler);
  this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);
  this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
};
mxConnectionHandler.prototype.isConnectableCell = function (a) {
  return !0;
};
mxConnectionHandler.prototype.createMarker = function () {
  var a = new mxCellMarker(this.graph);
  a.hotspotEnabled = !0;
  a.getCell = mxUtils.bind(this, function (b) {
    var c = mxCellMarker.prototype.getCell.apply(a, arguments);
    this.error = null;
    null == c && null != this.currentPoint && (c = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y));
    if (null != c && !this.graph.isCellConnectable(c)) {
      var d = this.graph.getModel().getParent(c);
      this.graph.getModel().isVertex(d) && this.graph.isCellConnectable(d) && (c = d);
    }
    if (
      (this.graph.isSwimlane(c) &&
        null != this.currentPoint &&
        this.graph.hitsSwimlaneContent(c, this.currentPoint.x, this.currentPoint.y)) ||
      !this.isConnectableCell(c)
    )
      c = null;
    null != c
      ? this.isConnecting()
        ? null != this.previous &&
          ((this.error = this.validateConnection(this.previous.cell, c)),
          null != this.error &&
            0 == this.error.length &&
            ((c = null), this.isCreateTarget(b.getEvent()) && (this.error = null)))
        : this.isValidSource(c, b) || (c = null)
      : !this.isConnecting() || this.isCreateTarget(b.getEvent()) || this.graph.allowDanglingEdges || (this.error = '');
    return c;
  });
  a.isValidState = mxUtils.bind(this, function (b) {
    return this.isConnecting() ? null == this.error : mxCellMarker.prototype.isValidState.apply(a, arguments);
  });
  a.getMarkerColor = mxUtils.bind(this, function (b, c, d) {
    return null == this.connectImage || this.isConnecting()
      ? mxCellMarker.prototype.getMarkerColor.apply(a, arguments)
      : null;
  });
  a.intersects = mxUtils.bind(this, function (b, c) {
    return null != this.connectImage || this.isConnecting()
      ? !0
      : mxCellMarker.prototype.intersects.apply(a, arguments);
  });
  return a;
};
mxConnectionHandler.prototype.start = function (a, b, c, d) {
  this.previous = a;
  this.first = new mxPoint(b, c);
  this.edgeState = null != d ? d : this.createEdgeState(null);
  this.marker.currentColor = this.marker.validColor;
  this.marker.markedState = a;
  this.marker.mark();
  this.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));
};
mxConnectionHandler.prototype.isConnecting = function () {
  return null != this.first && null != this.shape;
};
mxConnectionHandler.prototype.isValidSource = function (a, b) {
  return this.graph.isValidSource(a);
};
mxConnectionHandler.prototype.isValidTarget = function (a) {
  return !0;
};
mxConnectionHandler.prototype.validateConnection = function (a, b) {
  return this.isValidTarget(b) ? this.graph.getEdgeValidationError(null, a, b) : '';
};
mxConnectionHandler.prototype.getConnectImage = function (a) {
  return this.connectImage;
};
mxConnectionHandler.prototype.isMoveIconToFrontForState = function (a) {
  return null != a.text && a.text.node.parentNode == this.graph.container ? !0 : this.moveIconFront;
};
mxConnectionHandler.prototype.createIcons = function (a) {
  var b = this.getConnectImage(a);
  if (null != b && null != a) {
    this.iconState = a;
    var c = [],
      d = new mxRectangle(0, 0, b.width, b.height),
      e = new mxImageShape(d, b.src, null, null, 0);
    e.preserveImageAspect = !1;
    this.isMoveIconToFrontForState(a)
      ? ((e.dialect = mxConstants.DIALECT_STRICTHTML), e.init(this.graph.container))
      : ((e.dialect = mxConstants.DIALECT_SVG),
        e.init(this.graph.getView().getOverlayPane()),
        this.moveIconBack &&
          null != e.node.previousSibling &&
          e.node.parentNode.insertBefore(e.node, e.node.parentNode.firstChild));
    e.node.style.cursor = mxConstants.CURSOR_CONNECT;
    var f = mxUtils.bind(this, function () {
        return null != this.currentState ? this.currentState : a;
      }),
      b = mxUtils.bind(this, function (a) {
        mxEvent.isConsumed(a) ||
          ((this.icon = e), this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a, f())));
      });
    mxEvent.redirectMouseEvents(e.node, this.graph, f, b);
    c.push(e);
    this.redrawIcons(c, this.iconState);
    return c;
  }
  return null;
};
mxConnectionHandler.prototype.redrawIcons = function (a, b) {
  if (null != a && null != a[0] && null != b) {
    var c = this.getIconPosition(a[0], b);
    a[0].bounds.x = c.x;
    a[0].bounds.y = c.y;
    a[0].redraw();
  }
};
mxConnectionHandler.prototype.getIconPosition = function (a, b) {
  var c = this.graph.getView().scale,
    d = b.getCenterX(),
    e = b.getCenterY();
  if (this.graph.isSwimlane(b.cell)) {
    var f = this.graph.getStartSize(b.cell),
      d = 0 != f.width ? b.x + (f.width * c) / 2 : d,
      e = 0 != f.height ? b.y + (f.height * c) / 2 : e,
      f = mxUtils.toRadians(mxUtils.getValue(b.style, mxConstants.STYLE_ROTATION) || 0);
    if (0 != f)
      var c = Math.cos(f),
        f = Math.sin(f),
        g = new mxPoint(b.getCenterX(), b.getCenterY()),
        e = mxUtils.getRotatedPoint(new mxPoint(d, e), c, f, g),
        d = e.x,
        e = e.y;
  }
  return new mxPoint(d - a.bounds.width / 2, e - a.bounds.height / 2);
};
mxConnectionHandler.prototype.destroyIcons = function () {
  if (null != this.icons) {
    for (var a = 0; a < this.icons.length; a++) this.icons[a].destroy();
    this.iconState = this.selectedIcon = this.icon = this.icons = null;
  }
};
mxConnectionHandler.prototype.isStartEvent = function (a) {
  return (
    (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint) ||
    (null != this.previous && null == this.error && (null == this.icons || (null != this.icons && null != this.icon)))
  );
};
mxConnectionHandler.prototype.mouseDown = function (a, b) {
  this.mouseDownCounter++;
  if (this.isEnabled() && this.graph.isEnabled() && !b.isConsumed() && !this.isConnecting() && this.isStartEvent(b)) {
    null != this.constraintHandler.currentConstraint &&
    null != this.constraintHandler.currentFocus &&
    null != this.constraintHandler.currentPoint
      ? ((this.sourceConstraint = this.constraintHandler.currentConstraint),
        (this.previous = this.constraintHandler.currentFocus),
        (this.first = this.constraintHandler.currentPoint.clone()))
      : (this.first = new mxPoint(b.getGraphX(), b.getGraphY()));
    this.edgeState = this.createEdgeState(b);
    this.mouseDownCounter = 1;
    this.waypointsEnabled &&
      null == this.shape &&
      ((this.waypoints = null),
      (this.shape = this.createShape()),
      null != this.edgeState && this.shape.apply(this.edgeState));
    if (null == this.previous && null != this.edgeState) {
      var c = this.graph.getPointForEvent(b.getEvent());
      this.edgeState.cell.geometry.setTerminalPoint(c, !0);
    }
    this.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));
    b.consume();
  }
  this.selectedIcon = this.icon;
  this.icon = null;
};
mxConnectionHandler.prototype.isImmediateConnectSource = function (a) {
  return !this.graph.isCellMovable(a.cell);
};
mxConnectionHandler.prototype.createEdgeState = function (a) {
  return null;
};
mxConnectionHandler.prototype.isOutlineConnectEvent = function (a) {
  if (mxEvent.isShiftDown(a.getEvent()) && mxEvent.isAltDown(a.getEvent())) return !1;
  var b = mxUtils.getOffset(this.graph.container),
    c = a.getEvent(),
    d = mxEvent.getClientX(c),
    c = mxEvent.getClientY(c),
    e = document.documentElement,
    f =
      this.currentPoint.x -
      this.graph.container.scrollLeft +
      b.x -
      ((window.pageXOffset || e.scrollLeft) - (e.clientLeft || 0)),
    b =
      this.currentPoint.y -
      this.graph.container.scrollTop +
      b.y -
      ((window.pageYOffset || e.scrollTop) - (e.clientTop || 0));
  return (
    this.outlineConnect &&
    ((mxEvent.isShiftDown(a.getEvent()) && !mxEvent.isAltDown(a.getEvent())) ||
      a.isSource(this.marker.highlight.shape) ||
      (!mxEvent.isShiftDown(a.getEvent()) && mxEvent.isAltDown(a.getEvent()) && null != a.getState()) ||
      this.marker.highlight.isHighlightAt(d, c) ||
      ((f != d || b != c) && null == a.getState() && this.marker.highlight.isHighlightAt(f, b)))
  );
};
mxConnectionHandler.prototype.updateCurrentState = function (a, b) {
  this.constraintHandler.update(
    a,
    null == this.first,
    !1,
    null == this.first || a.isSource(this.marker.highlight.shape) ? null : b
  );
  if (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint)
    null != this.marker.highlight &&
    null != this.marker.highlight.state &&
    this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell
      ? 'transparent' != this.marker.highlight.shape.stroke &&
        ((this.marker.highlight.shape.stroke = 'transparent'), this.marker.highlight.repaint())
      : this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent'),
      null != this.previous &&
        ((this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell)),
        null == this.error && (this.currentState = this.constraintHandler.currentFocus),
        (null != this.error || (null != this.currentState && !this.isCellEnabled(this.currentState.cell))) &&
          this.constraintHandler.reset());
  else {
    this.graph.isIgnoreTerminalEvent(a.getEvent())
      ? (this.marker.reset(), (this.currentState = null))
      : (this.marker.process(a), (this.currentState = this.marker.getValidState()));
    null == this.currentState ||
      this.isCellEnabled(this.currentState.cell) ||
      (this.constraintHandler.reset(), this.marker.reset(), (this.currentState = null));
    var c = this.isOutlineConnectEvent(a);
    null != this.currentState &&
      c &&
      (a.isSource(this.marker.highlight.shape) && (b = new mxPoint(a.getGraphX(), a.getGraphY())),
      (c = this.graph.getOutlineConstraint(b, this.currentState, a)),
      this.constraintHandler.setFocus(a, this.currentState, !1),
      (this.constraintHandler.currentConstraint = c),
      (this.constraintHandler.currentPoint = b));
    this.outlineConnect &&
      null != this.marker.highlight &&
      null != this.marker.highlight.shape &&
      ((c = this.graph.view.scale),
      null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus
        ? ((this.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR),
          (this.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / c / c),
          this.marker.highlight.repaint())
        : this.marker.hasValidState() &&
          (this.graph.isCellConnectable(a.getCell()) && this.marker.getValidState() != a.getState()
            ? ((this.marker.highlight.shape.stroke = 'transparent'), (this.currentState = null))
            : (this.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR),
          (this.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / c / c),
          this.marker.highlight.repaint()));
  }
};
mxConnectionHandler.prototype.isCellEnabled = function (a) {
  return !0;
};
mxConnectionHandler.prototype.convertWaypoint = function (a) {
  var b = this.graph.getView().getScale(),
    c = this.graph.getView().getTranslate();
  a.x = a.x / b - c.x;
  a.y = a.y / b - c.y;
};
mxConnectionHandler.prototype.snapToPreview = function (a, b) {
  if (!mxEvent.isAltDown(a.getEvent()) && null != this.previous) {
    var c = (this.graph.gridSize * this.graph.view.scale) / 2,
      d =
        null != this.sourceConstraint
          ? this.first
          : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY());
    Math.abs(d.x - a.getGraphX()) < c && (b.x = d.x);
    Math.abs(d.y - a.getGraphY()) < c && (b.y = d.y);
  }
};
mxConnectionHandler.prototype.mouseMove = function (a, b) {
  if (b.isConsumed() || (!this.ignoreMouseDown && null == this.first && this.graph.isMouseDown))
    this.constraintHandler.reset();
  else {
    this.isEnabled() || null == this.currentState || (this.destroyIcons(), (this.currentState = null));
    var c = this.graph.getView(),
      d = c.scale,
      e = c.translate,
      c = new mxPoint(b.getGraphX(), b.getGraphY());
    this.error = null;
    this.graph.isGridEnabledEvent(b.getEvent()) &&
      (c = new mxPoint((this.graph.snap(c.x / d - e.x) + e.x) * d, (this.graph.snap(c.y / d - e.y) + e.y) * d));
    this.snapToPreview(b, c);
    this.currentPoint = c;
    (null != this.first || (this.isEnabled() && this.graph.isEnabled())) &&
      (null != this.shape ||
        null == this.first ||
        Math.abs(b.getGraphX() - this.first.x) > this.graph.tolerance ||
        Math.abs(b.getGraphY() - this.first.y) > this.graph.tolerance) &&
      this.updateCurrentState(b, c);
    if (null != this.first) {
      var f = null,
        d = c;
      null != this.constraintHandler.currentConstraint &&
      null != this.constraintHandler.currentFocus &&
      null != this.constraintHandler.currentPoint
        ? ((f = this.constraintHandler.currentConstraint), (d = this.constraintHandler.currentPoint.clone()))
        : null != this.previous &&
          mxEvent.isShiftDown(b.getEvent()) &&
          !this.graph.isIgnoreTerminalEvent(b.getEvent()) &&
          (Math.abs(this.previous.getCenterX() - c.x) < Math.abs(this.previous.getCenterY() - c.y)
            ? (c.x = this.previous.getCenterX())
            : (c.y = this.previous.getCenterY()));
      e = this.first;
      if (null != this.selectedIcon) {
        var g = this.selectedIcon.bounds.width,
          k = this.selectedIcon.bounds.height;
        null != this.currentState && this.targetConnectImage
          ? ((g = this.getIconPosition(this.selectedIcon, this.currentState)),
            (this.selectedIcon.bounds.x = g.x),
            (this.selectedIcon.bounds.y = g.y))
          : ((g = new mxRectangle(
              b.getGraphX() + this.connectIconOffset.x,
              b.getGraphY() + this.connectIconOffset.y,
              g,
              k
            )),
            (this.selectedIcon.bounds = g));
        this.selectedIcon.redraw();
      }
      null != this.edgeState
        ? (this.updateEdgeState(d, f),
          (d = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1]),
          (e = this.edgeState.absolutePoints[0]))
        : (null != this.currentState &&
            null == this.constraintHandler.currentConstraint &&
            ((g = this.getTargetPerimeterPoint(this.currentState, b)), null != g && (d = g)),
          null == this.sourceConstraint &&
            null != this.previous &&
            ((g = this.getSourcePerimeterPoint(
              this.previous,
              null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[0] : d,
              b
            )),
            null != g && (e = g)));
      if (null == this.currentState && this.movePreviewAway) {
        g = e;
        null != this.edgeState &&
          2 <= this.edgeState.absolutePoints.length &&
          ((f = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2]), null != f && (g = f));
        f = d.x - g.x;
        g = d.y - g.y;
        k = Math.sqrt(f * f + g * g);
        if (0 == k) return;
        this.originalPoint = d.clone();
        d.x -= (4 * f) / k;
        d.y -= (4 * g) / k;
      } else this.originalPoint = null;
      null == this.shape &&
        ((f = Math.abs(b.getGraphX() - this.first.x)),
        (g = Math.abs(b.getGraphY() - this.first.y)),
        f > this.graph.tolerance || g > this.graph.tolerance) &&
        ((this.shape = this.createShape()),
        null != this.edgeState && this.shape.apply(this.edgeState),
        this.updateCurrentState(b, c));
      null != this.shape &&
        (null != this.edgeState
          ? (this.shape.points = this.edgeState.absolutePoints)
          : ((c = [e]), null != this.waypoints && (c = c.concat(this.waypoints)), c.push(d), (this.shape.points = c)),
        this.drawPreview());
      null != this.cursor && (this.graph.container.style.cursor = this.cursor);
      mxEvent.consume(b.getEvent());
      b.consume();
    } else
      this.isEnabled() && this.graph.isEnabled()
        ? this.previous != this.currentState && null == this.edgeState
          ? (this.destroyIcons(),
            null != this.currentState &&
              null == this.error &&
              null == this.constraintHandler.currentConstraint &&
              ((this.icons = this.createIcons(this.currentState)),
              null == this.icons && (this.currentState.setCursor(mxConstants.CURSOR_CONNECT), b.consume())),
            (this.previous = this.currentState))
          : this.previous != this.currentState ||
            null == this.currentState ||
            null != this.icons ||
            this.graph.isMouseDown ||
            b.consume()
        : this.constraintHandler.reset();
    if (!this.graph.isMouseDown && null != this.currentState && null != this.icons) {
      c = !1;
      d = b.getSource();
      for (e = 0; e < this.icons.length && !c; e++) c = d == this.icons[e].node || d.parentNode == this.icons[e].node;
      c || this.updateIcons(this.currentState, this.icons, b);
    }
  }
};
mxConnectionHandler.prototype.updateEdgeState = function (a, b) {
  null != this.sourceConstraint &&
    null != this.sourceConstraint.point &&
    ((this.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x),
    (this.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y));
  null != b && null != b.point
    ? ((this.edgeState.style[mxConstants.STYLE_ENTRY_X] = b.point.x),
      (this.edgeState.style[mxConstants.STYLE_ENTRY_Y] = b.point.y))
    : (delete this.edgeState.style[mxConstants.STYLE_ENTRY_X], delete this.edgeState.style[mxConstants.STYLE_ENTRY_Y]);
  this.edgeState.absolutePoints = [null, null != this.currentState ? null : a];
  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, !0, this.sourceConstraint);
  null != this.currentState &&
    (null == b && (b = this.graph.getConnectionConstraint(this.edgeState, this.previous, !1)),
    this.edgeState.setAbsoluteTerminalPoint(null, !1),
    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, !1, b));
  var c = null;
  if (null != this.waypoints)
    for (var c = [], d = 0; d < this.waypoints.length; d++) {
      var e = this.waypoints[d].clone();
      this.convertWaypoint(e);
      c[d] = e;
    }
  this.graph.view.updatePoints(this.edgeState, c, this.previous, this.currentState);
  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
};
mxConnectionHandler.prototype.getTargetPerimeterPoint = function (a, b) {
  var c = null,
    d = a.view,
    e = d.getPerimeterFunction(a);
  if (null != e) {
    var f =
        null != this.waypoints && 0 < this.waypoints.length
          ? this.waypoints[this.waypoints.length - 1]
          : new mxPoint(this.previous.getCenterX(), this.previous.getCenterY()),
      d = e(d.getPerimeterBounds(a), this.edgeState, f, !1);
    null != d && (c = d);
  } else c = new mxPoint(a.getCenterX(), a.getCenterY());
  return c;
};
mxConnectionHandler.prototype.getSourcePerimeterPoint = function (a, b, c) {
  c = null;
  var d = a.view,
    e = d.getPerimeterFunction(a),
    f = new mxPoint(a.getCenterX(), a.getCenterY());
  if (null != e) {
    var g = mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0),
      k = (Math.PI / 180) * -g;
    0 != g && (b = mxUtils.getRotatedPoint(new mxPoint(b.x, b.y), Math.cos(k), Math.sin(k), f));
    a = e(d.getPerimeterBounds(a), a, b, !1);
    null != a &&
      (0 != g && (a = mxUtils.getRotatedPoint(new mxPoint(a.x, a.y), Math.cos(-k), Math.sin(-k), f)), (c = a));
  } else c = f;
  return c;
};
mxConnectionHandler.prototype.updateIcons = function (a, b, c) {};
mxConnectionHandler.prototype.isStopEvent = function (a) {
  return null != a.getState();
};
mxConnectionHandler.prototype.addWaypointForEvent = function (a) {
  var b = mxUtils.convertPoint(this.graph.container, a.getX(), a.getY()),
    c = Math.abs(b.x - this.first.x),
    b = Math.abs(b.y - this.first.y);
  if (null != this.waypoints || (1 < this.mouseDownCounter && (c > this.graph.tolerance || b > this.graph.tolerance)))
    null == this.waypoints && (this.waypoints = []),
      (c = this.graph.view.scale),
      (b = new mxPoint(this.graph.snap(a.getGraphX() / c) * c, this.graph.snap(a.getGraphY() / c) * c)),
      this.waypoints.push(b);
};
mxConnectionHandler.prototype.checkConstraints = function (a, b) {
  return (
    null == a ||
    null == b ||
    null == a.point ||
    null == b.point ||
    !a.point.equals(b.point) ||
    a.dx != b.dx ||
    a.dy != b.dy ||
    a.perimeter != b.perimeter
  );
};
mxConnectionHandler.prototype.mouseUp = function (a, b) {
  if (!b.isConsumed() && this.isConnecting()) {
    if (this.waypointsEnabled && !this.isStopEvent(b)) {
      this.addWaypointForEvent(b);
      b.consume();
      return;
    }
    var c = this.sourceConstraint,
      d = this.constraintHandler.currentConstraint,
      e = null != this.previous ? this.previous.cell : null,
      f = null;
    null != this.constraintHandler.currentConstraint &&
      null != this.constraintHandler.currentFocus &&
      (f = this.constraintHandler.currentFocus.cell);
    null == f && null != this.currentState && (f = this.currentState.cell);
    null != this.error || (null != e && null != f && e == f && !this.checkConstraints(c, d))
      ? (null != this.previous &&
          null != this.marker.validState &&
          this.previous.cell == this.marker.validState.cell &&
          this.graph.selectCellForEvent(this.marker.source, b.getEvent()),
        null != this.error && 0 < this.error.length && this.graph.validationAlert(this.error))
      : this.connect(e, f, b.getEvent(), b.getCell());
    this.destroyIcons();
    b.consume();
  }
  null != this.first && this.reset();
};
mxConnectionHandler.prototype.reset = function () {
  null != this.shape && (this.shape.destroy(), (this.shape = null));
  null != this.cursor && null != this.graph.container && (this.graph.container.style.cursor = '');
  this.destroyIcons();
  this.marker.reset();
  this.constraintHandler.reset();
  this.sourceConstraint = this.error = this.previous = this.edgeState = this.currentPoint = this.originalPoint = null;
  this.mouseDownCounter = 0;
  this.first = null;
  this.fireEvent(new mxEventObject(mxEvent.RESET));
};
mxConnectionHandler.prototype.drawPreview = function () {
  this.updatePreview(null == this.error);
  null != this.edgeState &&
    ((this.edgeState.shape = this.shape),
    this.graph.cellRenderer.postConfigureShape(this.edgeState),
    (this.edgeState.shape = null));
  this.shape.redraw();
};
mxConnectionHandler.prototype.updatePreview = function (a) {
  this.shape.strokewidth = this.getEdgeWidth(a);
  this.shape.stroke = this.getEdgeColor(a);
};
mxConnectionHandler.prototype.getEdgeColor = function (a) {
  return a ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;
};
mxConnectionHandler.prototype.getEdgeWidth = function (a) {
  return a ? 3 : 1;
};
mxConnectionHandler.prototype.connect = function (a, b, c, d) {
  if (null != b || this.isCreateTarget(c) || this.graph.allowDanglingEdges) {
    var e = this.graph.getModel(),
      f = !1,
      g = null;
    e.beginUpdate();
    try {
      if (
        null != a &&
        null == b &&
        !this.graph.isIgnoreTerminalEvent(c) &&
        this.isCreateTarget(c) &&
        ((b = this.createTargetVertex(c, a)), null != b)
      ) {
        d = this.graph.getDropTarget([b], c, d);
        f = !0;
        if (null != d && this.graph.getModel().isEdge(d)) d = this.graph.getDefaultParent();
        else {
          var k = this.graph.getView().getState(d);
          if (null != k) {
            var h = e.getGeometry(b);
            h.x -= k.origin.x;
            h.y -= k.origin.y;
          }
        }
        this.graph.addCell(b, d);
      }
      var l = this.graph.getDefaultParent();
      null != a &&
        null != b &&
        e.getParent(a) == e.getParent(b) &&
        e.getParent(e.getParent(a)) != e.getRoot() &&
        ((l = e.getParent(a)),
        null != a.geometry && a.geometry.relative && null != b.geometry && b.geometry.relative && (l = e.getParent(l)));
      var m = (k = null);
      null != this.edgeState && ((k = this.edgeState.cell.value), (m = this.edgeState.cell.style));
      g = this.insertEdge(l, null, k, a, b, m);
      if (null != g) {
        this.graph.setConnectionConstraint(g, a, !0, this.sourceConstraint);
        this.graph.setConnectionConstraint(g, b, !1, this.constraintHandler.currentConstraint);
        null != this.edgeState && e.setGeometry(g, this.edgeState.cell.geometry);
        l = e.getParent(a);
        if (this.isInsertBefore(g, a, b, c, d)) {
          for (h = a; null != h.parent && null != h.geometry && h.geometry.relative && h.parent != g.parent; )
            h = this.graph.model.getParent(h);
          null != h && null != h.parent && h.parent == g.parent && e.add(l, g, h.parent.getIndex(h));
        }
        var n = e.getGeometry(g);
        null == n && ((n = new mxGeometry()), (n.relative = !0), e.setGeometry(g, n));
        if (null != this.waypoints && 0 < this.waypoints.length) {
          var p = this.graph.view.scale,
            r = this.graph.view.translate;
          n.points = [];
          for (a = 0; a < this.waypoints.length; a++) {
            var t = this.waypoints[a];
            n.points.push(new mxPoint(t.x / p - r.x, t.y / p - r.y));
          }
        }
        if (null == b) {
          var u = this.graph.view.translate,
            p = this.graph.view.scale,
            t =
              null != this.originalPoint
                ? new mxPoint(this.originalPoint.x / p - u.x, this.originalPoint.y / p - u.y)
                : new mxPoint(this.currentPoint.x / p - u.x, this.currentPoint.y / p - u.y);
          t.x -= this.graph.panDx / this.graph.view.scale;
          t.y -= this.graph.panDy / this.graph.view.scale;
          n.setTerminalPoint(t, !1);
        }
        this.fireEvent(
          new mxEventObject(mxEvent.CONNECT, 'cell', g, 'terminal', b, 'event', c, 'target', d, 'terminalInserted', f)
        );
      }
    } catch (x) {
      mxLog.show(), mxLog.debug(x.message);
    } finally {
      e.endUpdate();
    }
    this.select && this.selectCells(g, f ? b : null);
  }
};
mxConnectionHandler.prototype.selectCells = function (a, b) {
  this.graph.setSelectionCell(a);
};
mxConnectionHandler.prototype.insertEdge = function (a, b, c, d, e, f) {
  if (null == this.factoryMethod) return this.graph.insertEdge(a, b, c, d, e, f);
  b = this.createEdge(c, d, e, f);
  return (b = this.graph.addEdge(b, a, d, e));
};
mxConnectionHandler.prototype.createTargetVertex = function (a, b) {
  for (var c = this.graph.getCellGeometry(b); null != c && c.relative; )
    (b = this.graph.getModel().getParent(b)), (c = this.graph.getCellGeometry(b));
  var d = this.graph.cloneCell(b),
    c = this.graph.getModel().getGeometry(d);
  if (null != c) {
    var e = this.graph.view.translate,
      f = this.graph.view.scale,
      g = new mxPoint(this.currentPoint.x / f - e.x, this.currentPoint.y / f - e.y);
    c.x = Math.round(g.x - c.width / 2 - this.graph.panDx / f);
    c.y = Math.round(g.y - c.height / 2 - this.graph.panDy / f);
    g = this.getAlignmentTolerance();
    if (0 < g) {
      var k = this.graph.view.getState(b);
      if (null != k) {
        var h = k.x / f - e.x,
          e = k.y / f - e.y;
        Math.abs(h - c.x) <= g && (c.x = Math.round(h));
        Math.abs(e - c.y) <= g && (c.y = Math.round(e));
      }
    }
  }
  return d;
};
mxConnectionHandler.prototype.getAlignmentTolerance = function (a) {
  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;
};
mxConnectionHandler.prototype.createEdge = function (a, b, c, d) {
  var e = null;
  null != this.factoryMethod && (e = this.factoryMethod(b, c, d));
  null == e &&
    ((e = new mxCell(a || '')),
    e.setEdge(!0),
    e.setStyle(d),
    (a = new mxGeometry()),
    (a.relative = !0),
    e.setGeometry(a));
  return e;
};
mxConnectionHandler.prototype.destroy = function () {
  this.graph.removeMouseListener(this);
  null != this.shape && (this.shape.destroy(), (this.shape = null));
  null != this.marker && (this.marker.destroy(), (this.marker = null));
  null != this.constraintHandler && (this.constraintHandler.destroy(), (this.constraintHandler = null));
  null != this.changeHandler &&
    (this.graph.getModel().removeListener(this.changeHandler),
    this.graph.getView().removeListener(this.changeHandler),
    (this.changeHandler = null));
  null != this.drillHandler &&
    (this.graph.removeListener(this.drillHandler),
    this.graph.getView().removeListener(this.drillHandler),
    (this.drillHandler = null));
  null != this.escapeHandler && (this.graph.removeListener(this.escapeHandler), (this.escapeHandler = null));
};
function mxConstraintHandler(a) {
  this.graph = a;
  this.resetHandler = mxUtils.bind(this, function (a, c) {
    null != this.currentFocus && null == this.graph.view.getState(this.currentFocus.cell)
      ? this.reset()
      : this.redraw();
  });
  this.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);
  this.graph.view.addListener(mxEvent.SCALE, this.resetHandler);
  this.graph.addListener(mxEvent.ROOT, this.resetHandler);
}
mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + '/point.gif', 5, 5);
mxConstraintHandler.prototype.graph = null;
mxConstraintHandler.prototype.enabled = !0;
mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;
mxConstraintHandler.prototype.isEnabled = function () {
  return this.enabled;
};
mxConstraintHandler.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxConstraintHandler.prototype.reset = function () {
  if (null != this.focusIcons) {
    for (var a = 0; a < this.focusIcons.length; a++) this.focusIcons[a].destroy();
    this.focusIcons = null;
  }
  null != this.focusHighlight && (this.focusHighlight.destroy(), (this.focusHighlight = null));
  this.focusPoints = this.currentFocus = this.currentPoint = this.currentFocusArea = this.currentConstraint = null;
};
mxConstraintHandler.prototype.getTolerance = function (a) {
  return this.graph.getTolerance();
};
mxConstraintHandler.prototype.getImageForConstraint = function (a, b, c) {
  return this.pointImage;
};
mxConstraintHandler.prototype.isEventIgnored = function (a, b) {
  return !1;
};
mxConstraintHandler.prototype.isStateIgnored = function (a, b) {
  return !1;
};
mxConstraintHandler.prototype.destroyIcons = function () {
  if (null != this.focusIcons) {
    for (var a = 0; a < this.focusIcons.length; a++) this.focusIcons[a].destroy();
    this.focusPoints = this.focusIcons = null;
  }
};
mxConstraintHandler.prototype.destroyFocusHighlight = function () {
  null != this.focusHighlight && (this.focusHighlight.destroy(), (this.focusHighlight = null));
};
mxConstraintHandler.prototype.isKeepFocusEvent = function (a) {
  return mxEvent.isShiftDown(a.getEvent()) && !mxEvent.isAltDown(a.getEvent());
};
mxConstraintHandler.prototype.getCellForEvent = function (a, b) {
  var c = a.getCell();
  null != c || null == b || (a.getGraphX() == b.x && a.getGraphY() == b.y) || (c = this.graph.getCellAt(b.x, b.y));
  if (null != c && !this.graph.isCellConnectable(c)) {
    var d = this.graph.getModel().getParent(c);
    this.graph.getModel().isVertex(d) && this.graph.isCellConnectable(d) && (c = d);
  }
  return this.graph.isCellLocked(c) ? null : c;
};
mxConstraintHandler.prototype.update = function (a, b, c, d) {
  if (this.isEnabled() && !this.isEventIgnored(a)) {
    null == this.mouseleaveHandler &&
      null != this.graph.container &&
      ((this.mouseleaveHandler = mxUtils.bind(this, function () {
        this.reset();
      })),
      mxEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler));
    var e = this.getTolerance(a),
      f = null != d ? d.x : a.getGraphX(),
      g = null != d ? d.y : a.getGraphY(),
      f = new mxRectangle(f - e, g - e, 2 * e, 2 * e),
      e = new mxRectangle(a.getGraphX() - e, a.getGraphY() - e, 2 * e, 2 * e),
      k = this.graph.view.getState(this.getCellForEvent(a, d));
    this.isKeepFocusEvent(a) ||
      (null != this.currentFocusArea &&
        null != this.currentFocus &&
        null == k &&
        this.graph.getModel().isVertex(this.currentFocus.cell) &&
        mxUtils.intersects(this.currentFocusArea, e)) ||
      k == this.currentFocus ||
      ((this.currentFocus = this.currentFocusArea = null), this.setFocus(a, k, b));
    a = this.currentPoint = this.currentConstraint = null;
    if (null != this.focusIcons && null != this.constraints && (null == k || this.currentFocus == k))
      for (var g = e.getCenterX(), h = e.getCenterY(), l = 0; l < this.focusIcons.length; l++) {
        var m = g - this.focusIcons[l].bounds.getCenterX(),
          n = h - this.focusIcons[l].bounds.getCenterY(),
          m = m * m + n * n;
        if (
          (this.intersects(this.focusIcons[l], e, b, c) ||
            (null != d && this.intersects(this.focusIcons[l], f, b, c))) &&
          (null == a || m < a)
        ) {
          this.currentConstraint = this.constraints[l];
          this.currentPoint = this.focusPoints[l];
          a = m;
          m = this.focusIcons[l].bounds.clone();
          m.grow(mxConstants.HIGHLIGHT_SIZE + 1);
          --m.width;
          --m.height;
          if (null == this.focusHighlight) {
            n = this.createHighlightShape();
            n.dialect = mxConstants.DIALECT_SVG;
            n.pointerEvents = !1;
            n.init(this.graph.getView().getOverlayPane());
            this.focusHighlight = n;
            var p = mxUtils.bind(this, function () {
              return null != this.currentFocus ? this.currentFocus : k;
            });
            mxEvent.redirectMouseEvents(n.node, this.graph, p);
          }
          this.focusHighlight.bounds = m;
          this.focusHighlight.redraw();
        }
      }
    null == this.currentConstraint && this.destroyFocusHighlight();
  } else this.currentPoint = this.currentFocus = this.currentConstraint = null;
};
mxConstraintHandler.prototype.redraw = function () {
  if (null != this.currentFocus && null != this.constraints && null != this.focusIcons) {
    var a = this.graph.view.getState(this.currentFocus.cell);
    this.currentFocus = a;
    this.currentFocusArea = new mxRectangle(a.x, a.y, a.width, a.height);
    for (var b = 0; b < this.constraints.length; b++) {
      var c = this.graph.getConnectionPoint(a, this.constraints[b]),
        d = this.getImageForConstraint(a, this.constraints[b], c),
        d = new mxRectangle(Math.round(c.x - d.width / 2), Math.round(c.y - d.height / 2), d.width, d.height);
      this.focusIcons[b].bounds = d;
      this.focusIcons[b].redraw();
      this.currentFocusArea.add(this.focusIcons[b].bounds);
      this.focusPoints[b] = c;
    }
  }
};
mxConstraintHandler.prototype.setFocus = function (a, b, c) {
  this.constraints =
    null != b && !this.isStateIgnored(b, c) && this.graph.isCellConnectable(b.cell)
      ? this.isEnabled()
        ? this.graph.getAllConnectionConstraints(b, c) || []
        : []
      : null;
  if (null != this.constraints) {
    this.currentFocus = b;
    this.currentFocusArea = new mxRectangle(b.x, b.y, b.width, b.height);
    if (null != this.focusIcons) {
      for (c = 0; c < this.focusIcons.length; c++) this.focusIcons[c].destroy();
      this.focusPoints = this.focusIcons = null;
    }
    this.focusPoints = [];
    this.focusIcons = [];
    for (c = 0; c < this.constraints.length; c++) {
      var d = this.graph.getConnectionPoint(b, this.constraints[c]),
        e = this.getImageForConstraint(b, this.constraints[c], d),
        f = e.src,
        e = new mxRectangle(Math.round(d.x - e.width / 2), Math.round(d.y - e.height / 2), e.width, e.height),
        f = new mxImageShape(e, f);
      f.dialect =
        this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;
      f.preserveImageAspect = !1;
      f.init(this.graph.getView().getDecoratorPane());
      null != f.node.previousSibling && f.node.parentNode.insertBefore(f.node, f.node.parentNode.firstChild);
      e = mxUtils.bind(this, function () {
        return null != this.currentFocus ? this.currentFocus : b;
      });
      f.redraw();
      mxEvent.redirectMouseEvents(f.node, this.graph, e);
      this.currentFocusArea.add(f.bounds);
      this.focusIcons.push(f);
      this.focusPoints.push(d);
    }
    this.currentFocusArea.grow(this.getTolerance(a));
  } else this.destroyIcons(), this.destroyFocusHighlight();
};
mxConstraintHandler.prototype.createHighlightShape = function () {
  var a = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);
  a.opacity = mxConstants.HIGHLIGHT_OPACITY;
  return a;
};
mxConstraintHandler.prototype.intersects = function (a, b, c, d) {
  return mxUtils.intersects(a.bounds, b);
};
mxConstraintHandler.prototype.destroy = function () {
  this.reset();
  null != this.resetHandler &&
    (this.graph.model.removeListener(this.resetHandler),
    this.graph.view.removeListener(this.resetHandler),
    this.graph.removeListener(this.resetHandler),
    (this.resetHandler = null));
  null != this.mouseleaveHandler &&
    null != this.graph.container &&
    (mxEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler),
    (this.mouseleaveHandler = null));
};
function mxHandle(a, b, c, d) {
  this.graph = a.view.graph;
  this.state = a;
  this.cursor = null != b ? b : this.cursor;
  this.image = null != c ? c : this.image;
  this.shape = null != d ? d : null;
  this.init();
}
mxHandle.prototype.cursor = 'default';
mxHandle.prototype.image = null;
mxHandle.prototype.ignoreGrid = !1;
mxHandle.prototype.getPosition = function (a) {};
mxHandle.prototype.setPosition = function (a, b, c) {};
mxHandle.prototype.execute = function (a) {};
mxHandle.prototype.copyStyle = function (a) {
  this.graph.setCellStyles(a, this.state.style[a], [this.state.cell]);
};
mxHandle.prototype.processEvent = function (a) {
  var b = this.graph.view.scale,
    c = this.graph.view.translate,
    c = new mxPoint(a.getGraphX() / b - c.x, a.getGraphY() / b - c.y);
  null != this.shape &&
    null != this.shape.bounds &&
    ((c.x -= this.shape.bounds.width / b / 4), (c.y -= this.shape.bounds.height / b / 4));
  var b = -mxUtils.toRadians(this.getRotation()),
    d = -mxUtils.toRadians(this.getTotalRotation()) - b,
    c = this.flipPoint(
      this.rotatePoint(
        this.snapPoint(this.rotatePoint(c, b), this.ignoreGrid || !this.graph.isGridEnabledEvent(a.getEvent())),
        d
      )
    );
  this.setPosition(this.state.getPaintBounds(), c, a);
  this.redraw();
};
mxHandle.prototype.positionChanged = function () {
  null != this.state.text && this.state.text.apply(this.state);
  null != this.state.shape && this.state.shape.apply(this.state);
  this.graph.cellRenderer.redraw(this.state, !0);
};
mxHandle.prototype.getRotation = function () {
  return null != this.state.shape ? this.state.shape.getRotation() : 0;
};
mxHandle.prototype.getTotalRotation = function () {
  return null != this.state.shape ? this.state.shape.getShapeRotation() : 0;
};
mxHandle.prototype.init = function () {
  var a = this.isHtmlRequired();
  null != this.image
    ? ((this.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src)),
      (this.shape.preserveImageAspect = !1))
    : null == this.shape && (this.shape = this.createShape(a));
  this.initShape(a);
};
mxHandle.prototype.createShape = function (a) {
  a = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);
  return new mxRectangleShape(a, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
};
mxHandle.prototype.initShape = function (a) {
  a && this.shape.isHtmlAllowed()
    ? ((this.shape.dialect = mxConstants.DIALECT_STRICTHTML), this.shape.init(this.graph.container))
    : ((this.shape.dialect =
        this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG),
      null != this.cursor && this.shape.init(this.graph.getView().getOverlayPane()));
  mxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
  this.shape.node.style.cursor = this.cursor;
};
mxHandle.prototype.redraw = function () {
  if (null != this.shape && null != this.state.shape) {
    var a = this.getPosition(this.state.getPaintBounds());
    if (null != a) {
      var b = mxUtils.toRadians(this.getTotalRotation()),
        a = this.rotatePoint(this.flipPoint(a), b),
        b = this.graph.view.scale,
        c = this.graph.view.translate;
      this.shape.bounds.x = Math.floor((a.x + c.x) * b - this.shape.bounds.width / 2);
      this.shape.bounds.y = Math.floor((a.y + c.y) * b - this.shape.bounds.height / 2);
      this.shape.redraw();
    }
  }
};
mxHandle.prototype.isHtmlRequired = function () {
  return null != this.state.text && this.state.text.node.parentNode == this.graph.container;
};
mxHandle.prototype.rotatePoint = function (a, b) {
  var c = this.state.getCellBounds(),
    c = new mxPoint(c.getCenterX(), c.getCenterY());
  return mxUtils.getRotatedPoint(a, Math.cos(b), Math.sin(b), c);
};
mxHandle.prototype.flipPoint = function (a) {
  if (null != this.state.shape) {
    var b = this.state.getCellBounds();
    this.state.shape.flipH && (a.x = 2 * b.x + b.width - a.x);
    this.state.shape.flipV && (a.y = 2 * b.y + b.height - a.y);
  }
  return a;
};
mxHandle.prototype.snapPoint = function (a, b) {
  b || ((a.x = this.graph.snap(a.x)), (a.y = this.graph.snap(a.y)));
  return a;
};
mxHandle.prototype.setVisible = function (a) {
  null != this.shape && null != this.shape.node && (this.shape.node.style.display = a ? '' : 'none');
};
mxHandle.prototype.reset = function () {
  this.setVisible(!0);
  this.state.style = this.graph.getCellStyle(this.state.cell);
  this.positionChanged();
};
mxHandle.prototype.destroy = function () {
  null != this.shape && (this.shape.destroy(), (this.shape = null));
};
function mxTooltipHandler(a, b) {
  null != a && ((this.graph = a), (this.delay = b || 500), this.graph.addMouseListener(this));
}
mxTooltipHandler.prototype.zIndex = 10005;
mxTooltipHandler.prototype.graph = null;
mxTooltipHandler.prototype.delay = null;
mxTooltipHandler.prototype.ignoreTouchEvents = !0;
mxTooltipHandler.prototype.hideOnHover = !1;
mxTooltipHandler.prototype.destroyed = !1;
mxTooltipHandler.prototype.enabled = !0;
mxTooltipHandler.prototype.isEnabled = function () {
  return this.enabled;
};
mxTooltipHandler.prototype.setEnabled = function (a) {
  this.enabled = a;
};
mxTooltipHandler.prototype.isHideOnHover = function () {
  return this.hideOnHover;
};
mxTooltipHandler.prototype.setHideOnHover = function (a) {
  this.hideOnHover = a;
};
mxTooltipHandler.prototype.init = function () {
  null != document.body &&
    ((this.div = document.createElement('div')),
    (this.div.className = 'mxTooltip'),
    (this.div.style.visibility = 'hidden'),
    document.body.appendChild(this.div),
    mxEvent.addGestureListeners(
      this.div,
      mxUtils.bind(this, function (a) {
        'A' != mxEvent.getSource(a).nodeName && this.hideTooltip();
      })
    ));
};
mxTooltipHandler.prototype.getStateForEvent = function (a) {
  return a.getState();
};
mxTooltipHandler.prototype.mouseDown = function (a, b) {
  this.reset(b, !1);
  this.hideTooltip();
};
mxTooltipHandler.prototype.mouseMove = function (a, b) {
  if (b.getX() != this.lastX || b.getY() != this.lastY) {
    this.reset(b, !0);
    var c = this.getStateForEvent(b);
    (this.isHideOnHover() ||
      c != this.state ||
      (b.getSource() != this.node &&
        (!this.stateSource || (null != c && this.stateSource == (b.isSource(c.shape) || !b.isSource(c.text)))))) &&
      this.hideTooltip();
  }
  this.lastX = b.getX();
  this.lastY = b.getY();
};
mxTooltipHandler.prototype.mouseUp = function (a, b) {
  this.reset(b, !0);
  this.hideTooltip();
};
mxTooltipHandler.prototype.resetTimer = function () {
  null != this.thread && (window.clearTimeout(this.thread), (this.thread = null));
};
mxTooltipHandler.prototype.reset = function (a, b, c) {
  if (!this.ignoreTouchEvents || mxEvent.isMouseEvent(a.getEvent()))
    if (
      (this.resetTimer(),
      (c = null != c ? c : this.getStateForEvent(a)),
      b && this.isEnabled() && null != c && (null == this.div || 'hidden' == this.div.style.visibility))
    ) {
      var d = a.getSource(),
        e = a.getX(),
        f = a.getY(),
        g = a.isSource(c.shape) || a.isSource(c.text);
      this.thread = window.setTimeout(
        mxUtils.bind(this, function () {
          if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
            var a = this.graph.getTooltip(c, d, e, f);
            this.show(a, e, f);
            this.state = c;
            this.node = d;
            this.stateSource = g;
          }
        }),
        this.delay
      );
    }
};
mxTooltipHandler.prototype.hide = function () {
  this.resetTimer();
  this.hideTooltip();
};
mxTooltipHandler.prototype.hideTooltip = function () {
  null != this.div && ((this.div.style.visibility = 'hidden'), (this.div.innerHTML = ''));
};
mxTooltipHandler.prototype.show = function (a, b, c) {
  if (!this.destroyed && null != a && 0 < a.length) {
    null == this.div && this.init();
    var d = mxUtils.getScrollOrigin();
    this.div.style.zIndex = this.zIndex;
    this.div.style.left = b + d.x + 'px';
    this.div.style.top = c + mxConstants.TOOLTIP_VERTICAL_OFFSET + d.y + 'px';
    mxUtils.isNode(a)
      ? ((this.div.innerHTML = ''), this.div.appendChild(a))
      : (this.div.innerHTML = a.replace(/\n/g, '<br>'));
    this.div.style.visibility = '';
    mxUtils.fit(this.div);
  }
};
mxTooltipHandler.prototype.destroy = function () {
  this.destroyed ||
    (this.graph.removeMouseListener(this),
    mxEvent.release(this.div),
    null != this.div && null != this.div.parentNode && this.div.parentNode.removeChild(this.div),
    (this.destroyed = !0),
    (this.div = null));
};
function mxCellHighlight(a, b, c, d) {
  null != a &&
    ((this.graph = a),
    (this.highlightColor = null != b ? b : mxConstants.DEFAULT_VALID_COLOR),
    (this.strokeWidth = null != c ? c : mxConstants.HIGHLIGHT_STROKEWIDTH),
    (this.dashed = null != d ? d : !1),
    (this.opacity = mxConstants.HIGHLIGHT_OPACITY),
    (this.repaintHandler = mxUtils.bind(this, function () {
      if (null != this.state) {
        var a = this.graph.view.getState(this.state.cell);
        null == a ? this.hide() : ((this.state = a), this.repaint());
      }
    })),
    this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler),
    this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler),
    this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler),
    this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler),
    (this.resetHandler = mxUtils.bind(this, function () {
      this.hide();
    })),
    this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler),
    this.graph.getView().addListener(mxEvent.UP, this.resetHandler));
}
mxCellHighlight.prototype.keepOnTop = !1;
mxCellHighlight.prototype.graph = null;
mxCellHighlight.prototype.state = null;
mxCellHighlight.prototype.spacing = 2;
mxCellHighlight.prototype.resetHandler = null;
mxCellHighlight.prototype.setHighlightColor = function (a) {
  this.highlightColor = a;
  null != this.shape && (this.shape.stroke = a);
};
mxCellHighlight.prototype.drawHighlight = function () {
  this.shape = this.createShape();
  this.repaint();
  this.keepOnTop ||
    this.shape.node.parentNode.firstChild == this.shape.node ||
    this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
};
mxCellHighlight.prototype.createShape = function () {
  var a = this.graph.cellRenderer.createShape(this.state);
  a.svgStrokeTolerance = this.graph.tolerance;
  a.points = this.state.absolutePoints;
  a.apply(this.state);
  a.stroke = this.highlightColor;
  a.opacity = this.opacity;
  a.isDashed = this.dashed;
  a.isShadow = !1;
  a.dialect = mxConstants.DIALECT_SVG;
  a.init(this.graph.getView().getOverlayPane());
  mxEvent.redirectMouseEvents(a.node, this.graph, this.state);
  this.graph.dialect != mxConstants.DIALECT_SVG ? (a.pointerEvents = !1) : (a.svgPointerEvents = 'stroke');
  return a;
};
mxCellHighlight.prototype.getStrokeWidth = function (a) {
  return this.strokeWidth;
};
mxCellHighlight.prototype.repaint = function () {
  null != this.state &&
    null != this.shape &&
    ((this.shape.scale = this.state.view.scale),
    this.graph.model.isEdge(this.state.cell)
      ? ((this.shape.strokewidth = this.getStrokeWidth()),
        (this.shape.points = this.state.absolutePoints),
        (this.shape.outline = !1))
      : ((this.shape.bounds = new mxRectangle(
          this.state.x - this.spacing,
          this.state.y - this.spacing,
          this.state.width + 2 * this.spacing,
          this.state.height + 2 * this.spacing
        )),
        (this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0')),
        (this.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale),
        (this.shape.outline = !0)),
    null != this.state.shape && this.shape.setCursor(this.state.shape.getCursor()),
    this.shape.redraw());
};
mxCellHighlight.prototype.hide = function () {
  this.highlight(null);
};
mxCellHighlight.prototype.highlight = function (a) {
  this.state != a &&
    (null != this.shape && (this.shape.destroy(), (this.shape = null)),
    (this.state = a),
    null != this.state && this.drawHighlight());
};
mxCellHighlight.prototype.isHighlightAt = function (a, b) {
  var c = !1;
  if (null != this.shape && null != document.elementFromPoint)
    for (var d = document.elementFromPoint(a, b); null != d; ) {
      if (d == this.shape.node) {
        c = !0;
        break;
      }
      d = d.parentNode;
    }
  return c;
};
mxCellHighlight.prototype.destroy = function () {
  this.graph.getView().removeListener(this.resetHandler);
  this.graph.getView().removeListener(this.repaintHandler);
  this.graph.getModel().removeListener(this.repaintHandler);
  null != this.shape && (this.shape.destroy(), (this.shape = null));
};
var mxCodecRegistry = {
  codecs: [],
  aliases: [],
  register: function (a) {
    if (null != a) {
      var b = a.getName();
      mxCodecRegistry.codecs[b] = a;
      var c = mxUtils.getFunctionName(a.template.constructor);
      c != b && mxCodecRegistry.addAlias(c, b);
    }
    return a;
  },
  addAlias: function (a, b) {
    mxCodecRegistry.aliases[a] = b;
  },
  getCodec: function (a) {
    var b = null;
    if (null != a) {
      var b = mxUtils.getFunctionName(a),
        c = mxCodecRegistry.aliases[b];
      null != c && (b = c);
      b = mxCodecRegistry.codecs[b];
      if (null == b)
        try {
          (b = new mxObjectCodec(new a())), mxCodecRegistry.register(b);
        } catch (d) {}
    }
    return b;
  },
};
function mxCodec(a) {
  this.document = a || mxUtils.createXmlDocument();
  this.objects = [];
}
mxCodec.prototype.document = null;
mxCodec.prototype.objects = null;
mxCodec.prototype.elements = null;
mxCodec.prototype.encodeDefaults = !1;
mxCodec.prototype.putObject = function (a, b) {
  return (this.objects[a] = b);
};
mxCodec.prototype.getObject = function (a) {
  var b = null;
  null != a &&
    ((b = this.objects[a]),
    null == b &&
      ((b = this.lookup(a)), null == b && ((a = this.getElementById(a)), null != a && (b = this.decode(a)))));
  return b;
};
mxCodec.prototype.lookup = function (a) {
  return null;
};
mxCodec.prototype.getElementById = function (a) {
  this.updateElements();
  return this.elements[a];
};
mxCodec.prototype.updateElements = function () {
  null == this.elements &&
    ((this.elements = {}), null != this.document.documentElement && this.addElement(this.document.documentElement));
};
mxCodec.prototype.addElement = function (a) {
  if (a.nodeType == mxConstants.NODETYPE_ELEMENT) {
    var b = a.getAttribute('id');
    if (null != b)
      if (null == this.elements[b]) this.elements[b] = a;
      else if (this.elements[b] != a) throw Error(b + ': Duplicate ID');
  }
  for (a = a.firstChild; null != a; ) this.addElement(a), (a = a.nextSibling);
};
mxCodec.prototype.getId = function (a) {
  var b = null;
  null != a &&
    ((b = this.reference(a)),
    null == b &&
      a instanceof mxCell &&
      ((b = a.getId()), null == b && ((b = mxCellPath.create(a)), 0 == b.length && (b = 'root'))));
  return b;
};
mxCodec.prototype.reference = function (a) {
  return null;
};
mxCodec.prototype.encode = function (a) {
  var b = null;
  if (null != a && null != a.constructor) {
    var c = mxCodecRegistry.getCodec(a.constructor);
    null != c
      ? (b = c.encode(this, a))
      : mxUtils.isNode(a)
      ? (b = mxUtils.importNode(this.document, a, !0))
      : mxLog.warn('mxCodec.encode: No codec for ' + mxUtils.getFunctionName(a.constructor));
  }
  return b;
};
mxCodec.prototype.decode = function (a, b) {
  this.updateElements();
  var c = null;
  if (null != a && a.nodeType == mxConstants.NODETYPE_ELEMENT) {
    c = null;
    try {
      c = window[a.nodeName];
    } catch (d) {}
    c = mxCodecRegistry.getCodec(c);
    null != c ? (c = c.decode(this, a, b)) : ((c = a.cloneNode(!0)), c.removeAttribute('as'));
  }
  return c;
};
mxCodec.prototype.encodeCell = function (a, b, c) {
  b.appendChild(this.encode(a));
  if (null == c || c) {
    c = a.getChildCount();
    for (var d = 0; d < c; d++) this.encodeCell(a.getChildAt(d), b);
  }
};
mxCodec.prototype.isCellCodec = function (a) {
  return null != a && 'function' == typeof a.isCellCodec ? a.isCellCodec() : !1;
};
mxCodec.prototype.decodeCell = function (a, b) {
  b = null != b ? b : !0;
  var c = null;
  if (null != a && a.nodeType == mxConstants.NODETYPE_ELEMENT) {
    c = mxCodecRegistry.getCodec(a.nodeName);
    if (!this.isCellCodec(c))
      for (var d = a.firstChild; null != d && !this.isCellCodec(c); )
        (c = mxCodecRegistry.getCodec(d.nodeName)), (d = d.nextSibling);
    this.isCellCodec(c) || (c = mxCodecRegistry.getCodec(mxCell));
    c = c.decode(this, a);
    b && this.insertIntoGraph(c);
  }
  return c;
};
mxCodec.prototype.insertIntoGraph = function (a) {
  var b = a.parent,
    c = a.getTerminal(!0),
    d = a.getTerminal(!1);
  a.setTerminal(null, !1);
  a.setTerminal(null, !0);
  a.parent = null;
  if (null != b) {
    if (b == a) throw Error(b.id + ': Self Reference');
    b.insert(a);
  }
  null != c && c.insertEdge(a, !0);
  null != d && d.insertEdge(a, !1);
};
mxCodec.prototype.setAttribute = function (a, b, c) {
  null != b && null != c && a.setAttribute(b, c);
};
function mxObjectCodec(a, b, c, d) {
  this.template = a;
  this.exclude = null != b ? b : [];
  this.idrefs = null != c ? c : [];
  this.mapping = null != d ? d : [];
  this.reverse = {};
  for (var e in this.mapping) this.reverse[this.mapping[e]] = e;
}
mxObjectCodec.allowEval = !1;
mxObjectCodec.prototype.template = null;
mxObjectCodec.prototype.exclude = null;
mxObjectCodec.prototype.idrefs = null;
mxObjectCodec.prototype.mapping = null;
mxObjectCodec.prototype.reverse = null;
mxObjectCodec.prototype.getName = function () {
  return mxUtils.getFunctionName(this.template.constructor);
};
mxObjectCodec.prototype.cloneTemplate = function () {
  return new this.template.constructor();
};
mxObjectCodec.prototype.getFieldName = function (a) {
  if (null != a) {
    var b = this.reverse[a];
    null != b && (a = b);
  }
  return a;
};
mxObjectCodec.prototype.getAttributeName = function (a) {
  if (null != a) {
    var b = this.mapping[a];
    null != b && (a = b);
  }
  return a;
};
mxObjectCodec.prototype.isExcluded = function (a, b, c, d) {
  return b == mxObjectIdentity.FIELD_NAME || 0 <= mxUtils.indexOf(this.exclude, b);
};
mxObjectCodec.prototype.isReference = function (a, b, c, d) {
  return 0 <= mxUtils.indexOf(this.idrefs, b);
};
mxObjectCodec.prototype.encode = function (a, b) {
  var c = a.document.createElement(this.getName());
  b = this.beforeEncode(a, b, c);
  this.encodeObject(a, b, c);
  return this.afterEncode(a, b, c);
};
mxObjectCodec.prototype.encodeObject = function (a, b, c) {
  a.setAttribute(c, 'id', a.getId(b));
  for (var d in b) {
    var e = d,
      f = b[e];
    null == f || this.isExcluded(b, e, f, !0) || (mxUtils.isInteger(e) && (e = null), this.encodeValue(a, b, e, f, c));
  }
};
mxObjectCodec.prototype.encodeValue = function (a, b, c, d, e) {
  if (null != d) {
    if (this.isReference(b, c, d, !0)) {
      var f = a.getId(d);
      if (null == f) {
        mxLog.warn('mxObjectCodec.encode: No ID for ' + this.getName() + '.' + c + '=' + d);
        return;
      }
      d = f;
    }
    f = this.template[c];
    if (null == c || a.encodeDefaults || f != d) (c = this.getAttributeName(c)), this.writeAttribute(a, b, c, d, e);
  }
};
mxObjectCodec.prototype.writeAttribute = function (a, b, c, d, e) {
  'object' != typeof d ? this.writePrimitiveAttribute(a, b, c, d, e) : this.writeComplexAttribute(a, b, c, d, e);
};
mxObjectCodec.prototype.writePrimitiveAttribute = function (a, b, c, d, e) {
  d = this.convertAttributeToXml(a, b, c, d, e);
  null == c
    ? ((b = a.document.createElement('add')),
      'function' == typeof d ? b.appendChild(a.document.createTextNode(d)) : a.setAttribute(b, 'value', d),
      e.appendChild(b))
    : 'function' != typeof d && a.setAttribute(e, c, d);
};
mxObjectCodec.prototype.writeComplexAttribute = function (a, b, c, d, e) {
  a = a.encode(d);
  null != a
    ? (null != c && a.setAttribute('as', c), e.appendChild(a))
    : mxLog.warn('mxObjectCodec.encode: No node for ' + this.getName() + '.' + c + ': ' + d);
};
mxObjectCodec.prototype.convertAttributeToXml = function (a, b, c, d) {
  this.isBooleanAttribute(a, b, c, d) && (d = 1 == d ? '1' : '0');
  return d;
};
mxObjectCodec.prototype.isBooleanAttribute = function (a, b, c, d) {
  return 'undefined' == typeof d.length && (1 == d || 0 == d);
};
mxObjectCodec.prototype.convertAttributeFromXml = function (a, b, c) {
  var d = b.value;
  this.isNumericAttribute(a, b, c) && ((d = parseFloat(d)), isNaN(d) || !isFinite(d)) && (d = 0);
  return d;
};
mxObjectCodec.prototype.isNumericAttribute = function (a, b, c) {
  return (
    (c.constructor == mxGeometry && ('x' == b.name || 'y' == b.name || 'width' == b.name || 'height' == b.name)) ||
    (c.constructor == mxPoint && ('x' == b.name || 'y' == b.name)) ||
    mxUtils.isNumeric(b.value)
  );
};
mxObjectCodec.prototype.beforeEncode = function (a, b, c) {
  return b;
};
mxObjectCodec.prototype.afterEncode = function (a, b, c) {
  return c;
};
mxObjectCodec.prototype.decode = function (a, b, c) {
  var d = b.getAttribute('id'),
    e = a.objects[d];
  null == e && ((e = c || this.cloneTemplate()), null != d && a.putObject(d, e));
  b = this.beforeDecode(a, b, e);
  this.decodeNode(a, b, e);
  return this.afterDecode(a, b, e);
};
mxObjectCodec.prototype.decodeNode = function (a, b, c) {
  null != b && (this.decodeAttributes(a, b, c), this.decodeChildren(a, b, c));
};
mxObjectCodec.prototype.decodeAttributes = function (a, b, c) {
  b = b.attributes;
  if (null != b) for (var d = 0; d < b.length; d++) this.decodeAttribute(a, b[d], c);
};
mxObjectCodec.prototype.isIgnoredAttribute = function (a, b, c) {
  return 'as' == b.nodeName || 'id' == b.nodeName;
};
mxObjectCodec.prototype.decodeAttribute = function (a, b, c) {
  if (!this.isIgnoredAttribute(a, b, c)) {
    var d = b.nodeName;
    b = this.convertAttributeFromXml(a, b, c);
    var e = this.getFieldName(d);
    if (this.isReference(c, e, b, !1)) {
      a = a.getObject(b);
      if (null == a) {
        mxLog.warn('mxObjectCodec.decode: No object for ' + this.getName() + '.' + d + '=' + b);
        return;
      }
      b = a;
    }
    this.isExcluded(c, d, b, !1) || (c[d] = b);
  }
};
mxObjectCodec.prototype.decodeChildren = function (a, b, c) {
  for (b = b.firstChild; null != b; ) {
    var d = b.nextSibling;
    b.nodeType != mxConstants.NODETYPE_ELEMENT || this.processInclude(a, b, c) || this.decodeChild(a, b, c);
    b = d;
  }
};
mxObjectCodec.prototype.decodeChild = function (a, b, c) {
  var d = this.getFieldName(b.getAttribute('as'));
  if (null == d || !this.isExcluded(c, d, b, !1)) {
    var e = this.getFieldTemplate(c, d, b);
    'add' == b.nodeName
      ? ((a = b.getAttribute('value')),
        null == a && mxObjectCodec.allowEval && (a = mxUtils.eval(mxUtils.getTextContent(b))))
      : (a = a.decode(b, e));
    try {
      this.addObjectValue(c, d, a, e);
    } catch (f) {
      throw Error(f.message + ' for ' + b.nodeName);
    }
  }
};
mxObjectCodec.prototype.getFieldTemplate = function (a, b, c) {
  a = a[b];
  a instanceof Array && 0 < a.length && (a = null);
  return a;
};
mxObjectCodec.prototype.addObjectValue = function (a, b, c, d) {
  null != c && c != d && (null != b && 0 < b.length ? (a[b] = c) : a.push(c));
};
mxObjectCodec.prototype.processInclude = function (a, b, c) {
  if ('include' == b.nodeName) {
    b = b.getAttribute('name');
    if (null != b)
      try {
        var d = mxUtils.load(b).getDocumentElement();
        null != d && a.decode(d, c);
      } catch (e) {}
    return !0;
  }
  return !1;
};
mxObjectCodec.prototype.beforeDecode = function (a, b, c) {
  return b;
};
mxObjectCodec.prototype.afterDecode = function (a, b, c) {
  return c;
};
mxCodecRegistry.register(
  (function () {
    var a = new mxObjectCodec(
      new mxCell(),
      ['children', 'edges', 'overlays', 'mxTransient'],
      ['parent', 'source', 'target']
    );
    a.isCellCodec = function () {
      return !0;
    };
    a.isNumericAttribute = function (a, c, d) {
      return 'value' !== c.nodeName && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);
    };
    a.isExcluded = function (a, c, d, e) {
      return (
        mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||
        (e && 'value' == c && d.nodeType == mxConstants.NODETYPE_ELEMENT)
      );
    };
    a.afterEncode = function (a, c, d) {
      if (null != c.value && c.value.nodeType == mxConstants.NODETYPE_ELEMENT) {
        var b = d;
        d = mxUtils.importNode(a.document, c.value, !0);
        d.appendChild(b);
        a = b.getAttribute('id');
        d.setAttribute('id', a);
        b.removeAttribute('id');
      }
      return d;
    };
    a.beforeDecode = function (a, c, d) {
      var b = c.cloneNode(!0),
        f = this.getName();
      c.nodeName != f
        ? ((b = c.getElementsByTagName(f)[0]),
          null != b && b.parentNode == c
            ? (mxUtils.removeWhitespace(b, !0), mxUtils.removeWhitespace(b, !1), b.parentNode.removeChild(b))
            : (b = null),
          (d.value = c.cloneNode(!0)),
          (c = d.value.getAttribute('id')),
          null != c && (d.setId(c), d.value.removeAttribute('id')))
        : d.setId(c.getAttribute('id'));
      if (null != b)
        for (c = 0; c < this.idrefs.length; c++) {
          var f = this.idrefs[c],
            g = b.getAttribute(f);
          if (null != g) {
            b.removeAttribute(f);
            var k = a.objects[g] || a.lookup(g);
            null == k &&
              ((g = a.getElementById(g)), null != g && (k = (mxCodecRegistry.codecs[g.nodeName] || this).decode(a, g)));
            d[f] = k;
          }
        }
      return b;
    };
    return a;
  })()
);
mxCodecRegistry.register(
  (function () {
    var a = new mxObjectCodec(new mxGraphModel());
    a.encodeObject = function (a, c, d) {
      var b = a.document.createElement('root');
      a.encodeCell(c.getRoot(), b);
      d.appendChild(b);
    };
    a.decodeChild = function (a, c, d) {
      'root' == c.nodeName ? this.decodeRoot(a, c, d) : mxObjectCodec.prototype.decodeChild.apply(this, arguments);
    };
    a.decodeRoot = function (a, c, d) {
      var b = null;
      for (c = c.firstChild; null != c; ) {
        var f = a.decodeCell(c);
        null != f && null == f.getParent() && (b = f);
        c = c.nextSibling;
      }
      null != b && d.setRoot(b);
    };
    return a;
  })()
);
var mxStylesheetCodec = mxCodecRegistry.register(
  (function () {
    var a = new mxObjectCodec(new mxStylesheet());
    a.encode = function (a, c) {
      var b = a.document.createElement(this.getName()),
        e;
      for (e in c.styles) {
        var f = c.styles[e],
          g = a.document.createElement('add');
        if (null != e) {
          g.setAttribute('as', e);
          for (var k in f) {
            var h = this.getStringValue(k, f[k]);
            if (null != h) {
              var l = a.document.createElement('add');
              l.setAttribute('value', h);
              l.setAttribute('as', k);
              g.appendChild(l);
            }
          }
          0 < g.childNodes.length && b.appendChild(g);
        }
      }
      return b;
    };
    a.getStringValue = function (a, c) {
      var b = typeof c;
      'function' == b ? (c = mxStyleRegistry.getName(c)) : 'object' == b && (c = null);
      return c;
    };
    a.decode = function (a, c, d) {
      d = d || new this.template.constructor();
      var b = c.getAttribute('id');
      null != b && (a.objects[b] = d);
      for (c = c.firstChild; null != c; ) {
        if (!this.processInclude(a, c, d) && 'add' == c.nodeName && ((b = c.getAttribute('as')), null != b)) {
          var f = c.getAttribute('extend'),
            g = null != f ? mxUtils.clone(d.styles[f]) : null;
          null == g &&
            (null != f && mxLog.warn('mxStylesheetCodec.decode: stylesheet ' + f + ' not found to extend'), (g = {}));
          for (f = c.firstChild; null != f; ) {
            if (f.nodeType == mxConstants.NODETYPE_ELEMENT) {
              var k = f.getAttribute('as');
              if ('add' == f.nodeName) {
                var h = mxUtils.getTextContent(f);
                null != h && 0 < h.length && mxStylesheetCodec.allowEval
                  ? (h = mxUtils.eval(h))
                  : ((h = f.getAttribute('value')), mxUtils.isNumeric(h) && (h = parseFloat(h)));
                null != h && (g[k] = h);
              } else 'remove' == f.nodeName && delete g[k];
            }
            f = f.nextSibling;
          }
          d.putCellStyle(b, g);
        }
        c = c.nextSibling;
      }
      return d;
    };
    return a;
  })()
);
mxStylesheetCodec.allowEval = !0;
(function () {
  var a = [
      ['nbsp', '160'],
      ['shy', '173'],
    ],
    b = mxUtils.parseXml;
  mxUtils.parseXml = function (c) {
    for (var d = 0; d < a.length; d++) c = c.replace(new RegExp('&' + a[d][0] + ';', 'g'), '&#' + a[d][1] + ';');
    return b(c);
  };
})();
Date.prototype.toISOString ||
  (function () {
    function a(a) {
      a = String(a);
      1 === a.length && (a = '0' + a);
      return a;
    }
    Date.prototype.toISOString = function () {
      return (
        this.getUTCFullYear() +
        '-' +
        a(this.getUTCMonth() + 1) +
        '-' +
        a(this.getUTCDate()) +
        'T' +
        a(this.getUTCHours()) +
        ':' +
        a(this.getUTCMinutes()) +
        ':' +
        a(this.getUTCSeconds()) +
        '.' +
        String((this.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) +
        'Z'
      );
    };
  })();
Date.now ||
  (Date.now = function () {
    return new Date().getTime();
  });
Uint8Array.from ||
  (Uint8Array.from = (function () {
    var a = Object.prototype.toString,
      b = function (b) {
        return 'function' === typeof b || '[object Function]' === a.call(b);
      },
      c = Math.pow(2, 53) - 1;
    return function (a) {
      var d = Object(a);
      if (null == a) throw new TypeError('Array.from requires an array-like object - not null or undefined');
      var f = 1 < arguments.length ? arguments[1] : void 0,
        g;
      if ('undefined' !== typeof f) {
        if (!b(f)) throw new TypeError('Array.from: when provided, the second argument must be a function');
        2 < arguments.length && (g = arguments[2]);
      }
      var k;
      k = Number(d.length);
      k = isNaN(k) ? 0 : 0 !== k && isFinite(k) ? (0 < k ? 1 : -1) * Math.floor(Math.abs(k)) : k;
      k = Math.min(Math.max(k, 0), c);
      for (var h = b(this) ? Object(new this(k)) : Array(k), l = 0, m; l < k; )
        (m = d[l]), (h[l] = f ? ('undefined' === typeof g ? f(m, l) : f.call(g, m, l)) : m), (l += 1);
      h.length = k;
      return h;
    };
  })());
mxConstants.POINTS = 1;
mxConstants.MILLIMETERS = 2;
mxConstants.INCHES = 3;
mxConstants.METERS = 4;
mxConstants.PIXELS_PER_MM = 3.937;
mxConstants.PIXELS_PER_INCH = 100;
mxConstants.SHADOW_OPACITY = 0.25;
mxConstants.SHADOWCOLOR = '#000000';
mxConstants.VML_SHADOWCOLOR = '#d0d0d0';
mxGraph.prototype.pageBreakColor = '#c0c0c0';
mxGraph.prototype.pageScale = 1;
(function () {
  try {
    if (null != navigator && null != navigator.language) {
      var a = navigator.language.toLowerCase();
      mxGraph.prototype.pageFormat =
        'en-us' === a || 'en-ca' === a || 'es-mx' === a
          ? mxConstants.PAGE_FORMAT_LETTER_PORTRAIT
          : mxConstants.PAGE_FORMAT_A4_PORTRAIT;
    }
  } catch (b) {}
})();
mxText.prototype.baseSpacingTop = 5;
mxText.prototype.baseSpacingBottom = 1;
mxGraphModel.prototype.ignoreRelativeEdgeParent = !1;
mxGraphView.prototype.gridImage = mxClient.IS_SVG
  ? 'data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs='
  : IMAGE_PATH + '/grid.gif';
mxGraphView.prototype.gridSteps = 4;
mxGraphView.prototype.minGridSize = 4;
mxGraphView.prototype.defaultGridColor = '#d0d0d0';
mxGraphView.prototype.defaultDarkGridColor = '#6e6e6e';
mxGraphView.prototype.gridColor = mxGraphView.prototype.defaultGridColor;
mxGraphView.prototype.unit = mxConstants.POINTS;
mxGraphView.prototype.setUnit = function (a) {
  this.unit != a && ((this.unit = a), this.fireEvent(new mxEventObject('unitChanged', 'unit', a)));
};
mxSvgCanvas2D.prototype.foAltText = '[Not supported by viewer]';
mxShape.prototype.getConstraints = function (a, b, c) {
  return null;
};
mxImageShape.prototype.getImageDataUri = function () {
  var a = this.image;
  if (
    'data:image/svg+xml;base64,' == a.substring(0, 26) &&
    null != this.style &&
    '1' == mxUtils.getValue(this.style, 'clipSvg', '0')
  ) {
    if (null == this.clippedSvg || this.clippedImage != a)
      (this.clippedSvg = Graph.clipSvgDataUri(a, !0)), (this.clippedImage = a);
    a = this.clippedSvg;
  }
  return a;
};
Graph = function (a, b, c, d, e, f) {
  mxGraph.call(this, a, b, c, d);
  this.themes = e || this.defaultThemes;
  this.currentEdgeStyle = mxUtils.clone(this.defaultEdgeStyle);
  this.currentVertexStyle = mxUtils.clone(this.defaultVertexStyle);
  this.standalone = null != f ? f : !1;
  a = this.baseUrl;
  b = a.indexOf('//');
  this.domainPathUrl = this.domainUrl = '';
  0 < b &&
    ((b = a.indexOf('/', b + 2)),
    0 < b && (this.domainUrl = a.substring(0, b)),
    (b = a.lastIndexOf('/')),
    0 < b && (this.domainPathUrl = a.substring(0, b + 1)));
  this.isHtmlLabel = function (a) {
    a = this.getCurrentCellStyle(a);
    return null != a ? '1' == a.html || 'wrap' == a[mxConstants.STYLE_WHITE_SPACE] : !1;
  };
  if (this.edgeMode) {
    var g = null,
      k = null,
      h = null,
      l = null,
      m = !1;
    this.addListener(
      mxEvent.FIRE_MOUSE_EVENT,
      mxUtils.bind(this, function (a, b) {
        if ('mouseDown' == b.getProperty('eventName') && this.isEnabled()) {
          var c = b.getProperty('event'),
            d = c.getState(),
            e = this.view.scale;
          if (!mxEvent.isAltDown(c.getEvent()) && null != d)
            if (this.model.isEdge(d.cell))
              if (
                ((g = new mxPoint(c.getGraphX(), c.getGraphY())),
                (m = this.isCellSelected(d.cell)),
                (h = d),
                (k = c),
                null != d.text &&
                  null != d.text.boundingBox &&
                  mxUtils.contains(d.text.boundingBox, c.getGraphX(), c.getGraphY()))
              )
                l = mxEvent.LABEL_HANDLE;
              else {
                var f = this.selectionCellsHandler.getHandler(d.cell);
                null != f && null != f.bends && 0 < f.bends.length && (l = f.getHandleForEvent(c));
              }
            else if (
              !this.panningHandler.isActive() &&
              !mxEvent.isControlDown(c.getEvent()) &&
              ((f = this.selectionCellsHandler.getHandler(d.cell)), null == f || null == f.getHandleForEvent(c))
            ) {
              var n = new mxRectangle(c.getGraphX() - 1, c.getGraphY() - 1),
                p = mxEvent.isTouchEvent(c.getEvent())
                  ? mxShape.prototype.svgStrokeTolerance - 1
                  : (mxShape.prototype.svgStrokeTolerance + 2) / 2,
                f = p + 2;
              n.grow(p);
              if (
                this.isTableCell(d.cell) &&
                !this.isCellSelected(d.cell) &&
                !(
                  mxUtils.contains(d, c.getGraphX() - f, c.getGraphY() - f) &&
                  mxUtils.contains(d, c.getGraphX() - f, c.getGraphY() + f) &&
                  mxUtils.contains(d, c.getGraphX() + f, c.getGraphY() + f) &&
                  mxUtils.contains(d, c.getGraphX() + f, c.getGraphY() - f)
                )
              ) {
                var t = this.model.getParent(d.cell),
                  f = this.model.getParent(t);
                if (!this.isCellSelected(f)) {
                  var p = p * e,
                    r = 2 * p;
                  if (
                    (this.model.getChildAt(f, 0) != t &&
                      mxUtils.intersects(n, new mxRectangle(d.x, d.y - p, d.width, r))) ||
                    (this.model.getChildAt(t, 0) != d.cell &&
                      mxUtils.intersects(n, new mxRectangle(d.x - p, d.y, r, d.height))) ||
                    mxUtils.intersects(n, new mxRectangle(d.x, d.y + d.height - p, d.width, r)) ||
                    mxUtils.intersects(n, new mxRectangle(d.x + d.width - p, d.y, r, d.height))
                  )
                    (t = this.selectionCellsHandler.isHandled(f)),
                      this.selectCellForEvent(f, c.getEvent()),
                      (f = this.selectionCellsHandler.getHandler(f)),
                      null != f &&
                        ((p = f.getHandleForEvent(c)),
                        null != p &&
                          (f.start(c.getGraphX(), c.getGraphY(), p), (f.blockDelayedSelection = !t), c.consume()));
                }
              }
              for (
                ;
                !c.isConsumed() &&
                null != d &&
                (this.isTableCell(d.cell) || this.isTableRow(d.cell) || this.isTable(d.cell));

              )
                this.isSwimlane(d.cell) &&
                  ((f = this.getActualStartSize(d.cell)),
                  ((0 < f.x || 0 < f.width) &&
                    mxUtils.intersects(
                      n,
                      new mxRectangle(d.x + (f.x - f.width - 1) * e + (0 == f.x ? d.width : 0), d.y, 1, d.height)
                    )) ||
                    ((0 < f.y || 0 < f.height) &&
                      mxUtils.intersects(
                        n,
                        new mxRectangle(d.x, d.y + (f.y - f.height - 1) * e + (0 == f.y ? d.height : 0), d.width, 1)
                      ))) &&
                  (this.selectCellForEvent(d.cell, c.getEvent()),
                  (f = this.selectionCellsHandler.getHandler(d.cell)),
                  null != f &&
                    ((p = mxEvent.CUSTOM_HANDLE - f.customHandles.length + 1),
                    f.start(c.getGraphX(), c.getGraphY(), p),
                    c.consume())),
                  (d = this.view.getState(this.model.getParent(d.cell)));
            }
        }
      })
    );
    this.addMouseListener({
      mouseDown: function (a, b) {},
      mouseMove: mxUtils.bind(this, function (a, b) {
        var c = this.selectionCellsHandler.handlers.map,
          d;
        for (d in c) if (null != c[d].index) return;
        if (this.isEnabled() && !this.panningHandler.isActive() && !mxEvent.isAltDown(b.getEvent())) {
          var e = this.tolerance;
          if (null != g && null != h && null != k) {
            if (((c = h), Math.abs(g.x - b.getGraphX()) > e || Math.abs(g.y - b.getGraphY()) > e)) {
              var f = this.selectionCellsHandler.getHandler(c.cell);
              null == f && this.model.isEdge(c.cell) && (f = this.createHandler(c));
              if (null != f && null != f.bends && 0 < f.bends.length) {
                d = f.getHandleForEvent(k);
                var n = this.view.getEdgeStyle(c),
                  e = n == mxEdgeStyle.EntityRelation;
                m || l != mxEvent.LABEL_HANDLE || (d = l);
                if (e && 0 != d && d != f.bends.length - 1 && d != mxEvent.LABEL_HANDLE)
                  !e ||
                    (null == c.visibleSourceState && null == c.visibleTargetState) ||
                    (this.graphHandler.reset(), b.consume());
                else if (
                  d == mxEvent.LABEL_HANDLE ||
                  0 == d ||
                  null != c.visibleSourceState ||
                  d == f.bends.length - 1 ||
                  null != c.visibleTargetState
                )
                  e ||
                    d == mxEvent.LABEL_HANDLE ||
                    ((e = c.absolutePoints),
                    null != e &&
                      ((null == n && null == d) || n == mxEdgeStyle.OrthConnector) &&
                      ((d = l),
                      null == d &&
                        ((d = new mxRectangle(g.x, g.y)),
                        d.grow(mxEdgeHandler.prototype.handleImage.width / 2),
                        mxUtils.contains(d, e[0].x, e[0].y)
                          ? (d = 0)
                          : mxUtils.contains(d, e[e.length - 1].x, e[e.length - 1].y)
                          ? (d = f.bends.length - 1)
                          : null != n &&
                            (2 == e.length ||
                              (3 == e.length &&
                                ((0 == Math.round(e[0].x - e[1].x) && 0 == Math.round(e[1].x - e[2].x)) ||
                                  (0 == Math.round(e[0].y - e[1].y) && 0 == Math.round(e[1].y - e[2].y)))))
                          ? (d = 2)
                          : ((d = mxUtils.findNearestSegment(c, g.x, g.y)),
                            (d = null == n ? mxEvent.VIRTUAL_HANDLE - d : d + 1)))),
                    null == d && (d = mxEvent.VIRTUAL_HANDLE)),
                    f.start(b.getGraphX(), b.getGraphX(), d),
                    b.consume(),
                    this.graphHandler.reset();
              }
              null != f &&
                (this.selectionCellsHandler.isHandlerActive(f)
                  ? this.isCellSelected(c.cell) ||
                    (this.selectionCellsHandler.handlers.put(c.cell, f), this.selectCellForEvent(c.cell, b.getEvent()))
                  : this.isCellSelected(c.cell) || f.destroy());
              m = !1;
              g = k = h = l = null;
            }
          } else if (((c = b.getState()), null != c && this.isCellEditable(c.cell))) {
            f = null;
            if (this.model.isEdge(c.cell)) {
              if (
                ((d = new mxRectangle(b.getGraphX(), b.getGraphY())),
                d.grow(mxEdgeHandler.prototype.handleImage.width / 2),
                (e = c.absolutePoints),
                null != e)
              )
                if (
                  null != c.text &&
                  null != c.text.boundingBox &&
                  mxUtils.contains(c.text.boundingBox, b.getGraphX(), b.getGraphY())
                )
                  f = 'move';
                else if (
                  mxUtils.contains(d, e[0].x, e[0].y) ||
                  mxUtils.contains(d, e[e.length - 1].x, e[e.length - 1].y)
                )
                  f = 'pointer';
                else if (null != c.visibleSourceState || null != c.visibleTargetState)
                  (d = this.view.getEdgeStyle(c)),
                    (f = 'crosshair'),
                    d != mxEdgeStyle.EntityRelation &&
                      this.isOrthogonal(c) &&
                      ((d = mxUtils.findNearestSegment(c, b.getGraphX(), b.getGraphY())),
                      d < e.length - 1 &&
                        0 <= d &&
                        (f = 0 == Math.round(e[d].x - e[d + 1].x) ? 'col-resize' : 'row-resize'));
            } else if (!mxEvent.isControlDown(b.getEvent())) {
              e = mxShape.prototype.svgStrokeTolerance / 2;
              d = new mxRectangle(b.getGraphX(), b.getGraphY());
              d.grow(e);
              if (
                this.isTableCell(c.cell) &&
                ((e = this.model.getParent(c.cell)), (n = this.model.getParent(e)), !this.isCellSelected(n))
              )
                if (
                  (mxUtils.intersects(d, new mxRectangle(c.x, c.y - 2, c.width, 4)) &&
                    this.model.getChildAt(n, 0) != e) ||
                  mxUtils.intersects(d, new mxRectangle(c.x, c.y + c.height - 2, c.width, 4))
                )
                  f = 'row-resize';
                else if (
                  (mxUtils.intersects(d, new mxRectangle(c.x - 2, c.y, 4, c.height)) &&
                    this.model.getChildAt(e, 0) != c.cell) ||
                  mxUtils.intersects(d, new mxRectangle(c.x + c.width - 2, c.y, 4, c.height))
                )
                  f = 'col-resize';
              for (
                e = c;
                null == f && null != e && (this.isTableCell(e.cell) || this.isTableRow(e.cell) || this.isTable(e.cell));

              ) {
                if (this.isSwimlane(e.cell)) {
                  var n = this.getActualStartSize(e.cell),
                    p = this.view.scale;
                  (0 < n.x || 0 < n.width) &&
                  mxUtils.intersects(
                    d,
                    new mxRectangle(e.x + (n.x - n.width - 1) * p + (0 == n.x ? e.width * p : 0), e.y, 1, e.height)
                  )
                    ? (f = 'col-resize')
                    : (0 < n.y || 0 < n.height) &&
                      mxUtils.intersects(
                        d,
                        new mxRectangle(e.x, e.y + (n.y - n.height - 1) * p + (0 == n.y ? e.height : 0), e.width, 1)
                      ) &&
                      (f = 'row-resize');
                }
                e = this.view.getState(this.model.getParent(e.cell));
              }
            }
            null != f && c.setCursor(f);
          }
        }
      }),
      mouseUp: mxUtils.bind(this, function (a, b) {
        l = g = k = h = null;
      }),
    });
  }
  this.cellRenderer.minSvgStrokeWidth = 0.1;
  this.cellRenderer.getLabelValue = function (a) {
    var b = mxCellRenderer.prototype.getLabelValue.apply(this, arguments);
    a.view.graph.isHtmlLabel(a.cell) &&
      (b = 1 != a.style.html ? mxUtils.htmlEntities(b, !1) : a.view.graph.sanitizeHtml(b));
    return b;
  };
  if ('undefined' !== typeof mxVertexHandler) {
    this.setConnectable(!0);
    this.setDropEnabled(!0);
    this.setPanning(!0);
    this.setTooltips(!0);
    this.setAllowLoops(!0);
    this.allowAutoPanning = !0;
    this.constrainChildren = this.resetEdgesOnConnect = !1;
    this.constrainRelativeChildren = !0;
    this.graphHandler.scrollOnMove = !1;
    this.graphHandler.scaleGrid = !0;
    this.connectionHandler.setCreateTarget(!1);
    this.connectionHandler.insertBeforeSource = !0;
    this.connectionHandler.isValidSource = function (a, b) {
      return !1;
    };
    this.alternateEdgeStyle = 'vertical';
    null == d && this.loadStylesheet();
    var n = this.graphHandler.getGuideStates;
    this.graphHandler.getGuideStates = function () {
      var a = n.apply(this, arguments);
      if (this.graph.pageVisible) {
        for (
          var b = [],
            c = this.graph.pageFormat,
            d = this.graph.pageScale,
            e = c.width * d,
            c = c.height * d,
            d = this.graph.view.translate,
            f = this.graph.view.scale,
            g = this.graph.getPageLayout(),
            k = 0;
          k < g.width;
          k++
        )
          b.push(new mxRectangle(((g.x + k) * e + d.x) * f, (g.y * c + d.y) * f, e * f, c * f));
        for (k = 1; k < g.height; k++)
          b.push(new mxRectangle((g.x * e + d.x) * f, ((g.y + k) * c + d.y) * f, e * f, c * f));
        a = b.concat(a);
      }
      return a;
    };
    mxDragSource.prototype.dragElementZIndex = mxPopupMenu.prototype.zIndex;
    mxGuide.prototype.getGuideColor = function (a, b) {
      return null == a.cell ? '#ffa500' : mxConstants.GUIDE_COLOR;
    };
    this.graphHandler.createPreviewShape = function (a) {
      this.previewColor = '#000000' == this.graph.background ? '#ffffff' : mxGraphHandler.prototype.previewColor;
      return mxGraphHandler.prototype.createPreviewShape.apply(this, arguments);
    };
    var p = this.graphHandler.getCells;
    this.graphHandler.getCells = function (a) {
      for (var b = p.apply(this, arguments), c = new mxDictionary(), d = [], e = 0; e < b.length; e++) {
        var f =
          this.graph.isTableCell(a) && this.graph.isTableCell(b[e]) && this.graph.isCellSelected(b[e])
            ? this.graph.model.getParent(b[e])
            : this.graph.isTableRow(a) && this.graph.isTableRow(b[e]) && this.graph.isCellSelected(b[e])
            ? b[e]
            : this.graph.getCompositeParent(b[e]);
        null == f || c.get(f) || (c.put(f, !0), d.push(f));
      }
      return d;
    };
    var r = this.graphHandler.start;
    this.graphHandler.start = function (a, b, c, d) {
      var e = !1;
      this.graph.isTableCell(a) && (this.graph.isCellSelected(a) ? (e = !0) : (a = this.graph.model.getParent(a)));
      e || (this.graph.isTableRow(a) && this.graph.isCellSelected(a)) || (a = this.graph.getCompositeParent(a));
      r.apply(this, arguments);
    };
    this.connectionHandler.createTargetVertex = function (a, b) {
      b = this.graph.getCompositeParent(b);
      return mxConnectionHandler.prototype.createTargetVertex.apply(this, arguments);
    };
    var t = new mxRubberband(this);
    this.getRubberband = function () {
      return t;
    };
    var u = new Date().getTime(),
      x = 0,
      z = this.connectionHandler.mouseMove;
    this.connectionHandler.mouseMove = function () {
      var a = this.currentState;
      z.apply(this, arguments);
      a != this.currentState ? ((u = new Date().getTime()), (x = 0)) : (x = new Date().getTime() - u);
    };
    var D = this.connectionHandler.isOutlineConnectEvent;
    this.connectionHandler.isOutlineConnectEvent = function (a) {
      return mxEvent.isShiftDown(a.getEvent()) && mxEvent.isAltDown(a.getEvent())
        ? !1
        : (null != this.currentState && a.getState() == this.currentState && 2e3 < x) ||
            ((null == this.currentState || '0' != mxUtils.getValue(this.currentState.style, 'outlineConnect', '1')) &&
              D.apply(this, arguments));
    };
    var B = this.isToggleEvent;
    this.isToggleEvent = function (a) {
      return B.apply(this, arguments) || (!mxClient.IS_CHROMEOS && mxEvent.isShiftDown(a));
    };
    var C = t.isForceRubberbandEvent;
    t.isForceRubberbandEvent = function (a) {
      return (
        C.apply(this, arguments) ||
        (mxClient.IS_CHROMEOS && mxEvent.isShiftDown(a.getEvent())) ||
        (mxUtils.hasScrollbars(this.graph.container) &&
          mxClient.IS_FF &&
          mxClient.IS_WIN &&
          null == a.getState() &&
          mxEvent.isTouchEvent(a.getEvent()))
      );
    };
    var J = null;
    this.panningHandler.addListener(
      mxEvent.PAN_START,
      mxUtils.bind(this, function () {
        this.isEnabled() && ((J = this.container.style.cursor), (this.container.style.cursor = 'move'));
      })
    );
    this.panningHandler.addListener(
      mxEvent.PAN_END,
      mxUtils.bind(this, function () {
        this.isEnabled() && (this.container.style.cursor = J);
      })
    );
    this.popupMenuHandler.autoExpand = !0;
    this.popupMenuHandler.isSelectOnPopup = function (a) {
      return mxEvent.isMouseEvent(a.getEvent());
    };
    var v = this.click;
    this.click = function (a) {
      var b = null == a.state && null != a.sourceState && this.isCellLocked(a.sourceState.cell);
      if ((this.isEnabled() && !b) || a.isConsumed()) return v.apply(this, arguments);
      var c = b ? a.sourceState.cell : a.getCell();
      null != c &&
        ((c = this.getClickableLinkForCell(c)),
        null != c && (this.isCustomLink(c) ? this.customLinkClicked(c) : this.openLink(c)));
      this.isEnabled() && b && this.clearSelection();
    };
    this.tooltipHandler.getStateForEvent = function (a) {
      return a.sourceState;
    };
    var K = this.tooltipHandler.show;
    this.tooltipHandler.show = function () {
      K.apply(this, arguments);
      if (null != this.div)
        for (var a = this.div.getElementsByTagName('a'), b = 0; b < a.length; b++)
          null != a[b].getAttribute('href') &&
            null == a[b].getAttribute('target') &&
            a[b].setAttribute('target', '_blank');
    };
    this.tooltipHandler.getStateForEvent = function (a) {
      return a.sourceState;
    };
    this.getCursorForMouseEvent = function (a) {
      var b = null == a.state && null != a.sourceState && this.isCellLocked(a.sourceState.cell);
      return this.getCursorForCell(b ? a.sourceState.cell : a.getCell());
    };
    var O = this.getCursorForCell;
    this.getCursorForCell = function (a) {
      if (!this.isEnabled() || this.isCellLocked(a)) {
        if (null != this.getClickableLinkForCell(a)) return 'pointer';
        if (this.isCellLocked(a)) return 'default';
      }
      return O.apply(this, arguments);
    };
    this.selectRegion = function (a, b) {
      var c = mxEvent.isAltDown(b) ? a : null,
        c = this.getCells(
          a.x,
          a.y,
          a.width,
          a.height,
          null,
          null,
          c,
          function (a) {
            return '1' == mxUtils.getValue(a.style, 'locked', '0');
          },
          !0
        );
      if (this.isToggleEvent(b)) for (var d = 0; d < c.length; d++) this.selectCellForEvent(c[d], b);
      else this.selectCellsForEvent(c, b);
      return c;
    };
    var T = this.graphHandler.shouldRemoveCellsFromParent;
    this.graphHandler.shouldRemoveCellsFromParent = function (a, b, c) {
      return this.graph.isCellSelected(a) ? !1 : T.apply(this, arguments);
    };
    this.isCellLocked = function (a) {
      for (; null != a; ) {
        if ('1' == mxUtils.getValue(this.getCurrentCellStyle(a), 'locked', '0')) return !0;
        a = this.model.getParent(a);
      }
      return !1;
    };
    var M = null;
    this.addListener(
      mxEvent.FIRE_MOUSE_EVENT,
      mxUtils.bind(this, function (a, b) {
        if ('mouseDown' == b.getProperty('eventName')) {
          var c = b.getProperty('event').getState();
          M = null == c || this.isSelectionEmpty() || this.isCellSelected(c.cell) ? null : this.getSelectionCells();
        }
      })
    );
    this.addListener(
      mxEvent.TAP_AND_HOLD,
      mxUtils.bind(this, function (a, b) {
        if (!mxEvent.isMultiTouchEvent(b)) {
          var c = b.getProperty('event'),
            d = b.getProperty('cell');
          null == d
            ? ((c = mxUtils.convertPoint(this.container, mxEvent.getClientX(c), mxEvent.getClientY(c))),
              t.start(c.x, c.y))
            : null != M
            ? this.addSelectionCells(M)
            : 1 < this.getSelectionCount() && this.isCellSelected(d) && this.removeSelectionCell(d);
          M = null;
          b.consume();
        }
      })
    );
    this.connectionHandler.selectCells = function (a, b) {
      this.graph.setSelectionCell(b || a);
    };
    this.connectionHandler.constraintHandler.isStateIgnored = function (a, b) {
      var c = a.view.graph;
      return (
        b &&
        (c.isCellSelected(a.cell) ||
          (c.isTableRow(a.cell) && c.selectionCellsHandler.isHandled(c.model.getParent(a.cell))))
      );
    };
    this.selectionModel.addListener(
      mxEvent.CHANGE,
      mxUtils.bind(this, function () {
        var a = this.connectionHandler.constraintHandler;
        null != a.currentFocus &&
          a.isStateIgnored(a.currentFocus, !0) &&
          ((a.currentFocus = null), (a.constraints = null), a.destroyIcons());
        a.destroyFocusHighlight();
      })
    );
    Graph.touchStyle && this.initTouch();
    var U = this.updateMouseEvent;
    this.updateMouseEvent = function (a) {
      a = U.apply(this, arguments);
      null != a.state && this.isCellLocked(a.getCell()) && (a.state = null);
      return a;
    };
  }
  this.currentTranslate = new mxPoint(0, 0);
};
Graph.touchStyle =
  mxClient.IS_TOUCH ||
  (mxClient.IS_FF && mxClient.IS_WIN) ||
  0 < navigator.maxTouchPoints ||
  0 < navigator.msMaxTouchPoints ||
  null == window.urlParams ||
  '1' == urlParams.touch;
Graph.fileSupport =
  null != window.File &&
  null != window.FileReader &&
  null != window.FileList &&
  (null == window.urlParams || '0' != urlParams.filesupport);
Graph.translateDiagram = '1' == urlParams['translate-diagram'];
Graph.diagramLanguage = null != urlParams['diagram-language'] ? urlParams['diagram-language'] : mxClient.language;
Graph.lineJumpsEnabled = !0;
Graph.defaultJumpSize = 6;
Graph.zoomWheel = !1;
Graph.minTableColumnWidth = 20;
Graph.minTableRowHeight = 20;
Graph.foreignObjectWarningText = 'Text is not SVG - cannot display';
Graph.foreignObjectWarningLink = 'https://www.diagrams.net/doc/faq/svg-export-text-problems';
Graph.xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
Graph.svgDoctype = '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
Graph.svgFileComment = '\x3c!-- Do not edit this file with editors other than diagrams.net --\x3e';
Graph.pasteStyles =
  'rounded shadow dashed dashPattern fontFamily fontSource fontSize fontColor fontStyle align verticalAlign strokeColor strokeWidth fillColor gradientColor swimlaneFillColor textOpacity gradientDirection glass labelBackgroundColor labelBorderColor opacity spacing spacingTop spacingLeft spacingBottom spacingRight endFill endArrow endSize targetPerimeterSpacing startFill startArrow startSize sourcePerimeterSpacing arcSize comic sketch fillWeight hachureGap hachureAngle jiggle disableMultiStroke disableMultiStrokeFill fillStyle curveFitting simplification comicStyle'.split(
    ' '
  );
Graph.createOffscreenGraph = function (a) {
  var b = new Graph(document.createElement('div'));
  b.stylesheet.styles = mxUtils.clone(a.styles);
  b.resetViewOnRootChange = !1;
  b.setConnectable(!1);
  b.gridEnabled = !1;
  b.autoScroll = !1;
  b.setTooltips(!1);
  b.setEnabled(!1);
  b.container.style.visibility = 'hidden';
  b.container.style.position = 'absolute';
  b.container.style.overflow = 'hidden';
  b.container.style.height = '1px';
  b.container.style.width = '1px';
  return b;
};
Graph.createSvgImage = function (a, b, c, d, e) {
  c = unescape(
    encodeURIComponent(
      Graph.svgDoctype +
        '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' +
        a +
        'px" height="' +
        b +
        'px" ' +
        (null != d && null != e ? 'viewBox="0 0 ' + d + ' ' + e + '" ' : '') +
        'version="1.1">' +
        c +
        '</svg>'
    )
  );
  return new mxImage('data:image/svg+xml;base64,' + (window.btoa ? btoa(c) : Base64.encode(c, !0)), a, b);
};
Graph.zapGremlins = function (a) {
  for (var b = 0, c = [], d = 0; d < a.length; d++) {
    var e = a.charCodeAt(d);
    ((32 <= e || 9 == e || 10 == e || 13 == e) && 65535 != e && 65534 != e) || (c.push(a.substring(b, d)), (b = d + 1));
  }
  0 < b && b < a.length && c.push(a.substring(b));
  return 0 == c.length ? a : c.join('');
};
Graph.stringToBytes = function (a) {
  for (var b = Array(a.length), c = 0; c < a.length; c++) b[c] = a.charCodeAt(c);
  return b;
};
Graph.bytesToString = function (a) {
  for (var b = Array(a.length), c = 0; c < a.length; c++) b[c] = String.fromCharCode(a[c]);
  return b.join('');
};
Graph.base64EncodeUnicode = function (a) {
  return btoa(
    encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, function (a, c) {
      return String.fromCharCode(parseInt(c, 16));
    })
  );
};
Graph.base64DecodeUnicode = function (a) {
  return decodeURIComponent(
    Array.prototype.map
      .call(atob(a), function (a) {
        return '%' + ('00' + a.charCodeAt(0).toString(16)).slice(-2);
      })
      .join('')
  );
};
Graph.compressNode = function (a, b) {
  var c = mxUtils.getXml(a);
  return Graph.compress(b ? c : Graph.zapGremlins(c));
};
Graph.arrayBufferToString = function (a) {
  var b = '';
  a = new Uint8Array(a);
  for (var c = a.byteLength, d = 0; d < c; d++) b += String.fromCharCode(a[d]);
  return b;
};
Graph.stringToArrayBuffer = function (a) {
  return Uint8Array.from(a, function (a) {
    return a.charCodeAt(0);
  });
};
Graph.arrayBufferIndexOfString = function (a, b, c) {
  var d = b.charCodeAt(0),
    e = 1,
    f = -1;
  for (c = c || 0; c < a.byteLength; c++)
    if (a[c] == d) {
      f = c;
      break;
    }
  for (c = f + 1; -1 < f && c < a.byteLength && c < f + b.length - 1; c++) {
    if (a[c] != b.charCodeAt(e)) return Graph.arrayBufferIndexOfString(a, b, f + 1);
    e++;
  }
  return e == b.length - 1 ? f : -1;
};
Graph.compress = function (a, b) {
  if (null == a || 0 == a.length || 'undefined' === typeof pako) return a;
  var c = b ? pako.deflate(encodeURIComponent(a)) : pako.deflateRaw(encodeURIComponent(a));
  return btoa(Graph.arrayBufferToString(new Uint8Array(c)));
};
Graph.decompress = function (a, b, c) {
  if (null == a || 0 == a.length || 'undefined' === typeof pako) return a;
  a = Graph.stringToArrayBuffer(atob(a));
  b = decodeURIComponent(b ? pako.inflate(a, { to: 'string' }) : pako.inflateRaw(a, { to: 'string' }));
  return c ? b : Graph.zapGremlins(b);
};
Graph.fadeNodes = function (a, b, c, d, e) {
  e = null != e ? e : 1e3;
  Graph.setTransitionForNodes(a, null);
  Graph.setOpacityForNodes(a, b);
  window.setTimeout(function () {
    Graph.setTransitionForNodes(a, 'all ' + e + 'ms ease-in-out');
    Graph.setOpacityForNodes(a, c);
    window.setTimeout(function () {
      Graph.setTransitionForNodes(a, null);
      null != d && d();
    }, e);
  }, 0);
};
Graph.removeKeys = function (a, b) {
  for (var c in a) b(c) && delete a[c];
};
Graph.setTransitionForNodes = function (a, b) {
  for (var c = 0; c < a.length; c++) mxUtils.setPrefixedStyle(a[c].style, 'transition', b);
};
Graph.setOpacityForNodes = function (a, b) {
  for (var c = 0; c < a.length; c++) a[c].style.opacity = b;
};
Graph.removePasteFormatting = function (a) {
  for (; null != a; )
    null != a.firstChild && Graph.removePasteFormatting(a.firstChild),
      a.nodeType == mxConstants.NODETYPE_ELEMENT &&
        null != a.style &&
        ((a.style.whiteSpace = ''), '#000000' == a.style.color && (a.style.color = '')),
      (a = a.nextSibling);
};
Graph.sanitizeHtml = function (a, b) {
  return DOMPurify.sanitize(a, {
    ADD_ATTR: ['target'],
    FORBID_TAGS: ['form'],
    ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
  });
};
Graph.sanitizeSvg = function (a) {
  return DOMPurify.sanitize(a, { IN_PLACE: !0 });
};
Graph.clipSvgDataUri = function (a, b) {
  if (!mxClient.IS_IE && !mxClient.IS_IE11 && null != a && 'data:image/svg+xml;base64,' == a.substring(0, 26))
    try {
      var c = document.createElement('div');
      c.style.position = 'absolute';
      c.style.visibility = 'hidden';
      var d = decodeURIComponent(escape(atob(a.substring(26)))),
        e = d.indexOf('<svg');
      if (0 <= e) {
        c.innerHTML = d.substring(e);
        Graph.sanitizeSvg(c);
        var f = c.getElementsByTagName('svg');
        if (0 < f.length) {
          if (b || null != f[0].getAttribute('preserveAspectRatio')) {
            document.body.appendChild(c);
            try {
              var e = (d = 1),
                g = f[0].getAttribute('width'),
                k = f[0].getAttribute('height'),
                g = null != g && '%' != g.charAt(g.length - 1) ? parseFloat(g) : NaN,
                k = null != k && '%' != k.charAt(k.length - 1) ? parseFloat(k) : NaN,
                h = f[0].getAttribute('viewBox');
              if (null != h && !isNaN(g) && !isNaN(k)) {
                var l = h.split(' ');
                4 <= h.length && ((d = parseFloat(l[2]) / g), (e = parseFloat(l[3]) / k));
              }
              var m = f[0].getBBox();
              0 < m.width &&
                0 < m.height &&
                (c
                  .getElementsByTagName('svg')[0]
                  .setAttribute('viewBox', m.x + ' ' + m.y + ' ' + m.width + ' ' + m.height),
                c.getElementsByTagName('svg')[0].setAttribute('width', m.width / d),
                c.getElementsByTagName('svg')[0].setAttribute('height', m.height / e));
            } catch (n) {
            } finally {
              document.body.removeChild(c);
            }
          }
          a = Editor.createSvgDataUri(mxUtils.getXml(f[0]));
        }
      }
    } catch (n) {}
  return a;
};
Graph.stripQuotes = function (a) {
  null != a &&
    ("'" == a.charAt(0) && (a = a.substring(1)),
    "'" == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1)),
    '"' == a.charAt(0) && (a = a.substring(1)),
    '"' == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1)));
  return a;
};
Graph.createRemoveIcon = function (a, b) {
  var c = document.createElement('img');
  c.setAttribute('src', Dialog.prototype.clearImage);
  c.setAttribute('title', a);
  c.setAttribute('width', '13');
  c.setAttribute('height', '10');
  c.style.marginLeft = '4px';
  c.style.marginBottom = '-1px';
  c.style.cursor = 'pointer';
  mxEvent.addListener(c, 'click', b);
  return c;
};
Graph.isPageLink = function (a) {
  return null != a && 'data:page/id,' == a.substring(0, 13);
};
Graph.isLink = function (a) {
  return null != a && Graph.linkPattern.test(a);
};
Graph.linkPattern =
  /^(https?:\/\/)?((([a-z\d]([a-z\d-]*[a-z\d])*)\.)+[a-z]{2,}|((\d{1,3}\.){3}\d{1,3}))(\:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(\#[-a-z\d_]*)?$/i;
mxUtils.extend(Graph, mxGraph);
Graph.prototype.minFitScale = null;
Graph.prototype.maxFitScale = null;
Graph.prototype.linkPolicy = 'frame' == urlParams.target ? 'blank' : urlParams.target || 'auto';
Graph.prototype.linkTarget = 'frame' == urlParams.target ? '_self' : '_blank';
Graph.prototype.linkRelation = 'nofollow noopener noreferrer';
Graph.prototype.defaultScrollbars = !0;
Graph.prototype.defaultPageVisible = !0;
Graph.prototype.defaultGridEnabled = '0' != urlParams.grid;
Graph.prototype.lightbox = !1;
Graph.prototype.defaultPageBackgroundColor = '#ffffff';
Graph.prototype.defaultPageBorderColor = '#ffffff';
Graph.prototype.shapeForegroundColor = '#000000';
Graph.prototype.shapeBackgroundColor = '#ffffff';
Graph.prototype.scrollTileSize = new mxRectangle(0, 0, 400, 400);
Graph.prototype.transparentBackground = !0;
Graph.prototype.selectParentAfterDelete = !1;
Graph.prototype.defaultEdgeLength = 80;
Graph.prototype.edgeMode = !1;
Graph.prototype.connectionArrowsEnabled = !0;
Graph.prototype.placeholderPattern = RegExp('%(date{.*}|[^%^{^}^ ^"^ \'^=^;]+)%', 'g');
Graph.prototype.absoluteUrlPattern = /^(?:[a-z]+:)?\/\//i;
Graph.prototype.defaultThemeName = 'default';
Graph.prototype.defaultThemes = {};
Graph.prototype.baseUrl =
  null != urlParams.base
    ? decodeURIComponent(urlParams.base)
    : (window != window.top ? document.referrer : document.location.toString()).split('#')[0];
Graph.prototype.editAfterInsert = !1;
Graph.prototype.builtInProperties = ['label', 'tooltip', 'placeholders', 'placeholder'];
Graph.prototype.standalone = !1;
Graph.prototype.enableFlowAnimation = !1;
Graph.prototype.roundableShapes =
  'label rectangle internalStorage corner parallelogram swimlane triangle trapezoid ext step tee process link rhombus offPageConnector loopLimit hexagon manualInput card curlyBracket singleArrow callout doubleArrow flexArrow umlLifeline'.split(
    ' '
  );
Graph.prototype.init = function (a) {
  mxGraph.prototype.init.apply(this, arguments);
  this.cellRenderer.initializeLabel = function (a, b) {
    mxCellRenderer.prototype.initializeLabel.apply(this, arguments);
    var c = a.view.graph.tolerance,
      d = !0,
      g = null,
      k = mxUtils.bind(this, function (a) {
        d = !0;
        g = new mxPoint(mxEvent.getClientX(a), mxEvent.getClientY(a));
      }),
      h = mxUtils.bind(this, function (a) {
        d = d && null != g && Math.abs(g.x - mxEvent.getClientX(a)) < c && Math.abs(g.y - mxEvent.getClientY(a)) < c;
      }),
      l = mxUtils.bind(this, function (c) {
        if (d)
          for (var e = mxEvent.getSource(c); null != e && e != b.node; ) {
            if ('a' == e.nodeName.toLowerCase()) {
              a.view.graph.labelLinkClicked(a, e, c);
              break;
            }
            e = e.parentNode;
          }
      });
    mxEvent.addGestureListeners(b.node, k, h, l);
    mxEvent.addListener(b.node, 'click', function (a) {
      mxEvent.consume(a);
    });
  };
  if (null != this.tooltipHandler) {
    var b = this.tooltipHandler.init;
    this.tooltipHandler.init = function () {
      b.apply(this, arguments);
      null != this.div &&
        mxEvent.addListener(
          this.div,
          'click',
          mxUtils.bind(this, function (a) {
            var b = mxEvent.getSource(a);
            'A' == b.nodeName &&
              ((b = b.getAttribute('href')),
              null != b &&
                this.graph.isCustomLink(b) &&
                (mxEvent.isTouchEvent(a) || !mxEvent.isPopupTrigger(a)) &&
                this.graph.customLinkClicked(b) &&
                mxEvent.consume(a));
          })
        );
    };
  }
  this.addListener(
    mxEvent.SIZE,
    mxUtils.bind(this, function (a, b) {
      if (null != this.container && this.flowAnimationStyle) {
        var c = this.flowAnimationStyle.getAttribute('id');
        this.flowAnimationStyle.innerHTML = this.getFlowAnimationStyleCss(c);
      }
    })
  );
  this.initLayoutManager();
};
(function () {
  Graph.prototype.useCssTransforms = !1;
  Graph.prototype.currentScale = 1;
  Graph.prototype.currentTranslate = new mxPoint(0, 0);
  Graph.prototype.isFillState = function (a) {
    return (
      !this.isSpecialColor(a.style[mxConstants.STYLE_FILLCOLOR]) &&
      '1' != mxUtils.getValue(a.style, 'lineShape', null) &&
      (this.model.isVertex(a.cell) ||
        'arrow' == mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null) ||
        'filledEdge' == mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null) ||
        'flexArrow' == mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null))
    );
  };
  Graph.prototype.isStrokeState = function (a) {
    return !this.isSpecialColor(a.style[mxConstants.STYLE_STROKECOLOR]);
  };
  Graph.prototype.isSpecialColor = function (a) {
    return (
      0 <=
      mxUtils.indexOf(
        [mxConstants.STYLE_STROKECOLOR, mxConstants.STYLE_FILLCOLOR, 'inherit', 'swimlane', 'indicated'],
        a
      )
    );
  };
  Graph.prototype.isGlassState = function (a) {
    a = mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null);
    return (
      'label' == a ||
      'rectangle' == a ||
      'internalStorage' == a ||
      'ext' == a ||
      'umlLifeline' == a ||
      'swimlane' == a ||
      'process' == a
    );
  };
  Graph.prototype.isRoundedState = function (a) {
    return null != a.shape
      ? a.shape.isRoundable()
      : 0 <= mxUtils.indexOf(this.roundableShapes, mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null));
  };
  Graph.prototype.isLineJumpState = function (a) {
    var b = mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null);
    return !mxUtils.getValue(a.style, mxConstants.STYLE_CURVED, !1) && ('connector' == b || 'filledEdge' == b);
  };
  Graph.prototype.isAutoSizeState = function (a) {
    return '1' == mxUtils.getValue(a.style, mxConstants.STYLE_AUTOSIZE, null);
  };
  Graph.prototype.isImageState = function (a) {
    a = mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null);
    return 'label' == a || 'image' == a;
  };
  Graph.prototype.isShadowState = function (a) {
    return 'image' != mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null);
  };
  Graph.prototype.getVerticesAndEdges = function (a, b) {
    a = null != a ? a : !0;
    b = null != b ? b : !0;
    var c = this.model;
    return c.filterDescendants(function (d) {
      return (a && c.isVertex(d)) || (b && c.isEdge(d));
    }, c.getRoot());
  };
  Graph.prototype.getCommonStyle = function (a) {
    for (var b = {}, c = 0; c < a.length; c++) {
      var d = this.view.getState(a[c]);
      this.mergeStyle(d.style, b, 0 == c);
    }
    return b;
  };
  Graph.prototype.mergeStyle = function (a, b, c) {
    if (null != a) {
      var d = {},
        e;
      for (e in a) {
        var f = a[e];
        null != f && ((d[e] = !0), null == b[e] && c ? (b[e] = f) : b[e] != f && delete b[e]);
      }
      for (e in b) d[e] || delete b[e];
    }
  };
  Graph.prototype.getStartEditingCell = function (a, b) {
    var c = this.getCellStyle(a),
      c = parseInt(mxUtils.getValue(c, mxConstants.STYLE_STARTSIZE, 0));
    this.isTable(a) &&
      (!this.isSwimlane(a) || 0 == c) &&
      '' == this.getLabel(a) &&
      0 < this.model.getChildCount(a) &&
      ((a = this.model.getChildAt(a, 0)),
      (c = this.getCellStyle(a)),
      (c = parseInt(mxUtils.getValue(c, mxConstants.STYLE_STARTSIZE, 0))));
    if (
      this.isTableRow(a) &&
      (!this.isSwimlane(a) || 0 == c) &&
      '' == this.getLabel(a) &&
      0 < this.model.getChildCount(a)
    )
      for (c = 0; c < this.model.getChildCount(a); c++) {
        var d = this.model.getChildAt(a, c);
        if (this.isCellEditable(d)) {
          a = d;
          break;
        }
      }
    return a;
  };
  Graph.prototype.copyStyle = function (a) {
    return this.getCellStyle(a, !1);
  };
  Graph.prototype.pasteStyle = function (a, b, c) {
    c = null != c ? c : Graph.pasteStyles;
    Graph.removeKeys(a, function (a) {
      return 0 > mxUtils.indexOf(c, a);
    });
    this.updateCellStyles(a, b);
  };
  Graph.prototype.updateCellStyles = function (a, b) {
    this.model.beginUpdate();
    try {
      for (var c = 0; c < b.length; c++)
        if (this.model.isVertex(b[c]) || this.model.isEdge(b[c])) {
          var d = this.getCellStyle(b[c], !1),
            e;
          for (e in a) {
            var f = a[e];
            d[e] != f && this.setCellStyles(e, f, [b[c]]);
          }
        }
    } finally {
      this.model.endUpdate();
    }
  };
  Graph.prototype.isFastZoomEnabled = function () {
    return (
      'nocss' != urlParams.zoom &&
      !mxClient.NO_FO &&
      !mxClient.IS_EDGE &&
      !this.useCssTransforms &&
      (this.isCssTransformsSupported() || mxClient.IS_IOS)
    );
  };
  Graph.prototype.isCssTransformsSupported = function () {
    return this.dialect == mxConstants.DIALECT_SVG && !mxClient.NO_FO && (!this.lightbox || !mxClient.IS_SF);
  };
  Graph.prototype.getCellAt = function (a, b, c, d, e, f) {
    this.useCssTransforms &&
      ((a = a / this.currentScale - this.currentTranslate.x), (b = b / this.currentScale - this.currentTranslate.y));
    return this.getScaledCellAt.apply(this, arguments);
  };
  Graph.prototype.getScaledCellAt = function (a, b, c, d, e, f) {
    d = null != d ? d : !0;
    e = null != e ? e : !0;
    null == c && ((c = this.getCurrentRoot()), null == c && (c = this.getModel().getRoot()));
    if (null != c)
      for (var g = this.model.getChildCount(c) - 1; 0 <= g; g--) {
        var k = this.model.getChildAt(c, g),
          h = this.getScaledCellAt(a, b, k, d, e, f);
        if (null != h) return h;
        if (
          this.isCellVisible(k) &&
          ((e && this.model.isEdge(k)) || (d && this.model.isVertex(k))) &&
          ((h = this.view.getState(k)), null != h && (null == f || !f(h, a, b)) && this.intersects(h, a, b))
        )
          return k;
      }
    return null;
  };
  Graph.prototype.isRecursiveVertexResize = function (a) {
    return (
      !this.isSwimlane(a.cell) &&
      0 < this.model.getChildCount(a.cell) &&
      !this.isCellCollapsed(a.cell) &&
      '1' == mxUtils.getValue(a.style, 'recursiveResize', '1') &&
      null == mxUtils.getValue(a.style, 'childLayout', null)
    );
  };
  Graph.prototype.getAbsoluteParent = function (a) {
    for (var b = this.getCellGeometry(a); null != b && b.relative; )
      (a = this.getModel().getParent(a)), (b = this.getCellGeometry(a));
    return a;
  };
  Graph.prototype.isPart = function (a) {
    return (
      '1' == mxUtils.getValue(this.getCurrentCellStyle(a), 'part', '0') || this.isTableCell(a) || this.isTableRow(a)
    );
  };
  Graph.prototype.getCompositeParents = function (a) {
    for (var b = new mxDictionary(), c = [], d = 0; d < a.length; d++) {
      var e = this.getCompositeParent(a[d]);
      this.isTableCell(e) && (e = this.graph.model.getParent(e));
      this.isTableRow(e) && (e = this.graph.model.getParent(e));
      null == e || b.get(e) || (b.put(e, !0), c.push(e));
    }
    return c;
  };
  Graph.prototype.getCompositeParent = function (a) {
    for (; this.isPart(a); ) {
      var b = this.model.getParent(a);
      if (!this.model.isVertex(b)) break;
      a = b;
    }
    return a;
  };
  Graph.prototype.filterSelectionCells = function (a) {
    var b = this.getSelectionCells();
    if (null != a) {
      for (var c = [], d = 0; d < b.length; d++) a(b[d]) || c.push(b[d]);
      b = c;
    }
    return b;
  };
  var a = mxGraph.prototype.scrollRectToVisible;
  Graph.prototype.scrollRectToVisible = function (b) {
    if (this.useCssTransforms) {
      var c = this.currentScale,
        d = this.currentTranslate;
      b = new mxRectangle((b.x + 2 * d.x) * c - d.x, (b.y + 2 * d.y) * c - d.y, b.width * c, b.height * c);
    }
    a.apply(this, arguments);
  };
  mxCellHighlight.prototype.getStrokeWidth = function (a) {
    a = this.strokeWidth;
    this.graph.useCssTransforms && (a /= this.graph.currentScale);
    return a;
  };
  mxGraphView.prototype.getGraphBounds = function () {
    var a = this.graphBounds;
    if (this.graph.useCssTransforms)
      var b = this.graph.currentTranslate,
        c = this.graph.currentScale,
        a = new mxRectangle((a.x + b.x) * c, (a.y + b.y) * c, a.width * c, a.height * c);
    return a;
  };
  mxGraphView.prototype.viewStateChanged = function () {
    this.graph.useCssTransforms ? this.validate() : this.revalidate();
    this.graph.sizeDidChange();
  };
  var b = mxGraphView.prototype.validate;
  mxGraphView.prototype.validate = function (a) {
    this.graph.useCssTransforms &&
      ((this.graph.currentScale = this.scale),
      (this.graph.currentTranslate.x = this.translate.x),
      (this.graph.currentTranslate.y = this.translate.y),
      (this.scale = 1),
      (this.translate.x = 0),
      (this.translate.y = 0));
    b.apply(this, arguments);
    this.graph.useCssTransforms &&
      (this.graph.updateCssTransform(),
      (this.scale = this.graph.currentScale),
      (this.translate.x = this.graph.currentTranslate.x),
      (this.translate.y = this.graph.currentTranslate.y));
  };
  var c = mxGraph.prototype.getCellsForGroup;
  Graph.prototype.getCellsForGroup = function (a) {
    a = c.apply(this, arguments);
    for (var b = [], d = 0; d < a.length; d++) this.isTableRow(a[d]) || this.isTableCell(a[d]) || b.push(a[d]);
    return b;
  };
  var d = mxGraph.prototype.getCellsForUngroup;
  Graph.prototype.getCellsForUngroup = function (a) {
    a = d.apply(this, arguments);
    for (var b = [], c = 0; c < a.length; c++)
      this.isTable(a[c]) || this.isTableRow(a[c]) || this.isTableCell(a[c]) || b.push(a[c]);
    return b;
  };
  Graph.prototype.updateCssTransform = function () {
    var a = this.view.getDrawPane();
    if (null != a)
      if (((a = a.parentNode), this.useCssTransforms)) {
        var b = a.getAttribute('transform');
        a.setAttribute('transformOrigin', '0 0');
        var c = Math.round(100 * this.currentScale) / 100;
        a.setAttribute(
          'transform',
          'scale(' +
            c +
            ',' +
            c +
            ')translate(' +
            Math.round(100 * this.currentTranslate.x) / 100 +
            ',' +
            Math.round(100 * this.currentTranslate.y) / 100 +
            ')'
        );
        b != a.getAttribute('transform') &&
          this.fireEvent(new mxEventObject('cssTransformChanged'), 'transform', a.getAttribute('transform'));
      } else a.removeAttribute('transformOrigin'), a.removeAttribute('transform');
  };
  var e = mxGraphView.prototype.validateBackgroundPage;
  mxGraphView.prototype.validateBackgroundPage = function () {
    var a = this.graph.useCssTransforms,
      b = this.scale,
      c = this.translate;
    a && ((this.scale = this.graph.currentScale), (this.translate = this.graph.currentTranslate));
    e.apply(this, arguments);
    a && ((this.scale = b), (this.translate = c));
  };
  var f = mxGraph.prototype.updatePageBreaks;
  mxGraph.prototype.updatePageBreaks = function (a, b, c) {
    var d = this.useCssTransforms,
      e = this.view.scale,
      g = this.view.translate;
    d && ((this.view.scale = 1), (this.view.translate = new mxPoint(0, 0)), (this.useCssTransforms = !1));
    f.apply(this, arguments);
    d && ((this.view.scale = e), (this.view.translate = g), (this.useCssTransforms = !0));
  };
})();
Graph.prototype.isLightboxView = function () {
  return this.lightbox;
};
Graph.prototype.isViewer = function () {
  return !1;
};
Graph.prototype.labelLinkClicked = function (a, b, c) {
  b = b.getAttribute('href');
  if (
    null != b &&
    !this.isCustomLink(b) &&
    ((mxEvent.isLeftMouseButton(c) && !mxEvent.isPopupTrigger(c)) || mxEvent.isTouchEvent(c))
  ) {
    if (!this.isEnabled() || this.isCellLocked(a.cell))
      (a = this.isBlankLink(b) ? this.linkTarget : '_top'), this.openLink(this.getAbsoluteUrl(b), a);
    mxEvent.consume(c);
  }
};
Graph.prototype.openLink = function (a, b, c) {
  var d = window;
  try {
    if ('_self' == b && window != window.top) window.location.href = a;
    else if (
      a.substring(0, this.baseUrl.length) == this.baseUrl &&
      '#' == a.charAt(this.baseUrl.length) &&
      '_top' == b &&
      window == window.top
    ) {
      var e = a.split('#')[1];
      window.location.hash == '#' + e && (window.location.hash = '');
      window.location.hash = e;
    } else (d = window.open(a, null != b ? b : '_blank')), null == d || c || (d.opener = null);
  } catch (f) {}
  return d;
};
Graph.prototype.getLinkTitle = function (a) {
  return a.substring(a.lastIndexOf('/') + 1);
};
Graph.prototype.isCustomLink = function (a) {
  return 'data:' == a.substring(0, 5);
};
Graph.prototype.customLinkClicked = function (a) {
  return !1;
};
Graph.prototype.isExternalProtocol = function (a) {
  return 'mailto:' === a.substring(0, 7);
};
Graph.prototype.isBlankLink = function (a) {
  return (
    !this.isExternalProtocol(a) &&
    ('blank' === this.linkPolicy ||
      ('self' !== this.linkPolicy &&
        !this.isRelativeUrl(a) &&
        a.substring(0, this.domainUrl.length) !== this.domainUrl))
  );
};
Graph.prototype.isRelativeUrl = function (a) {
  return null != a && !this.absoluteUrlPattern.test(a) && 'data:' !== a.substring(0, 5) && !this.isExternalProtocol(a);
};
Graph.prototype.getAbsoluteUrl = function (a) {
  null != a &&
    this.isRelativeUrl(a) &&
    (a = '#' == a.charAt(0) ? this.baseUrl + a : '/' == a.charAt(0) ? this.domainUrl + a : this.domainPathUrl + a);
  return a;
};
Graph.prototype.initLayoutManager = function () {
  this.layoutManager = new mxLayoutManager(this);
  this.layoutManager.hasLayout = function (a) {
    return null != this.graph.getCellStyle(a).childLayout;
  };
  this.layoutManager.getLayout = function (a, b) {
    var c = this.graph.model.getParent(a);
    if (!this.graph.isCellCollapsed(a) && (b != mxEvent.BEGIN_UPDATE || this.hasLayout(c, b))) {
      c = this.graph.getCellStyle(a);
      if ('stackLayout' == c.childLayout) {
        var d = new mxStackLayout(this.graph, !0);
        d.resizeParentMax = '1' == mxUtils.getValue(c, 'resizeParentMax', '1');
        d.horizontal = '1' == mxUtils.getValue(c, 'horizontalStack', '1');
        d.resizeParent = '1' == mxUtils.getValue(c, 'resizeParent', '1');
        d.resizeLast = '1' == mxUtils.getValue(c, 'resizeLast', '0');
        d.spacing = c.stackSpacing || d.spacing;
        d.border = c.stackBorder || d.border;
        d.marginLeft = c.marginLeft || 0;
        d.marginRight = c.marginRight || 0;
        d.marginTop = c.marginTop || 0;
        d.marginBottom = c.marginBottom || 0;
        d.allowGaps = c.allowGaps || 0;
        d.fill = !0;
        d.allowGaps && (d.gridSize = parseFloat(mxUtils.getValue(c, 'stackUnitSize', 20)));
        return d;
      }
      if ('treeLayout' == c.childLayout)
        return (
          (d = new mxCompactTreeLayout(this.graph)),
          (d.horizontal = '1' == mxUtils.getValue(c, 'horizontalTree', '1')),
          (d.resizeParent = '1' == mxUtils.getValue(c, 'resizeParent', '1')),
          (d.groupPadding = mxUtils.getValue(c, 'parentPadding', 20)),
          (d.levelDistance = mxUtils.getValue(c, 'treeLevelDistance', 30)),
          (d.maintainParentLocation = !0),
          (d.edgeRouting = !1),
          (d.resetEdges = !1),
          d
        );
      if ('flowLayout' == c.childLayout)
        return (
          (d = new mxHierarchicalLayout(
            this.graph,
            mxUtils.getValue(c, 'flowOrientation', mxConstants.DIRECTION_EAST)
          )),
          (d.resizeParent = '1' == mxUtils.getValue(c, 'resizeParent', '1')),
          (d.parentBorder = mxUtils.getValue(c, 'parentPadding', 20)),
          (d.maintainParentLocation = !0),
          (d.intraCellSpacing = mxUtils.getValue(
            c,
            'intraCellSpacing',
            mxHierarchicalLayout.prototype.intraCellSpacing
          )),
          (d.interRankCellSpacing = mxUtils.getValue(
            c,
            'interRankCellSpacing',
            mxHierarchicalLayout.prototype.interRankCellSpacing
          )),
          (d.interHierarchySpacing = mxUtils.getValue(
            c,
            'interHierarchySpacing',
            mxHierarchicalLayout.prototype.interHierarchySpacing
          )),
          (d.parallelEdgeSpacing = mxUtils.getValue(
            c,
            'parallelEdgeSpacing',
            mxHierarchicalLayout.prototype.parallelEdgeSpacing
          )),
          d
        );
      if ('circleLayout' == c.childLayout) return new mxCircleLayout(this.graph);
      if ('organicLayout' == c.childLayout) return new mxFastOrganicLayout(this.graph);
      if ('tableLayout' == c.childLayout) return new TableLayout(this.graph);
    }
    return null;
  };
};
Graph.prototype.getDataForCells = function (a) {
  for (var b = [], c = 0; c < a.length; c++) {
    var d = null != a[c].value ? a[c].value.attributes : null,
      e = {};
    e.id = a[c].id;
    if (null != d) for (var f = 0; f < d.length; f++) e[d[f].nodeName] = d[f].nodeValue;
    else e.label = this.convertValueToString(a[c]);
    b.push(e);
  }
  return b;
};
Graph.prototype.getNodesForCells = function (a) {
  for (var b = [], c = 0; c < a.length; c++) {
    var d = this.view.getState(a[c]);
    if (null != d) {
      for (var e = this.cellRenderer.getShapesForState(d), f = 0; f < e.length; f++)
        null != e[f] && null != e[f].node && b.push(e[f].node);
      null != d.control && null != d.control.node && b.push(d.control.node);
    }
  }
  return b;
};
Graph.prototype.createWipeAnimations = function (a, b) {
  for (var c = [], d = 0; d < a.length; d++) {
    var e = this.view.getState(a[d]);
    null != e &&
      null != e.shape &&
      (this.model.isEdge(e.cell) && null != e.absolutePoints && 1 < e.absolutePoints.length
        ? c.push(this.createEdgeWipeAnimation(e, b))
        : this.model.isVertex(e.cell) && null != e.shape.bounds && c.push(this.createVertexWipeAnimation(e, b)));
  }
  return c;
};
Graph.prototype.createEdgeWipeAnimation = function (a, b) {
  var c = a.absolutePoints.slice(),
    d = a.segments,
    e = a.length,
    f = c.length;
  return {
    execute: mxUtils.bind(this, function (g, k) {
      if (null != a.shape) {
        var h = [c[0]],
          l = g / k;
        b || (l = 1 - l);
        for (var m = e * l, n = 1; n < f; n++)
          if (m <= d[n - 1]) {
            h.push(
              new mxPoint(
                c[n - 1].x + ((c[n].x - c[n - 1].x) * m) / d[n - 1],
                c[n - 1].y + ((c[n].y - c[n - 1].y) * m) / d[n - 1]
              )
            );
            break;
          } else (m -= d[n - 1]), h.push(c[n]);
        a.shape.points = h;
        a.shape.redraw();
        0 == g && Graph.setOpacityForNodes(this.getNodesForCells([a.cell]), 1);
        null != a.text && null != a.text.node && (a.text.node.style.opacity = l);
      }
    }),
    stop: mxUtils.bind(this, function () {
      null != a.shape &&
        ((a.shape.points = c),
        a.shape.redraw(),
        null != a.text && null != a.text.node && (a.text.node.style.opacity = ''),
        Graph.setOpacityForNodes(this.getNodesForCells([a.cell]), b ? 1 : 0));
    }),
  };
};
Graph.prototype.createVertexWipeAnimation = function (a, b) {
  var c = new mxRectangle.fromRectangle(a.shape.bounds);
  return {
    execute: mxUtils.bind(this, function (d, e) {
      if (null != a.shape) {
        var f = d / e;
        b || (f = 1 - f);
        a.shape.bounds = new mxRectangle(c.x, c.y, c.width * f, c.height);
        a.shape.redraw();
        0 == d && Graph.setOpacityForNodes(this.getNodesForCells([a.cell]), 1);
        null != a.text && null != a.text.node && (a.text.node.style.opacity = f);
      }
    }),
    stop: mxUtils.bind(this, function () {
      null != a.shape &&
        ((a.shape.bounds = c),
        a.shape.redraw(),
        null != a.text && null != a.text.node && (a.text.node.style.opacity = ''),
        Graph.setOpacityForNodes(this.getNodesForCells([a.cell]), b ? 1 : 0));
    }),
  };
};
Graph.prototype.executeAnimations = function (a, b, c, d) {
  c = null != c ? c : 30;
  d = null != d ? d : 30;
  var e = null,
    f = 0,
    g = mxUtils.bind(this, function () {
      if (f == c || this.stoppingCustomActions) {
        window.clearInterval(e);
        for (var d = 0; d < a.length; d++) a[d].stop();
        null != b && b();
      } else for (d = 0; d < a.length; d++) a[d].execute(f, c);
      f++;
    }),
    e = window.setInterval(g, d);
  g();
};
Graph.prototype.getPageSize = function () {
  return this.pageVisible
    ? new mxRectangle(0, 0, this.pageFormat.width * this.pageScale, this.pageFormat.height * this.pageScale)
    : this.scrollTileSize;
};
Graph.prototype.getPageLayout = function () {
  var a = this.getPageSize(),
    b = this.getGraphBounds();
  if (0 == b.width || 0 == b.height) return new mxRectangle(0, 0, 1, 1);
  var c = Math.floor(Math.ceil(b.x / this.view.scale - this.view.translate.x) / a.width),
    d = Math.floor(Math.ceil(b.y / this.view.scale - this.view.translate.y) / a.height);
  return new mxRectangle(
    c,
    d,
    Math.ceil((Math.floor((b.x + b.width) / this.view.scale) - this.view.translate.x) / a.width) - c,
    Math.ceil((Math.floor((b.y + b.height) / this.view.scale) - this.view.translate.y) / a.height) - d
  );
};
Graph.prototype.sanitizeHtml = function (a, b) {
  return Graph.sanitizeHtml(a, b);
};
Graph.prototype.updatePlaceholders = function () {
  var a = !1,
    b;
  for (b in this.model.cells) {
    var c = this.model.cells[b];
    this.isReplacePlaceholders(c) && (this.view.invalidate(c, !1, !1), (a = !0));
  }
  a && this.view.validate();
};
Graph.prototype.isReplacePlaceholders = function (a) {
  return null != a.value && 'object' == typeof a.value && '1' == a.value.getAttribute('placeholders');
};
Graph.prototype.isZoomWheelEvent = function (a) {
  return (
    (Graph.zoomWheel &&
      !mxEvent.isShiftDown(a) &&
      !mxEvent.isMetaDown(a) &&
      !mxEvent.isAltDown(a) &&
      (!mxEvent.isControlDown(a) || mxClient.IS_MAC)) ||
    (!Graph.zoomWheel && (mxEvent.isAltDown(a) || mxEvent.isControlDown(a)))
  );
};
Graph.prototype.isScrollWheelEvent = function (a) {
  return !this.isZoomWheelEvent(a);
};
Graph.prototype.isTransparentClickEvent = function (a) {
  return mxEvent.isAltDown(a) || (mxClient.IS_CHROMEOS && mxEvent.isShiftDown(a));
};
Graph.prototype.isIgnoreTerminalEvent = function (a) {
  return mxEvent.isAltDown(a) && !mxEvent.isShiftDown(a) && !mxEvent.isControlDown(a) && !mxEvent.isMetaDown(a);
};
Graph.prototype.isEdgeIgnored = function (a) {
  var b = !1;
  null != a && ((a = this.getCurrentCellStyle(a)), (b = '1' == mxUtils.getValue(a, 'ignoreEdge', '0')));
  return b;
};
Graph.prototype.isSplitTarget = function (a, b, c) {
  return (
    !this.model.isEdge(b[0]) &&
    !mxEvent.isAltDown(c) &&
    !mxEvent.isShiftDown(c) &&
    mxGraph.prototype.isSplitTarget.apply(this, arguments)
  );
};
Graph.prototype.getLabel = function (a) {
  var b = mxGraph.prototype.getLabel.apply(this, arguments);
  null != b &&
    this.isReplacePlaceholders(a) &&
    null == a.getAttribute('placeholder') &&
    (b = this.replacePlaceholders(a, b));
  return b;
};
Graph.prototype.isLabelMovable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return (
    !this.isCellLocked(a) &&
    ((this.model.isEdge(a) && this.edgeLabelsMovable) ||
      (this.model.isVertex(a) && (this.vertexLabelsMovable || '1' == mxUtils.getValue(b, 'labelMovable', '0'))))
  );
};
Graph.prototype.setGridSize = function (a) {
  this.gridSize = a;
  this.fireEvent(new mxEventObject('gridSizeChanged'));
};
Graph.prototype.setDefaultParent = function (a) {
  this.defaultParent = a;
  this.fireEvent(new mxEventObject('defaultParentChanged'));
};
Graph.prototype.getClickableLinkForCell = function (a) {
  do {
    var b = this.getLinkForCell(a);
    if (null != b) return b;
    a = this.model.getParent(a);
  } while (null != a);
  return null;
};
Graph.prototype.getGlobalVariable = function (a) {
  var b = null;
  'date' == a
    ? (b = new Date().toLocaleDateString())
    : 'time' == a
    ? (b = new Date().toLocaleTimeString())
    : 'timestamp' == a
    ? (b = new Date().toLocaleString())
    : 'date{' == a.substring(0, 5) && ((a = a.substring(5, a.length - 1)), (b = this.formatDate(new Date(), a)));
  return b;
};
Graph.prototype.formatDate = function (a, b, c) {
  null == this.dateFormatCache &&
    (this.dateFormatCache = {
      i18n: {
        dayNames: 'Sun Mon Tue Wed Thu Fri Sat Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),
        monthNames:
          'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec January February March April May June July August September October November December'.split(
            ' '
          ),
      },
      masks: {
        default: 'ddd mmm dd yyyy HH:MM:ss',
        shortDate: 'm/d/yy',
        mediumDate: 'mmm d, yyyy',
        longDate: 'mmmm d, yyyy',
        fullDate: 'dddd, mmmm d, yyyy',
        shortTime: 'h:MM TT',
        mediumTime: 'h:MM:ss TT',
        longTime: 'h:MM:ss TT Z',
        isoDate: 'yyyy-mm-dd',
        isoTime: 'HH:MM:ss',
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
      },
    });
  var d = this.dateFormatCache,
    e =
      /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    f = /[^-+\dA-Z]/g,
    g = function (a, b) {
      a = String(a);
      for (b = b || 2; a.length < b; ) a = '0' + a;
      return a;
    };
  1 != arguments.length ||
    '[object String]' != Object.prototype.toString.call(a) ||
    /\d/.test(a) ||
    ((b = a), (a = void 0));
  a = a ? new Date(a) : new Date();
  if (isNaN(a)) throw SyntaxError('invalid date');
  b = String(d.masks[b] || b || d.masks['default']);
  'UTC:' == b.slice(0, 4) && ((b = b.slice(4)), (c = !0));
  var k = c ? 'getUTC' : 'get',
    h = a[k + 'Date'](),
    l = a[k + 'Day'](),
    m = a[k + 'Month'](),
    n = a[k + 'FullYear'](),
    p = a[k + 'Hours'](),
    r = a[k + 'Minutes'](),
    t = a[k + 'Seconds'](),
    k = a[k + 'Milliseconds'](),
    u = c ? 0 : a.getTimezoneOffset(),
    x = {
      d: h,
      dd: g(h),
      ddd: d.i18n.dayNames[l],
      dddd: d.i18n.dayNames[l + 7],
      m: m + 1,
      mm: g(m + 1),
      mmm: d.i18n.monthNames[m],
      mmmm: d.i18n.monthNames[m + 12],
      yy: String(n).slice(2),
      yyyy: n,
      h: p % 12 || 12,
      hh: g(p % 12 || 12),
      H: p,
      HH: g(p),
      M: r,
      MM: g(r),
      s: t,
      ss: g(t),
      l: g(k, 3),
      L: g(99 < k ? Math.round(k / 10) : k),
      t: 12 > p ? 'a' : 'p',
      tt: 12 > p ? 'am' : 'pm',
      T: 12 > p ? 'A' : 'P',
      TT: 12 > p ? 'AM' : 'PM',
      Z: c ? 'UTC' : (String(a).match(e) || ['']).pop().replace(f, ''),
      o: (0 < u ? '-' : '+') + g(100 * Math.floor(Math.abs(u) / 60) + (Math.abs(u) % 60), 4),
      S: ['th', 'st', 'nd', 'rd'][3 < h % 10 ? 0 : ((10 != (h % 100) - (h % 10)) * h) % 10],
    };
  return b.replace(/d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g, function (a) {
    return a in x ? x[a] : a.slice(1, a.length - 1);
  });
};
Graph.prototype.getLayerForCells = function (a) {
  var b = null;
  if (0 < a.length) {
    for (b = a[0]; !this.model.isLayer(b); ) b = this.model.getParent(b);
    for (var c = 1; c < a.length; c++)
      if (!this.model.isAncestor(b, a[c])) {
        b = null;
        break;
      }
  }
  return b;
};
Graph.prototype.createLayersDialog = function (a, b) {
  var c = document.createElement('div');
  c.style.position = 'absolute';
  for (var d = this.getModel(), e = d.getChildCount(d.root), f = 0; f < e; f++)
    mxUtils.bind(this, function (e) {
      function f() {
        d.isVisible(e)
          ? (m.setAttribute('src', Editor.visibleImage), mxUtils.setOpacity(l, 75))
          : (m.setAttribute('src', Editor.hiddenImage), mxUtils.setOpacity(l, 25));
      }
      var g = this.convertValueToString(e) || mxResources.get('background') || 'Background',
        l = document.createElement('div');
      l.style.overflow = 'hidden';
      l.style.textOverflow = 'ellipsis';
      l.style.padding = '2px';
      l.style.whiteSpace = 'nowrap';
      l.style.cursor = 'pointer';
      l.setAttribute('title', mxResources.get(d.isVisible(e) ? 'hideIt' : 'show', [g]));
      var m = document.createElement('img');
      m.setAttribute('draggable', 'false');
      m.setAttribute('align', 'absmiddle');
      m.setAttribute('border', '0');
      m.style.position = 'relative';
      m.style.width = '16px';
      m.style.padding = '0px 6px 0 4px';
      b && ((m.style.filter = 'invert(100%)'), (m.style.top = '-2px'));
      l.appendChild(m);
      mxUtils.write(l, g);
      c.appendChild(l);
      mxEvent.addListener(l, 'click', function () {
        d.setVisible(e, !d.isVisible(e));
        f();
        null != a && a(e);
      });
      f();
    })(d.getChildAt(d.root, f));
  return c;
};
Graph.prototype.replacePlaceholders = function (a, b, c, d) {
  d = [];
  if (null != b) {
    for (var e = 0; (match = this.placeholderPattern.exec(b)); ) {
      var f = match[0];
      if (2 < f.length && '%label%' != f && '%tooltip%' != f) {
        var g = null;
        if (match.index > e && '%' == b.charAt(match.index - 1)) g = f.substring(1);
        else {
          var k = f.substring(1, f.length - 1);
          if ('id' == k) g = a.id;
          else if (0 > k.indexOf('{'))
            for (var h = a; null == g && null != h; )
              null != h.value &&
                'object' == typeof h.value &&
                (Graph.translateDiagram &&
                  null != Graph.diagramLanguage &&
                  (g = h.getAttribute(k + '_' + Graph.diagramLanguage)),
                null == g && (g = h.hasAttribute(k) ? (null != h.getAttribute(k) ? h.getAttribute(k) : '') : null)),
                (h = this.model.getParent(h));
          null == g && (g = this.getGlobalVariable(k));
          null == g && null != c && (g = c[k]);
        }
        d.push(b.substring(e, match.index) + (null != g ? g : f));
        e = match.index + f.length;
      }
    }
    d.push(b.substring(e));
  }
  return d.join('');
};
Graph.prototype.restoreSelection = function (a) {
  if (null != a && 0 < a.length) {
    for (var b = [], c = 0; c < a.length; c++) {
      var d = this.model.getCell(a[c].id);
      null != d && b.push(d);
    }
    this.setSelectionCells(b);
  } else this.clearSelection();
};
Graph.prototype.selectCellForEvent = function (a, b) {
  (mxEvent.isShiftDown(b) && !this.isSelectionEmpty() && this.selectTableRange(this.getSelectionCell(), a)) ||
    mxGraph.prototype.selectCellForEvent.apply(this, arguments);
};
Graph.prototype.selectTableRange = function (a, b) {
  var c = !1;
  if (this.isTableCell(a) && this.isTableCell(b)) {
    var d = this.model.getParent(a),
      e = this.model.getParent(d),
      f = this.model.getParent(b);
    if (e == this.model.getParent(f)) {
      for (
        var g = d.getIndex(a),
          k = e.getIndex(d),
          h = f.getIndex(b),
          l = e.getIndex(f),
          f = Math.max(k, l),
          d = Math.min(g, h),
          g = Math.max(g, h),
          h = [],
          k = Math.min(k, l);
        k <= f;
        k++
      )
        for (var l = this.model.getChildAt(e, k), m = d; m <= g; m++) h.push(this.model.getChildAt(l, m));
      0 < h.length &&
        (1 < h.length || 1 < this.getSelectionCount() || !this.isCellSelected(h[0])) &&
        (this.setSelectionCells(h), (c = !0));
    }
  }
  return c;
};
Graph.prototype.snapCellsToGrid = function (a, b) {
  this.getModel().beginUpdate();
  try {
    for (var c = 0; c < a.length; c++) {
      var d = a[c],
        e = this.getCellGeometry(d);
      if (null != e) {
        e = e.clone();
        if (this.getModel().isVertex(d))
          (e.x = Math.round(e.x / b) * b),
            (e.y = Math.round(e.y / b) * b),
            (e.width = Math.round(e.width / b) * b),
            (e.height = Math.round(e.height / b) * b);
        else if (this.getModel().isEdge(d) && null != e.points)
          for (var f = 0; f < e.points.length; f++)
            (e.points[f].x = Math.round(e.points[f].x / b) * b), (e.points[f].y = Math.round(e.points[f].y / b) * b);
        this.getModel().setGeometry(d, e);
      }
    }
  } finally {
    this.getModel().endUpdate();
  }
};
Graph.prototype.selectCellsForConnectVertex = function (a, b, c) {
  2 == a.length && this.model.isVertex(a[1])
    ? (this.setSelectionCell(a[1]),
      this.scrollCellToVisible(a[1]),
      null != c && (mxEvent.isTouchEvent(b) ? c.update(c.getState(this.view.getState(a[1]))) : c.reset()))
    : this.setSelectionCells(a);
};
Graph.prototype.isCloneConnectSource = function (a) {
  var b = null;
  null != this.layoutManager && (b = this.layoutManager.getLayout(this.model.getParent(a)));
  return this.isTableRow(a) || this.isTableCell(a) || (null != b && b.constructor == mxStackLayout);
};
Graph.prototype.connectVertex = function (a, b, c, d, e, f, g, k) {
  f = f ? f : !1;
  if (a.geometry.relative && this.model.isEdge(a.parent)) return [];
  for (; a.geometry.relative && this.model.isVertex(a.parent); ) a = a.parent;
  var h = this.isCloneConnectSource(a),
    l = h ? a : this.getCompositeParent(a),
    m =
      a.geometry.relative && null != a.parent.geometry
        ? new mxPoint(a.parent.geometry.width * a.geometry.x, a.parent.geometry.height * a.geometry.y)
        : new mxPoint(l.geometry.x, l.geometry.y);
  b == mxConstants.DIRECTION_NORTH
    ? ((m.x += l.geometry.width / 2), (m.y -= c))
    : b == mxConstants.DIRECTION_SOUTH
    ? ((m.x += l.geometry.width / 2), (m.y += l.geometry.height + c))
    : ((m.x = b == mxConstants.DIRECTION_WEST ? m.x - c : m.x + (l.geometry.width + c)),
      (m.y += l.geometry.height / 2));
  var n = this.view.getState(this.model.getParent(a));
  c = this.view.scale;
  var p = this.view.translate,
    l = p.x * c,
    p = p.y * c;
  null != n && this.model.isVertex(n.cell) && ((l = n.x), (p = n.y));
  this.model.isVertex(a.parent) && a.geometry.relative && ((m.x += a.parent.geometry.x), (m.y += a.parent.geometry.y));
  f = f ? null : new mxRectangle(l + m.x * c, p + m.y * c).grow(40 * c);
  f = null != f ? this.getCells(0, 0, 0, 0, null, null, f, null, !0) : null;
  var n = this.view.getState(a),
    r = null,
    t = null;
  if (null != f) {
    f = f.reverse();
    for (var u = 0; u < f.length; u++)
      if (!this.isCellLocked(f[u]) && !this.model.isEdge(f[u]) && f[u] != a)
        if (!this.model.isAncestor(a, f[u]) && this.isContainer(f[u]) && (null == r || f[u] == this.model.getParent(a)))
          r = f[u];
        else if (
          null == t &&
          this.isCellConnectable(f[u]) &&
          !this.model.isAncestor(f[u], a) &&
          !this.isSwimlane(f[u])
        ) {
          var x = this.view.getState(f[u]);
          null == n || null == x || mxUtils.intersects(n, x) || (t = f[u]);
        }
  }
  var z = !mxEvent.isShiftDown(d) || mxEvent.isControlDown(d) || e;
  z &&
    ('1' != urlParams.sketch || e) &&
    (b == mxConstants.DIRECTION_NORTH
      ? (m.y -= a.geometry.height / 2)
      : b == mxConstants.DIRECTION_SOUTH
      ? (m.y += a.geometry.height / 2)
      : (m.x = b == mxConstants.DIRECTION_WEST ? m.x - a.geometry.width / 2 : m.x + a.geometry.width / 2));
  var D = [],
    B = t,
    t = r;
  e = mxUtils.bind(this, function (c) {
    if (null == g || null != c || (null == t && h)) {
      this.model.beginUpdate();
      try {
        if (null == B && z) {
          var e = this.getAbsoluteParent(null != c ? c : a),
            e = h ? a : this.getCompositeParent(e);
          B = null != c ? c : this.duplicateCells([e], !1)[0];
          null != c && this.addCells([B], this.model.getParent(a), null, null, null, !0);
          var f = this.getCellGeometry(B);
          null != f &&
            (null != c &&
              '1' == urlParams.sketch &&
              (b == mxConstants.DIRECTION_NORTH
                ? (m.y -= f.height / 2)
                : b == mxConstants.DIRECTION_SOUTH
                ? (m.y += f.height / 2)
                : (m.x = b == mxConstants.DIRECTION_WEST ? m.x - f.width / 2 : m.x + f.width / 2)),
            (f.x = m.x - f.width / 2),
            (f.y = m.y - f.height / 2));
          null != r
            ? (this.addCells([B], r, null, null, null, !0), (t = null))
            : z && !h && this.addCells([B], this.getDefaultParent(), null, null, null, !0);
        }
        var l =
          (mxEvent.isControlDown(d) && mxEvent.isShiftDown(d) && z) || (null == t && h)
            ? null
            : this.insertEdge(this.model.getParent(a), null, '', a, B, this.createCurrentEdgeStyle());
        if (null != l && this.connectionHandler.insertBeforeSource) {
          var n = null;
          for (c = a; null != c.parent && null != c.geometry && c.geometry.relative && c.parent != l.parent; )
            c = this.model.getParent(c);
          null != c &&
            null != c.parent &&
            c.parent == l.parent &&
            ((n = c.parent.getIndex(c)), this.model.add(c.parent, l, n));
        }
        null == t &&
          null != B &&
          null != a.parent &&
          h &&
          b == mxConstants.DIRECTION_WEST &&
          ((n = a.parent.getIndex(a)), this.model.add(a.parent, B, n));
        null != l && D.push(l);
        null == t && null != B && D.push(B);
        null == B && null != l && l.geometry.setTerminalPoint(m, !1);
        null != l && this.fireEvent(new mxEventObject('cellsInserted', 'cells', [l]));
      } finally {
        this.model.endUpdate();
      }
    }
    if (null != k) k(D);
    else return D;
  });
  if (null == g || null != B || !z || (null == t && h)) return e(B);
  g(l + m.x * c, p + m.y * c, e);
};
Graph.prototype.getIndexableText = function (a) {
  a = null != a ? a : this.model.getDescendants(this.model.root);
  for (var b = document.createElement('div'), c = [], d, e = 0; e < a.length; e++)
    if (((d = a[e]), this.model.isVertex(d) || this.model.isEdge(d)))
      this.isHtmlLabel(d)
        ? ((b.innerHTML = this.sanitizeHtml(this.getLabel(d))), (d = mxUtils.extractTextWithWhitespace([b])))
        : (d = this.getLabel(d)),
        (d = mxUtils.trim(d.replace(/[\x00-\x1F\x7F-\x9F]|\s+/g, ' '))),
        0 < d.length && c.push(d);
  return c.join(' ');
};
Graph.prototype.convertValueToString = function (a) {
  var b = this.model.getValue(a);
  if (null != b && 'object' == typeof b) {
    var c = null;
    if (this.isReplacePlaceholders(a) && null != a.getAttribute('placeholder'))
      for (var b = a.getAttribute('placeholder'), d = a; null == c && null != d; )
        null != d.value &&
          'object' == typeof d.value &&
          (c = d.hasAttribute(b) ? (null != d.getAttribute(b) ? d.getAttribute(b) : '') : null),
          (d = this.model.getParent(d));
    else
      (c = null),
        Graph.translateDiagram &&
          null != Graph.diagramLanguage &&
          (c = b.getAttribute('label_' + Graph.diagramLanguage)),
        null == c && (c = b.getAttribute('label') || '');
    return c || '';
  }
  return mxGraph.prototype.convertValueToString.apply(this, arguments);
};
Graph.prototype.getLinksForState = function (a) {
  return null != a && null != a.text && null != a.text.node ? a.text.node.getElementsByTagName('a') : null;
};
Graph.prototype.getLinkForCell = function (a) {
  return null != a.value && 'object' == typeof a.value
    ? ((a = a.value.getAttribute('link')),
      null != a && 'javascript:' === a.toLowerCase().substring(0, 11) && (a = a.substring(11)),
      a)
    : null;
};
Graph.prototype.getLinkTargetForCell = function (a) {
  return null != a.value && 'object' == typeof a.value ? a.value.getAttribute('linkTarget') : null;
};
Graph.prototype.postProcessCellStyle = function (a, b) {
  return this.updateHorizontalStyle(
    a,
    this.replaceDefaultColors(a, mxGraph.prototype.postProcessCellStyle.apply(this, arguments))
  );
};
Graph.prototype.updateHorizontalStyle = function (a, b) {
  if (null != a && null != b && null != this.layoutManager) {
    var c = this.model.getParent(a);
    this.model.isVertex(c) &&
      this.isCellCollapsed(a) &&
      ((c = this.layoutManager.getLayout(c)),
      null != c && c.constructor == mxStackLayout && (b[mxConstants.STYLE_HORIZONTAL] = !c.horizontal));
  }
  return b;
};
Graph.prototype.replaceDefaultColors = function (a, b) {
  if (null != b) {
    var c = mxUtils.hex2rgb(this.shapeBackgroundColor),
      d = mxUtils.hex2rgb(this.shapeForegroundColor);
    this.replaceDefaultColor(b, mxConstants.STYLE_FONTCOLOR, d);
    this.replaceDefaultColor(b, mxConstants.STYLE_FILLCOLOR, c);
    this.replaceDefaultColor(b, mxConstants.STYLE_STROKECOLOR, d);
    this.replaceDefaultColor(b, mxConstants.STYLE_IMAGE_BORDER, d);
    this.replaceDefaultColor(b, mxConstants.STYLE_IMAGE_BACKGROUND, c);
    this.replaceDefaultColor(b, mxConstants.STYLE_LABEL_BORDERCOLOR, d);
    this.replaceDefaultColor(b, mxConstants.STYLE_SWIMLANE_FILLCOLOR, c);
    this.replaceDefaultColor(b, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, c);
  }
  return b;
};
Graph.prototype.replaceDefaultColor = function (a, b, c) {
  null != a && 'default' == a[b] && null != c && (a[b] = c);
};
Graph.prototype.updateAlternateBounds = function (a, b, c) {
  if (null != a && null != b && null != this.layoutManager && null != b.alternateBounds) {
    var d = this.layoutManager.getLayout(this.model.getParent(a));
    null != d &&
      d.constructor == mxStackLayout &&
      (d.horizontal ? (b.alternateBounds.height = 0) : (b.alternateBounds.width = 0));
  }
  mxGraph.prototype.updateAlternateBounds.apply(this, arguments);
};
Graph.prototype.isMoveCellsEvent = function (a, b) {
  return mxEvent.isShiftDown(a) || '1' == mxUtils.getValue(b.style, 'moveCells', '0');
};
Graph.prototype.foldCells = function (a, b, c, d, e) {
  b = null != b ? b : !1;
  null == c && (c = this.getFoldableCells(this.getSelectionCells(), a));
  if (null != c) {
    this.model.beginUpdate();
    try {
      if ((mxGraph.prototype.foldCells.apply(this, arguments), null != this.layoutManager))
        for (var f = 0; f < c.length; f++) {
          var g = this.view.getState(c[f]),
            k = this.getCellGeometry(c[f]);
          if (null != g && null != k) {
            var h = Math.round(k.width - g.width / this.view.scale),
              l = Math.round(k.height - g.height / this.view.scale);
            if (0 != l || 0 != h) {
              var m = this.model.getParent(c[f]),
                n = this.layoutManager.getLayout(m);
              null == n
                ? null != e && this.isMoveCellsEvent(e, g) && this.moveSiblings(g, m, h, l)
                : (null != e && mxEvent.isAltDown(e)) ||
                  n.constructor != mxStackLayout ||
                  n.resizeLast ||
                  this.resizeParentStacks(m, n, h, l);
            }
          }
        }
    } finally {
      this.model.endUpdate();
    }
    this.isEnabled() && this.setSelectionCells(c);
  }
};
Graph.prototype.moveSiblings = function (a, b, c, d) {
  this.model.beginUpdate();
  try {
    var e = this.getCellsBeyond(a.x, a.y, b, !0, !0);
    for (b = 0; b < e.length; b++)
      if (e[b] != a.cell) {
        var f = this.view.getState(e[b]),
          g = this.getCellGeometry(e[b]);
        null != f &&
          null != g &&
          ((g = g.clone()),
          g.translate(
            Math.round(c * Math.max(0, Math.min(1, (f.x - a.x) / a.width))),
            Math.round(d * Math.max(0, Math.min(1, (f.y - a.y) / a.height)))
          ),
          this.model.setGeometry(e[b], g));
      }
  } finally {
    this.model.endUpdate();
  }
};
Graph.prototype.resizeParentStacks = function (a, b, c, d) {
  if (null != this.layoutManager && null != b && b.constructor == mxStackLayout && !b.resizeLast) {
    this.model.beginUpdate();
    try {
      for (
        var e = b.horizontal;
        null != a && null != b && b.constructor == mxStackLayout && b.horizontal == e && !b.resizeLast;

      ) {
        var f = this.getCellGeometry(a),
          g = this.view.getState(a);
        null != g &&
          null != f &&
          ((f = f.clone()),
          b.horizontal
            ? (f.width += c + Math.min(0, g.width / this.view.scale - f.width))
            : (f.height += d + Math.min(0, g.height / this.view.scale - f.height)),
          this.model.setGeometry(a, f));
        a = this.model.getParent(a);
        b = this.layoutManager.getLayout(a);
      }
    } finally {
      this.model.endUpdate();
    }
  }
};
Graph.prototype.isContainer = function (a) {
  var b = this.getCurrentCellStyle(a);
  return this.isSwimlane(a) ? '0' != b.container : '1' == b.container;
};
Graph.prototype.isCellConnectable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return null != b.connectable ? '0' != b.connectable : mxGraph.prototype.isCellConnectable.apply(this, arguments);
};
Graph.prototype.isLabelMovable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return null != b.movableLabel ? '0' != b.movableLabel : mxGraph.prototype.isLabelMovable.apply(this, arguments);
};
Graph.prototype.selectAll = function (a) {
  a = a || this.getDefaultParent();
  this.isCellLocked(a) || mxGraph.prototype.selectAll.apply(this, arguments);
};
Graph.prototype.selectCells = function (a, b, c) {
  c = c || this.getDefaultParent();
  this.isCellLocked(c) || mxGraph.prototype.selectCells.apply(this, arguments);
};
Graph.prototype.getSwimlaneAt = function (a, b, c) {
  var d = mxGraph.prototype.getSwimlaneAt.apply(this, arguments);
  this.isCellLocked(d) && (d = null);
  return d;
};
Graph.prototype.isCellFoldable = function (a) {
  var b = this.getCurrentCellStyle(a);
  return (
    this.foldingEnabled &&
    '0' != mxUtils.getValue(b, mxConstants.STYLE_RESIZABLE, '1') &&
    ('1' == b.treeFolding ||
      (!this.isCellLocked(a) &&
        ((this.isContainer(a) && '0' != b.collapsible) || (!this.isContainer(a) && '1' == b.collapsible))))
  );
};
Graph.prototype.reset = function () {
  this.isEditing() && this.stopEditing(!0);
  this.escape();
  this.isSelectionEmpty() || this.clearSelection();
};
Graph.prototype.zoom = function (a, b) {
  a = Math.max(0.01, Math.min(this.view.scale * a, 160)) / this.view.scale;
  mxGraph.prototype.zoom.apply(this, arguments);
};
Graph.prototype.zoomIn = function () {
  0.15 > this.view.scale
    ? this.zoom((this.view.scale + 0.01) / this.view.scale)
    : this.zoom(Math.round(this.view.scale * this.zoomFactor * 20) / 20 / this.view.scale);
};
Graph.prototype.zoomOut = function () {
  0.15 >= this.view.scale
    ? this.zoom((this.view.scale - 0.01) / this.view.scale)
    : this.zoom(Math.round((1 / this.zoomFactor) * this.view.scale * 20) / 20 / this.view.scale);
};
Graph.prototype.fitWindow = function (a, b) {
  b = null != b ? b : 10;
  var c = this.container.clientWidth - b,
    d = this.container.clientHeight - b,
    e = Math.floor(20 * Math.min(c / a.width, d / a.height)) / 20;
  this.zoomTo(e);
  if (mxUtils.hasScrollbars(this.container)) {
    var f = this.view.translate;
    this.container.scrollTop = (a.y + f.y) * e - Math.max((d - a.height * e) / 2 + b / 2, 0);
    this.container.scrollLeft = (a.x + f.x) * e - Math.max((c - a.width * e) / 2 + b / 2, 0);
  }
};
Graph.prototype.getTooltipForCell = function (a) {
  var b = '';
  if (mxUtils.isNode(a.value)) {
    var c = null;
    Graph.translateDiagram &&
      null != Graph.diagramLanguage &&
      (c = a.value.getAttribute('tooltip_' + Graph.diagramLanguage));
    null == c && (c = a.value.getAttribute('tooltip'));
    if (null != c)
      null != c && this.isReplacePlaceholders(a) && (c = this.replacePlaceholders(a, c)), (b = this.sanitizeHtml(c));
    else {
      c = this.builtInProperties;
      a = a.value.attributes;
      var d = [];
      this.isEnabled() && (c.push('linkTarget'), c.push('link'));
      for (var e = 0; e < a.length; e++)
        0 > mxUtils.indexOf(c, a[e].nodeName) &&
          0 < a[e].nodeValue.length &&
          d.push({ name: a[e].nodeName, value: a[e].nodeValue });
      d.sort(function (a, b) {
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });
      for (e = 0; e < d.length; e++)
        ('link' == d[e].name && this.isCustomLink(d[e].value)) ||
          (b += ('link' != d[e].name ? '<b>' + d[e].name + ':</b> ' : '') + mxUtils.htmlEntities(d[e].value) + '\n');
      0 < b.length &&
        ((b = b.substring(0, b.length - 1)),
        mxClient.IS_SVG &&
          (b = '<div style="max-width:360px;text-overflow:ellipsis;overflow:hidden;">' + b + '</div>'));
    }
  }
  return b;
};
Graph.prototype.getFlowAnimationStyle = function () {
  var a = document.getElementsByTagName('head')[0];
  if (null != a && null == this.flowAnimationStyle) {
    this.flowAnimationStyle = document.createElement('style');
    this.flowAnimationStyle.setAttribute('id', 'geEditorFlowAnimation-' + Editor.guid());
    this.flowAnimationStyle.type = 'text/css';
    var b = this.flowAnimationStyle.getAttribute('id');
    this.flowAnimationStyle.innerHTML = this.getFlowAnimationStyleCss(b);
    a.appendChild(this.flowAnimationStyle);
  }
  return this.flowAnimationStyle;
};
Graph.prototype.getFlowAnimationStyleCss = function (a) {
  return (
    '.' +
    a +
    ' {\nanimation: ' +
    a +
    ' 0.5s linear;\nanimation-iteration-count: infinite;\n}\n@keyframes ' +
    a +
    ' {\nto {\nstroke-dashoffset: ' +
    -16 * this.view.scale +
    ';\n}\n}'
  );
};
Graph.prototype.stringToBytes = function (a) {
  return Graph.stringToBytes(a);
};
Graph.prototype.bytesToString = function (a) {
  return Graph.bytesToString(a);
};
Graph.prototype.compressNode = function (a) {
  return Graph.compressNode(a);
};
Graph.prototype.compress = function (a, b) {
  return Graph.compress(a, b);
};
Graph.prototype.decompress = function (a, b) {
  return Graph.decompress(a, b);
};
Graph.prototype.zapGremlins = function (a) {
  return Graph.zapGremlins(a);
};
HoverIcons = function (a) {
  mxEventSource.call(this);
  this.graph = a;
  this.init();
};
mxUtils.extend(HoverIcons, mxEventSource);
HoverIcons.prototype.arrowSpacing = 2;
HoverIcons.prototype.updateDelay = 500;
HoverIcons.prototype.activationDelay = 140;
HoverIcons.prototype.currentState = null;
HoverIcons.prototype.activeArrow = null;
HoverIcons.prototype.inactiveOpacity = 15;
HoverIcons.prototype.cssCursor = 'copy';
HoverIcons.prototype.checkCollisions = !0;
HoverIcons.prototype.arrowFill = '#29b6f2';
HoverIcons.prototype.triangleUp = mxClient.IS_SVG
  ? Graph.createSvgImage(
      18,
      28,
      '<path d="m 6 26 L 12 26 L 12 12 L 18 12 L 9 1 L 1 12 L 6 12 z" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/>'
    )
  : new mxImage(IMAGE_PATH + '/triangle-up.png', 26, 14);
HoverIcons.prototype.triangleRight = mxClient.IS_SVG
  ? Graph.createSvgImage(
      26,
      18,
      '<path d="m 1 6 L 14 6 L 14 1 L 26 9 L 14 18 L 14 12 L 1 12 z" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/>'
    )
  : new mxImage(IMAGE_PATH + '/triangle-right.png', 14, 26);
HoverIcons.prototype.triangleDown = mxClient.IS_SVG
  ? Graph.createSvgImage(
      18,
      26,
      '<path d="m 6 1 L 6 14 L 1 14 L 9 26 L 18 14 L 12 14 L 12 1 z" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/>'
    )
  : new mxImage(IMAGE_PATH + '/triangle-down.png', 26, 14);
HoverIcons.prototype.triangleLeft = mxClient.IS_SVG
  ? Graph.createSvgImage(
      28,
      18,
      '<path d="m 1 9 L 12 1 L 12 6 L 26 6 L 26 12 L 12 12 L 12 18 z" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/>'
    )
  : new mxImage(IMAGE_PATH + '/triangle-left.png', 14, 26);
HoverIcons.prototype.roundDrop = mxClient.IS_SVG
  ? Graph.createSvgImage(
      26,
      26,
      '<circle cx="13" cy="13" r="12" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>'
    )
  : new mxImage(IMAGE_PATH + '/round-drop.png', 26, 26);
HoverIcons.prototype.refreshTarget = new mxImage(
  mxClient.IS_SVG
    ? 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjM2cHgiIGhlaWdodD0iMzZweCI+PGVsbGlwc2UgZmlsbD0iIzI5YjZmMiIgY3g9IjEyIiBjeT0iMTIiIHJ4PSIxMiIgcnk9IjEyIi8+PHBhdGggdHJhbnNmb3JtPSJzY2FsZSgwLjgpIHRyYW5zbGF0ZSgyLjQsIDIuNCkiIHN0cm9rZT0iI2ZmZiIgZmlsbD0iI2ZmZiIgZD0iTTEyIDZ2M2w0LTQtNC00djNjLTQuNDIgMC04IDMuNTgtOCA4IDAgMS41Ny40NiAzLjAzIDEuMjQgNC4yNkw2LjcgMTQuOGMtLjQ1LS44My0uNy0xLjc5LS43LTIuOCAwLTMuMzEgMi42OS02IDYtNnptNi43NiAxLjc0TDE3LjMgOS4yYy40NC44NC43IDEuNzkuNyAyLjggMCAzLjMxLTIuNjkgNi02IDZ2LTNsLTQgNCA0IDR2LTNjNC40MiAwIDgtMy41OCA4LTggMC0xLjU3LS40Ni0zLjAzLTEuMjQtNC4yNnoiLz48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+Cg=='
    : IMAGE_PATH + '/refresh.png',
  38,
  38
);
HoverIcons.prototype.tolerance = mxClient.IS_TOUCH ? 6 : 0;
HoverIcons.prototype.init = function () {
  this.arrowUp = this.createArrow(this.triangleUp, mxResources.get('plusTooltip'), mxConstants.DIRECTION_NORTH);
  this.arrowRight = this.createArrow(this.triangleRight, mxResources.get('plusTooltip'), mxConstants.DIRECTION_EAST);
  this.arrowDown = this.createArrow(this.triangleDown, mxResources.get('plusTooltip'), mxConstants.DIRECTION_SOUTH);
  this.arrowLeft = this.createArrow(this.triangleLeft, mxResources.get('plusTooltip'), mxConstants.DIRECTION_WEST);
  this.elts = [this.arrowUp, this.arrowRight, this.arrowDown, this.arrowLeft];
  this.resetHandler = mxUtils.bind(this, function () {
    this.reset();
  });
  this.repaintHandler = mxUtils.bind(this, function () {
    this.repaint();
  });
  this.graph.selectionModel.addListener(mxEvent.CHANGE, this.resetHandler);
  this.graph.model.addListener(mxEvent.CHANGE, this.repaintHandler);
  this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
  this.graph.view.addListener(mxEvent.TRANSLATE, this.repaintHandler);
  this.graph.view.addListener(mxEvent.SCALE, this.repaintHandler);
  this.graph.view.addListener(mxEvent.DOWN, this.repaintHandler);
  this.graph.view.addListener(mxEvent.UP, this.repaintHandler);
  this.graph.addListener(mxEvent.ROOT, this.repaintHandler);
  this.graph.addListener(mxEvent.ESCAPE, this.resetHandler);
  mxEvent.addListener(this.graph.container, 'scroll', this.resetHandler);
  this.graph.addListener(
    mxEvent.ESCAPE,
    mxUtils.bind(this, function () {
      this.mouseDownPoint = null;
    })
  );
  mxEvent.addListener(
    this.graph.container,
    'mouseleave',
    mxUtils.bind(this, function (a) {
      null != a.relatedTarget && mxEvent.getSource(a) == this.graph.container && this.setDisplay('none');
    })
  );
  this.graph.addListener(
    mxEvent.START_EDITING,
    mxUtils.bind(this, function (a) {
      this.reset();
    })
  );
  var a = this.graph.click;
  this.graph.click = mxUtils.bind(this, function (b) {
    a.apply(this.graph, arguments);
    null == this.currentState ||
      this.graph.isCellSelected(this.currentState.cell) ||
      !mxEvent.isTouchEvent(b.getEvent()) ||
      this.graph.model.isVertex(b.getCell()) ||
      this.reset();
  });
  var b = !1;
  this.graph.addMouseListener({
    mouseDown: mxUtils.bind(this, function (a, d) {
      b = !1;
      var c = d.getEvent();
      if (this.isResetEvent(c)) this.reset();
      else if (!this.isActive()) {
        var f = this.getState(d.getState());
        (null == f && mxEvent.isTouchEvent(c)) || this.update(f);
      }
      this.setDisplay('none');
    }),
    mouseMove: mxUtils.bind(this, function (a, d) {
      var c = d.getEvent();
      this.isResetEvent(c)
        ? this.reset()
        : this.graph.isMouseDown ||
          mxEvent.isTouchEvent(c) ||
          this.update(this.getState(d.getState()), d.getGraphX(), d.getGraphY());
      null != this.graph.connectionHandler && null != this.graph.connectionHandler.shape && (b = !0);
    }),
    mouseUp: mxUtils.bind(this, function (a, d) {
      var c = d.getEvent();
      mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(c), mxEvent.getClientY(c));
      this.isResetEvent(c)
        ? this.reset()
        : this.isActive() && !b && null != this.mouseDownPoint
        ? this.click(this.currentState, this.getDirection(), d)
        : this.isActive()
        ? 1 == this.graph.getSelectionCount() && this.graph.model.isEdge(this.graph.getSelectionCell())
          ? this.reset()
          : this.update(this.getState(this.graph.view.getState(this.graph.getCellAt(d.getGraphX(), d.getGraphY()))))
        : mxEvent.isTouchEvent(c) || (null != this.bbox && mxUtils.contains(this.bbox, d.getGraphX(), d.getGraphY()))
        ? (this.setDisplay(''), this.repaint())
        : mxEvent.isTouchEvent(c) || this.reset();
      b = !1;
      this.resetActiveArrow();
    }),
  });
};
HoverIcons.prototype.isResetEvent = function (a, b) {
  return (
    mxEvent.isAltDown(a) ||
    (null == this.activeArrow && mxEvent.isShiftDown(a)) ||
    (mxEvent.isPopupTrigger(a) && !this.graph.isCloneEvent(a))
  );
};
HoverIcons.prototype.createArrow = function (a, b, c) {
  var d = null,
    d = mxUtils.createImage(a.src);
  d.style.width = a.width + 'px';
  d.style.height = a.height + 'px';
  d.style.padding = this.tolerance + 'px';
  null != b && d.setAttribute('title', b);
  d.style.position = 'absolute';
  d.style.cursor = this.cssCursor;
  mxEvent.addGestureListeners(
    d,
    mxUtils.bind(this, function (a) {
      null == this.currentState ||
        this.isResetEvent(a) ||
        ((this.mouseDownPoint = mxUtils.convertPoint(
          this.graph.container,
          mxEvent.getClientX(a),
          mxEvent.getClientY(a)
        )),
        this.drag(a, this.mouseDownPoint.x, this.mouseDownPoint.y),
        (this.activeArrow = d),
        this.setDisplay('none'),
        mxEvent.consume(a));
    })
  );
  mxEvent.redirectMouseEvents(d, this.graph, this.currentState);
  mxEvent.addListener(
    d,
    'mouseenter',
    mxUtils.bind(this, function (a) {
      mxEvent.isMouseEvent(a) &&
        (null != this.activeArrow &&
          this.activeArrow != d &&
          mxUtils.setOpacity(this.activeArrow, this.inactiveOpacity),
        this.graph.connectionHandler.constraintHandler.reset(),
        mxUtils.setOpacity(d, 100),
        (this.activeArrow = d),
        this.fireEvent(new mxEventObject('focus', 'arrow', d, 'direction', c, 'event', a)));
    })
  );
  mxEvent.addListener(
    d,
    'mouseleave',
    mxUtils.bind(this, function (a) {
      mxEvent.isMouseEvent(a) && this.fireEvent(new mxEventObject('blur', 'arrow', d, 'direction', c, 'event', a));
      this.graph.isMouseDown || this.resetActiveArrow();
    })
  );
  return d;
};
HoverIcons.prototype.resetActiveArrow = function () {
  null != this.activeArrow && (mxUtils.setOpacity(this.activeArrow, this.inactiveOpacity), (this.activeArrow = null));
};
HoverIcons.prototype.getDirection = function () {
  var a = mxConstants.DIRECTION_EAST;
  this.activeArrow == this.arrowUp
    ? (a = mxConstants.DIRECTION_NORTH)
    : this.activeArrow == this.arrowDown
    ? (a = mxConstants.DIRECTION_SOUTH)
    : this.activeArrow == this.arrowLeft && (a = mxConstants.DIRECTION_WEST);
  return a;
};
HoverIcons.prototype.visitNodes = function (a) {
  for (var b = 0; b < this.elts.length; b++) null != this.elts[b] && a(this.elts[b]);
};
HoverIcons.prototype.removeNodes = function () {
  this.visitNodes(function (a) {
    null != a.parentNode && a.parentNode.removeChild(a);
  });
};
HoverIcons.prototype.setDisplay = function (a) {
  this.visitNodes(function (b) {
    b.style.display = a;
  });
};
HoverIcons.prototype.isActive = function () {
  return null != this.activeArrow && null != this.currentState;
};
HoverIcons.prototype.drag = function (a, b, c) {
  this.graph.popupMenuHandler.hideMenu();
  this.graph.stopEditing(!1);
  null != this.currentState &&
    (this.graph.connectionHandler.start(this.currentState, b, c),
    (this.graph.isMouseTrigger = mxEvent.isMouseEvent(a)),
    (this.graph.isMouseDown = !0),
    (b = this.graph.selectionCellsHandler.getHandler(this.currentState.cell)),
    null != b && b.setHandlesVisible(!1),
    (b = this.graph.connectionHandler.edgeState),
    null != a &&
      mxEvent.isShiftDown(a) &&
      mxEvent.isControlDown(a) &&
      null != b &&
      'orthogonalEdgeStyle' === mxUtils.getValue(b.style, mxConstants.STYLE_EDGE, null) &&
      ((a = this.getDirection()),
      (b.cell.style = mxUtils.setStyle(b.cell.style, 'sourcePortConstraint', a)),
      (b.style.sourcePortConstraint = a)));
};
HoverIcons.prototype.getStateAt = function (a, b, c) {
  return this.graph.view.getState(this.graph.getCellAt(b, c));
};
HoverIcons.prototype.click = function (a, b, c) {
  var d = c.getEvent(),
    e = c.getGraphX(),
    f = c.getGraphY(),
    e = this.getStateAt(a, e, f);
  null == e ||
  !this.graph.model.isEdge(e.cell) ||
  this.graph.isCloneEvent(d) ||
  (e.getVisibleTerminalState(!0) != a && e.getVisibleTerminalState(!1) != a)
    ? null != a && this.execute(a, b, c)
    : (this.graph.setSelectionCell(e.cell), this.reset());
  c.consume();
};
HoverIcons.prototype.execute = function (a, b, c) {
  c = c.getEvent();
  this.graph.selectCellsForConnectVertex(
    this.graph.connectVertex(
      a.cell,
      b,
      this.graph.defaultEdgeLength,
      c,
      this.graph.isCloneEvent(c),
      this.graph.isCloneEvent(c)
    ),
    c,
    this
  );
};
HoverIcons.prototype.reset = function (a) {
  (null != a && !a) || null == this.updateThread || window.clearTimeout(this.updateThread);
  this.activeArrow = this.currentState = this.mouseDownPoint = null;
  this.removeNodes();
  this.bbox = null;
  this.fireEvent(new mxEventObject('reset'));
};
HoverIcons.prototype.repaint = function () {
  this.bbox = null;
  if (null != this.currentState) {
    this.currentState = this.getState(this.currentState);
    if (
      null != this.currentState &&
      this.graph.model.isVertex(this.currentState.cell) &&
      this.graph.isCellConnectable(this.currentState.cell)
    ) {
      var a = mxRectangle.fromRectangle(this.currentState);
      null != this.currentState.shape &&
        null != this.currentState.shape.boundingBox &&
        (a = mxRectangle.fromRectangle(this.currentState.shape.boundingBox));
      a.grow(this.graph.tolerance);
      a.grow(this.arrowSpacing);
      var b = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);
      this.graph.isTableRow(this.currentState.cell) &&
        (b = this.graph.selectionCellsHandler.getHandler(this.graph.model.getParent(this.currentState.cell)));
      var c = null;
      null != b &&
        ((a.x -= b.horizontalOffset / 2),
        (a.y -= b.verticalOffset / 2),
        (a.width += b.horizontalOffset),
        (a.height += b.verticalOffset),
        null != b.rotationShape &&
          null != b.rotationShape.node &&
          'hidden' != b.rotationShape.node.style.visibility &&
          'none' != b.rotationShape.node.style.display &&
          null != b.rotationShape.boundingBox &&
          (c = b.rotationShape.boundingBox));
      b = mxUtils.bind(this, function (a, b, d) {
        if (null != c) {
          var e = new mxRectangle(b, d, a.clientWidth, a.clientHeight);
          mxUtils.intersects(e, c) &&
            (a == this.arrowUp
              ? (d -= e.y + e.height - c.y)
              : a == this.arrowRight
              ? (b += c.x + c.width - e.x)
              : a == this.arrowDown
              ? (d += c.y + c.height - e.y)
              : a == this.arrowLeft && (b -= e.x + e.width - c.x));
        }
        a.style.left = b + 'px';
        a.style.top = d + 'px';
        mxUtils.setOpacity(a, this.inactiveOpacity);
      });
      b(
        this.arrowUp,
        Math.round(this.currentState.getCenterX() - this.triangleUp.width / 2 - this.tolerance),
        Math.round(a.y - this.triangleUp.height - this.tolerance)
      );
      b(
        this.arrowRight,
        Math.round(a.x + a.width - this.tolerance),
        Math.round(this.currentState.getCenterY() - this.triangleRight.height / 2 - this.tolerance)
      );
      b(this.arrowDown, parseInt(this.arrowUp.style.left), Math.round(a.y + a.height - this.tolerance));
      b(
        this.arrowLeft,
        Math.round(a.x - this.triangleLeft.width - this.tolerance),
        parseInt(this.arrowRight.style.top)
      );
      if (this.checkCollisions) {
        var b = this.graph.getCellAt(a.x + a.width + this.triangleRight.width / 2, this.currentState.getCenterY()),
          d = this.graph.getCellAt(a.x - this.triangleLeft.width / 2, this.currentState.getCenterY()),
          e = this.graph.getCellAt(this.currentState.getCenterX(), a.y - this.triangleUp.height / 2),
          a = this.graph.getCellAt(this.currentState.getCenterX(), a.y + a.height + this.triangleDown.height / 2);
        null != b && b == d && d == e && e == a && (a = e = d = b = null);
        var f = this.graph.getCellGeometry(this.currentState.cell),
          g = mxUtils.bind(this, function (a, b) {
            var c = this.graph.model.isVertex(a) && this.graph.getCellGeometry(a);
            null == a ||
            this.graph.model.isAncestor(a, this.currentState.cell) ||
            this.graph.isSwimlane(a) ||
            !(null == c || null == f || (c.height < 3 * f.height && c.width < 3 * f.width))
              ? (b.style.visibility = 'visible')
              : (b.style.visibility = 'hidden');
          });
        g(b, this.arrowRight);
        g(d, this.arrowLeft);
        g(e, this.arrowUp);
        g(a, this.arrowDown);
      } else
        (this.arrowLeft.style.visibility = 'visible'),
          (this.arrowRight.style.visibility = 'visible'),
          (this.arrowUp.style.visibility = 'visible'),
          (this.arrowDown.style.visibility = 'visible');
      this.graph.tooltipHandler.isEnabled()
        ? (this.arrowLeft.setAttribute('title', mxResources.get('plusTooltip')),
          this.arrowRight.setAttribute('title', mxResources.get('plusTooltip')),
          this.arrowUp.setAttribute('title', mxResources.get('plusTooltip')),
          this.arrowDown.setAttribute('title', mxResources.get('plusTooltip')))
        : (this.arrowLeft.removeAttribute('title'),
          this.arrowRight.removeAttribute('title'),
          this.arrowUp.removeAttribute('title'),
          this.arrowDown.removeAttribute('title'));
    } else this.reset();
    null != this.currentState && ((this.bbox = this.computeBoundingBox()), null != this.bbox && this.bbox.grow(10));
  }
};
HoverIcons.prototype.computeBoundingBox = function () {
  var a = this.graph.model.isEdge(this.currentState.cell) ? null : mxRectangle.fromRectangle(this.currentState);
  this.visitNodes(function (b) {
    null != b.parentNode &&
      ((b = new mxRectangle(b.offsetLeft, b.offsetTop, b.offsetWidth, b.offsetHeight)), null == a ? (a = b) : a.add(b));
  });
  return a;
};
HoverIcons.prototype.getState = function (a) {
  if (null != a)
    if (((a = a.cell), this.graph.getModel().contains(a))) {
      if (this.graph.getModel().isVertex(a) && !this.graph.isCellConnectable(a)) {
        var b = this.graph.getModel().getParent(a);
        this.graph.getModel().isVertex(b) && this.graph.isCellConnectable(b) && (a = b);
      }
      if (this.graph.isCellLocked(a) || this.graph.model.isEdge(a)) a = null;
      a = this.graph.view.getState(a);
      null != a && null == a.style && (a = null);
    } else a = null;
  return a;
};
HoverIcons.prototype.update = function (a, b, c) {
  if (!this.graph.connectionArrowsEnabled || (null != a && '0' == mxUtils.getValue(a.style, 'allowArrows', '1')))
    this.reset();
  else {
    null != a &&
      null != a.cell.geometry &&
      a.cell.geometry.relative &&
      this.graph.model.isEdge(a.cell.parent) &&
      (a = null);
    var d = null;
    this.prev != a || this.isActive()
      ? ((this.startTime = new Date().getTime()),
        (this.prev = a),
        (d = 0),
        null != this.updateThread && window.clearTimeout(this.updateThread),
        null != a &&
          (this.updateThread = window.setTimeout(
            mxUtils.bind(this, function () {
              this.isActive() ||
                this.graph.isMouseDown ||
                this.graph.panningHandler.isActive() ||
                ((this.prev = a), this.update(a, b, c));
            }),
            this.updateDelay + 10
          )))
      : null != this.startTime && (d = new Date().getTime() - this.startTime);
    this.setDisplay('');
    null != this.currentState &&
    this.currentState != a &&
    d < this.activationDelay &&
    null != this.bbox &&
    !mxUtils.contains(this.bbox, b, c)
      ? this.reset(!1)
      : (null != this.currentState || d > this.activationDelay) &&
        this.currentState != a &&
        ((d > this.updateDelay && null != a) ||
          null == this.bbox ||
          null == b ||
          null == c ||
          !mxUtils.contains(this.bbox, b, c)) &&
        (null != a && this.graph.isEnabled()
          ? (this.removeNodes(),
            this.setCurrentState(a),
            this.repaint(),
            this.graph.connectionHandler.constraintHandler.currentFocus != a &&
              this.graph.connectionHandler.constraintHandler.reset())
          : this.reset());
  }
};
HoverIcons.prototype.setCurrentState = function (a) {
  'eastwest' != a.style.portConstraint &&
    (this.graph.container.appendChild(this.arrowUp), this.graph.container.appendChild(this.arrowDown));
  this.graph.container.appendChild(this.arrowRight);
  this.graph.container.appendChild(this.arrowLeft);
  this.currentState = a;
};
Graph.prototype.createParent = function (a, b, c, d, e) {
  a = this.cloneCell(a);
  for (var f = 0; f < c; f++) {
    var g = this.cloneCell(b),
      k = this.getCellGeometry(g);
    null != k && ((k.x += f * d), (k.y += f * e));
    a.insert(g);
  }
  return a;
};
Graph.prototype.createTable = function (a, b, c, d, e, f, g, k, h) {
  c = null != c ? c : 60;
  d = null != d ? d : 40;
  f = null != f ? f : 30;
  k =
    null != k
      ? k
      : 'shape=tableRow;horizontal=0;startSize=0;swimlaneHead=0;swimlaneBody=0;top=0;left=0;bottom=0;right=0;collapsible=0;dropTarget=0;fillColor=none;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;';
  h =
    null != h
      ? h
      : 'shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;overflow=hidden;fillColor=none;top=0;left=0;bottom=0;right=0;pointerEvents=1;';
  return this.createParent(
    this.createVertex(
      null,
      null,
      null != e ? e : '',
      0,
      0,
      b * c,
      a * d + (null != e ? f : 0),
      null != g
        ? g
        : 'shape=table;startSize=' + (null != e ? f : '0') + ';container=1;collapsible=0;childLayout=tableLayout;'
    ),
    this.createParent(
      this.createVertex(null, null, '', 0, 0, b * c, d, k),
      this.createVertex(null, null, '', 0, 0, c, d, h),
      b,
      c,
      0
    ),
    a,
    0,
    d
  );
};
Graph.prototype.setTableValues = function (a, b, c) {
  for (var d = this.model.getChildCells(a, !0), e = 0; e < d.length; e++)
    if ((null != c && (d[e].value = c[e]), null != b))
      for (var f = this.model.getChildCells(d[e], !0), g = 0; g < f.length; g++)
        null != b[e][g] && (f[g].value = b[e][g]);
  return a;
};
Graph.prototype.createCrossFunctionalSwimlane = function (a, b, c, d, e, f, g, k, h) {
  c = null != c ? c : 120;
  d = null != d ? d : 120;
  g =
    null != g
      ? g
      : 'shape=tableRow;horizontal=0;swimlaneHead=0;swimlaneBody=0;top=0;left=0;bottom=0;right=0;dropTarget=0;fontStyle=0;fillColor=none;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;startSize=40;collapsible=0;recursiveResize=0;expand=0;';
  k =
    null != k
      ? k
      : 'swimlane;swimlaneHead=0;swimlaneBody=0;fontStyle=0;connectable=0;fillColor=none;startSize=40;collapsible=0;recursiveResize=0;expand=0;';
  h =
    null != h
      ? h
      : 'swimlane;swimlaneHead=0;swimlaneBody=0;fontStyle=0;connectable=0;fillColor=none;startSize=0;collapsible=0;recursiveResize=0;expand=0;';
  e = this.createVertex(
    null,
    null,
    null != e ? e : '',
    0,
    0,
    b * c,
    a * d,
    null != f
      ? f
      : 'shape=table;childLayout=tableLayout;' +
          (null == e ? 'startSize=0;fillColor=none;' : 'startSize=40;') +
          'collapsible=0;recursiveResize=0;expand=0;'
  );
  f = mxUtils.getValue(this.getCellStyle(e), mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
  e.geometry.width += f;
  e.geometry.height += f;
  g = this.createVertex(null, null, '', 0, f, b * c + f, d, g);
  e.insert(this.createParent(g, this.createVertex(null, null, '', f, 0, c, d, k), b, c, 0));
  return 1 < a
    ? ((g.geometry.y = d + f),
      this.createParent(
        e,
        this.createParent(g, this.createVertex(null, null, '', f, 0, c, d, h), b, c, 0),
        a - 1,
        0,
        d
      ))
    : e;
};
Graph.prototype.visitTableCells = function (a, b) {
  for (
    var c = null, d = this.model.getChildCells(a, !0), e = this.getActualStartSize(a, !0), f = 0;
    f < d.length;
    f++
  ) {
    for (
      var g = this.getActualStartSize(d[f], !0),
        k = this.model.getChildCells(d[f], !0),
        h = this.getCellStyle(d[f], !0),
        l = null,
        m = [],
        n = 0;
      n < k.length;
      n++
    ) {
      var p = this.getCellGeometry(k[n]),
        r = { cell: k[n], rospan: 1, colspan: 1, row: f, col: n, geo: p },
        p = null != p.alternateBounds ? p.alternateBounds : p;
      r.point = new mxPoint(
        p.width + (null != l ? l.point.x : e.x + g.x),
        p.height + (null != c && null != c[0] ? c[0].point.y : e.y + g.y)
      );
      r.actual = r;
      null != c && null != c[n] && 1 < c[n].rowspan
        ? ((r.rowspan = c[n].rowspan - 1), (r.colspan = c[n].colspan), (r.actual = c[n].actual))
        : null != l && 1 < l.colspan
        ? ((r.rowspan = l.rowspan), (r.colspan = l.colspan - 1), (r.actual = l.actual))
        : ((l = this.getCurrentCellStyle(k[n], !0)),
          null != l && ((r.rowspan = parseInt(l.rowspan || 1)), (r.colspan = parseInt(l.colspan || 1))));
      l =
        1 == mxUtils.getValue(h, mxConstants.STYLE_SWIMLANE_HEAD, 1) &&
        mxUtils.getValue(h, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE) != mxConstants.NONE;
      b(r, k.length, d.length, e.x + (l ? g.x : 0), e.y + (l ? g.y : 0));
      m.push(r);
      l = r;
    }
    c = m;
  }
};
Graph.prototype.getTableLines = function (a, b, c) {
  var d = [],
    e = [];
  (b || c) &&
    this.visitTableCells(
      a,
      mxUtils.bind(this, function (a, g, k, h, l) {
        b &&
          a.row < k - 1 &&
          (null == d[a.row] && (d[a.row] = [new mxPoint(h, a.point.y)]),
          1 < a.rowspan && d[a.row].push(null),
          d[a.row].push(a.point));
        c &&
          a.col < g - 1 &&
          (null == e[a.col] && (e[a.col] = [new mxPoint(a.point.x, l)]),
          1 < a.colspan && e[a.col].push(null),
          e[a.col].push(a.point));
      })
    );
  return d.concat(e);
};
Graph.prototype.isTableCell = function (a) {
  return this.model.isVertex(a) && this.isTableRow(this.model.getParent(a));
};
Graph.prototype.isTableRow = function (a) {
  return this.model.isVertex(a) && this.isTable(this.model.getParent(a));
};
Graph.prototype.isTable = function (a) {
  a = this.getCellStyle(a);
  return null != a && 'tableLayout' == a.childLayout;
};
Graph.prototype.isStack = function (a) {
  a = this.getCellStyle(a);
  return null != a && 'stackLayout' == a.childLayout;
};
Graph.prototype.isStackChild = function (a) {
  return this.model.isVertex(a) && this.isStack(this.model.getParent(a));
};
Graph.prototype.setTableRowHeight = function (a, b, c) {
  c = null != c ? c : !0;
  var d = this.getModel();
  d.beginUpdate();
  try {
    var e = this.getCellGeometry(a);
    if (null != e) {
      e = e.clone();
      e.height += b;
      d.setGeometry(a, e);
      var f = d.getParent(a),
        g = d.getChildCells(f, !0);
      if (!c) {
        var k = mxUtils.indexOf(g, a);
        if (k < g.length - 1) {
          var h = g[k + 1],
            l = this.getCellGeometry(h);
          null != l && ((l = l.clone()), (l.y += b), (l.height -= b), d.setGeometry(h, l));
        }
      }
      var m = this.getCellGeometry(f);
      null != m && (c || (c = a == g[g.length - 1]), c && ((m = m.clone()), (m.height += b), d.setGeometry(f, m)));
    }
  } finally {
    d.endUpdate();
  }
};
Graph.prototype.setTableColumnWidth = function (a, b, c) {
  c = null != c ? c : !1;
  var d = this.getModel(),
    e = d.getParent(a),
    f = d.getParent(e),
    g = d.getChildCells(e, !0);
  a = mxUtils.indexOf(g, a);
  var k = a == g.length - 1;
  d.beginUpdate();
  try {
    for (var h = d.getChildCells(f, !0), l = 0; l < h.length; l++) {
      var e = h[l],
        g = d.getChildCells(e, !0),
        m = g[a],
        n = this.getCellGeometry(m);
      null != n &&
        ((n = n.clone()),
        (n.width += b),
        null != n.alternateBounds && (n.alternateBounds.width += b),
        d.setGeometry(m, n));
      a < g.length - 1 &&
        ((m = g[a + 1]),
        (n = this.getCellGeometry(m)),
        null != n &&
          ((n = n.clone()),
          (n.x += b),
          c || ((n.width -= b), null != n.alternateBounds && (n.alternateBounds.width -= b)),
          d.setGeometry(m, n)));
    }
    if (k || c) {
      var p = this.getCellGeometry(f);
      null != p && ((p = p.clone()), (p.width += b), d.setGeometry(f, p));
    }
    null != this.layoutManager && this.layoutManager.executeLayout(f);
  } finally {
    d.endUpdate();
  }
};
function TableLayout(a) {
  mxGraphLayout.call(this, a);
}
TableLayout.prototype = new mxStackLayout();
TableLayout.prototype.constructor = TableLayout;
TableLayout.prototype.isHorizontal = function () {
  return !1;
};
TableLayout.prototype.isVertexIgnored = function (a) {
  return !this.graph.getModel().isVertex(a) || !this.graph.isCellVisible(a);
};
TableLayout.prototype.getSize = function (a, b) {
  for (var c = 0, d = 0; d < a.length; d++)
    if (!this.isVertexIgnored(a[d])) {
      var e = this.graph.getCellGeometry(a[d]);
      null != e && (c += b ? e.width : e.height);
    }
  return c;
};
TableLayout.prototype.getRowLayout = function (a, b) {
  for (
    var c = this.graph.model.getChildCells(a, !0),
      d = this.graph.getActualStartSize(a, !0),
      e = this.getSize(c, !0),
      f = b - d.x - d.width,
      g = [],
      d = d.x,
      k = 0;
    k < c.length;
    k++
  ) {
    var h = this.graph.getCellGeometry(c[k]);
    null != h &&
      ((d += ((null != h.alternateBounds ? h.alternateBounds.width : h.width) * f) / e), g.push(Math.round(d)));
  }
  return g;
};
TableLayout.prototype.layoutRow = function (a, b, c, d) {
  var e = this.graph.getModel(),
    f = e.getChildCells(a, !0);
  a = this.graph.getActualStartSize(a, !0);
  var g = a.x,
    k = 0;
  null != b && ((b = b.slice()), b.splice(0, 0, a.x));
  for (var h = 0; h < f.length; h++) {
    var l = this.graph.getCellGeometry(f[h]);
    null != l &&
      ((l = l.clone()),
      (l.y = a.y),
      (l.height = c - a.y - a.height),
      null != b
        ? ((l.x = b[h]),
          (l.width = b[h + 1] - l.x),
          h == f.length - 1 && h < b.length - 2 && (l.width = d - l.x - a.x - a.width))
        : ((l.x = g), (g += l.width), h == f.length - 1 ? (l.width = d - a.x - a.width - k) : (k += l.width)),
      (l.alternateBounds = new mxRectangle(0, 0, l.width, l.height)),
      e.setGeometry(f[h], l));
  }
  return k;
};
TableLayout.prototype.execute = function (a) {
  if (null != a) {
    var b = this.graph.getActualStartSize(a, !0),
      c = this.graph.getCellGeometry(a),
      d = this.graph.getCellStyle(a),
      e = '1' == mxUtils.getValue(d, 'resizeLastRow', '0'),
      f = '1' == mxUtils.getValue(d, 'resizeLast', '0'),
      d = '1' == mxUtils.getValue(d, 'fixedRows', '0'),
      g = this.graph.getModel(),
      k = 0;
    g.beginUpdate();
    try {
      for (
        var h = c.height - b.y - b.height, l = c.width - b.x - b.width, m = g.getChildCells(a, !0), n = 0;
        n < m.length;
        n++
      )
        g.setVisible(m[n], !0);
      var p = this.getSize(m, !1);
      if (0 < h && 0 < l && 0 < m.length && 0 < p) {
        if (e) {
          var r = this.graph.getCellGeometry(m[m.length - 1]);
          null != r && ((r = r.clone()), (r.height = h - p + r.height), g.setGeometry(m[m.length - 1], r));
        }
        for (var t = f ? null : this.getRowLayout(m[0], l), u = [], x = b.y, n = 0; n < m.length; n++)
          (r = this.graph.getCellGeometry(m[n])),
            null != r &&
              ((r = r.clone()),
              (r.x = b.x),
              (r.width = l),
              (r.y = Math.round(x)),
              (x = e || d ? x + r.height : x + (r.height / p) * h),
              (r.height = Math.round(x) - r.y),
              g.setGeometry(m[n], r)),
            (k = Math.max(k, this.layoutRow(m[n], t, r.height, l, u)));
        d && h < p && ((c = c.clone()), (c.height = x + b.height), g.setGeometry(a, c));
        f &&
          l < k + Graph.minTableColumnWidth &&
          ((c = c.clone()), (c.width = k + b.width + b.x + Graph.minTableColumnWidth), g.setGeometry(a, c));
        this.graph.visitTableCells(
          a,
          mxUtils.bind(this, function (a) {
            g.setVisible(a.cell, a.actual.cell == a.cell);
            if (a.actual.cell != a.cell) {
              if (a.actual.row == a.row) {
                var b = null != a.geo.alternateBounds ? a.geo.alternateBounds : a.geo;
                a.actual.geo.width += b.width;
              }
              a.actual.col == a.col &&
                ((b = null != a.geo.alternateBounds ? a.geo.alternateBounds : a.geo),
                (a.actual.geo.height += b.height));
            }
          })
        );
      } else for (n = 0; n < m.length; n++) g.setVisible(m[n], !1);
    } finally {
      g.endUpdate();
    }
  }
};
(function () {
  var a = mxGraphView.prototype.resetValidationState;
  mxGraphView.prototype.resetValidationState = function () {
    a.apply(this, arguments);
    this.validEdges = [];
  };
  var b = mxGraphView.prototype.validateCellState;
  mxGraphView.prototype.validateCellState = function (a, c) {
    c = null != c ? c : !0;
    var d = this.getState(a);
    null != d &&
      c &&
      this.graph.model.isEdge(d.cell) &&
      null != d.style &&
      1 != d.style[mxConstants.STYLE_CURVED] &&
      !d.invalid &&
      this.updateLineJumps(d) &&
      this.graph.cellRenderer.redraw(d, !1, this.isRendering());
    d = b.apply(this, arguments);
    null != d &&
      c &&
      this.graph.model.isEdge(d.cell) &&
      null != d.style &&
      1 != d.style[mxConstants.STYLE_CURVED] &&
      this.validEdges.push(d);
    return d;
  };
  var c = mxShape.prototype.paint;
  mxShape.prototype.paint = function () {
    c.apply(this, arguments);
    if (
      null != this.state &&
      null != this.node &&
      this.state.view.graph.enableFlowAnimation &&
      this.state.view.graph.model.isEdge(this.state.cell) &&
      '1' == mxUtils.getValue(this.state.style, 'flowAnimation', '0')
    ) {
      var a = this.node.getElementsByTagName('path');
      if (1 < a.length) {
        '1' != mxUtils.getValue(this.state.style, mxConstants.STYLE_DASHED, '0') &&
          a[1].setAttribute('stroke-dasharray', 8 * this.state.view.scale);
        var b = this.state.view.graph.getFlowAnimationStyle();
        null != b && a[1].setAttribute('class', b.getAttribute('id'));
      }
    }
  };
  var d = mxCellRenderer.prototype.isShapeInvalid;
  mxCellRenderer.prototype.isShapeInvalid = function (a, b) {
    return (
      d.apply(this, arguments) ||
      (null != a.routedPoints && null != b.routedPoints && !mxUtils.equalPoints(b.routedPoints, a.routedPoints))
    );
  };
  var e = mxGraphView.prototype.updateCellState;
  mxGraphView.prototype.updateCellState = function (a) {
    e.apply(this, arguments);
    this.graph.model.isEdge(a.cell) && 1 != a.style[mxConstants.STYLE_CURVED] && this.updateLineJumps(a);
  };
  mxGraphView.prototype.updateLineJumps = function (a) {
    var b = a.absolutePoints;
    if (Graph.lineJumpsEnabled) {
      var c = null != a.routedPoints,
        d = null;
      if (null != b && null != this.validEdges && 'none' !== mxUtils.getValue(a.style, 'jumpStyle', 'none')) {
        for (
          var e = function (b, c, e) {
              var f = new mxPoint(c, e);
              f.type = b;
              d.push(f);
              f = null != a.routedPoints ? a.routedPoints[d.length - 1] : null;
              return null == f || f.type != b || f.x != c || f.y != e;
            },
            f = 0.5 * this.scale,
            c = !1,
            d = [],
            g = 0;
          g < b.length - 1;
          g++
        ) {
          for (
            var k = b[g + 1], h = b[g], l = [], m = b[g + 2];
            g < b.length - 2 && mxUtils.ptSegDistSq(h.x, h.y, m.x, m.y, k.x, k.y) < 1 * this.scale * this.scale;

          )
            (k = m), g++, (m = b[g + 2]);
          for (var c = e(0, h.x, h.y) || c, J = 0; J < this.validEdges.length; J++) {
            var v = this.validEdges[J],
              K = v.absolutePoints;
            if (null != K && mxUtils.intersects(a, v) && '1' != v.style.noJump)
              for (v = 0; v < K.length - 1; v++) {
                for (
                  var O = K[v + 1], T = K[v], m = K[v + 2];
                  v < K.length - 2 && mxUtils.ptSegDistSq(T.x, T.y, m.x, m.y, O.x, O.y) < 1 * this.scale * this.scale;

                )
                  (O = m), v++, (m = K[v + 2]);
                m = mxUtils.intersection(h.x, h.y, k.x, k.y, T.x, T.y, O.x, O.y);
                if (
                  null != m &&
                  (Math.abs(m.x - h.x) > f || Math.abs(m.y - h.y) > f) &&
                  (Math.abs(m.x - k.x) > f || Math.abs(m.y - k.y) > f) &&
                  (Math.abs(m.x - T.x) > f || Math.abs(m.y - T.y) > f) &&
                  (Math.abs(m.x - O.x) > f || Math.abs(m.y - O.y) > f)
                ) {
                  O = m.x - h.x;
                  T = m.y - h.y;
                  m = { distSq: O * O + T * T, x: m.x, y: m.y };
                  for (O = 0; O < l.length; O++)
                    if (l[O].distSq > m.distSq) {
                      l.splice(O, 0, m);
                      m = null;
                      break;
                    }
                  null == m || (0 != l.length && l[l.length - 1].x === m.x && l[l.length - 1].y === m.y) || l.push(m);
                }
              }
          }
          for (v = 0; v < l.length; v++) c = e(1, l[v].x, l[v].y) || c;
        }
        m = b[b.length - 1];
        c = e(0, m.x, m.y) || c;
      }
      a.routedPoints = d;
      return c;
    }
    return !1;
  };
  var f = mxConnector.prototype.paintLine;
  mxConnector.prototype.paintLine = function (a, b, c) {
    this.routedPoints = null != this.state ? this.state.routedPoints : null;
    if (
      this.outline ||
      null == this.state ||
      null == this.style ||
      null == this.state.routedPoints ||
      0 == this.state.routedPoints.length
    )
      f.apply(this, arguments);
    else {
      var d = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2,
        e = (parseInt(mxUtils.getValue(this.style, 'jumpSize', Graph.defaultJumpSize)) - 2) / 2 + this.strokewidth,
        g = mxUtils.getValue(this.style, 'jumpStyle', 'none'),
        k = !0,
        h = null,
        l = null,
        m = [],
        n = null;
      a.begin();
      for (var p = 0; p < this.state.routedPoints.length; p++) {
        var v = this.state.routedPoints[p],
          K = new mxPoint(v.x / this.scale, v.y / this.scale);
        0 == p ? (K = b[0]) : p == this.state.routedPoints.length - 1 && (K = b[b.length - 1]);
        var O = !1;
        if (null != h && 1 == v.type) {
          var T = this.state.routedPoints[p + 1],
            v = T.x / this.scale - K.x,
            T = T.y / this.scale - K.y,
            v = v * v + T * T;
          null == n &&
            ((n = new mxPoint(K.x - h.x, K.y - h.y)),
            (l = Math.sqrt(n.x * n.x + n.y * n.y)),
            0 < l ? ((n.x = (n.x * e) / l), (n.y = (n.y * e) / l)) : (n = null));
          v > e * e &&
            0 < l &&
            ((v = h.x - K.x),
            (T = h.y - K.y),
            (v = v * v + T * T),
            v > e * e &&
              ((O = new mxPoint(K.x - n.x, K.y - n.y)),
              (v = new mxPoint(K.x + n.x, K.y + n.y)),
              m.push(O),
              this.addPoints(a, m, c, d, !1, null, k),
              (m = 0 > Math.round(n.x) || (0 == Math.round(n.x) && 0 >= Math.round(n.y)) ? 1 : -1),
              (k = !1),
              'sharp' == g
                ? (a.lineTo(O.x - n.y * m, O.y + n.x * m), a.lineTo(v.x - n.y * m, v.y + n.x * m), a.lineTo(v.x, v.y))
                : 'line' == g
                ? (a.moveTo(O.x + n.y * m, O.y - n.x * m),
                  a.lineTo(O.x - n.y * m, O.y + n.x * m),
                  a.moveTo(v.x - n.y * m, v.y + n.x * m),
                  a.lineTo(v.x + n.y * m, v.y - n.x * m),
                  a.moveTo(v.x, v.y))
                : 'arc' == g
                ? ((m *= 1.3), a.curveTo(O.x - n.y * m, O.y + n.x * m, v.x - n.y * m, v.y + n.x * m, v.x, v.y))
                : (a.moveTo(v.x, v.y), (k = !0)),
              (m = [v]),
              (O = !0)));
        } else n = null;
        O || (m.push(K), (h = K));
      }
      this.addPoints(a, m, c, d, !1, null, k);
      a.stroke();
    }
  };
  var g = mxGraphView.prototype.getFixedTerminalPoint;
  mxGraphView.prototype.getFixedTerminalPoint = function (a, b, c, d) {
    return null != b && 'centerPerimeter' == b.style[mxConstants.STYLE_PERIMETER]
      ? new mxPoint(b.getCenterX(), b.getCenterY())
      : g.apply(this, arguments);
  };
  var k = mxGraphView.prototype.updateFloatingTerminalPoint;
  mxGraphView.prototype.updateFloatingTerminalPoint = function (a, b, c, d) {
    if (null == b || null == a || ('1' != b.style.snapToPoint && '1' != a.style.snapToPoint)) k.apply(this, arguments);
    else {
      b = this.getTerminalPort(a, b, d);
      var e = this.getNextPoint(a, c, d),
        f = this.graph.isOrthogonal(a),
        g = mxUtils.toRadians(Number(b.style[mxConstants.STYLE_ROTATION] || '0')),
        h = new mxPoint(b.getCenterX(), b.getCenterY());
      if (0 != g)
        var l = Math.cos(-g),
          m = Math.sin(-g),
          e = mxUtils.getRotatedPoint(e, l, m, h);
      l = parseFloat(a.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
      l += parseFloat(
        a.style[d ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING : mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0
      );
      e = this.getPerimeterPoint(b, e, 0 == g && f, l);
      0 != g && ((l = Math.cos(g)), (m = Math.sin(g)), (e = mxUtils.getRotatedPoint(e, l, m, h)));
      a.setAbsoluteTerminalPoint(this.snapToAnchorPoint(a, b, c, d, e), d);
    }
  };
  mxGraphView.prototype.snapToAnchorPoint = function (a, b, c, d, e) {
    if (null != b && null != a) {
      a = this.graph.getAllConnectionConstraints(b);
      d = c = null;
      if (null != a)
        for (var f = 0; f < a.length; f++) {
          var g = this.graph.getConnectionPoint(b, a[f]);
          if (null != g) {
            var k = (g.x - e.x) * (g.x - e.x) + (g.y - e.y) * (g.y - e.y);
            if (null == d || k < d) (c = g), (d = k);
          }
        }
      null != c && (e = c);
    }
    return e;
  };
  var h = mxStencil.prototype.evaluateTextAttribute;
  mxStencil.prototype.evaluateTextAttribute = function (a, b, c) {
    var d = h.apply(this, arguments);
    '1' == a.getAttribute('placeholders') &&
      null != c.state &&
      (d = c.state.view.graph.replacePlaceholders(c.state.cell, d));
    return d;
  };
  var l = mxCellRenderer.prototype.createShape;
  mxCellRenderer.prototype.createShape = function (a) {
    if (null != a.style && 'undefined' !== typeof pako) {
      var b = mxUtils.getValue(a.style, mxConstants.STYLE_SHAPE, null);
      if (null != b && 'string' === typeof b && 'stencil(' == b.substring(0, 8))
        try {
          var c = b.substring(8, b.length - 1),
            d = mxUtils.parseXml(Graph.decompress(c));
          return new mxShape(new mxStencil(d.documentElement));
        } catch (t) {
          null != window.console && console.log('Error in shape: ' + t);
        }
    }
    return l.apply(this, arguments);
  };
})();
mxStencilRegistry.libraries = {};
mxStencilRegistry.dynamicLoading = !0;
mxStencilRegistry.allowEval = !0;
mxStencilRegistry.packages = [];
mxStencilRegistry.filesLoaded = {};
mxStencilRegistry.getStencil = function (a) {
  var b = mxStencilRegistry.stencils[a];
  if (null == b && null == mxCellRenderer.defaultShapes[a] && mxStencilRegistry.dynamicLoading) {
    var c = mxStencilRegistry.getBasenameForStencil(a);
    if (null != c) {
      b = mxStencilRegistry.libraries[c];
      if (null != b) {
        if (null == mxStencilRegistry.packages[c]) {
          for (var d = 0; d < b.length; d++) {
            var e = b[d];
            if (!mxStencilRegistry.filesLoaded[e])
              if (
                ((mxStencilRegistry.filesLoaded[e] = !0), '.xml' == e.toLowerCase().substring(e.length - 4, e.length))
              )
                mxStencilRegistry.loadStencilSet(e, null);
              else if ('.js' == e.toLowerCase().substring(e.length - 3, e.length))
                try {
                  if (mxStencilRegistry.allowEval) {
                    var f = mxUtils.load(e);
                    null != f && 200 <= f.getStatus() && 299 >= f.getStatus() && eval.call(window, f.getText());
                  }
                } catch (g) {
                  null != window.console && console.log('error in getStencil:', a, c, b, e, g);
                }
          }
          mxStencilRegistry.packages[c] = 1;
        }
      } else (c = c.replace('_-_', '_')), mxStencilRegistry.loadStencilSet(STENCIL_PATH + '/' + c + '.xml', null);
      b = mxStencilRegistry.stencils[a];
    }
  }
  return b;
};
mxStencilRegistry.getBasenameForStencil = function (a) {
  var b = null;
  if (null != a && 'string' === typeof a && ((a = a.split('.')), 0 < a.length && 'mxgraph' == a[0]))
    for (var b = a[1], c = 2; c < a.length - 1; c++) b += '/' + a[c];
  return b;
};
mxStencilRegistry.loadStencilSet = function (a, b, c, d) {
  var e = mxStencilRegistry.packages[a];
  if ((null != c && c) || null == e) {
    var f = !1;
    if (null == e)
      try {
        if (d) {
          mxStencilRegistry.loadStencil(
            a,
            mxUtils.bind(this, function (c) {
              null != c &&
                null != c.documentElement &&
                ((mxStencilRegistry.packages[a] = c),
                (f = !0),
                mxStencilRegistry.parseStencilSet(c.documentElement, b, f));
            })
          );
          return;
        }
        e = mxStencilRegistry.loadStencil(a);
        mxStencilRegistry.packages[a] = e;
        f = !0;
      } catch (g) {
        null != window.console && console.log('error in loadStencilSet:', a, g);
      }
    null != e && null != e.documentElement && mxStencilRegistry.parseStencilSet(e.documentElement, b, f);
  }
};
mxStencilRegistry.loadStencil = function (a, b) {
  if (null != b)
    mxUtils.get(
      a,
      mxUtils.bind(this, function (a) {
        b(200 <= a.getStatus() && 299 >= a.getStatus() ? a.getXml() : null);
      })
    );
  else return mxUtils.load(a).getXml();
};
mxStencilRegistry.parseStencilSets = function (a) {
  for (var b = 0; b < a.length; b++) mxStencilRegistry.parseStencilSet(mxUtils.parseXml(a[b]).documentElement);
};
mxStencilRegistry.parseStencilSet = function (a, b, c) {
  if ('stencils' == a.nodeName)
    for (var d = a.firstChild; null != d; )
      'shapes' == d.nodeName && mxStencilRegistry.parseStencilSet(d, b, c), (d = d.nextSibling);
  else {
    c = null != c ? c : !0;
    var d = a.firstChild,
      e = '';
    a = a.getAttribute('name');
    for (null != a && (e = a + '.'); null != d; ) {
      if (d.nodeType == mxConstants.NODETYPE_ELEMENT && ((a = d.getAttribute('name')), null != a)) {
        var e = e.toLowerCase(),
          f = a.replace(/ /g, '_');
        c && mxStencilRegistry.addStencil(e + f.toLowerCase(), new mxStencil(d));
        if (null != b) {
          var g = d.getAttribute('w'),
            k = d.getAttribute('h'),
            g = null == g ? 80 : parseInt(g, 10),
            k = null == k ? 80 : parseInt(k, 10);
          b(e, f, a, g, k);
        }
      }
      d = d.nextSibling;
    }
  }
};
'undefined' !== typeof mxVertexHandler &&
  (function () {
    function a() {
      var a = document.createElement('div');
      a.className = 'geHint';
      a.style.whiteSpace = 'nowrap';
      a.style.position = 'absolute';
      return a;
    }
    function b(a, b) {
      switch (b) {
        case mxConstants.POINTS:
          return a;
        case mxConstants.MILLIMETERS:
          return (a / mxConstants.PIXELS_PER_MM).toFixed(1);
        case mxConstants.METERS:
          return (a / (1e3 * mxConstants.PIXELS_PER_MM)).toFixed(4);
        case mxConstants.INCHES:
          return (a / mxConstants.PIXELS_PER_INCH).toFixed(2);
      }
    }
    mxConstants.HANDLE_FILLCOLOR = '#29b6f2';
    mxConstants.HANDLE_STROKECOLOR = '#0088cf';
    mxConstants.VERTEX_SELECTION_COLOR = '#00a8ff';
    mxConstants.OUTLINE_COLOR = '#00a8ff';
    mxConstants.OUTLINE_HANDLE_FILLCOLOR = '#99ccff';
    mxConstants.OUTLINE_HANDLE_STROKECOLOR = '#00a8ff';
    mxConstants.CONNECT_HANDLE_FILLCOLOR = '#cee7ff';
    mxConstants.EDGE_SELECTION_COLOR = '#00a8ff';
    mxConstants.DEFAULT_VALID_COLOR = '#00a8ff';
    mxConstants.LABEL_HANDLE_FILLCOLOR = '#cee7ff';
    mxConstants.GUIDE_COLOR = '#0088cf';
    mxConstants.HIGHLIGHT_OPACITY = 30;
    mxConstants.HIGHLIGHT_SIZE = 5;
    mxEdgeHandler.prototype.snapToTerminals = !0;
    mxGraphHandler.prototype.guidesEnabled = !0;
    mxGraphHandler.prototype.removeEmptyParents = !0;
    mxRubberband.prototype.fadeOut = !0;
    mxGuide.prototype.isEnabledForEvent = function (a) {
      return !mxEvent.isAltDown(a);
    };
    var c = mxGraphLayout.prototype.isVertexIgnored;
    mxGraphLayout.prototype.isVertexIgnored = function (a) {
      return c.apply(this, arguments) || this.graph.isTableRow(a) || this.graph.isTableCell(a);
    };
    var d = mxGraphLayout.prototype.isEdgeIgnored;
    mxGraphLayout.prototype.isEdgeIgnored = function (a) {
      return d.apply(this, arguments) || this.graph.isEdgeIgnored(a);
    };
    var e = mxConnectionHandler.prototype.isCreateTarget;
    mxConnectionHandler.prototype.isCreateTarget = function (a) {
      return this.graph.isCloneEvent(a) != e.apply(this, arguments);
    };
    mxConstraintHandler.prototype.createHighlightShape = function () {
      var a = new mxEllipse(null, this.highlightColor, this.highlightColor, 0);
      a.opacity = mxConstants.HIGHLIGHT_OPACITY;
      return a;
    };
    mxConnectionHandler.prototype.livePreview = !0;
    mxConnectionHandler.prototype.cursor = 'crosshair';
    mxConnectionHandler.prototype.createEdgeState = function (a) {
      a = this.graph.createCurrentEdgeStyle();
      a = this.graph.createEdge(null, null, null, null, null, a);
      a = new mxCellState(this.graph.view, a, this.graph.getCellStyle(a));
      for (var b in this.graph.currentEdgeStyle) a.style[b] = this.graph.currentEdgeStyle[b];
      a.style = this.graph.postProcessCellStyle(a.cell, a.style);
      return a;
    };
    var f = mxConnectionHandler.prototype.createShape;
    mxConnectionHandler.prototype.createShape = function () {
      var a = f.apply(this, arguments);
      a.isDashed = '1' == this.graph.currentEdgeStyle[mxConstants.STYLE_DASHED];
      return a;
    };
    mxConnectionHandler.prototype.updatePreview = function (a) {};
    var g = mxConnectionHandler.prototype.createMarker;
    mxConnectionHandler.prototype.createMarker = function () {
      var a = g.apply(this, arguments),
        b = a.getCell;
      a.getCell = mxUtils.bind(this, function (a) {
        var c = b.apply(this, arguments);
        this.error = null;
        return c;
      });
      return a;
    };
    Graph.prototype.defaultVertexStyle = {};
    Graph.prototype.defaultEdgeStyle = {
      edgeStyle: 'orthogonalEdgeStyle',
      rounded: '0',
      jettySize: 'auto',
      orthogonalLoop: '1',
    };
    Graph.prototype.createCurrentEdgeStyle = function () {
      for (
        var a = 'edgeStyle=' + (this.currentEdgeStyle.edgeStyle || 'none') + ';',
          b =
            'shape curved rounded comic sketch fillWeight hachureGap hachureAngle jiggle disableMultiStroke disableMultiStrokeFill fillStyle curveFitting simplification comicStyle jumpStyle jumpSize'.split(
              ' '
            ),
          c = 0;
        c < b.length;
        c++
      )
        null != this.currentEdgeStyle[b[c]] && (a += b[c] + '=' + this.currentEdgeStyle[b[c]] + ';');
      null != this.currentEdgeStyle.orthogonalLoop
        ? (a += 'orthogonalLoop=' + this.currentEdgeStyle.orthogonalLoop + ';')
        : null != Graph.prototype.defaultEdgeStyle.orthogonalLoop &&
          (a += 'orthogonalLoop=' + Graph.prototype.defaultEdgeStyle.orthogonalLoop + ';');
      null != this.currentEdgeStyle.jettySize
        ? (a += 'jettySize=' + this.currentEdgeStyle.jettySize + ';')
        : null != Graph.prototype.defaultEdgeStyle.jettySize &&
          (a += 'jettySize=' + Graph.prototype.defaultEdgeStyle.jettySize + ';');
      'elbowEdgeStyle' == this.currentEdgeStyle.edgeStyle &&
        null != this.currentEdgeStyle.elbow &&
        (a += 'elbow=' + this.currentEdgeStyle.elbow + ';');
      return (a =
        null != this.currentEdgeStyle.html ? a + ('html=' + this.currentEdgeStyle.html + ';') : a + 'html=1;');
    };
    Graph.prototype.getPagePadding = function () {
      return new mxPoint(0, 0);
    };
    Graph.prototype.loadStylesheet = function () {
      var a =
        null != this.themes
          ? this.themes[this.defaultThemeName]
          : mxStyleRegistry.dynamicLoading
          ? mxUtils.load(STYLE_PATH + '/default.xml').getDocumentElement()
          : null;
      null != a && new mxCodec(a.ownerDocument).decode(a, this.getStylesheet());
    };
    Graph.prototype.createCellLookup = function (a, b) {
      b = null != b ? b : {};
      for (var c = 0; c < a.length; c++) {
        var d = a[c];
        b[mxObjectIdentity.get(d)] = d.getId();
        for (var e = this.model.getChildCount(d), f = 0; f < e; f++)
          this.createCellLookup([this.model.getChildAt(d, f)], b);
      }
      return b;
    };
    Graph.prototype.createCellMapping = function (a, b, c) {
      c = null != c ? c : {};
      for (var d in a) {
        var e = b[d];
        null == c[e] && (c[e] = a[d].getId() || '');
      }
      return c;
    };
    Graph.prototype.importGraphModel = function (a, b, c, d) {
      b = null != b ? b : 0;
      c = null != c ? c : 0;
      var e = new mxCodec(a.ownerDocument),
        f = new mxGraphModel();
      e.decode(a, f);
      a = [];
      var e = {},
        g = {},
        k = f.getChildren(this.cloneCell(f.root, this.isCloneInvalidEdges(), e));
      if (null != k) {
        var h = this.createCellLookup([f.root]),
          k = k.slice();
        this.model.beginUpdate();
        try {
          if (1 != k.length || this.isCellLocked(this.getDefaultParent()))
            for (f = 0; f < k.length; f++)
              (l = this.model.getChildren(this.moveCells([k[f]], b, c, !1, this.model.getRoot())[0])),
                null != l && (a = a.concat(l));
          else {
            var l = f.getChildren(k[0]);
            null != l &&
              ((a = this.moveCells(l, b, c, !1, this.getDefaultParent())),
              (g[f.getChildAt(f.root, 0).getId()] = this.getDefaultParent().getId()));
          }
          if (null != a && (this.createCellMapping(e, h, g), this.updateCustomLinks(g, a), d)) {
            this.isGridEnabled() && ((b = this.snap(b)), (c = this.snap(c)));
            var m = this.getBoundingBoxFromGeometry(a, !0);
            null != m && this.moveCells(a, b - m.x, c - m.y);
          }
        } finally {
          this.model.endUpdate();
        }
      }
      return a;
    };
    Graph.prototype.encodeCells = function (a) {
      for (var b = {}, c = this.cloneCells(a, null, b), d = new mxDictionary(), e = 0; e < a.length; e++)
        d.put(a[e], !0);
      for (var f = new mxCodec(), g = new mxGraphModel(), k = g.getChildAt(g.getRoot(), 0), e = 0; e < c.length; e++) {
        g.add(k, c[e]);
        var h = this.view.getState(a[e]);
        if (null != h) {
          var l = this.getCellGeometry(c[e]);
          null != l &&
            l.relative &&
            !this.model.isEdge(a[e]) &&
            null == d.get(this.model.getParent(a[e])) &&
            ((l.offset = null),
            (l.relative = !1),
            (l.x = h.x / h.view.scale - h.view.translate.x),
            (l.y = h.y / h.view.scale - h.view.translate.y));
        }
      }
      this.updateCustomLinks(this.createCellMapping(b, this.createCellLookup(a)), c);
      return f.encode(g);
    };
    Graph.prototype.isSwimlane = function (a, b) {
      var c = null;
      null == a ||
        this.model.isEdge(a) ||
        this.model.getParent(a) == this.model.getRoot() ||
        (c = this.getCurrentCellStyle(a, b)[mxConstants.STYLE_SHAPE]);
      return c == mxConstants.SHAPE_SWIMLANE || 'table' == c || 'tableRow' == c;
    };
    var k = Graph.prototype.isExtendParent;
    Graph.prototype.isExtendParent = function (a) {
      var b = this.model.getParent(a);
      if (null != b) {
        var c = this.getCurrentCellStyle(b);
        if (null != c.expand) return '0' != c.expand;
      }
      return k.apply(this, arguments) && (null == b || !this.isTable(b));
    };
    var h = Graph.prototype.splitEdge;
    Graph.prototype.splitEdge = function (a, b, c, d, e, f, g, k) {
      null == k &&
        ((k = this.model.getParent(a)), this.isTable(k) || this.isTableRow(k)) &&
        (k = this.getCellAt(f, g, null, !0, !1));
      c = null;
      this.model.beginUpdate();
      try {
        c = h.apply(this, [a, b, c, d, e, f, g, k]);
        this.model.setValue(c, '');
        var l = this.getChildCells(c, !0);
        for (b = 0; b < l.length; b++) {
          var m = this.getCellGeometry(l[b]);
          null != m && m.relative && 0 < m.x && this.model.remove(l[b]);
        }
        var E = this.getChildCells(a, !0);
        for (b = 0; b < E.length; b++)
          (m = this.getCellGeometry(E[b])), null != m && m.relative && 0 >= m.x && this.model.remove(E[b]);
        this.setCellStyles(mxConstants.STYLE_TARGET_PERIMETER_SPACING, null, [c]);
        this.setCellStyles(mxConstants.STYLE_ENDARROW, mxConstants.NONE, [c]);
        this.setCellStyles(mxConstants.STYLE_SOURCE_PERIMETER_SPACING, null, [a]);
        this.setCellStyles(mxConstants.STYLE_STARTARROW, mxConstants.NONE, [a]);
        var n = this.model.getTerminal(c, !1);
        if (null != n) {
          var I = this.getCurrentCellStyle(n);
          null != I &&
            '1' == I.snapToPoint &&
            (this.setCellStyles(mxConstants.STYLE_EXIT_X, null, [a]),
            this.setCellStyles(mxConstants.STYLE_EXIT_Y, null, [a]),
            this.setCellStyles(mxConstants.STYLE_ENTRY_X, null, [c]),
            this.setCellStyles(mxConstants.STYLE_ENTRY_Y, null, [c]));
        }
      } finally {
        this.model.endUpdate();
      }
      return c;
    };
    var l = Graph.prototype.selectCell;
    Graph.prototype.selectCell = function (a, b, c) {
      if (b || c) l.apply(this, arguments);
      else {
        var d = this.getSelectionCell(),
          e = null,
          f = [],
          g = mxUtils.bind(this, function (b) {
            if (null != this.view.getState(b) && (this.model.isVertex(b) || this.model.isEdge(b)))
              if ((f.push(b), b == d)) e = f.length - 1;
              else if ((a && null == d && 0 < f.length) || (null != e && a && f.length > e) || (!a && 0 < e)) return;
            for (var c = 0; c < this.model.getChildCount(b); c++) g(this.model.getChildAt(b, c));
          });
        g(this.model.root);
        0 < f.length && ((e = null != e ? mxUtils.mod(e + (a ? 1 : -1), f.length) : 0), this.setSelectionCell(f[e]));
      }
    };
    Graph.prototype.swapShapes = function (a, b, c, d, e, f, g) {
      b = !1;
      if (
        !d &&
        null != e &&
        1 == a.length &&
        ((d = this.view.getState(e)),
        (c = this.view.getState(a[0])),
        null != d &&
          null != c &&
          ((null != f && mxEvent.isShiftDown(f)) ||
            ('umlLifeline' == d.style.shape && 'umlLifeline' == c.style.shape)) &&
          ((d = this.getCellGeometry(e)), (f = this.getCellGeometry(a[0])), null != d && null != f))
      ) {
        b = d.clone();
        d = f.clone();
        d.x = b.x;
        d.y = b.y;
        b.x = f.x;
        b.y = f.y;
        this.model.beginUpdate();
        try {
          this.model.setGeometry(e, b), this.model.setGeometry(a[0], d);
        } finally {
          this.model.endUpdate();
        }
        b = !0;
      }
      return b;
    };
    var m = Graph.prototype.moveCells;
    Graph.prototype.moveCells = function (a, b, c, d, e, f, g) {
      if (this.swapShapes(a, b, c, d, e, f, g)) return a;
      g = null != g ? g : {};
      if (this.isTable(e)) {
        for (var k = [], h = 0; h < a.length; h++)
          this.isTable(a[h]) ? (k = k.concat(this.model.getChildCells(a[h], !0).reverse())) : k.push(a[h]);
        a = k;
      }
      this.model.beginUpdate();
      try {
        k = [];
        for (h = 0; h < a.length; h++)
          if (null != e && this.isTableRow(a[h])) {
            var l = this.model.getParent(a[h]),
              E = this.getCellGeometry(a[h]);
            this.isTable(l) && k.push(l);
            if (null != l && null != E && this.isTable(l) && this.isTable(e) && (d || l != e)) {
              if (!d) {
                var n = this.getCellGeometry(l);
                null != n && ((n = n.clone()), (n.height -= E.height), this.model.setGeometry(l, n));
              }
              n = this.getCellGeometry(e);
              null != n && ((n = n.clone()), (n.height += E.height), this.model.setGeometry(e, n));
              var I = this.model.getChildCells(e, !0);
              if (0 < I.length) {
                a[h] = d ? this.cloneCell(a[h]) : a[h];
                var F = this.model.getChildCells(a[h], !0),
                  p = this.model.getChildCells(I[0], !0),
                  N = p.length - F.length;
                if (0 < N)
                  for (var V = 0; V < N; V++) {
                    var t = this.cloneCell(F[F.length - 1]);
                    null != t && ((t.value = ''), this.model.add(a[h], t));
                  }
                else if (0 > N) for (V = 0; V > N; V--) this.model.remove(F[F.length + V - 1]);
                F = this.model.getChildCells(a[h], !0);
                for (V = 0; V < p.length; V++) {
                  var r = this.getCellGeometry(p[V]),
                    Q = this.getCellGeometry(F[V]);
                  null != r && null != Q && ((Q = Q.clone()), (Q.width = r.width), this.model.setGeometry(F[V], Q));
                }
              }
            }
          }
        for (var u = m.apply(this, arguments), h = 0; h < k.length; h++)
          !d && this.model.contains(k[h]) && 0 == this.model.getChildCount(k[h]) && this.model.remove(k[h]);
        d && this.updateCustomLinks(this.createCellMapping(g, this.createCellLookup(a)), u);
      } finally {
        this.model.endUpdate();
      }
      return u;
    };
    var n = Graph.prototype.removeCells;
    Graph.prototype.removeCells = function (a, b) {
      var c = [];
      this.model.beginUpdate();
      try {
        for (var d = 0; d < a.length; d++)
          if (this.isTableCell(a[d])) {
            var e = this.model.getParent(a[d]),
              f = this.model.getParent(e);
            1 == this.model.getChildCount(e) && 1 == this.model.getChildCount(f)
              ? 0 > mxUtils.indexOf(a, f) && 0 > mxUtils.indexOf(c, f) && c.push(f)
              : this.labelChanged(a[d], '');
          } else {
            if (
              this.isTableRow(a[d]) &&
              ((f = this.model.getParent(a[d])), 0 > mxUtils.indexOf(a, f) && 0 > mxUtils.indexOf(c, f))
            ) {
              for (var g = this.model.getChildCells(f, !0), k = 0, h = 0; h < g.length; h++)
                0 <= mxUtils.indexOf(a, g[h]) && k++;
              k == g.length && c.push(f);
            }
            c.push(a[d]);
          }
        c = n.apply(this, [c, b]);
      } finally {
        this.model.endUpdate();
      }
      return c;
    };
    Graph.prototype.updateCustomLinks = function (a, b, c) {
      c = null != c ? c : new Graph();
      for (var d = 0; d < b.length; d++) null != b[d] && c.updateCustomLinksForCell(a, b[d], c);
    };
    Graph.prototype.updateCustomLinksForCell = function (a, b) {
      this.doUpdateCustomLinksForCell(a, b);
      for (var c = this.model.getChildCount(b), d = 0; d < c; d++)
        this.updateCustomLinksForCell(a, this.model.getChildAt(b, d));
    };
    Graph.prototype.doUpdateCustomLinksForCell = function (a, b) {};
    Graph.prototype.getAllConnectionConstraints = function (a, b) {
      if (null != a) {
        var c = mxUtils.getValue(a.style, 'points', null);
        if (null != c) {
          var d = [];
          try {
            for (var e = JSON.parse(c), c = 0; c < e.length; c++) {
              var f = e[c];
              d.push(
                new mxConnectionConstraint(
                  new mxPoint(f[0], f[1]),
                  2 < f.length ? '0' != f[2] : !0,
                  null,
                  3 < f.length ? f[3] : 0,
                  4 < f.length ? f[4] : 0
                )
              );
            }
          } catch (X) {}
          return d;
        }
        if (null != a.shape && null != a.shape.bounds) {
          f = a.shape.direction;
          e = a.shape.bounds;
          c = a.shape.scale;
          d = e.width / c;
          e = e.height / c;
          if (f == mxConstants.DIRECTION_NORTH || f == mxConstants.DIRECTION_SOUTH) (f = d), (d = e), (e = f);
          c = a.shape.getConstraints(a.style, d, e);
          if (null != c) return c;
          if (null != a.shape.stencil && null != a.shape.stencil.constraints) return a.shape.stencil.constraints;
          if (null != a.shape.constraints) return a.shape.constraints;
        }
      }
      return null;
    };
    Graph.prototype.flipEdge = function (a) {
      if (null != a) {
        var b = this.getCurrentCellStyle(a),
          b =
            mxUtils.getValue(b, mxConstants.STYLE_ELBOW, mxConstants.ELBOW_HORIZONTAL) == mxConstants.ELBOW_HORIZONTAL
              ? mxConstants.ELBOW_VERTICAL
              : mxConstants.ELBOW_HORIZONTAL;
        this.setCellStyles(mxConstants.STYLE_ELBOW, b, [a]);
      }
    };
    Graph.prototype.isValidRoot = function (a) {
      for (var b = this.model.getChildCount(a), c = 0, d = 0; d < b; d++) {
        var e = this.model.getChildAt(a, d);
        this.model.isVertex(e) && ((e = this.getCellGeometry(e)), null == e || e.relative || c++);
      }
      return 0 < c || this.isContainer(a);
    };
    Graph.prototype.isValidDropTarget = function (a, b, c) {
      for (var d = this.getCurrentCellStyle(a), e = !0, f = !0, g = 0; g < b.length && f; g++)
        (e = e && this.isTable(b[g])), (f = f && this.isTableRow(b[g]));
      return (
        ((1 == b.length && null != c && mxEvent.isShiftDown(c) && !mxEvent.isControlDown(c) && !mxEvent.isAltDown(c)) ||
          (('1' != mxUtils.getValue(d, 'part', '0') || this.isContainer(a)) &&
            '0' != mxUtils.getValue(d, 'dropTarget', '1') &&
            (mxGraph.prototype.isValidDropTarget.apply(this, arguments) || this.isContainer(a)) &&
            !this.isTableRow(a) &&
            (!this.isTable(a) || f || e))) &&
        !this.isCellLocked(a)
      );
    };
    Graph.prototype.createGroupCell = function () {
      var a = mxGraph.prototype.createGroupCell.apply(this, arguments);
      a.setStyle('group');
      return a;
    };
    Graph.prototype.isExtendParentsOnAdd = function (a) {
      var b = mxGraph.prototype.isExtendParentsOnAdd.apply(this, arguments);
      if (b && null != a && null != this.layoutManager) {
        var c = this.model.getParent(a);
        null != c && ((c = this.layoutManager.getLayout(c)), null != c && c.constructor == mxStackLayout && (b = !1));
      }
      return b;
    };
    Graph.prototype.getPreferredSizeForCell = function (a) {
      var b = mxGraph.prototype.getPreferredSizeForCell.apply(this, arguments);
      null != b &&
        ((b.width += 10),
        (b.height += 4),
        this.gridEnabled && ((b.width = this.snap(b.width)), (b.height = this.snap(b.height))));
      return b;
    };
    Graph.prototype.turnShapes = function (a, b) {
      var c = this.getModel(),
        d = [];
      c.beginUpdate();
      try {
        for (var e = 0; e < a.length; e++) {
          var f = a[e];
          if (c.isEdge(f)) {
            var g = c.getTerminal(f, !0),
              k = c.getTerminal(f, !1);
            c.setTerminal(f, k, !0);
            c.setTerminal(f, g, !1);
            var h = c.getGeometry(f);
            if (null != h) {
              h = h.clone();
              null != h.points && h.points.reverse();
              var l = h.getTerminalPoint(!0),
                m = h.getTerminalPoint(!1);
              h.setTerminalPoint(l, !1);
              h.setTerminalPoint(m, !0);
              c.setGeometry(f, h);
              var E = this.view.getState(f),
                n = this.view.getState(g),
                I = this.view.getState(k);
              if (null != E) {
                var p = null != n ? this.getConnectionConstraint(E, n, !0) : null,
                  t = null != I ? this.getConnectionConstraint(E, I, !1) : null;
                this.setConnectionConstraint(f, g, !0, t);
                this.setConnectionConstraint(f, k, !1, p);
                var r = mxUtils.getValue(E.style, mxConstants.STYLE_SOURCE_PERIMETER_SPACING);
                this.setCellStyles(
                  mxConstants.STYLE_SOURCE_PERIMETER_SPACING,
                  mxUtils.getValue(E.style, mxConstants.STYLE_TARGET_PERIMETER_SPACING),
                  [f]
                );
                this.setCellStyles(mxConstants.STYLE_TARGET_PERIMETER_SPACING, r, [f]);
              }
              d.push(f);
            }
          } else if (c.isVertex(f) && ((h = this.getCellGeometry(f)), null != h)) {
            if (!(this.isTable(f) || this.isTableRow(f) || this.isTableCell(f) || this.isSwimlane(f))) {
              h = h.clone();
              h.x += h.width / 2 - h.height / 2;
              h.y += h.height / 2 - h.width / 2;
              var u = h.width;
              h.width = h.height;
              h.height = u;
              c.setGeometry(f, h);
            }
            var v = this.view.getState(f);
            if (null != v) {
              var x = [
                  mxConstants.DIRECTION_EAST,
                  mxConstants.DIRECTION_SOUTH,
                  mxConstants.DIRECTION_WEST,
                  mxConstants.DIRECTION_NORTH,
                ],
                z = mxUtils.getValue(v.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);
              this.setCellStyles(
                mxConstants.STYLE_DIRECTION,
                x[mxUtils.mod(mxUtils.indexOf(x, z) + (b ? -1 : 1), x.length)],
                [f]
              );
            }
            d.push(f);
          }
        }
      } finally {
        c.endUpdate();
      }
      return d;
    };
    Graph.prototype.stencilHasPlaceholders = function (a) {
      if (null != a && null != a.fgNode)
        for (a = a.fgNode.firstChild; null != a; ) {
          if ('text' == a.nodeName && '1' == a.getAttribute('placeholders')) return !0;
          a = a.nextSibling;
        }
      return !1;
    };
    var p = Graph.prototype.processChange;
    Graph.prototype.processChange = function (a) {
      if (
        a instanceof mxGeometryChange &&
        (this.isTableCell(a.cell) || this.isTableRow(a.cell)) &&
        ((null == a.previous && null != a.geometry) || (null != a.previous && !a.previous.equals(a.geometry)))
      ) {
        var b = a.cell;
        this.isTableCell(b) && (b = this.model.getParent(b));
        this.isTableRow(b) && (b = this.model.getParent(b));
        var c = this.view.getState(b);
        null != c && null != c.shape && (this.view.invalidate(b), (c.shape.bounds = null));
      }
      p.apply(this, arguments);
      a instanceof mxValueChange &&
        null != a.cell &&
        null != a.cell.value &&
        'object' == typeof a.cell.value &&
        this.invalidateDescendantsWithPlaceholders(a.cell);
    };
    Graph.prototype.invalidateDescendantsWithPlaceholders = function (a) {
      a = this.model.getDescendants(a);
      if (0 < a.length)
        for (var b = 0; b < a.length; b++) {
          var c = this.view.getState(a[b]);
          null != c && null != c.shape && null != c.shape.stencil && this.stencilHasPlaceholders(c.shape.stencil)
            ? this.removeStateForCell(a[b])
            : this.isReplacePlaceholders(a[b]) && this.view.invalidate(a[b], !1, !1);
        }
    };
    Graph.prototype.replaceElement = function (a, b) {
      for (
        var c = a.ownerDocument.createElement(null != b ? b : 'span'), d = Array.prototype.slice.call(a.attributes);
        (attr = d.pop());

      )
        c.setAttribute(attr.nodeName, attr.nodeValue);
      c.innerHTML = a.innerHTML;
      a.parentNode.replaceChild(c, a);
    };
    Graph.prototype.processElements = function (a, b) {
      if (null != a) for (var c = a.getElementsByTagName('*'), d = 0; d < c.length; d++) b(c[d]);
    };
    Graph.prototype.updateLabelElements = function (a, b, c) {
      a = null != a ? a : this.getSelectionCells();
      for (var d = document.createElement('div'), e = 0; e < a.length; e++)
        if (this.isHtmlLabel(a[e])) {
          var f = this.convertValueToString(a[e]);
          if (null != f && 0 < f.length) {
            d.innerHTML = f;
            for (var g = d.getElementsByTagName(null != c ? c : '*'), k = 0; k < g.length; k++) b(g[k]);
            d.innerHTML != f && this.cellLabelChanged(a[e], d.innerHTML);
          }
        }
    };
    Graph.prototype.cellLabelChanged = function (a, b, c) {
      b = Graph.zapGremlins(b);
      this.model.beginUpdate();
      try {
        if (null != a.value && 'object' == typeof a.value) {
          if (this.isReplacePlaceholders(a) && null != a.getAttribute('placeholder'))
            for (var d = a.getAttribute('placeholder'), e = a; null != e; ) {
              if (e == this.model.getRoot() || (null != e.value && 'object' == typeof e.value && e.hasAttribute(d))) {
                this.setAttributeForCell(e, d, b);
                break;
              }
              e = this.model.getParent(e);
            }
          var f = a.value.cloneNode(!0);
          Graph.translateDiagram && null != Graph.diagramLanguage && f.hasAttribute('label_' + Graph.diagramLanguage)
            ? f.setAttribute('label_' + Graph.diagramLanguage, b)
            : f.setAttribute('label', b);
          b = f;
        }
        mxGraph.prototype.cellLabelChanged.apply(this, arguments);
      } finally {
        this.model.endUpdate();
      }
    };
    Graph.prototype.cellsRemoved = function (a) {
      if (null != a) {
        for (var b = new mxDictionary(), c = 0; c < a.length; c++) b.put(a[c], !0);
        for (var d = [], c = 0; c < a.length; c++) {
          var e = this.model.getParent(a[c]);
          null == e || b.get(e) || (b.put(e, !0), d.push(e));
        }
        for (c = 0; c < d.length; c++)
          if (
            ((e = this.view.getState(d[c])),
            null != e &&
              (this.model.isEdge(e.cell) || this.model.isVertex(e.cell)) &&
              this.isCellDeletable(e.cell) &&
              this.isTransparentState(e))
          ) {
            for (var f = !0, g = 0; g < this.model.getChildCount(e.cell) && f; g++)
              b.get(this.model.getChildAt(e.cell, g)) || (f = !1);
            f && a.push(e.cell);
          }
      }
      mxGraph.prototype.cellsRemoved.apply(this, arguments);
    };
    Graph.prototype.removeCellsAfterUngroup = function (a) {
      for (var b = [], c = 0; c < a.length; c++)
        this.isCellDeletable(a[c]) && this.isTransparentState(this.view.getState(a[c])) && b.push(a[c]);
      a = b;
      mxGraph.prototype.removeCellsAfterUngroup.apply(this, arguments);
    };
    Graph.prototype.setLinkForCell = function (a, b) {
      this.setAttributeForCell(a, 'link', b);
    };
    Graph.prototype.setTooltipForCell = function (a, b) {
      var c = 'tooltip';
      Graph.translateDiagram &&
        null != Graph.diagramLanguage &&
        mxUtils.isNode(a.value) &&
        a.value.hasAttribute('tooltip_' + Graph.diagramLanguage) &&
        (c = 'tooltip_' + Graph.diagramLanguage);
      this.setAttributeForCell(a, c, b);
    };
    Graph.prototype.getAttributeForCell = function (a, b, c) {
      a = null != a.value && 'object' === typeof a.value ? a.value.getAttribute(b) : null;
      return null != a ? a : c;
    };
    Graph.prototype.setAttributeForCell = function (a, b, c) {
      var d;
      null != a.value && 'object' == typeof a.value
        ? (d = a.value.cloneNode(!0))
        : ((d = mxUtils.createXmlDocument().createElement('UserObject')), d.setAttribute('label', a.value || ''));
      null != c ? d.setAttribute(b, c) : d.removeAttribute(b);
      this.model.setValue(a, d);
    };
    var r = Graph.prototype.getDropTarget;
    Graph.prototype.getDropTarget = function (a, b, c, d) {
      this.getModel();
      if (mxEvent.isAltDown(b)) return null;
      for (var e = 0; e < a.length; e++) {
        var f = this.model.getParent(a[e]);
        if (this.model.isEdge(f) && 0 > mxUtils.indexOf(a, f)) return null;
      }
      for (var f = r.apply(this, arguments), g = !0, e = 0; e < a.length && g; e++) g = g && this.isTableRow(a[e]);
      g &&
        (this.isTableCell(f) && (f = this.model.getParent(f)),
        this.isTableRow(f) && (f = this.model.getParent(f)),
        this.isTable(f) || (f = null));
      return f;
    };
    Graph.prototype.click = function (a) {
      mxGraph.prototype.click.call(this, a);
      this.firstClickState = a.getState();
      this.firstClickSource = a.getSource();
    };
    Graph.prototype.dblClick = function (a, b) {
      this.isEnabled() && ((b = this.insertTextForEvent(a, b)), mxGraph.prototype.dblClick.call(this, a, b));
    };
    Graph.prototype.insertTextForEvent = function (a, b) {
      var c = mxUtils.convertPoint(this.container, mxEvent.getClientX(a), mxEvent.getClientY(a));
      if (null != a && !this.model.isVertex(b)) {
        var d = this.model.isEdge(b) ? this.view.getState(b) : null,
          e = mxEvent.getSource(a);
        this.firstClickState != d ||
          this.firstClickSource != e ||
          (null != d &&
            null != d.text &&
            null != d.text.node &&
            null != d.text.boundingBox &&
            (mxUtils.contains(d.text.boundingBox, c.x, c.y) ||
              mxUtils.isAncestorNode(d.text.node, mxEvent.getSource(a)))) ||
          ((null != d || this.isCellLocked(this.getDefaultParent())) && (null == d || this.isCellLocked(d.cell))) ||
          !(null != d || (mxClient.IS_SVG && e == this.view.getCanvas().ownerSVGElement)) ||
          (null == d && (d = this.view.getState(this.getCellAt(c.x, c.y))), (b = this.addText(c.x, c.y, d)));
      }
      return b;
    };
    Graph.prototype.getInsertPoint = function () {
      var a = this.getGridSize(),
        b = this.container.scrollLeft / this.view.scale - this.view.translate.x,
        c = this.container.scrollTop / this.view.scale - this.view.translate.y;
      if (this.pageVisible)
        var d = this.getPageLayout(),
          e = this.getPageSize(),
          b = Math.max(b, d.x * e.width),
          c = Math.max(c, d.y * e.height);
      return new mxPoint(this.snap(b + a), this.snap(c + a));
    };
    Graph.prototype.getFreeInsertPoint = function () {
      var a = this.view,
        b = this.getGraphBounds(),
        c = this.getInsertPoint(),
        d = this.snap(
          Math.round(Math.max(c.x, b.x / a.scale - a.translate.x + (0 == b.width ? 2 * this.gridSize : 0)))
        ),
        a = this.snap(Math.round(Math.max(c.y, (b.y + b.height) / a.scale - a.translate.y + 2 * this.gridSize)));
      return new mxPoint(d, a);
    };
    Graph.prototype.getCenterInsertPoint = function (a) {
      a = null != a ? a : new mxRectangle();
      return mxUtils.hasScrollbars(this.container)
        ? new mxPoint(
            this.snap(
              Math.round(
                (this.container.scrollLeft + this.container.clientWidth / 2) / this.view.scale -
                  this.view.translate.x -
                  a.width / 2
              )
            ),
            this.snap(
              Math.round(
                (this.container.scrollTop + this.container.clientHeight / 2) / this.view.scale -
                  this.view.translate.y -
                  a.height / 2
              )
            )
          )
        : new mxPoint(
            this.snap(
              Math.round(this.container.clientWidth / 2 / this.view.scale - this.view.translate.x - a.width / 2)
            ),
            this.snap(
              Math.round(this.container.clientHeight / 2 / this.view.scale - this.view.translate.y - a.height / 2)
            )
          );
    };
    Graph.prototype.isMouseInsertPoint = function () {
      return !1;
    };
    Graph.prototype.addText = function (a, b, c) {
      var d = new mxCell();
      d.value = 'Text';
      d.geometry = new mxGeometry(0, 0, 0, 0);
      d.vertex = !0;
      if (null != c && this.model.isEdge(c.cell)) {
        d.style = 'edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];';
        d.geometry.relative = !0;
        d.connectable = !1;
        var e = this.view.getRelativePoint(c, a, b);
        d.geometry.x = Math.round(1e4 * e.x) / 1e4;
        d.geometry.y = Math.round(e.y);
        d.geometry.offset = new mxPoint(0, 0);
        var e = this.view.getPoint(c, d.geometry),
          f = this.view.scale;
        d.geometry.offset = new mxPoint(Math.round((a - e.x) / f), Math.round((b - e.y) / f));
      } else
        (e = this.view.translate),
          (d.style = 'text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];'),
          (d.geometry.width = 40),
          (d.geometry.height = 20),
          (d.geometry.x = Math.round(a / this.view.scale) - e.x - (null != c ? c.origin.x : 0)),
          (d.geometry.y = Math.round(b / this.view.scale) - e.y - (null != c ? c.origin.y : 0)),
          (d.style += 'autosize=1;');
      this.getModel().beginUpdate();
      try {
        this.addCells([d], null != c ? c.cell : null),
          this.fireEvent(new mxEventObject('textInserted', 'cells', [d])),
          this.autoSizeCell(d);
      } finally {
        this.getModel().endUpdate();
      }
      return d;
    };
    Graph.prototype.addClickHandler = function (a, b, c) {
      var d = mxUtils.bind(this, function () {
        var a = this.container.getElementsByTagName('a');
        if (null != a)
          for (var c = 0; c < a.length; c++) {
            var d = this.getAbsoluteUrl(a[c].getAttribute('href'));
            null != d &&
              (a[c].setAttribute('rel', this.linkRelation),
              a[c].setAttribute('href', d),
              null != b && mxEvent.addGestureListeners(a[c], null, null, b));
          }
      });
      this.model.addListener(mxEvent.CHANGE, d);
      d();
      var e = this.container.style.cursor,
        f = this.getTolerance(),
        g = this,
        k = {
          currentState: null,
          currentLink: null,
          currentTarget: null,
          highlight: null != a && '' != a && a != mxConstants.NONE ? new mxCellHighlight(g, a, 4) : null,
          startX: 0,
          startY: 0,
          scrollLeft: 0,
          scrollTop: 0,
          updateCurrentState: function (a) {
            var b = a.sourceState;
            if (null == b || null == g.getLinkForCell(b.cell))
              (a = g.getCellAt(a.getGraphX(), a.getGraphY(), null, null, null, function (a, b, c) {
                return null == g.getLinkForCell(a.cell);
              })),
                (b = null == b || g.model.isAncestor(a, b.cell) ? g.view.getState(a) : null);
            b != this.currentState &&
              (null != this.currentState && this.clear(),
              (this.currentState = b),
              null != this.currentState && this.activate(this.currentState));
          },
          mouseDown: function (a, b) {
            this.startX = b.getGraphX();
            this.startY = b.getGraphY();
            this.scrollLeft = g.container.scrollLeft;
            this.scrollTop = g.container.scrollTop;
            null == this.currentLink && 'auto' == g.container.style.overflow && (g.container.style.cursor = 'move');
            this.updateCurrentState(b);
          },
          mouseMove: function (a, b) {
            if (g.isMouseDown) {
              if (null != this.currentLink) {
                var c = Math.abs(this.startX - b.getGraphX()),
                  d = Math.abs(this.startY - b.getGraphY());
                (c > f || d > f) && this.clear();
              }
            } else {
              for (c = b.getSource(); null != c && 'a' != c.nodeName.toLowerCase(); ) c = c.parentNode;
              null != c
                ? this.clear()
                : (null != g.tooltipHandler &&
                    null != this.currentLink &&
                    null != this.currentState &&
                    g.tooltipHandler.reset(b, !0, this.currentState),
                  (null == this.currentState ||
                    (b.getState() != this.currentState && null != b.sourceState) ||
                    !g.intersects(this.currentState, b.getGraphX(), b.getGraphY())) &&
                    this.updateCurrentState(b));
            }
          },
          mouseUp: function (a, d) {
            for (var e = d.getSource(), k = d.getEvent(); null != e && 'a' != e.nodeName.toLowerCase(); )
              e = e.parentNode;
            null == e &&
              Math.abs(this.scrollLeft - g.container.scrollLeft) < f &&
              Math.abs(this.scrollTop - g.container.scrollTop) < f &&
              (null == d.sourceState || !d.isSource(d.sourceState.control)) &&
              (((mxEvent.isLeftMouseButton(k) || mxEvent.isMiddleMouseButton(k)) && !mxEvent.isPopupTrigger(k)) ||
                mxEvent.isTouchEvent(k)) &&
              (null != this.currentLink
                ? ((e = g.isBlankLink(this.currentLink)),
                  ('data:' !== this.currentLink.substring(0, 5) && e) || null == b || b(k, this.currentLink),
                  mxEvent.isConsumed(k) ||
                    ((k =
                      null != this.currentTarget
                        ? this.currentTarget
                        : mxEvent.isMiddleMouseButton(k)
                        ? '_blank'
                        : e
                        ? g.linkTarget
                        : '_top'),
                    g.openLink(this.currentLink, k),
                    d.consume()))
                : null != c &&
                  !d.isConsumed() &&
                  Math.abs(this.scrollLeft - g.container.scrollLeft) < f &&
                  Math.abs(this.scrollTop - g.container.scrollTop) < f &&
                  Math.abs(this.startX - d.getGraphX()) < f &&
                  Math.abs(this.startY - d.getGraphY()) < f &&
                  c(d.getEvent()));
            this.clear();
          },
          activate: function (a) {
            this.currentLink = g.getAbsoluteUrl(g.getLinkForCell(a.cell));
            null != this.currentLink &&
              ((this.currentTarget = g.getLinkTargetForCell(a.cell)),
              (g.container.style.cursor = 'pointer'),
              null != this.highlight && this.highlight.highlight(a));
          },
          clear: function () {
            null != g.container && (g.container.style.cursor = e);
            this.currentLink = this.currentState = this.currentTarget = null;
            null != this.highlight && this.highlight.hide();
            null != g.tooltipHandler && g.tooltipHandler.hide();
          },
        };
      g.click = function (a) {};
      g.addMouseListener(k);
      mxEvent.addListener(document, 'mouseleave', function (a) {
        k.clear();
      });
    };
    Graph.prototype.duplicateCells = function (a, b) {
      a = null != a ? a : this.getSelectionCells();
      b = null != b ? b : !0;
      for (var c = 0; c < a.length; c++) this.isTableCell(a[c]) && (a[c] = this.model.getParent(a[c]));
      a = this.model.getTopmostCells(a);
      var d = this.getModel(),
        e = this.gridSize,
        f = [];
      d.beginUpdate();
      try {
        for (var g = {}, k = this.createCellLookup(a), h = this.cloneCells(a, !1, g, !0), c = 0; c < a.length; c++) {
          var l = d.getParent(a[c]);
          if (null != l) {
            var m = this.moveCells([h[c]], e, e, !1)[0];
            f.push(m);
            if (b) d.add(l, h[c]);
            else {
              var n = l.getIndex(a[c]);
              d.add(l, h[c], n + 1);
            }
            if (this.isTable(l)) {
              var E = this.getCellGeometry(h[c]),
                p = this.getCellGeometry(l);
              null != E && null != p && ((p = p.clone()), (p.height += E.height), d.setGeometry(l, p));
            }
          } else f.push(h[c]);
        }
        this.updateCustomLinks(this.createCellMapping(g, k), h, this);
        this.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, 'cells', h));
      } finally {
        d.endUpdate();
      }
      return f;
    };
    Graph.prototype.insertImage = function (a, b, c) {
      if (null != a && null != this.cellEditor.textarea) {
        for (var d = this.cellEditor.textarea.getElementsByTagName('img'), e = [], f = 0; f < d.length; f++)
          e.push(d[f]);
        document.execCommand('insertimage', !1, a);
        a = this.cellEditor.textarea.getElementsByTagName('img');
        if (a.length == e.length + 1)
          for (f = a.length - 1; 0 <= f; f--)
            if (0 == f || a[f] != e[f - 1]) {
              a[f].setAttribute('width', b);
              a[f].setAttribute('height', c);
              break;
            }
      }
    };
    Graph.prototype.insertLink = function (a) {
      if (null != this.cellEditor.textarea)
        if (0 == a.length) document.execCommand('unlink', !1);
        else if (mxClient.IS_FF) {
          for (var b = this.cellEditor.textarea.getElementsByTagName('a'), c = [], d = 0; d < b.length; d++)
            c.push(b[d]);
          document.execCommand('createlink', !1, mxUtils.trim(a));
          b = this.cellEditor.textarea.getElementsByTagName('a');
          if (b.length == c.length + 1)
            for (d = b.length - 1; 0 <= d; d--)
              if (b[d] != c[d - 1]) {
                for (b = b[d].getElementsByTagName('a'); 0 < b.length; ) {
                  for (c = b[0].parentNode; null != b[0].firstChild; ) c.insertBefore(b[0].firstChild, b[0]);
                  c.removeChild(b[0]);
                }
                break;
              }
        } else document.execCommand('createlink', !1, mxUtils.trim(a));
    };
    Graph.prototype.isCellResizable = function (a) {
      var b = mxGraph.prototype.isCellResizable.apply(this, arguments),
        c = this.getCurrentCellStyle(a);
      return (
        !this.isTableCell(a) &&
        !this.isTableRow(a) &&
        (b ||
          ('0' != mxUtils.getValue(c, mxConstants.STYLE_RESIZABLE, '1') && 'wrap' == c[mxConstants.STYLE_WHITE_SPACE]))
      );
    };
    Graph.prototype.distributeCells = function (a, b) {
      null == b && (b = this.getSelectionCells());
      if (null != b && 1 < b.length) {
        for (var c = [], d = null, e = null, f = 0; f < b.length; f++)
          if (this.getModel().isVertex(b[f])) {
            var g = this.view.getState(b[f]);
            if (null != g) {
              var k = a ? g.getCenterX() : g.getCenterY(),
                d = null != d ? Math.max(d, k) : k,
                e = null != e ? Math.min(e, k) : k;
              c.push(g);
            }
          }
        if (2 < c.length) {
          c.sort(function (b, c) {
            return a ? b.x - c.x : b.y - c.y;
          });
          g = this.view.translate;
          k = this.view.scale;
          e = e / k - (a ? g.x : g.y);
          d = d / k - (a ? g.x : g.y);
          this.getModel().beginUpdate();
          try {
            for (var h = (d - e) / (c.length - 1), d = e, f = 1; f < c.length - 1; f++) {
              var l = this.view.getState(this.model.getParent(c[f].cell)),
                m = this.getCellGeometry(c[f].cell),
                d = d + h;
              null != m &&
                null != l &&
                ((m = m.clone()),
                a
                  ? (m.x = Math.round(d - m.width / 2) - l.origin.x)
                  : (m.y = Math.round(d - m.height / 2) - l.origin.y),
                this.getModel().setGeometry(c[f].cell, m));
            }
          } finally {
            this.getModel().endUpdate();
          }
        }
      }
      return b;
    };
    Graph.prototype.isCloneEvent = function (a) {
      return (mxClient.IS_MAC && mxEvent.isMetaDown(a)) || mxEvent.isControlDown(a);
    };
    Graph.prototype.createSvgImageExport = function () {
      var a = new mxImageExport();
      a.getLinkForCellState = mxUtils.bind(this, function (a, b) {
        return this.getLinkForCell(a.cell);
      });
      return a;
    };
    Graph.prototype.parseBackgroundImage = function (a) {
      var b = null;
      null != a && 0 < a.length && ((a = JSON.parse(a)), (b = new mxImage(a.src, a.width, a.height)));
      return b;
    };
    Graph.prototype.getBackgroundImageObject = function (a) {
      return a;
    };
    Graph.prototype.getSvg = function (a, b, c, d, e, f, g, k, h, l, m, n, p, t) {
      var E = null;
      if (null != t) for (E = new mxDictionary(), m = 0; m < t.length; m++) E.put(t[m], !0);
      if ((t = this.useCssTransforms)) (this.useCssTransforms = !1), this.view.revalidate(), this.sizeDidChange();
      try {
        b = null != b ? b : 1;
        c = null != c ? c : 0;
        e = null != e ? e : !0;
        f = null != f ? f : !0;
        g = null != g ? g : !0;
        l = null != l ? l : !1;
        var I =
            'page' == p
              ? this.view.getBackgroundPageBounds()
              : (f && null == E) || d || 'diagram' == p
              ? this.getGraphBounds()
              : this.getBoundingBox(this.getSelectionCells()),
          F = this.view.scale;
        'diagram' == p &&
          null != this.backgroundImage &&
          ((I = mxRectangle.fromRectangle(I)),
          I.add(
            new mxRectangle(
              (this.view.translate.x + this.backgroundImage.x) * F,
              (this.view.translate.y + this.backgroundImage.y) * F,
              this.backgroundImage.width * F,
              this.backgroundImage.height * F
            )
          ));
        if (null == I) throw Error(mxResources.get('drawingEmpty'));
        var r = mxUtils.createXmlDocument(),
          N = null != r.createElementNS ? r.createElementNS(mxConstants.NS_SVG, 'svg') : r.createElement('svg');
        null != a &&
          (null != N.style ? (N.style.backgroundColor = a) : N.setAttribute('style', 'background-color:' + a));
        null == r.createElementNS
          ? (N.setAttribute('xmlns', mxConstants.NS_SVG), N.setAttribute('xmlns:xlink', mxConstants.NS_XLINK))
          : N.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);
        a = b / F;
        var u = Math.max(1, Math.ceil(I.width * a) + 2 * c) + (l && 0 == c ? 5 : 0),
          V = Math.max(1, Math.ceil(I.height * a) + 2 * c) + (l && 0 == c ? 5 : 0);
        N.setAttribute('version', '1.1');
        N.setAttribute('width', u + 'px');
        N.setAttribute('height', V + 'px');
        N.setAttribute('viewBox', (e ? '-0.5 -0.5' : '0 0') + ' ' + u + ' ' + V);
        r.appendChild(N);
        var v = null != r.createElementNS ? r.createElementNS(mxConstants.NS_SVG, 'g') : r.createElement('g');
        N.appendChild(v);
        var Q = this.createSvgCanvas(v);
        Q.foOffset = e ? -0.5 : 0;
        Q.textOffset = e ? -0.5 : 0;
        Q.imageOffset = e ? -0.5 : 0;
        Q.translate(Math.floor(c / b - I.x / F), Math.floor(c / b - I.y / F));
        var x = document.createElement('div'),
          z = Q.getAlternateText;
        Q.getAlternateText = function (a, b, c, d, e, f, g, k, h, l, m, n, E) {
          if (null != f && 0 < this.state.fontSize)
            try {
              mxUtils.isNode(f)
                ? (f = f.innerText)
                : ((x.innerHTML = f), (f = mxUtils.extractTextWithWhitespace(x.childNodes)));
              for (
                var p = Math.ceil((2 * d) / this.state.fontSize), I = [], q = 0, w = 0;
                (0 == p || q < p) && w < f.length;

              ) {
                var y = f.charCodeAt(w);
                if (10 == y || 13 == y) {
                  if (0 < q) break;
                } else I.push(f.charAt(w)), 255 > y && q++;
                w++;
              }
              I.length < f.length && 1 < f.length - I.length && (f = mxUtils.trim(I.join('')) + '...');
              return f;
            } catch (A) {
              return z.apply(this, arguments);
            }
          else return z.apply(this, arguments);
        };
        var X = this.backgroundImage;
        if (null != X) {
          b = F / b;
          var B = this.view.translate,
            C = new mxRectangle((X.x + B.x) * b, (X.y + B.y) * b, X.width * b, X.height * b);
          mxUtils.intersects(I, C) && Q.image(X.x + B.x, X.y + B.y, X.width, X.height, X.src, !0);
        }
        Q.scale(a);
        Q.textEnabled = g;
        k = null != k ? k : this.createSvgImageExport();
        var D = k.drawCellState,
          J = k.getLinkForCellState;
        k.getLinkForCellState = function (a, b) {
          var c = J.apply(this, arguments);
          return null == c || a.view.graph.isCustomLink(c) ? null : c;
        };
        k.getLinkTargetForCellState = function (a, b) {
          return a.view.graph.getLinkTargetForCell(a.cell);
        };
        k.drawCellState = function (a, b) {
          for (
            var c = a.view.graph,
              d = null != E ? E.get(a.cell) : c.isCellSelected(a.cell),
              e = c.model.getParent(a.cell);
            !((f && null == E) || d) && null != e;

          )
            (d = null != E ? E.get(e) : c.isCellSelected(e)), (e = c.model.getParent(e));
          ((f && null == E) || d) && D.apply(this, arguments);
        };
        k.drawState(this.getView().getState(this.model.root), Q);
        this.updateSvgLinks(N, h, !0);
        this.addForeignObjectWarning(Q, N);
        return N;
      } finally {
        t && ((this.useCssTransforms = !0), this.view.revalidate(), this.sizeDidChange());
      }
    };
    Graph.prototype.addForeignObjectWarning = function (a, b) {
      if ('0' != urlParams['svg-warning'] && 0 < b.getElementsByTagName('foreignObject').length) {
        var c = a.createElement('switch'),
          d = a.createElement('g');
        d.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');
        var e = a.createElement('a');
        e.setAttribute('transform', 'translate(0,-5)');
        null == e.setAttributeNS || (b.ownerDocument != document && null == document.documentMode)
          ? (e.setAttribute('xlink:href', Graph.foreignObjectWarningLink), e.setAttribute('target', '_blank'))
          : (e.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', Graph.foreignObjectWarningLink),
            e.setAttributeNS(mxConstants.NS_XLINK, 'target', '_blank'));
        var f = a.createElement('text');
        f.setAttribute('text-anchor', 'middle');
        f.setAttribute('font-size', '10px');
        f.setAttribute('x', '50%');
        f.setAttribute('y', '100%');
        mxUtils.write(f, Graph.foreignObjectWarningText);
        c.appendChild(d);
        e.appendChild(f);
        c.appendChild(e);
        b.appendChild(c);
      }
    };
    Graph.prototype.updateSvgLinks = function (a, b, c) {
      a = a.getElementsByTagName('a');
      for (var d = 0; d < a.length; d++)
        if (null == a[d].getAttribute('target')) {
          var e = a[d].getAttribute('href');
          null == e && (e = a[d].getAttribute('xlink:href'));
          null != e &&
            (null != b && /^https?:\/\//.test(e)
              ? a[d].setAttribute('target', b)
              : c && this.isCustomLink(e) && a[d].setAttribute('href', 'javascript:void(0);'));
        }
    };
    Graph.prototype.createSvgCanvas = function (a) {
      a = new mxSvgCanvas2D(a);
      a.minStrokeWidth = this.cellRenderer.minSvgStrokeWidth;
      a.pointerEvents = !0;
      return a;
    };
    Graph.prototype.getSelectedElement = function () {
      var a = null;
      if (window.getSelection) {
        var b = window.getSelection();
        b.getRangeAt && b.rangeCount && (a = b.getRangeAt(0).commonAncestorContainer);
      } else document.selection && (a = document.selection.createRange().parentElement());
      return a;
    };
    Graph.prototype.getSelectedEditingElement = function () {
      for (var a = this.getSelectedElement(); null != a && a.nodeType != mxConstants.NODETYPE_ELEMENT; )
        a = a.parentNode;
      null != a &&
        a == this.cellEditor.textarea &&
        1 == this.cellEditor.textarea.children.length &&
        this.cellEditor.textarea.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT &&
        (a = this.cellEditor.textarea.firstChild);
      return a;
    };
    Graph.prototype.getParentByName = function (a, b, c) {
      for (; null != a && a.nodeName != b; ) {
        if (a == c) return null;
        a = a.parentNode;
      }
      return a;
    };
    Graph.prototype.getParentByNames = function (a, b, c) {
      for (; null != a && !(0 <= mxUtils.indexOf(b, a.nodeName)); ) {
        if (a == c) return null;
        a = a.parentNode;
      }
      return a;
    };
    Graph.prototype.selectNode = function (a) {
      var b = null;
      if (window.getSelection) {
        if (((b = window.getSelection()), b.getRangeAt && b.rangeCount)) {
          var c = document.createRange();
          c.selectNode(a);
          b.removeAllRanges();
          b.addRange(c);
        }
      } else
        (b = document.selection) &&
          'Control' != b.type &&
          ((a = b.createRange()), a.collapse(!0), (c = b.createRange()), c.setEndPoint('StartToStart', a), c.select());
    };
    Graph.prototype.flipEdgePoints = function (a, b, c) {
      var d = this.getCellGeometry(a);
      if (null != d) {
        d = d.clone();
        if (null != d.points)
          for (var e = 0; e < d.points.length; e++)
            b ? (d.points[e].x = c + (c - d.points[e].x)) : (d.points[e].y = c + (c - d.points[e].y));
        e = function (a) {
          null != a && (b ? (a.x = c + (c - a.x)) : (a.y = c + (c - a.y)));
        };
        e(d.getTerminalPoint(!0));
        e(d.getTerminalPoint(!1));
        this.model.setGeometry(a, d);
      }
    };
    Graph.prototype.flipChildren = function (a, b, c) {
      this.model.beginUpdate();
      try {
        for (var d = this.model.getChildCount(a), e = 0; e < d; e++) {
          var f = this.model.getChildAt(a, e);
          if (this.model.isEdge(f)) this.flipEdgePoints(f, b, c);
          else {
            var g = this.getCellGeometry(f);
            null != g &&
              ((g = g.clone()),
              b ? (g.x = c + (c - g.x - g.width)) : (g.y = c + (c - g.y - g.height)),
              this.model.setGeometry(f, g));
          }
        }
      } finally {
        this.model.endUpdate();
      }
    };
    Graph.prototype.flipCells = function (a, b) {
      this.model.beginUpdate();
      try {
        a = this.model.getTopmostCells(a);
        for (var c = [], d = 0; d < a.length; d++)
          if (this.model.isEdge(a[d])) {
            var e = this.view.getState(a[d]);
            null != e &&
              this.flipEdgePoints(
                a[d],
                b,
                (b ? e.getCenterX() : e.getCenterY()) / this.view.scale -
                  (b ? e.origin.x : e.origin.y) -
                  (b ? this.view.translate.x : this.view.translate.y)
              );
          } else {
            var f = this.getCellGeometry(a[d]);
            null != f && this.flipChildren(a[d], b, b ? f.getCenterX() - f.x : f.getCenterY() - f.y);
            c.push(a[d]);
          }
        this.toggleCellStyles(b ? mxConstants.STYLE_FLIPH : mxConstants.STYLE_FLIPV, !1, c);
      } finally {
        this.model.endUpdate();
      }
    };
    Graph.prototype.deleteCells = function (a, b) {
      var c = null;
      if (null != a && 0 < a.length) {
        this.model.beginUpdate();
        try {
          for (var d = 0; d < a.length; d++) {
            var e = this.model.getParent(a[d]);
            if (this.isTable(e)) {
              var f = this.getCellGeometry(a[d]),
                g = this.getCellGeometry(e);
              null != f && null != g && ((g = g.clone()), (g.height -= f.height), this.model.setGeometry(e, g));
            }
          }
          var k = this.selectParentAfterDelete ? this.model.getParents(a) : null;
          this.removeCells(a, b);
        } finally {
          this.model.endUpdate();
        }
        if (null != k)
          for (c = [], d = 0; d < k.length; d++)
            this.model.contains(k[d]) && (this.model.isVertex(k[d]) || this.model.isEdge(k[d])) && c.push(k[d]);
      }
      return c;
    };
    Graph.prototype.insertTableColumn = function (a, b) {
      var c = this.getModel();
      c.beginUpdate();
      try {
        var d = a,
          e = 0;
        if (this.isTableCell(a))
          var f = c.getParent(a),
            d = c.getParent(f),
            e = mxUtils.indexOf(c.getChildCells(f, !0), a);
        else
          this.isTableRow(a) ? (d = c.getParent(a)) : (a = c.getChildCells(d, !0)[0]),
            b || (e = c.getChildCells(a, !0).length - 1);
        for (var g = c.getChildCells(d, !0), k = Graph.minTableColumnWidth, f = 0; f < g.length; f++) {
          var h = c.getChildCells(g[f], !0)[e],
            l = c.cloneCell(h, !1),
            m = this.getCellGeometry(l);
          l.value = null;
          l.style = mxUtils.setStyle(mxUtils.setStyle(l.style, 'rowspan', null), 'colspan', null);
          if (null != m) {
            null != m.alternateBounds &&
              ((m.width = m.alternateBounds.width), (m.height = m.alternateBounds.height), (m.alternateBounds = null));
            var k = m.width,
              n = this.getCellGeometry(g[f]);
            null != n && (m.height = n.height);
          }
          c.add(g[f], l, e + (b ? 0 : 1));
        }
        var p = this.getCellGeometry(d);
        null != p && ((p = p.clone()), (p.width += k), c.setGeometry(d, p));
      } finally {
        c.endUpdate();
      }
    };
    Graph.prototype.deleteLane = function (a) {
      var b = this.getModel();
      b.beginUpdate();
      try {
        var c = null,
          c = 'stackLayout' == this.getCurrentCellStyle(a).childLayout ? a : b.getParent(a),
          d = b.getChildCells(c, !0);
        0 == d.length ? b.remove(c) : (c == a && (a = d[d.length - 1]), b.remove(a));
      } finally {
        b.endUpdate();
      }
    };
    Graph.prototype.insertLane = function (a, b) {
      var c = this.getModel();
      c.beginUpdate();
      try {
        var d = null,
          e = a;
        if ('stackLayout' == this.getCurrentCellStyle(e).childLayout)
          var d = e,
            f = c.getChildCells(d, !0),
            e = f[b ? 0 : f.length - 1];
        else d = c.getParent(e);
        var g = d.getIndex(e),
          e = c.cloneCell(e, !1);
        e.value = null;
        c.add(d, e, g + (b ? 0 : 1));
      } finally {
        c.endUpdate();
      }
    };
    Graph.prototype.insertTableRow = function (a, b) {
      var c = this.getModel();
      c.beginUpdate();
      try {
        var d = a,
          e = a;
        if (this.isTableCell(a)) (e = c.getParent(a)), (d = c.getParent(e));
        else if (this.isTableRow(a)) d = c.getParent(a);
        else
          var f = c.getChildCells(d, !0),
            e = f[b ? 0 : f.length - 1];
        var g = c.getChildCells(e, !0),
          k = d.getIndex(e),
          e = c.cloneCell(e, !1);
        e.value = null;
        var h = this.getCellGeometry(e);
        if (null != h) {
          for (f = 0; f < g.length; f++) {
            a = c.cloneCell(g[f], !1);
            a.value = null;
            a.style = mxUtils.setStyle(mxUtils.setStyle(a.style, 'rowspan', null), 'colspan', null);
            var l = this.getCellGeometry(a);
            null != l &&
              (null != l.alternateBounds &&
                ((l.width = l.alternateBounds.width),
                (l.height = l.alternateBounds.height),
                (l.alternateBounds = null)),
              (l.height = h.height));
            e.insert(a);
          }
          c.add(d, e, k + (b ? 0 : 1));
          var m = this.getCellGeometry(d);
          null != m && ((m = m.clone()), (m.height += h.height), c.setGeometry(d, m));
        }
      } finally {
        c.endUpdate();
      }
    };
    Graph.prototype.deleteTableColumn = function (a) {
      var b = this.getModel();
      b.beginUpdate();
      try {
        var c = a,
          d = a;
        this.isTableCell(a) && (d = b.getParent(a));
        this.isTableRow(d) && (c = b.getParent(d));
        var e = b.getChildCells(c, !0);
        if (0 == e.length) b.remove(c);
        else {
          this.isTableRow(d) || (d = e[0]);
          var f = b.getChildCells(d, !0);
          if (1 >= f.length) b.remove(c);
          else {
            var g = f.length - 1;
            this.isTableCell(a) && (g = mxUtils.indexOf(f, a));
            for (d = a = 0; d < e.length; d++) {
              var k = b.getChildCells(e[d], !0)[g];
              b.remove(k);
              var h = this.getCellGeometry(k);
              null != h && (a = Math.max(a, h.width));
            }
            var l = this.getCellGeometry(c);
            null != l && ((l = l.clone()), (l.width -= a), b.setGeometry(c, l));
          }
        }
      } finally {
        b.endUpdate();
      }
    };
    Graph.prototype.deleteTableRow = function (a) {
      var b = this.getModel();
      b.beginUpdate();
      try {
        var c = a,
          d = a;
        this.isTableCell(a) && (a = d = b.getParent(a));
        this.isTableRow(a) && (c = b.getParent(d));
        var e = b.getChildCells(c, !0);
        if (1 >= e.length) b.remove(c);
        else {
          this.isTableRow(d) || (d = e[e.length - 1]);
          b.remove(d);
          a = 0;
          var f = this.getCellGeometry(d);
          null != f && (a = f.height);
          var g = this.getCellGeometry(c);
          null != g && ((g = g.clone()), (g.height -= a), b.setGeometry(c, g));
        }
      } finally {
        b.endUpdate();
      }
    };
    Graph.prototype.insertRow = function (a, b) {
      for (var c = a.tBodies[0], d = c.rows[0].cells, e = 0, f = 0; f < d.length; f++)
        var g = d[f].getAttribute('colspan'), e = e + (null != g ? parseInt(g) : 1);
      c = c.insertRow(b);
      for (f = 0; f < e; f++) mxUtils.br(c.insertCell(-1));
      return c.cells[0];
    };
    Graph.prototype.deleteRow = function (a, b) {
      a.tBodies[0].deleteRow(b);
    };
    Graph.prototype.insertColumn = function (a, b) {
      var c = a.tHead;
      if (null != c)
        for (var d = 0; d < c.rows.length; d++) {
          var e = document.createElement('th');
          c.rows[d].appendChild(e);
          mxUtils.br(e);
        }
      c = a.tBodies[0];
      for (d = 0; d < c.rows.length; d++) (e = c.rows[d].insertCell(b)), mxUtils.br(e);
      return c.rows[0].cells[0 <= b ? b : c.rows[0].cells.length - 1];
    };
    Graph.prototype.deleteColumn = function (a, b) {
      if (0 <= b) for (var c = a.tBodies[0].rows, d = 0; d < c.length; d++) c[d].cells.length > b && c[d].deleteCell(b);
    };
    Graph.prototype.pasteHtmlAtCaret = function (a) {
      var b;
      if (window.getSelection) {
        if (((b = window.getSelection()), b.getRangeAt && b.rangeCount)) {
          b = b.getRangeAt(0);
          b.deleteContents();
          var c = document.createElement('div');
          c.innerHTML = a;
          a = document.createDocumentFragment();
          for (var d; (d = c.firstChild); ) lastNode = a.appendChild(d);
          b.insertNode(a);
        }
      } else (b = document.selection) && 'Control' != b.type && b.createRange().pasteHTML(a);
    };
    Graph.prototype.createLinkForHint = function (a, b) {
      function c(a, b) {
        a.length > b && (a = a.substring(0, Math.round(b / 2)) + '...' + a.substring(a.length - Math.round(b / 4)));
        return a;
      }
      a = null != a ? a : 'javascript:void(0);';
      if (null == b || 0 == b.length) b = this.isCustomLink(a) ? this.getLinkTitle(a) : a;
      var d = document.createElement('a');
      d.setAttribute('rel', this.linkRelation);
      d.setAttribute('href', this.getAbsoluteUrl(a));
      d.setAttribute('title', c(this.isCustomLink(a) ? this.getLinkTitle(a) : a, 80));
      null != this.linkTarget && d.setAttribute('target', this.linkTarget);
      mxUtils.write(d, c(b, 40));
      this.isCustomLink(a) &&
        mxEvent.addListener(
          d,
          'click',
          mxUtils.bind(this, function (b) {
            this.customLinkClicked(a);
            mxEvent.consume(b);
          })
        );
      return d;
    };
    Graph.prototype.initTouch = function () {
      this.connectionHandler.marker.isEnabled = function () {
        return null != this.graph.connectionHandler.first;
      };
      this.addListener(mxEvent.START_EDITING, function (a, b) {
        this.popupMenuHandler.hideMenu();
      });
      var a = this.updateMouseEvent;
      this.updateMouseEvent = function (b) {
        b = a.apply(this, arguments);
        if (mxEvent.isTouchEvent(b.getEvent()) && null == b.getState()) {
          var c = this.getCellAt(b.graphX, b.graphY);
          (null != c && this.isSwimlane(c) && this.hitsSwimlaneContent(c, b.graphX, b.graphY)) ||
            ((b.state = this.view.getState(c)),
            null != b.state &&
              null != b.state.shape &&
              (this.container.style.cursor = b.state.shape.node.style.cursor));
        }
        null == b.getState() && this.isEnabled() && (this.container.style.cursor = 'default');
        return b;
      };
      var b = !1,
        c = !1,
        d = !1,
        e = this.fireMouseEvent;
      this.fireMouseEvent = function (a, f, g) {
        a == mxEvent.MOUSE_DOWN &&
          ((f = this.updateMouseEvent(f)),
          (b = this.isCellSelected(f.getCell())),
          (c = this.isSelectionEmpty()),
          (d = this.popupMenuHandler.isMenuShowing()));
        e.apply(this, arguments);
      };
      this.popupMenuHandler.mouseUp = mxUtils.bind(this, function (a, e) {
        var f = mxEvent.isMouseEvent(e.getEvent());
        this.popupMenuHandler.popupTrigger =
          !this.isEditing() &&
          this.isEnabled() &&
          (null == e.getState() || !e.isSource(e.getState().control)) &&
          (this.popupMenuHandler.popupTrigger ||
            (!d &&
              !f &&
              ((c && null == e.getCell() && this.isSelectionEmpty()) || (b && this.isCellSelected(e.getCell())))));
        f =
          !b || f
            ? null
            : mxUtils.bind(this, function (a) {
                window.setTimeout(
                  mxUtils.bind(this, function () {
                    if (!this.isEditing()) {
                      var b = mxUtils.getScrollOrigin();
                      this.popupMenuHandler.popup(e.getX() + b.x + 1, e.getY() + b.y + 1, a, e.getEvent());
                    }
                  }),
                  500
                );
              });
        mxPopupMenuHandler.prototype.mouseUp.apply(this.popupMenuHandler, [a, e, f]);
      });
    };
    mxCellEditor.prototype.isContentEditing = function () {
      var a = this.graph.view.getState(this.editingCell);
      return null != a && 1 == a.style.html;
    };
    mxCellEditor.prototype.isTableSelected = function () {
      return null != this.graph.getParentByName(this.graph.getSelectedElement(), 'TABLE', this.textarea);
    };
    mxCellEditor.prototype.isTextSelected = function () {
      var a = '';
      window.getSelection
        ? (a = window.getSelection())
        : document.getSelection
        ? (a = document.getSelection())
        : document.selection && (a = document.selection.createRange().text);
      return '' != a;
    };
    mxCellEditor.prototype.insertTab = function (a) {
      var b = this.textarea.ownerDocument.defaultView.getSelection(),
        c = b.getRangeAt(0),
        d = '\t';
      if (null != a) for (d = ''; 0 < a; ) (d += ''), a--;
      a = document.createElement('span');
      a.style.whiteSpace = 'pre';
      a.appendChild(document.createTextNode(d));
      c.insertNode(a);
      c.setStartAfter(a);
      c.setEndAfter(a);
      b.removeAllRanges();
      b.addRange(c);
    };
    mxCellEditor.prototype.alignText = function (a, b) {
      var c = null != b && mxEvent.isShiftDown(b);
      if (c || (null != window.getSelection && null != window.getSelection().containsNode)) {
        var d = !0;
        this.graph.processElements(this.textarea, function (a) {
          c || window.getSelection().containsNode(a, !0)
            ? (a.removeAttribute('align'), (a.style.textAlign = null))
            : (d = !1);
        });
        d && this.graph.cellEditor.setAlign(a);
      }
      document.execCommand('justify' + a.toLowerCase(), !1, null);
    };
    mxCellEditor.prototype.saveSelection = function () {
      if (window.getSelection) {
        var a = window.getSelection();
        if (a.getRangeAt && a.rangeCount) {
          for (var b = [], c = 0, d = a.rangeCount; c < d; ++c) b.push(a.getRangeAt(c));
          return b;
        }
      } else if (document.selection && document.selection.createRange) return document.selection.createRange();
      return null;
    };
    mxCellEditor.prototype.restoreSelection = function (a) {
      try {
        if (a)
          if (window.getSelection) {
            sel = window.getSelection();
            sel.removeAllRanges();
            for (var b = 0, c = a.length; b < c; ++b) sel.addRange(a[b]);
          } else document.selection && a.select && a.select();
      } catch (N) {}
    };
    var t = mxCellRenderer.prototype.initializeLabel;
    mxCellRenderer.prototype.initializeLabel = function (a) {
      null != a.text && (a.text.replaceLinefeeds = '0' != mxUtils.getValue(a.style, 'nl2Br', '1'));
      t.apply(this, arguments);
    };
    var u = mxConstraintHandler.prototype.update;
    mxConstraintHandler.prototype.update = function (a, b) {
      this.isKeepFocusEvent(a) || !mxEvent.isAltDown(a.getEvent()) ? u.apply(this, arguments) : this.reset();
    };
    mxGuide.prototype.createGuideShape = function (a) {
      return new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
    };
    mxCellEditor.prototype.escapeCancelsEditing = !1;
    var x = mxCellEditor.prototype.startEditing;
    mxCellEditor.prototype.startEditing = function (a, b) {
      a = this.graph.getStartEditingCell(a, b);
      x.apply(this, arguments);
      var c = this.graph.view.getState(a);
      this.textarea.className =
        null != c && 1 == c.style.html ? 'mxCellEditor geContentEditable' : 'mxCellEditor mxPlainTextEditor';
      this.codeViewMode = !1;
      this.switchSelectionState = null;
      this.graph.setSelectionCell(a);
      var c = this.graph.getModel().getParent(a),
        d = this.graph.getCellGeometry(a);
      if ((this.graph.getModel().isEdge(c) && null != d && d.relative) || this.graph.getModel().isEdge(a))
        this.textarea.style.outline =
          mxClient.IS_IE || mxClient.IS_IE11 || (mxClient.IS_FF && mxClient.IS_WIN) ? 'gray dotted 1px' : '';
    };
    var z = mxCellEditor.prototype.installListeners;
    mxCellEditor.prototype.installListeners = function (a) {
      function b(a, c) {
        c.originalNode = a;
        a = a.firstChild;
        for (var d = c.firstChild; null != a && null != d; ) b(a, d), (a = a.nextSibling), (d = d.nextSibling);
        return c;
      }
      function c(a, b) {
        if (null != a)
          if (b.originalNode != a) d(a);
          else
            for (a = a.firstChild, b = b.firstChild; null != a; ) {
              var e = a.nextSibling;
              null == b ? d(a) : (c(a, b), (b = b.nextSibling));
              a = e;
            }
      }
      function d(a) {
        for (var b = a.firstChild; null != b; ) {
          var c = b.nextSibling;
          d(b);
          b = c;
        }
        (1 == a.nodeType && ('BR' === a.nodeName || null != a.firstChild)) ||
        (3 == a.nodeType && 0 != mxUtils.trim(mxUtils.getTextContent(a)).length)
          ? (3 == a.nodeType && mxUtils.setTextContent(a, mxUtils.getTextContent(a).replace(/\n|\r/g, '')),
            1 == a.nodeType &&
              (a.removeAttribute('style'),
              a.removeAttribute('class'),
              a.removeAttribute('width'),
              a.removeAttribute('cellpadding'),
              a.removeAttribute('cellspacing'),
              a.removeAttribute('border')))
          : a.parentNode.removeChild(a);
      }
      z.apply(this, arguments);
      7 !== document.documentMode &&
        8 !== document.documentMode &&
        mxEvent.addListener(
          this.textarea,
          'paste',
          mxUtils.bind(this, function (a) {
            var d = b(this.textarea, this.textarea.cloneNode(!0));
            window.setTimeout(
              mxUtils.bind(this, function () {
                null != this.textarea &&
                  (0 <= this.textarea.innerHTML.indexOf('<o:OfficeDocumentSettings>') ||
                  0 <= this.textarea.innerHTML.indexOf('\x3c!--[if !mso]>')
                    ? c(this.textarea, d)
                    : Graph.removePasteFormatting(this.textarea));
              }),
              0
            );
          })
        );
    };
    mxCellEditor.prototype.toggleViewMode = function () {
      var a = this.graph.view.getState(this.editingCell);
      if (null != a) {
        var b = null != a && '0' != mxUtils.getValue(a.style, 'nl2Br', '1'),
          c = this.saveSelection();
        if (this.codeViewMode) {
          h = mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
          0 < h.length && '\n' == h.charAt(h.length - 1) && (h = h.substring(0, h.length - 1));
          h = this.graph.sanitizeHtml(b ? h.replace(/\n/g, '<br/>') : h, !0);
          this.textarea.className = 'mxCellEditor geContentEditable';
          var d = mxUtils.getValue(a.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE),
            b = mxUtils.getValue(a.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY),
            e = mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT),
            f =
              (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) ==
              mxConstants.FONT_BOLD,
            g =
              (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) ==
              mxConstants.FONT_ITALIC,
            k = [];
          (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) ==
            mxConstants.FONT_UNDERLINE && k.push('underline');
          (mxUtils.getValue(a.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_STRIKETHROUGH) ==
            mxConstants.FONT_STRIKETHROUGH && k.push('line-through');
          this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT
            ? Math.round(d * mxConstants.LINE_HEIGHT) + 'px'
            : mxConstants.LINE_HEIGHT;
          this.textarea.style.fontSize = Math.round(d) + 'px';
          this.textarea.style.textDecoration = k.join(' ');
          this.textarea.style.fontWeight = f ? 'bold' : 'normal';
          this.textarea.style.fontStyle = g ? 'italic' : '';
          this.textarea.style.fontFamily = b;
          this.textarea.style.textAlign = e;
          this.textarea.style.padding = '0px';
          this.textarea.innerHTML != h &&
            ((this.textarea.innerHTML = h),
            0 == this.textarea.innerHTML.length &&
              ((this.textarea.innerHTML = this.getEmptyLabelText()),
              (this.clearOnChange = 0 < this.textarea.innerHTML.length)));
          this.codeViewMode = !1;
        } else {
          this.clearOnChange &&
            this.textarea.innerHTML == this.getEmptyLabelText() &&
            ((this.clearOnChange = !1), (this.textarea.innerHTML = ''));
          var h = mxUtils.htmlEntities(this.textarea.innerHTML);
          8 != document.documentMode && (h = mxUtils.replaceTrailingNewlines(h, '<div><br></div>'));
          h = this.graph.sanitizeHtml(b ? h.replace(/\n/g, '').replace(/&lt;br\s*.?&gt;/g, '<br>') : h, !0);
          this.textarea.className = 'mxCellEditor mxPlainTextEditor';
          var d = mxConstants.DEFAULT_FONTSIZE;
          this.textarea.style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT
            ? Math.round(d * mxConstants.LINE_HEIGHT) + 'px'
            : mxConstants.LINE_HEIGHT;
          this.textarea.style.fontSize = Math.round(d) + 'px';
          this.textarea.style.textDecoration = '';
          this.textarea.style.fontWeight = 'normal';
          this.textarea.style.fontStyle = '';
          this.textarea.style.fontFamily = mxConstants.DEFAULT_FONTFAMILY;
          this.textarea.style.textAlign = 'left';
          this.textarea.style.width = '';
          this.textarea.style.padding = '2px';
          this.textarea.innerHTML != h && (this.textarea.innerHTML = h);
          this.codeViewMode = !0;
        }
        this.textarea.focus();
        null != this.switchSelectionState && this.restoreSelection(this.switchSelectionState);
        this.switchSelectionState = c;
        this.resize();
      }
    };
    var D = mxCellEditor.prototype.resize;
    mxCellEditor.prototype.resize = function (a, b) {
      if (null != this.textarea)
        if (((a = this.graph.getView().getState(this.editingCell)), this.codeViewMode && null != a)) {
          var c = a.view.scale;
          this.bounds = mxRectangle.fromRectangle(a);
          if (0 == this.bounds.width && 0 == this.bounds.height) {
            this.bounds.width = 160 * c;
            this.bounds.height = 60 * c;
            var d = null != a.text ? a.text.margin : null;
            null == d &&
              (d = mxUtils.getAlignmentAsPoint(
                mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),
                mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE)
              ));
            this.bounds.x += d.x * this.bounds.width;
            this.bounds.y += d.y * this.bounds.height;
          }
          this.textarea.style.width = Math.round((this.bounds.width - 4) / c) + 'px';
          this.textarea.style.height = Math.round((this.bounds.height - 4) / c) + 'px';
          this.textarea.style.overflow = 'auto';
          this.textarea.clientHeight < this.textarea.offsetHeight &&
            ((this.textarea.style.height =
              Math.round(this.bounds.height / c) + (this.textarea.offsetHeight - this.textarea.clientHeight) + 'px'),
            (this.bounds.height = parseInt(this.textarea.style.height) * c));
          this.textarea.clientWidth < this.textarea.offsetWidth &&
            ((this.textarea.style.width =
              Math.round(this.bounds.width / c) + (this.textarea.offsetWidth - this.textarea.clientWidth) + 'px'),
            (this.bounds.width = parseInt(this.textarea.style.width) * c));
          this.textarea.style.left = Math.round(this.bounds.x) + 'px';
          this.textarea.style.top = Math.round(this.bounds.y) + 'px';
          mxUtils.setPrefixedStyle(this.textarea.style, 'transform', 'scale(' + c + ',' + c + ')');
        } else (this.textarea.style.height = ''), (this.textarea.style.overflow = ''), D.apply(this, arguments);
    };
    mxCellEditorGetInitialValue = mxCellEditor.prototype.getInitialValue;
    mxCellEditor.prototype.getInitialValue = function (a, b) {
      if ('0' == mxUtils.getValue(a.style, 'html', '0')) return mxCellEditorGetInitialValue.apply(this, arguments);
      var c = this.graph.getEditingValue(a.cell, b);
      '1' == mxUtils.getValue(a.style, 'nl2Br', '1') && (c = c.replace(/\n/g, '<br/>'));
      return (c = this.graph.sanitizeHtml(c, !0));
    };
    mxCellEditorGetCurrentValue = mxCellEditor.prototype.getCurrentValue;
    mxCellEditor.prototype.getCurrentValue = function (a) {
      if ('0' == mxUtils.getValue(a.style, 'html', '0')) return mxCellEditorGetCurrentValue.apply(this, arguments);
      var b = this.graph.sanitizeHtml(this.textarea.innerHTML, !0);
      return (b =
        '1' == mxUtils.getValue(a.style, 'nl2Br', '1')
          ? b.replace(/\r\n/g, '<br/>').replace(/\n/g, '<br/>')
          : b.replace(/\r\n/g, '').replace(/\n/g, ''));
    };
    var B = mxCellEditor.prototype.stopEditing;
    mxCellEditor.prototype.stopEditing = function (a) {
      this.codeViewMode && this.toggleViewMode();
      B.apply(this, arguments);
      this.focusContainer();
    };
    mxCellEditor.prototype.focusContainer = function () {
      try {
        this.graph.container.focus();
      } catch (E) {}
    };
    var C = mxCellEditor.prototype.applyValue;
    mxCellEditor.prototype.applyValue = function (a, b) {
      this.graph.getModel().beginUpdate();
      try {
        C.apply(this, arguments),
          '' == b &&
            this.graph.isCellDeletable(a.cell) &&
            0 == this.graph.model.getChildCount(a.cell) &&
            this.graph.isTransparentState(a) &&
            this.graph.removeCells([a.cell], !1);
      } finally {
        this.graph.getModel().endUpdate();
      }
    };
    mxCellEditor.prototype.getBackgroundColor = function (a) {
      var b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, null);
      (null != b && b != mxConstants.NONE) ||
        !(null != a.cell.geometry && 0 < a.cell.geometry.width) ||
        (0 == mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0) &&
          0 != mxUtils.getValue(a.style, mxConstants.STYLE_HORIZONTAL, 1)) ||
        (b = mxUtils.getValue(a.style, mxConstants.STYLE_FILLCOLOR, null));
      b == mxConstants.NONE && (b = null);
      return b;
    };
    mxCellEditor.prototype.getBorderColor = function (a) {
      var b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_BORDERCOLOR, null);
      (null != b && b != mxConstants.NONE) ||
        !(null != a.cell.geometry && 0 < a.cell.geometry.width) ||
        (0 == mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0) &&
          0 != mxUtils.getValue(a.style, mxConstants.STYLE_HORIZONTAL, 1)) ||
        (b = mxUtils.getValue(a.style, mxConstants.STYLE_STROKECOLOR, null));
      b == mxConstants.NONE && (b = null);
      return b;
    };
    mxCellEditor.prototype.getMinimumSize = function (a) {
      var b = this.graph.getView().scale;
      return new mxRectangle(0, 0, null == a.text ? 30 : a.text.size * b + 20, 30);
    };
    mxGraphHandlerIsValidDropTarget = mxGraphHandler.prototype.isValidDropTarget;
    mxGraphHandler.prototype.isValidDropTarget = function (a, b) {
      return mxGraphHandlerIsValidDropTarget.apply(this, arguments) && !mxEvent.isAltDown(b.getEvent);
    };
    mxGraphView.prototype.formatUnitText = function (a) {
      return a ? b(a, this.unit) : a;
    };
    mxGraphHandler.prototype.updateHint = function (c) {
      if (null != this.pBounds && (null != this.shape || this.livePreviewActive)) {
        null == this.hint && ((this.hint = a()), this.graph.container.appendChild(this.hint));
        var d = this.graph.view.translate,
          e = this.graph.view.scale;
        c = this.roundLength((this.bounds.x + this.currentDx) / e - d.x);
        d = this.roundLength((this.bounds.y + this.currentDy) / e - d.y);
        e = this.graph.view.unit;
        this.hint.innerHTML = b(c, e) + ', ' + b(d, e);
        this.hint.style.left =
          this.pBounds.x + this.currentDx + Math.round((this.pBounds.width - this.hint.clientWidth) / 2) + 'px';
        this.hint.style.top = this.pBounds.y + this.currentDy + this.pBounds.height + Editor.hintOffset + 'px';
      }
    };
    mxGraphHandler.prototype.removeHint = function () {
      null != this.hint && (this.hint.parentNode.removeChild(this.hint), (this.hint = null));
    };
    var J = mxStackLayout.prototype.resizeCell;
    mxStackLayout.prototype.resizeCell = function (a, b) {
      J.apply(this, arguments);
      var c = this.graph.getCellStyle(a);
      if (null == c.childLayout) {
        var d = this.graph.model.getParent(a),
          e = null != d ? this.graph.getCellGeometry(d) : null;
        if (null != e && ((c = this.graph.getCellStyle(d)), 'stackLayout' == c.childLayout)) {
          var f = parseFloat(mxUtils.getValue(c, 'stackBorder', mxStackLayout.prototype.border)),
            c = '1' == mxUtils.getValue(c, 'horizontalStack', '1'),
            g = this.graph.getActualStartSize(d),
            e = e.clone();
          c ? (e.height = b.height + g.y + g.height + 2 * f) : (e.width = b.width + g.x + g.width + 2 * f);
          this.graph.model.setGeometry(d, e);
        }
      }
    };
    var v = mxSelectionCellsHandler.prototype.getHandledSelectionCells;
    mxSelectionCellsHandler.prototype.getHandledSelectionCells = function () {
      function a(a) {
        c.get(a) || (c.put(a, !0), e.push(a));
      }
      for (
        var b = v.apply(this, arguments), c = new mxDictionary(), d = this.graph.model, e = [], f = 0;
        f < b.length;
        f++
      ) {
        var g = b[f];
        this.graph.isTableCell(g) ? a(d.getParent(d.getParent(g))) : this.graph.isTableRow(g) && a(d.getParent(g));
        a(g);
      }
      return e;
    };
    var K = mxVertexHandler.prototype.createParentHighlightShape;
    mxVertexHandler.prototype.createParentHighlightShape = function (a) {
      var b = K.apply(this, arguments);
      b.stroke = '#C0C0C0';
      b.strokewidth = 1;
      return b;
    };
    var O = mxEdgeHandler.prototype.createParentHighlightShape;
    mxEdgeHandler.prototype.createParentHighlightShape = function (a) {
      var b = O.apply(this, arguments);
      b.stroke = '#C0C0C0';
      b.strokewidth = 1;
      return b;
    };
    mxVertexHandler.prototype.rotationHandleVSpacing = -12;
    mxVertexHandler.prototype.getRotationHandlePosition = function () {
      var a = this.getHandlePadding();
      return new mxPoint(
        this.bounds.x + this.bounds.width - this.rotationHandleVSpacing + a.x / 2,
        this.bounds.y + this.rotationHandleVSpacing - a.y / 2
      );
    };
    mxVertexHandler.prototype.isRecursiveResize = function (a, b) {
      return this.graph.isRecursiveVertexResize(a) && !mxEvent.isAltDown(b.getEvent());
    };
    mxVertexHandler.prototype.isCenteredEvent = function (a, b) {
      return mxEvent.isControlDown(b.getEvent()) || mxEvent.isMetaDown(b.getEvent());
    };
    var T = mxVertexHandler.prototype.isRotationHandleVisible;
    mxVertexHandler.prototype.isRotationHandleVisible = function () {
      return (
        T.apply(this, arguments) &&
        !this.graph.isTableCell(this.state.cell) &&
        !this.graph.isTableRow(this.state.cell) &&
        !this.graph.isTable(this.state.cell)
      );
    };
    mxVertexHandler.prototype.getSizerBounds = function () {
      return this.graph.isTableCell(this.state.cell)
        ? this.graph.view.getState(this.graph.model.getParent(this.graph.model.getParent(this.state.cell)))
        : this.bounds;
    };
    var M = mxVertexHandler.prototype.isParentHighlightVisible;
    mxVertexHandler.prototype.isParentHighlightVisible = function () {
      return (
        M.apply(this, arguments) && !this.graph.isTableCell(this.state.cell) && !this.graph.isTableRow(this.state.cell)
      );
    };
    var U = mxVertexHandler.prototype.isCustomHandleVisible;
    mxVertexHandler.prototype.isCustomHandleVisible = function (a) {
      return (
        a.tableHandle ||
        (U.apply(this, arguments) &&
          (!this.graph.isTable(this.state.cell) || this.graph.isCellSelected(this.state.cell)))
      );
    };
    mxVertexHandler.prototype.getSelectionBorderInset = function () {
      var a = 0;
      this.graph.isTableRow(this.state.cell) ? (a = 1) : this.graph.isTableCell(this.state.cell) && (a = 2);
      return a;
    };
    var da = mxVertexHandler.prototype.getSelectionBorderBounds;
    mxVertexHandler.prototype.getSelectionBorderBounds = function () {
      return da.apply(this, arguments).grow(-this.getSelectionBorderInset());
    };
    var ha = null,
      Y = mxVertexHandler.prototype.createCustomHandles;
    mxVertexHandler.prototype.createCustomHandles = function () {
      null == ha && (ha = mxCellRenderer.defaultShapes.tableLine);
      var a = Y.apply(this, arguments);
      if (this.graph.isTable(this.state.cell)) {
        var b = function (a, b, c) {
            for (var d = [], e = 0; e < a.length; e++) {
              var g = a[e];
              d.push(null == g ? null : new mxPoint((h + g.x + b) * f, (l + g.y + c) * f));
            }
            return d;
          },
          c = this,
          d = this.graph,
          e = d.model,
          f = d.view.scale,
          g = this.state,
          k = this.selectionBorder,
          h = this.state.origin.x + d.view.translate.x,
          l = this.state.origin.y + d.view.translate.y;
        null == a && (a = []);
        var m = d.view.getCellStates(e.getChildCells(this.state.cell, !0));
        if (0 < m.length) {
          for (
            var n = e.getChildCells(m[0].cell, !0),
              p = d.getTableLines(this.state.cell, !1, !0),
              t = d.getTableLines(this.state.cell, !0, !1),
              e = 0;
            e < m.length;
            e++
          )
            mxUtils.bind(this, function (e) {
              var h = m[e],
                l = e < m.length - 1 ? m[e + 1] : null,
                l = null != l ? d.getCellGeometry(l.cell) : null,
                n = null != l && null != l.alternateBounds ? l.alternateBounds : l,
                l =
                  null != t[e]
                    ? new ha(t[e], mxConstants.NONE, 1)
                    : new mxLine(new mxRectangle(), mxConstants.NONE, 1, !1);
              l.isDashed = k.isDashed;
              l.svgStrokeTolerance++;
              h = new mxHandle(h, 'row-resize', null, l);
              h.tableHandle = !0;
              var p = 0;
              h.shape.node.parentNode.insertBefore(h.shape.node, h.shape.node.parentNode.firstChild);
              h.redraw = function () {
                if (null != this.shape) {
                  this.shape.stroke = 0 == p ? mxConstants.NONE : k.stroke;
                  if (this.shape.constructor == ha)
                    (this.shape.line = b(t[e], 0, p)), this.shape.updateBoundsFromLine();
                  else {
                    var a = d.getActualStartSize(g.cell, !0);
                    this.shape.bounds.height = 1;
                    this.shape.bounds.y = this.state.y + this.state.height + p * f;
                    this.shape.bounds.x = g.x + (e == m.length - 1 ? 0 : a.x * f);
                    this.shape.bounds.width = g.width - (e == m.length - 1 ? 0 : a.width + a.x + f);
                  }
                  this.shape.redraw();
                }
              };
              var r = !1;
              h.setPosition = function (a, b, c) {
                p = Math.max(Graph.minTableRowHeight - a.height, b.y - a.y - a.height);
                r = mxEvent.isShiftDown(c.getEvent());
                null != n && r && (p = Math.min(p, n.height - Graph.minTableRowHeight));
              };
              h.execute = function (a) {
                if (0 != p) d.setTableRowHeight(this.state.cell, p, !r);
                else if (!c.blockDelayedSelection) {
                  var b = d.getCellAt(a.getGraphX(), a.getGraphY()) || g.cell;
                  d.graphHandler.selectCellForEvent(b, a);
                }
                p = 0;
              };
              h.reset = function () {
                p = 0;
              };
              a.push(h);
            })(e);
          for (e = 0; e < n.length; e++)
            mxUtils.bind(this, function (e) {
              var h = d.view.getState(n[e]),
                l = d.getCellGeometry(n[e]),
                m = null != l.alternateBounds ? l.alternateBounds : l;
              null == h &&
                ((h = new mxCellState(d.view, n[e], d.getCellStyle(n[e]))),
                (h.x = g.x + l.x * f),
                (h.y = g.y + l.y * f),
                (h.width = m.width * f),
                (h.height = m.height * f),
                h.updateCachedBounds());
              var l = e < n.length - 1 ? n[e + 1] : null,
                l = null != l ? d.getCellGeometry(l) : null,
                t = null != l && null != l.alternateBounds ? l.alternateBounds : l,
                l =
                  null != p[e]
                    ? new ha(p[e], mxConstants.NONE, 1)
                    : new mxLine(new mxRectangle(), mxConstants.NONE, 1, !0);
              l.isDashed = k.isDashed;
              l.svgStrokeTolerance++;
              h = new mxHandle(h, 'col-resize', null, l);
              h.tableHandle = !0;
              var r = 0;
              h.shape.node.parentNode.insertBefore(h.shape.node, h.shape.node.parentNode.firstChild);
              h.redraw = function () {
                if (null != this.shape) {
                  this.shape.stroke = 0 == r ? mxConstants.NONE : k.stroke;
                  if (this.shape.constructor == ha)
                    (this.shape.line = b(p[e], r, 0)), this.shape.updateBoundsFromLine();
                  else {
                    var a = d.getActualStartSize(g.cell, !0);
                    this.shape.bounds.width = 1;
                    this.shape.bounds.x = this.state.x + (m.width + r) * f;
                    this.shape.bounds.y = g.y + (e == n.length - 1 ? 0 : a.y * f);
                    this.shape.bounds.height = g.height - (e == n.length - 1 ? 0 : (a.height + a.y) * f);
                  }
                  this.shape.redraw();
                }
              };
              var u = !1;
              h.setPosition = function (a, b, c) {
                r = Math.max(Graph.minTableColumnWidth - m.width, b.x - a.x - m.width);
                u = mxEvent.isShiftDown(c.getEvent());
                null == t || u || (r = Math.min(r, t.width - Graph.minTableColumnWidth));
              };
              h.execute = function (a) {
                if (0 != r) d.setTableColumnWidth(this.state.cell, r, u);
                else if (!c.blockDelayedSelection) {
                  var b = d.getCellAt(a.getGraphX(), a.getGraphY()) || g.cell;
                  d.graphHandler.selectCellForEvent(b, a);
                }
                r = 0;
              };
              h.positionChanged = function () {};
              h.reset = function () {
                r = 0;
              };
              a.push(h);
            })(e);
        }
      }
      return null != a ? a.reverse() : null;
    };
    var P = mxVertexHandler.prototype.setHandlesVisible;
    mxVertexHandler.prototype.setHandlesVisible = function (a) {
      P.apply(this, arguments);
      if (null != this.moveHandles)
        for (var b = 0; b < this.moveHandles.length; b++) this.moveHandles[b].style.visibility = a ? '' : 'hidden';
      if (null != this.cornerHandles)
        for (b = 0; b < this.cornerHandles.length; b++) this.cornerHandles[b].node.style.visibility = a ? '' : 'hidden';
    };
    mxVertexHandler.prototype.refreshMoveHandles = function () {
      var a = this.graph.model;
      if (null != this.moveHandles) {
        for (var b = 0; b < this.moveHandles.length; b++)
          this.moveHandles[b].parentNode.removeChild(this.moveHandles[b]);
        this.moveHandles = null;
      }
      this.moveHandles = [];
      for (b = 0; b < a.getChildCount(this.state.cell); b++)
        mxUtils.bind(this, function (b) {
          if (null != b && a.isVertex(b.cell)) {
            var c = mxUtils.createImage(Editor.rowMoveImage);
            c.style.position = 'absolute';
            c.style.cursor = 'pointer';
            c.style.width = '7px';
            c.style.height = '4px';
            c.style.padding = '4px 2px 4px 2px';
            c.rowState = b;
            mxEvent.addGestureListeners(
              c,
              mxUtils.bind(this, function (a) {
                this.graph.popupMenuHandler.hideMenu();
                this.graph.stopEditing(!1);
                (!this.graph.isToggleEvent(a) && this.graph.isCellSelected(b.cell)) ||
                  this.graph.selectCellForEvent(b.cell, a);
                mxEvent.isPopupTrigger(a) ||
                  (this.graph.graphHandler.start(
                    this.state.cell,
                    mxEvent.getClientX(a),
                    mxEvent.getClientY(a),
                    this.graph.getSelectionCells()
                  ),
                  (this.graph.graphHandler.cellWasClicked = !0),
                  (this.graph.isMouseTrigger = mxEvent.isMouseEvent(a)),
                  (this.graph.isMouseDown = !0));
                mxEvent.consume(a);
              }),
              null,
              mxUtils.bind(this, function (a) {
                mxEvent.isPopupTrigger(a) &&
                  (this.graph.popupMenuHandler.popup(mxEvent.getClientX(a), mxEvent.getClientY(a), b.cell, a),
                  mxEvent.consume(a));
              })
            );
            this.moveHandles.push(c);
            this.graph.container.appendChild(c);
          }
        })(this.graph.view.getState(a.getChildAt(this.state.cell, b)));
    };
    mxVertexHandler.prototype.refresh = function () {
      if (null != this.customHandles) {
        for (var a = 0; a < this.customHandles.length; a++) this.customHandles[a].destroy();
        this.customHandles = this.createCustomHandles();
      }
      this.graph.isTable(this.state.cell) && this.refreshMoveHandles();
    };
    var Oa = mxVertexHandler.prototype.getHandlePadding;
    mxVertexHandler.prototype.getHandlePadding = function () {
      var a = new mxPoint(0, 0),
        b = this.tolerance,
        c = this.state.style.shape;
      null == mxCellRenderer.defaultShapes[c] && mxStencilRegistry.getStencil(c);
      c = this.graph.isTable(this.state.cell) || this.graph.cellEditor.getEditingCell() == this.state.cell;
      if (!c && null != this.customHandles)
        for (var d = 0; d < this.customHandles.length; d++)
          if (null != this.customHandles[d].shape && null != this.customHandles[d].shape.bounds) {
            var e = this.customHandles[d].shape.bounds,
              f = e.getCenterX(),
              g = e.getCenterY();
            if (
              Math.abs(this.state.x - f) < e.width / 2 ||
              Math.abs(this.state.y - g) < e.height / 2 ||
              Math.abs(this.state.x + this.state.width - f) < e.width / 2 ||
              Math.abs(this.state.y + this.state.height - g) < e.height / 2
            ) {
              c = !0;
              break;
            }
          }
      c && null != this.sizers && 0 < this.sizers.length && null != this.sizers[0]
        ? ((b /= 2),
          this.graph.isTable(this.state.cell) && (b += 7),
          (a.x = this.sizers[0].bounds.width + b),
          (a.y = this.sizers[0].bounds.height + b))
        : (a = Oa.apply(this, arguments));
      return a;
    };
    mxVertexHandler.prototype.updateHint = function (c) {
      if (this.index != mxEvent.LABEL_HANDLE) {
        null == this.hint && ((this.hint = a()), this.state.view.graph.container.appendChild(this.hint));
        if (this.index == mxEvent.ROTATION_HANDLE) this.hint.innerHTML = this.currentAlpha + '&deg;';
        else {
          c = this.state.view.scale;
          var d = this.state.view.unit;
          this.hint.innerHTML =
            b(this.roundLength(this.bounds.width / c), d) + ' x ' + b(this.roundLength(this.bounds.height / c), d);
        }
        c = mxUtils.getBoundingBox(
          this.bounds,
          null != this.currentAlpha ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || '0'
        );
        null == c && (c = this.bounds);
        this.hint.style.left = c.x + Math.round((c.width - this.hint.clientWidth) / 2) + 'px';
        this.hint.style.top = c.y + c.height + Editor.hintOffset + 'px';
        null != this.linkHint && (this.linkHint.style.display = 'none');
      }
    };
    mxVertexHandler.prototype.removeHint = function () {
      mxGraphHandler.prototype.removeHint.apply(this, arguments);
      null != this.linkHint && (this.linkHint.style.display = '');
    };
    var Da = mxEdgeHandler.prototype.mouseMove;
    mxEdgeHandler.prototype.mouseMove = function (a, b) {
      Da.apply(this, arguments);
      null != this.linkHint &&
        'none' != this.linkHint.style.display &&
        null != this.graph.graphHandler &&
        null != this.graph.graphHandler.first &&
        (this.linkHint.style.display = 'none');
    };
    var Pa = mxEdgeHandler.prototype.mouseUp;
    mxEdgeHandler.prototype.mouseUp = function (a, b) {
      Pa.apply(this, arguments);
      null != this.linkHint && 'none' == this.linkHint.style.display && (this.linkHint.style.display = '');
    };
    mxEdgeHandler.prototype.updateHint = function (c, d) {
      null == this.hint && ((this.hint = a()), this.state.view.graph.container.appendChild(this.hint));
      var e = this.graph.view.translate,
        f = this.graph.view.scale,
        g = this.roundLength(d.x / f - e.x),
        e = this.roundLength(d.y / f - e.y),
        f = this.graph.view.unit;
      this.hint.innerHTML = b(g, f) + ', ' + b(e, f);
      this.hint.style.visibility = 'visible';
      if (this.isSource || this.isTarget)
        null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus
          ? ((g = this.constraintHandler.currentConstraint.point),
            (this.hint.innerHTML = '[' + Math.round(100 * g.x) + '%, ' + Math.round(100 * g.y) + '%]'))
          : this.marker.hasValidState() && (this.hint.style.visibility = 'hidden');
      this.hint.style.left = Math.round(c.getGraphX() - this.hint.clientWidth / 2) + 'px';
      this.hint.style.top = Math.max(c.getGraphY(), d.y) + Editor.hintOffset + 'px';
      null != this.linkHint && (this.linkHint.style.display = 'none');
    };
    Graph.prototype.expandedImage = Graph.createSvgImage(
      9,
      9,
      '<defs><linearGradient id="grad1" x1="50%" y1="0%" x2="50%" y2="100%"><stop offset="30%" style="stop-color:#f0f0f0;" /><stop offset="100%" style="stop-color:#AFB0B6;" /></linearGradient></defs><rect x="0" y="0" width="9" height="9" stroke="#8A94A5" fill="url(#grad1)" stroke-width="2"/><path d="M 2 4.5 L 7 4.5 z" stroke="#000"/>'
    );
    Graph.prototype.collapsedImage = Graph.createSvgImage(
      9,
      9,
      '<defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="30%" style="stop-color:#f0f0f0;" /><stop offset="100%" style="stop-color:#AFB0B6;" /></linearGradient></defs><rect x="0" y="0" width="9" height="9" stroke="#8A94A5" fill="url(#grad1)" stroke-width="2"/><path d="M 4.5 2 L 4.5 7 M 2 4.5 L 7 4.5 z" stroke="#000"/>'
    );
    mxEdgeHandler.prototype.removeHint = mxVertexHandler.prototype.removeHint;
    HoverIcons.prototype.mainHandle = Graph.createSvgImage(
      18,
      18,
      '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>'
    );
    HoverIcons.prototype.endMainHandle = Graph.createSvgImage(
      18,
      18,
      '<circle cx="9" cy="9" r="6" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>'
    );
    HoverIcons.prototype.secondaryHandle = Graph.createSvgImage(
      16,
      16,
      '<path d="m 8 3 L 13 8 L 8 13 L 3 8 z" stroke="#fff" fill="#fca000"/>'
    );
    HoverIcons.prototype.fixedHandle = Graph.createSvgImage(
      22,
      22,
      '<circle cx="11" cy="11" r="6" stroke="#fff" fill="#01bd22"/><path d="m 8 8 L 14 14M 8 14 L 14 8" stroke="#fff"/>'
    );
    HoverIcons.prototype.endFixedHandle = Graph.createSvgImage(
      22,
      22,
      '<circle cx="11" cy="11" r="7" stroke="#fff" fill="#01bd22"/><path d="m 8 8 L 14 14M 8 14 L 14 8" stroke="#fff"/>'
    );
    HoverIcons.prototype.terminalHandle = Graph.createSvgImage(
      22,
      22,
      '<circle cx="11" cy="11" r="6" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/><circle cx="11" cy="11" r="3" stroke="#fff" fill="transparent"/>'
    );
    HoverIcons.prototype.endTerminalHandle = Graph.createSvgImage(
      22,
      22,
      '<circle cx="11" cy="11" r="7" stroke="#fff" fill="' +
        HoverIcons.prototype.arrowFill +
        '"/><circle cx="11" cy="11" r="3" stroke="#fff" fill="transparent"/>'
    );
    HoverIcons.prototype.rotationHandle = Graph.createSvgImage(
      16,
      16,
      '<path stroke="' +
        HoverIcons.prototype.arrowFill +
        '" fill="' +
        HoverIcons.prototype.arrowFill +
        '" d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z"/>',
      24,
      24
    );
    mxConstraintHandler.prototype.pointImage = Graph.createSvgImage(
      5,
      5,
      '<path d="m 0 0 L 5 5 M 0 5 L 5 0" stroke-width="2" style="stroke-opacity:0.4" stroke="#ffffff"/><path d="m 0 0 L 5 5 M 0 5 L 5 0" stroke="' +
        HoverIcons.prototype.arrowFill +
        '"/>'
    );
    mxVertexHandler.TABLE_HANDLE_COLOR = '#fca000';
    mxVertexHandler.prototype.handleImage = HoverIcons.prototype.mainHandle;
    mxVertexHandler.prototype.secondaryHandleImage = HoverIcons.prototype.secondaryHandle;
    mxEdgeHandler.prototype.handleImage = HoverIcons.prototype.mainHandle;
    mxEdgeHandler.prototype.endHandleImage = HoverIcons.prototype.endMainHandle;
    mxEdgeHandler.prototype.terminalHandleImage = HoverIcons.prototype.terminalHandle;
    mxEdgeHandler.prototype.endTerminalHandleImage = HoverIcons.prototype.endTerminalHandle;
    mxEdgeHandler.prototype.fixedHandleImage = HoverIcons.prototype.fixedHandle;
    mxEdgeHandler.prototype.endFixedHandleImage = HoverIcons.prototype.endFixedHandle;
    mxEdgeHandler.prototype.labelHandleImage = HoverIcons.prototype.secondaryHandle;
    mxOutline.prototype.sizerImage = HoverIcons.prototype.mainHandle;
    null != window.Sidebar &&
      ((Sidebar.prototype.triangleUp = HoverIcons.prototype.triangleUp),
      (Sidebar.prototype.triangleRight = HoverIcons.prototype.triangleRight),
      (Sidebar.prototype.triangleDown = HoverIcons.prototype.triangleDown),
      (Sidebar.prototype.triangleLeft = HoverIcons.prototype.triangleLeft),
      (Sidebar.prototype.refreshTarget = HoverIcons.prototype.refreshTarget),
      (Sidebar.prototype.roundDrop = HoverIcons.prototype.roundDrop));
    mxVertexHandler.prototype.rotationEnabled = !0;
    mxVertexHandler.prototype.manageSizers = !0;
    mxVertexHandler.prototype.livePreview = !0;
    mxGraphHandler.prototype.maxLivePreview = 16;
    mxRubberband.prototype.defaultOpacity = 30;
    mxConnectionHandler.prototype.outlineConnect = !0;
    mxCellHighlight.prototype.keepOnTop = !0;
    mxVertexHandler.prototype.parentHighlightEnabled = !0;
    mxEdgeHandler.prototype.parentHighlightEnabled = !0;
    mxEdgeHandler.prototype.dblClickRemoveEnabled = !0;
    mxEdgeHandler.prototype.straightRemoveEnabled = !0;
    mxEdgeHandler.prototype.virtualBendsEnabled = !0;
    mxEdgeHandler.prototype.mergeRemoveEnabled = !0;
    mxEdgeHandler.prototype.manageLabelHandle = !0;
    mxEdgeHandler.prototype.outlineConnect = !0;
    mxEdgeHandler.prototype.isAddVirtualBendEvent = function (a) {
      return !mxEvent.isShiftDown(a.getEvent());
    };
    mxEdgeHandler.prototype.isCustomHandleEvent = function (a) {
      return !mxEvent.isShiftDown(a.getEvent());
    };
    if (Graph.touchStyle) {
      if (mxClient.IS_TOUCH || 0 < navigator.maxTouchPoints || 0 < navigator.msMaxTouchPoints)
        (mxShape.prototype.svgStrokeTolerance = 18),
          (mxVertexHandler.prototype.tolerance = 12),
          (mxEdgeHandler.prototype.tolerance = 12),
          (Graph.prototype.tolerance = 12),
          (mxVertexHandler.prototype.rotationHandleVSpacing = -16),
          (mxConstraintHandler.prototype.getTolerance = function (a) {
            return mxEvent.isMouseEvent(a.getEvent()) ? 4 : this.graph.getTolerance();
          });
      mxPanningHandler.prototype.isPanningTrigger = function (a) {
        var b = a.getEvent();
        return (
          (null == a.getState() && !mxEvent.isMouseEvent(b)) ||
          (mxEvent.isPopupTrigger(b) && (null == a.getState() || mxEvent.isControlDown(b) || mxEvent.isShiftDown(b)))
        );
      };
      var Wa = mxGraphHandler.prototype.mouseDown;
      mxGraphHandler.prototype.mouseDown = function (a, b) {
        Wa.apply(this, arguments);
        mxEvent.isTouchEvent(b.getEvent()) &&
          this.graph.isCellSelected(b.getCell()) &&
          1 < this.graph.getSelectionCount() &&
          (this.delayedSelection = !1);
      };
    } else
      mxPanningHandler.prototype.isPanningTrigger = function (a) {
        var b = a.getEvent();
        return (
          (mxEvent.isLeftMouseButton(b) &&
            ((this.useLeftButtonForPanning && null == a.getState()) ||
              (mxEvent.isControlDown(b) && !mxEvent.isShiftDown(b)))) ||
          (this.usePopupTrigger && mxEvent.isPopupTrigger(b))
        );
      };
    mxRubberband.prototype.isSpaceEvent = function (a) {
      return (
        this.graph.isEnabled() &&
        !this.graph.isCellLocked(this.graph.getDefaultParent()) &&
        (mxEvent.isControlDown(a.getEvent()) || mxEvent.isMetaDown(a.getEvent())) &&
        mxEvent.isShiftDown(a.getEvent()) &&
        mxEvent.isAltDown(a.getEvent())
      );
    };
    mxRubberband.prototype.cancelled = !1;
    mxRubberband.prototype.cancel = function () {
      this.isActive() && ((this.cancelled = !0), this.reset());
    };
    mxRubberband.prototype.mouseUp = function (a, b) {
      if (this.cancelled) (this.cancelled = !1), b.consume();
      else {
        var c = null != this.div && 'none' != this.div.style.display,
          d = null,
          e = null,
          f = null,
          g = null;
        null != this.first &&
          null != this.currentX &&
          null != this.currentY &&
          ((d = this.first.x),
          (e = this.first.y),
          (f = (this.currentX - d) / this.graph.view.scale),
          (g = (this.currentY - e) / this.graph.view.scale),
          mxEvent.isAltDown(b.getEvent()) ||
            ((f = this.graph.snap(f)),
            (g = this.graph.snap(g)),
            this.graph.isGridEnabled() ||
              (Math.abs(f) < this.graph.tolerance && (f = 0), Math.abs(g) < this.graph.tolerance && (g = 0))));
        this.reset();
        if (c) {
          if (this.isSpaceEvent(b)) {
            this.graph.model.beginUpdate();
            try {
              for (
                var k = this.graph.getCellsBeyond(d, e, this.graph.getDefaultParent(), !0, !0), c = 0;
                c < k.length;
                c++
              )
                if (this.graph.isCellMovable(k[c])) {
                  var h = this.graph.view.getState(k[c]),
                    l = this.graph.getCellGeometry(k[c]);
                  null != h && null != l && ((l = l.clone()), l.translate(f, g), this.graph.model.setGeometry(k[c], l));
                }
            } finally {
              this.graph.model.endUpdate();
            }
          } else
            (f = new mxRectangle(this.x, this.y, this.width, this.height)), this.graph.selectRegion(f, b.getEvent());
          b.consume();
        }
      }
    };
    mxRubberband.prototype.mouseMove = function (a, b) {
      if (!b.isConsumed() && null != this.first) {
        var c = mxUtils.getScrollOrigin(this.graph.container),
          d = mxUtils.getOffset(this.graph.container);
        c.x -= d.x;
        c.y -= d.y;
        var d = b.getX() + c.x,
          c = b.getY() + c.y,
          e = this.first.x - d,
          f = this.first.y - c,
          g = this.graph.tolerance;
        if (null != this.div || Math.abs(e) > g || Math.abs(f) > g)
          null == this.div && (this.div = this.createShape()),
            mxUtils.clearSelection(),
            this.update(d, c),
            this.isSpaceEvent(b)
              ? ((d = this.x + this.width),
                (c = this.y + this.height),
                (e = this.graph.view.scale),
                mxEvent.isAltDown(b.getEvent()) ||
                  ((this.width = this.graph.snap(this.width / e) * e),
                  (this.height = this.graph.snap(this.height / e) * e),
                  this.graph.isGridEnabled() ||
                    (this.width < this.graph.tolerance && (this.width = 0),
                    this.height < this.graph.tolerance && (this.height = 0)),
                  this.x < this.first.x && (this.x = d - this.width),
                  this.y < this.first.y && (this.y = c - this.height)),
                (this.div.style.borderStyle = 'dashed'),
                (this.div.style.backgroundColor = 'white'),
                (this.div.style.left = this.x + 'px'),
                (this.div.style.top = this.y + 'px'),
                (this.div.style.width = Math.max(0, this.width) + 'px'),
                (this.div.style.height = this.graph.container.clientHeight + 'px'),
                (this.div.style.borderWidth = 0 >= this.width ? '0px 1px 0px 0px' : '0px 1px 0px 1px'),
                null == this.secondDiv &&
                  ((this.secondDiv = this.div.cloneNode(!0)), this.div.parentNode.appendChild(this.secondDiv)),
                (this.secondDiv.style.left = this.x + 'px'),
                (this.secondDiv.style.top = this.y + 'px'),
                (this.secondDiv.style.width = this.graph.container.clientWidth + 'px'),
                (this.secondDiv.style.height = Math.max(0, this.height) + 'px'),
                (this.secondDiv.style.borderWidth = 0 >= this.height ? '1px 0px 0px 0px' : '1px 0px 1px 0px'))
              : ((this.div.style.backgroundColor = ''),
                (this.div.style.borderWidth = ''),
                (this.div.style.borderStyle = ''),
                null != this.secondDiv &&
                  (this.secondDiv.parentNode.removeChild(this.secondDiv), (this.secondDiv = null))),
            b.consume();
      }
    };
    var Ea = mxRubberband.prototype.reset;
    mxRubberband.prototype.reset = function () {
      null != this.secondDiv && (this.secondDiv.parentNode.removeChild(this.secondDiv), (this.secondDiv = null));
      Ea.apply(this, arguments);
    };
    var qa = new Date().getTime(),
      ia = 0,
      Ka = mxEdgeHandler.prototype.updatePreviewState;
    mxEdgeHandler.prototype.updatePreviewState = function (a, b, c, d) {
      Ka.apply(this, arguments);
      c != this.currentTerminalState ? ((qa = new Date().getTime()), (ia = 0)) : (ia = new Date().getTime() - qa);
      this.currentTerminalState = c;
    };
    var ua = mxEdgeHandler.prototype.isOutlineConnectEvent;
    mxEdgeHandler.prototype.isOutlineConnectEvent = function (a) {
      return mxEvent.isShiftDown(a.getEvent()) && mxEvent.isAltDown(a.getEvent())
        ? !1
        : (null != this.currentTerminalState && a.getState() == this.currentTerminalState && 2e3 < ia) ||
            ((null == this.currentTerminalState ||
              '0' != mxUtils.getValue(this.currentTerminalState.style, 'outlineConnect', '1')) &&
              ua.apply(this, arguments));
    };
    mxEdgeHandler.prototype.createHandleShape = function (a, b, c) {
      b = null != a && 0 == a;
      var d = this.state.getVisibleTerminalState(b);
      a =
        null != a &&
        (0 == a || a >= this.state.absolutePoints.length - 1 || (this.constructor == mxElbowEdgeHandler && 2 == a))
          ? this.graph.getConnectionConstraint(this.state, d, b)
          : null;
      c =
        null != (null != a ? this.graph.getConnectionPoint(this.state.getVisibleTerminalState(b), a) : null)
          ? c
            ? this.endFixedHandleImage
            : this.fixedHandleImage
          : null != a && null != d
          ? c
            ? this.endTerminalHandleImage
            : this.terminalHandleImage
          : c
          ? this.endHandleImage
          : this.handleImage;
      if (null != c)
        return (c = new mxImageShape(new mxRectangle(0, 0, c.width, c.height), c.src)), (c.preserveImageAspect = !1), c;
      c = mxConstants.HANDLE_SIZE;
      this.preferHtml && --c;
      return new mxRectangleShape(
        new mxRectangle(0, 0, c, c),
        mxConstants.HANDLE_FILLCOLOR,
        mxConstants.HANDLE_STROKECOLOR
      );
    };
    var Xa = mxVertexHandler.prototype.createSizerShape;
    mxVertexHandler.prototype.createSizerShape = function (a, b, c) {
      this.handleImage =
        b == mxEvent.ROTATION_HANDLE
          ? HoverIcons.prototype.rotationHandle
          : b == mxEvent.LABEL_HANDLE
          ? this.secondaryHandleImage
          : this.handleImage;
      return Xa.apply(this, arguments);
    };
    var Z = mxGraphHandler.prototype.getBoundingBox;
    mxGraphHandler.prototype.getBoundingBox = function (a) {
      if (null != a && 1 == a.length) {
        var b = this.graph.getModel(),
          c = b.getParent(a[0]),
          d = this.graph.getCellGeometry(a[0]);
        if (
          b.isEdge(c) &&
          null != d &&
          d.relative &&
          ((b = this.graph.view.getState(a[0])),
          null != b && 2 > b.width && 2 > b.height && null != b.text && null != b.text.boundingBox)
        )
          return mxRectangle.fromRectangle(b.text.boundingBox);
      }
      return Z.apply(this, arguments);
    };
    var ea = mxGraphHandler.prototype.getGuideStates;
    mxGraphHandler.prototype.getGuideStates = function () {
      for (var a = ea.apply(this, arguments), b = [], c = 0; c < a.length; c++)
        '1' != mxUtils.getValue(a[c].style, 'part', '0') && b.push(a[c]);
      return b;
    };
    var L = mxVertexHandler.prototype.getSelectionBounds;
    mxVertexHandler.prototype.getSelectionBounds = function (a) {
      var b = this.graph.getModel(),
        c = b.getParent(a.cell),
        d = this.graph.getCellGeometry(a.cell);
      return b.isEdge(c) &&
        null != d &&
        d.relative &&
        2 > a.width &&
        2 > a.height &&
        null != a.text &&
        null != a.text.boundingBox
        ? ((b = a.text.unrotatedBoundingBox || a.text.boundingBox),
          new mxRectangle(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)))
        : L.apply(this, arguments);
    };
    var db = mxVertexHandler.prototype.mouseDown;
    mxVertexHandler.prototype.mouseDown = function (a, b) {
      var c = this.graph.getModel(),
        d = c.getParent(this.state.cell),
        e = this.graph.getCellGeometry(this.state.cell);
      (this.getHandleForEvent(b) == mxEvent.ROTATION_HANDLE ||
        !c.isEdge(d) ||
        null == e ||
        !e.relative ||
        null == this.state ||
        2 <= this.state.width ||
        2 <= this.state.height) &&
        db.apply(this, arguments);
    };
    mxVertexHandler.prototype.rotateClick = function () {
      var a = mxUtils.getValue(this.state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE),
        b = mxUtils.getValue(this.state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
      this.state.view.graph.model.isVertex(this.state.cell) && a == mxConstants.NONE && b == mxConstants.NONE
        ? ((a = mxUtils.mod(mxUtils.getValue(this.state.style, mxConstants.STYLE_ROTATION, 0) + 90, 360)),
          this.state.view.graph.setCellStyles(mxConstants.STYLE_ROTATION, a, [this.state.cell]))
        : this.state.view.graph.turnShapes([this.state.cell]);
    };
    var sa = mxVertexHandler.prototype.mouseMove;
    mxVertexHandler.prototype.mouseMove = function (a, b) {
      sa.apply(this, arguments);
      null != this.graph.graphHandler.first &&
        (null != this.rotationShape &&
          null != this.rotationShape.node &&
          (this.rotationShape.node.style.display = 'none'),
        null != this.linkHint && 'none' != this.linkHint.style.display && (this.linkHint.style.display = 'none'));
    };
    var eb = mxVertexHandler.prototype.mouseUp;
    mxVertexHandler.prototype.mouseUp = function (a, b) {
      eb.apply(this, arguments);
      null != this.rotationShape &&
        null != this.rotationShape.node &&
        (this.rotationShape.node.style.display = 1 == this.graph.getSelectionCount() ? '' : 'none');
      null != this.linkHint && 'none' == this.linkHint.style.display && (this.linkHint.style.display = '');
      this.blockDelayedSelection = null;
    };
    var ta = mxVertexHandler.prototype.init;
    mxVertexHandler.prototype.init = function () {
      ta.apply(this, arguments);
      var a = !1;
      null != this.rotationShape && this.rotationShape.node.setAttribute('title', mxResources.get('rotateTooltip'));
      if (this.graph.isTable(this.state.cell)) this.refreshMoveHandles();
      else if (
        1 == this.graph.getSelectionCount() &&
        (this.graph.isTableCell(this.state.cell) || this.graph.isTableRow(this.state.cell))
      ) {
        this.cornerHandles = [];
        for (var b = 0; 4 > b; b++) {
          var c = new mxRectangleShape(new mxRectangle(0, 0, 6, 6), '#ffffff', mxConstants.HANDLE_STROKECOLOR);
          c.dialect = mxConstants.DIALECT_SVG;
          c.init(this.graph.view.getOverlayPane());
          this.cornerHandles.push(c);
        }
      }
      var d = mxUtils.bind(this, function () {
        null != this.specialHandle &&
          (this.specialHandle.node.style.display =
            this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? '' : 'none');
        this.redrawHandles();
      });
      this.changeHandler = mxUtils.bind(this, function (a, b) {
        this.updateLinkHint(this.graph.getLinkForCell(this.state.cell), this.graph.getLinksForState(this.state));
        d();
      });
      this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.changeHandler);
      this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
      this.editingHandler = mxUtils.bind(this, function (a, b) {
        this.redrawHandles();
      });
      this.graph.addListener(mxEvent.EDITING_STOPPED, this.editingHandler);
      b = this.graph.getLinkForCell(this.state.cell);
      c = this.graph.getLinksForState(this.state);
      this.updateLinkHint(b, c);
      if (null != b || (null != c && 0 < c.length)) a = !0;
      a && this.redrawHandles();
    };
    mxVertexHandler.prototype.updateLinkHint = function (b, c) {
      try {
        if ((null == b && (null == c || 0 == c.length)) || 1 < this.graph.getSelectionCount())
          null != this.linkHint && (this.linkHint.parentNode.removeChild(this.linkHint), (this.linkHint = null));
        else if (null != b || (null != c && 0 < c.length)) {
          null == this.linkHint &&
            ((this.linkHint = a()),
            (this.linkHint.style.padding = '6px 8px 6px 8px'),
            (this.linkHint.style.opacity = '1'),
            (this.linkHint.style.filter = ''),
            this.graph.container.appendChild(this.linkHint),
            mxEvent.addListener(
              this.linkHint,
              'mouseenter',
              mxUtils.bind(this, function () {
                this.graph.tooltipHandler.hide();
              })
            ));
          this.linkHint.innerHTML = '';
          if (
            null != b &&
            (this.linkHint.appendChild(this.graph.createLinkForHint(b)),
            this.graph.isEnabled() && 'function' === typeof this.graph.editLink)
          ) {
            var d = document.createElement('img');
            d.setAttribute('src', Editor.editImage);
            d.setAttribute('title', mxResources.get('editLink'));
            d.setAttribute('width', '11');
            d.setAttribute('height', '11');
            d.style.marginLeft = '10px';
            d.style.marginBottom = '-1px';
            d.style.cursor = 'pointer';
            this.linkHint.appendChild(d);
            mxEvent.addListener(
              d,
              'click',
              mxUtils.bind(this, function (a) {
                this.graph.setSelectionCell(this.state.cell);
                this.graph.editLink();
                mxEvent.consume(a);
              })
            );
            this.linkHint.appendChild(
              Graph.createRemoveIcon(
                mxResources.get('removeIt', [mxResources.get('link')]),
                mxUtils.bind(this, function (a) {
                  this.graph.setLinkForCell(this.state.cell, null);
                  mxEvent.consume(a);
                })
              )
            );
          }
          if (null != c)
            for (d = 0; d < c.length; d++) {
              var e = document.createElement('div');
              e.style.marginTop = null != b || 0 < d ? '6px' : '0px';
              e.appendChild(this.graph.createLinkForHint(c[d].getAttribute('href'), mxUtils.getTextContent(c[d])));
              this.linkHint.appendChild(e);
            }
        }
      } catch (V) {}
    };
    mxEdgeHandler.prototype.updateLinkHint = mxVertexHandler.prototype.updateLinkHint;
    var Fa = mxEdgeHandler.prototype.init;
    mxEdgeHandler.prototype.init = function () {
      Fa.apply(this, arguments);
      this.constraintHandler.isEnabled = mxUtils.bind(this, function () {
        return this.state.view.graph.connectionHandler.isEnabled();
      });
      var a = mxUtils.bind(this, function () {
        null != this.linkHint && (this.linkHint.style.display = 1 == this.graph.getSelectionCount() ? '' : 'none');
        null != this.labelShape &&
          (this.labelShape.node.style.display =
            this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? '' : 'none');
      });
      this.changeHandler = mxUtils.bind(this, function (b, c) {
        this.updateLinkHint(this.graph.getLinkForCell(this.state.cell), this.graph.getLinksForState(this.state));
        a();
        this.redrawHandles();
      });
      this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.changeHandler);
      this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
      var b = this.graph.getLinkForCell(this.state.cell),
        c = this.graph.getLinksForState(this.state);
      if (null != b || (null != c && 0 < c.length)) this.updateLinkHint(b, c), this.redrawHandles();
    };
    var La = mxConnectionHandler.prototype.init;
    mxConnectionHandler.prototype.init = function () {
      La.apply(this, arguments);
      this.constraintHandler.isEnabled = mxUtils.bind(this, function () {
        return this.graph.connectionHandler.isEnabled();
      });
    };
    var la = mxVertexHandler.prototype.redrawHandles;
    mxVertexHandler.prototype.redrawHandles = function () {
      if (null != this.moveHandles)
        for (var a = 0; a < this.moveHandles.length; a++)
          (this.moveHandles[a].style.left =
            this.moveHandles[a].rowState.x + this.moveHandles[a].rowState.width - 5 + 'px'),
            (this.moveHandles[a].style.top =
              this.moveHandles[a].rowState.y + this.moveHandles[a].rowState.height / 2 - 6 + 'px');
      if (null != this.cornerHandles) {
        var a = this.getSelectionBorderInset(),
          b = this.cornerHandles,
          c = b[0].bounds.height / 2;
        b[0].bounds.x = this.state.x - b[0].bounds.width / 2 + a;
        b[0].bounds.y = this.state.y - c + a;
        b[0].redraw();
        b[1].bounds.x = b[0].bounds.x + this.state.width - 2 * a;
        b[1].bounds.y = b[0].bounds.y;
        b[1].redraw();
        b[2].bounds.x = b[0].bounds.x;
        b[2].bounds.y = this.state.y + this.state.height - 2 * a;
        b[2].redraw();
        b[3].bounds.x = b[1].bounds.x;
        b[3].bounds.y = b[2].bounds.y;
        b[3].redraw();
        for (a = 0; a < this.cornerHandles.length; a++)
          this.cornerHandles[a].node.style.display = 1 == this.graph.getSelectionCount() ? '' : 'none';
      }
      null != this.rotationShape &&
        null != this.rotationShape.node &&
        (this.rotationShape.node.style.display =
          null != this.moveHandles ||
          1 != this.graph.getSelectionCount() ||
          (null != this.index && this.index != mxEvent.ROTATION_HANDLE)
            ? 'none'
            : '');
      la.apply(this);
      null != this.state &&
        null != this.linkHint &&
        ((a = new mxPoint(this.state.getCenterX(), this.state.getCenterY())),
        (b = new mxRectangle(this.state.x, this.state.y - 22, this.state.width + 24, this.state.height + 22)),
        (c = mxUtils.getBoundingBox(b, this.state.style[mxConstants.STYLE_ROTATION] || '0', a)),
        (a =
          null != c
            ? mxUtils.getBoundingBox(this.state, this.state.style[mxConstants.STYLE_ROTATION] || '0')
            : this.state),
        (b = null != this.state.text ? this.state.text.boundingBox : null),
        null == c && (c = this.state),
        (c = c.y + c.height),
        null != b && (c = Math.max(c, b.y + b.height)),
        (this.linkHint.style.left = Math.max(0, Math.round(a.x + (a.width - this.linkHint.clientWidth) / 2)) + 'px'),
        (this.linkHint.style.top = Math.round(c + this.verticalOffset / 2 + Editor.hintOffset) + 'px'));
    };
    var Ca = mxVertexHandler.prototype.destroy;
    mxVertexHandler.prototype.destroy = function () {
      Ca.apply(this, arguments);
      if (null != this.moveHandles) {
        for (var a = 0; a < this.moveHandles.length; a++)
          null != this.moveHandles[a] &&
            null != this.moveHandles[a].parentNode &&
            this.moveHandles[a].parentNode.removeChild(this.moveHandles[a]);
        this.moveHandles = null;
      }
      if (null != this.cornerHandles) {
        for (a = 0; a < this.cornerHandles.length; a++)
          null != this.cornerHandles[a] &&
            null != this.cornerHandles[a].node &&
            null != this.cornerHandles[a].node.parentNode &&
            this.cornerHandles[a].node.parentNode.removeChild(this.cornerHandles[a].node);
        this.cornerHandles = null;
      }
      null != this.linkHint &&
        (null != this.linkHint.parentNode && this.linkHint.parentNode.removeChild(this.linkHint),
        (this.linkHint = null));
      null != this.changeHandler &&
        (this.graph.getSelectionModel().removeListener(this.changeHandler),
        this.graph.getModel().removeListener(this.changeHandler),
        (this.changeHandler = null));
      null != this.editingHandler && (this.graph.removeListener(this.editingHandler), (this.editingHandler = null));
    };
    var pa = mxEdgeHandler.prototype.redrawHandles;
    mxEdgeHandler.prototype.redrawHandles = function () {
      if (null != this.marker && (pa.apply(this), null != this.state && null != this.linkHint)) {
        var a = this.state;
        null != this.state.text &&
          null != this.state.text.bounds &&
          ((a = new mxRectangle(a.x, a.y, a.width, a.height)), a.add(this.state.text.bounds));
        this.linkHint.style.left = Math.max(0, Math.round(a.x + (a.width - this.linkHint.clientWidth) / 2)) + 'px';
        this.linkHint.style.top = Math.round(a.y + a.height + Editor.hintOffset) + 'px';
      }
    };
    var Ja = mxEdgeHandler.prototype.reset;
    mxEdgeHandler.prototype.reset = function () {
      Ja.apply(this, arguments);
      null != this.linkHint && (this.linkHint.style.visibility = '');
    };
    var ba = mxEdgeHandler.prototype.destroy;
    mxEdgeHandler.prototype.destroy = function () {
      ba.apply(this, arguments);
      null != this.linkHint && (this.linkHint.parentNode.removeChild(this.linkHint), (this.linkHint = null));
      null != this.changeHandler &&
        (this.graph.getModel().removeListener(this.changeHandler),
        this.graph.getSelectionModel().removeListener(this.changeHandler),
        (this.changeHandler = null));
    };
  })();
(function () {
  function a(a, b, c) {
    mxShape.call(this);
    this.line = a;
    this.stroke = b;
    this.strokewidth = null != c ? c : 1;
    this.updateBoundsFromLine();
  }
  function b() {
    mxSwimlane.call(this);
  }
  function c() {
    mxSwimlane.call(this);
  }
  function d() {
    mxCylinder.call(this);
  }
  function e() {
    mxCylinder.call(this);
  }
  function f() {
    mxActor.call(this);
  }
  function g() {
    mxCylinder.call(this);
  }
  function k() {
    mxCylinder.call(this);
  }
  function h() {
    mxCylinder.call(this);
  }
  function l() {
    mxCylinder.call(this);
  }
  function m() {
    mxShape.call(this);
  }
  function n() {
    mxShape.call(this);
  }
  function p(a, b, c, d) {
    mxShape.call(this);
    this.bounds = a;
    this.fill = b;
    this.stroke = c;
    this.strokewidth = null != d ? d : 1;
  }
  function r() {
    mxActor.call(this);
  }
  function t() {
    mxCylinder.call(this);
  }
  function u() {
    mxCylinder.call(this);
  }
  function x() {
    mxActor.call(this);
  }
  function z() {
    mxActor.call(this);
  }
  function D() {
    mxActor.call(this);
  }
  function B() {
    mxActor.call(this);
  }
  function C() {
    mxActor.call(this);
  }
  function J() {
    mxActor.call(this);
  }
  function v() {
    mxActor.call(this);
  }
  function K(a, b) {
    this.canvas = a;
    this.canvas.setLineJoin('round');
    this.canvas.setLineCap('round');
    this.defaultVariation = b;
    this.originalLineTo = this.canvas.lineTo;
    this.canvas.lineTo = mxUtils.bind(this, K.prototype.lineTo);
    this.originalMoveTo = this.canvas.moveTo;
    this.canvas.moveTo = mxUtils.bind(this, K.prototype.moveTo);
    this.originalClose = this.canvas.close;
    this.canvas.close = mxUtils.bind(this, K.prototype.close);
    this.originalQuadTo = this.canvas.quadTo;
    this.canvas.quadTo = mxUtils.bind(this, K.prototype.quadTo);
    this.originalCurveTo = this.canvas.curveTo;
    this.canvas.curveTo = mxUtils.bind(this, K.prototype.curveTo);
    this.originalArcTo = this.canvas.arcTo;
    this.canvas.arcTo = mxUtils.bind(this, K.prototype.arcTo);
  }
  function O() {
    mxRectangleShape.call(this);
  }
  function T() {
    mxRectangleShape.call(this);
  }
  function M() {
    mxActor.call(this);
  }
  function U() {
    mxActor.call(this);
  }
  function da() {
    mxActor.call(this);
  }
  function ha() {
    mxRectangleShape.call(this);
  }
  function Y() {
    mxRectangleShape.call(this);
  }
  function P() {
    mxCylinder.call(this);
  }
  function Oa() {
    mxShape.call(this);
  }
  function Da() {
    mxShape.call(this);
  }
  function Pa() {
    mxEllipse.call(this);
  }
  function Wa() {
    mxShape.call(this);
  }
  function Ea() {
    mxShape.call(this);
  }
  function qa() {
    mxRectangleShape.call(this);
  }
  function ia() {
    mxShape.call(this);
  }
  function Ka() {
    mxShape.call(this);
  }
  function ua() {
    mxShape.call(this);
  }
  function Xa() {
    mxShape.call(this);
  }
  function Z() {
    mxShape.call(this);
  }
  function ea() {
    mxCylinder.call(this);
  }
  function L() {
    mxCylinder.call(this);
  }
  function db() {
    mxRectangleShape.call(this);
  }
  function sa() {
    mxDoubleEllipse.call(this);
  }
  function eb() {
    mxDoubleEllipse.call(this);
  }
  function ta() {
    mxArrowConnector.call(this);
    this.spacing = 0;
  }
  function Fa() {
    mxArrowConnector.call(this);
    this.spacing = 0;
  }
  function La() {
    mxActor.call(this);
  }
  function la() {
    mxRectangleShape.call(this);
  }
  function Ca() {
    mxActor.call(this);
  }
  function pa() {
    mxActor.call(this);
  }
  function Ja() {
    mxActor.call(this);
  }
  function ba() {
    mxActor.call(this);
  }
  function E() {
    mxActor.call(this);
  }
  function I() {
    mxActor.call(this);
  }
  function F() {
    mxActor.call(this);
  }
  function N() {
    mxActor.call(this);
  }
  function V() {
    mxActor.call(this);
  }
  function Q() {
    mxActor.call(this);
  }
  function X() {
    mxEllipse.call(this);
  }
  function ja() {
    mxEllipse.call(this);
  }
  function Qa() {
    mxEllipse.call(this);
  }
  function Ga() {
    mxRhombus.call(this);
  }
  function Ra() {
    mxEllipse.call(this);
  }
  function Sa() {
    mxEllipse.call(this);
  }
  function ya() {
    mxEllipse.call(this);
  }
  function Ma() {
    mxEllipse.call(this);
  }
  function fa() {
    mxActor.call(this);
  }
  function S() {
    mxActor.call(this);
  }
  function ma() {
    mxActor.call(this);
  }
  function R(a, b, c, d) {
    mxShape.call(this);
    this.bounds = a;
    this.fill = b;
    this.stroke = c;
    this.strokewidth = null != d ? d : 1;
    this.rectStyle = 'square';
    this.size = 10;
    this.absoluteCornerSize = !0;
    this.indent = 2;
    this.rectOutline = 'single';
  }
  function ra() {
    mxConnector.call(this);
  }
  function ib(a, b, c, d, e, f, g, k, h, l) {
    g += h;
    var q = d.clone();
    d.x -= e * (2 * g + h);
    d.y -= f * (2 * g + h);
    e *= g + h;
    f *= g + h;
    return function () {
      a.ellipse(q.x - e - g, q.y - f - g, 2 * g, 2 * g);
      l ? a.fillAndStroke() : a.stroke();
    };
  }
  mxUtils.extend(a, mxShape);
  a.prototype.updateBoundsFromLine = function () {
    var a = null;
    if (null != this.line)
      for (var b = 0; b < this.line.length; b++) {
        var c = this.line[b];
        null != c &&
          ((c = new mxRectangle(c.x, c.y, this.strokewidth, this.strokewidth)), null == a ? (a = c) : a.add(c));
      }
    this.bounds = null != a ? a : new mxRectangle();
  };
  a.prototype.paintVertexShape = function (a, b, c, d, e) {
    this.paintTableLine(a, this.line, 0, 0);
  };
  a.prototype.paintTableLine = function (a, b, c, d) {
    if (null != b) {
      var e = null;
      a.begin();
      for (var f = 0; f < b.length; f++) {
        var g = b[f];
        null != g && (null == e ? a.moveTo(g.x + c, g.y + d) : null != e && a.lineTo(g.x + c, g.y + d));
        e = g;
      }
      a.end();
      a.stroke();
    }
  };
  a.prototype.intersectsRectangle = function (a) {
    var b = !1;
    if (mxShape.prototype.intersectsRectangle.apply(this, arguments) && null != this.line)
      for (var c = null, d = 0; d < this.line.length && !b; d++) {
        var e = this.line[d];
        null != e && null != c && (b = mxUtils.rectangleIntersectsSegment(a, c, e));
        c = e;
      }
    return b;
  };
  mxCellRenderer.registerShape('tableLine', a);
  mxUtils.extend(b, mxSwimlane);
  b.prototype.getLabelBounds = function (a) {
    return 0 == this.getTitleSize()
      ? mxShape.prototype.getLabelBounds.apply(this, arguments)
      : mxSwimlane.prototype.getLabelBounds.apply(this, arguments);
  };
  b.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = null != this.state ? this.state.view.graph.isCellCollapsed(this.state.cell) : !1,
      g = this.isHorizontal(),
      q = this.getTitleSize();
    0 == q || this.outline
      ? ya.prototype.paintVertexShape.apply(this, arguments)
      : (mxSwimlane.prototype.paintVertexShape.apply(this, arguments), a.translate(-b, -c));
    f || this.outline || !((g && q < e) || (!g && q < d)) || this.paintForeground(a, b, c, d, e);
  };
  b.prototype.paintForeground = function (a, b, c, d, e) {
    if (null != this.state) {
      var f = this.flipH,
        g = this.flipV;
      if (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)
        var q = f,
          f = g,
          g = q;
      a.rotate(-this.getShapeRotation(), f, g, b + d / 2, c + e / 2);
      s = this.scale;
      b = this.bounds.x / s;
      c = this.bounds.y / s;
      d = this.bounds.width / s;
      e = this.bounds.height / s;
      this.paintTableForeground(a, b, c, d, e);
    }
  };
  b.prototype.paintTableForeground = function (b, c, d, e, f) {
    e = this.state.view.graph.getTableLines(
      this.state.cell,
      '0' != mxUtils.getValue(this.state.style, 'rowLines', '1'),
      '0' != mxUtils.getValue(this.state.style, 'columnLines', '1')
    );
    for (f = 0; f < e.length; f++) a.prototype.paintTableLine(b, e[f], c, d);
  };
  b.prototype.configurePointerEvents = function (a) {
    0 == this.getTitleSize()
      ? (a.pointerEvents = !1)
      : mxSwimlane.prototype.configurePointerEvents.apply(this, arguments);
  };
  mxCellRenderer.registerShape('table', b);
  mxUtils.extend(c, b);
  c.prototype.paintForeground = function () {};
  mxCellRenderer.registerShape('tableRow', c);
  mxUtils.extend(d, mxCylinder);
  d.prototype.size = 20;
  d.prototype.darkOpacity = 0;
  d.prototype.darkOpacity2 = 0;
  d.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(d, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))))),
      g = Math.max(-1, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'darkOpacity', this.darkOpacity)))),
      q = Math.max(-1, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'darkOpacity2', this.darkOpacity2))));
    a.translate(b, c);
    a.begin();
    a.moveTo(0, 0);
    a.lineTo(d - f, 0);
    a.lineTo(d, f);
    a.lineTo(d, e);
    a.lineTo(f, e);
    a.lineTo(0, e - f);
    a.lineTo(0, 0);
    a.close();
    a.end();
    a.fillAndStroke();
    this.outline ||
      (a.setShadow(!1),
      0 != g &&
        (a.setFillAlpha(Math.abs(g)),
        a.setFillColor(0 > g ? '#FFFFFF' : '#000000'),
        a.begin(),
        a.moveTo(0, 0),
        a.lineTo(d - f, 0),
        a.lineTo(d, f),
        a.lineTo(f, f),
        a.close(),
        a.fill()),
      0 != q &&
        (a.setFillAlpha(Math.abs(q)),
        a.setFillColor(0 > q ? '#FFFFFF' : '#000000'),
        a.begin(),
        a.moveTo(0, 0),
        a.lineTo(f, f),
        a.lineTo(f, e),
        a.lineTo(0, e - f),
        a.close(),
        a.fill()),
      a.begin(),
      a.moveTo(f, e),
      a.lineTo(f, f),
      a.lineTo(0, 0),
      a.moveTo(f, f),
      a.lineTo(d, f),
      a.end(),
      a.stroke());
  };
  d.prototype.getLabelMargins = function (a) {
    return mxUtils.getValue(this.style, 'boundedLbl', !1)
      ? ((a = parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * this.scale), new mxRectangle(a, a, 0, 0))
      : null;
  };
  mxCellRenderer.registerShape('cube', d);
  var Ta = Math.tan(mxUtils.toRadians(30)),
    za = (0.5 - Ta) / 2;
  mxCellRenderer.registerShape('isoRectangle', f);
  mxUtils.extend(e, mxCylinder);
  e.prototype.size = 6;
  e.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.setFillColor(this.stroke);
    var f = Math.max(0, parseFloat(mxUtils.getValue(this.style, 'size', this.size)) - 2) + 2 * this.strokewidth;
    a.ellipse(b + 0.5 * (d - f), c + 0.5 * (e - f), f, f);
    a.fill();
    a.setFillColor(mxConstants.NONE);
    a.rect(b, c, d, e);
    a.fill();
  };
  mxCellRenderer.registerShape('waypoint', e);
  mxUtils.extend(f, mxActor);
  f.prototype.size = 20;
  f.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(d, e / Ta);
    a.translate((d - b) / 2, (e - b) / 2 + b / 4);
    a.moveTo(0, 0.25 * b);
    a.lineTo(0.5 * b, b * za);
    a.lineTo(b, 0.25 * b);
    a.lineTo(0.5 * b, (0.5 - za) * b);
    a.lineTo(0, 0.25 * b);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('isoRectangle', f);
  mxUtils.extend(g, mxCylinder);
  g.prototype.size = 20;
  g.prototype.redrawPath = function (a, b, c, d, e, f) {
    b = Math.min(d, e / (0.5 + Ta));
    f
      ? (a.moveTo(0, 0.25 * b),
        a.lineTo(0.5 * b, (0.5 - za) * b),
        a.lineTo(b, 0.25 * b),
        a.moveTo(0.5 * b, (0.5 - za) * b),
        a.lineTo(0.5 * b, (1 - za) * b))
      : (a.translate((d - b) / 2, (e - b) / 2),
        a.moveTo(0, 0.25 * b),
        a.lineTo(0.5 * b, b * za),
        a.lineTo(b, 0.25 * b),
        a.lineTo(b, 0.75 * b),
        a.lineTo(0.5 * b, (1 - za) * b),
        a.lineTo(0, 0.75 * b),
        a.close());
    a.end();
  };
  mxCellRenderer.registerShape('isoCube', g);
  mxUtils.extend(k, mxCylinder);
  k.prototype.redrawPath = function (a, b, c, d, e, f) {
    b = Math.min(e / 2, Math.round(e / 8) + this.strokewidth - 1);
    if ((f && null != this.fill) || (!f && null == this.fill))
      a.moveTo(0, b),
        a.curveTo(0, 2 * b, d, 2 * b, d, b),
        f || (a.stroke(), a.begin()),
        a.translate(0, b / 2),
        a.moveTo(0, b),
        a.curveTo(0, 2 * b, d, 2 * b, d, b),
        f || (a.stroke(), a.begin()),
        a.translate(0, b / 2),
        a.moveTo(0, b),
        a.curveTo(0, 2 * b, d, 2 * b, d, b),
        f || (a.stroke(), a.begin()),
        a.translate(0, -b);
    f ||
      (a.moveTo(0, b),
      a.curveTo(0, -b / 3, d, -b / 3, d, b),
      a.lineTo(d, e - b),
      a.curveTo(d, e + b / 3, 0, e + b / 3, 0, e - b),
      a.close());
  };
  k.prototype.getLabelMargins = function (a) {
    return new mxRectangle(0, 2.5 * Math.min(a.height / 2, Math.round(a.height / 8) + this.strokewidth - 1), 0, 0);
  };
  mxCellRenderer.registerShape('datastore', k);
  mxUtils.extend(h, mxCylinder);
  h.prototype.size = 30;
  h.prototype.darkOpacity = 0;
  h.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(d, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))))),
      g = Math.max(-1, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'darkOpacity', this.darkOpacity))));
    a.translate(b, c);
    a.begin();
    a.moveTo(0, 0);
    a.lineTo(d - f, 0);
    a.lineTo(d, f);
    a.lineTo(d, e);
    a.lineTo(0, e);
    a.lineTo(0, 0);
    a.close();
    a.end();
    a.fillAndStroke();
    this.outline ||
      (a.setShadow(!1),
      0 != g &&
        (a.setFillAlpha(Math.abs(g)),
        a.setFillColor(0 > g ? '#FFFFFF' : '#000000'),
        a.begin(),
        a.moveTo(d - f, 0),
        a.lineTo(d - f, f),
        a.lineTo(d, f),
        a.close(),
        a.fill()),
      a.begin(),
      a.moveTo(d - f, 0),
      a.lineTo(d - f, f),
      a.lineTo(d, f),
      a.end(),
      a.stroke());
  };
  mxCellRenderer.registerShape('note', h);
  mxUtils.extend(l, h);
  mxCellRenderer.registerShape('note2', l);
  l.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'size', 15);
      return new mxRectangle(0, Math.min(a.height * this.scale, b * this.scale), 0, 0);
    }
    return null;
  };
  mxUtils.extend(m, mxShape);
  m.prototype.isoAngle = 15;
  m.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f =
        (Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI) /
        200,
      f = Math.min(d * Math.tan(f), 0.5 * e);
    a.translate(b, c);
    a.begin();
    a.moveTo(0.5 * d, 0);
    a.lineTo(d, f);
    a.lineTo(d, e - f);
    a.lineTo(0.5 * d, e);
    a.lineTo(0, e - f);
    a.lineTo(0, f);
    a.close();
    a.fillAndStroke();
    a.setShadow(!1);
    a.begin();
    a.moveTo(0, f);
    a.lineTo(0.5 * d, 2 * f);
    a.lineTo(d, f);
    a.moveTo(0.5 * d, 2 * f);
    a.lineTo(0.5 * d, e);
    a.stroke();
  };
  mxCellRenderer.registerShape('isoCube2', m);
  mxUtils.extend(n, mxShape);
  n.prototype.size = 15;
  n.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(0.5 * e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    a.translate(b, c);
    0 == f
      ? (a.rect(0, 0, d, e), a.fillAndStroke())
      : (a.begin(),
        a.moveTo(0, f),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, 0),
        a.arcTo(0.5 * d, f, 0, 0, 1, d, f),
        a.lineTo(d, e - f),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, e),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0, e - f),
        a.close(),
        a.fillAndStroke(),
        a.setShadow(!1),
        a.begin(),
        a.moveTo(d, f),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, 2 * f),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0, f),
        a.stroke());
  };
  mxCellRenderer.registerShape('cylinder2', n);
  mxUtils.extend(p, mxCylinder);
  p.prototype.size = 15;
  p.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(0.5 * e, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))),
      g = mxUtils.getValue(this.style, 'lid', !0);
    a.translate(b, c);
    0 == f
      ? (a.rect(0, 0, d, e), a.fillAndStroke())
      : (a.begin(),
        g
          ? (a.moveTo(0, f), a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, 0), a.arcTo(0.5 * d, f, 0, 0, 1, d, f))
          : (a.moveTo(0, 0), a.arcTo(0.5 * d, f, 0, 0, 0, 0.5 * d, f), a.arcTo(0.5 * d, f, 0, 0, 0, d, 0)),
        a.lineTo(d, e - f),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, e),
        a.arcTo(0.5 * d, f, 0, 0, 1, 0, e - f),
        a.close(),
        a.fillAndStroke(),
        a.setShadow(!1),
        g &&
          (a.begin(),
          a.moveTo(d, f),
          a.arcTo(0.5 * d, f, 0, 0, 1, 0.5 * d, 2 * f),
          a.arcTo(0.5 * d, f, 0, 0, 1, 0, f),
          a.stroke()));
  };
  mxCellRenderer.registerShape('cylinder3', p);
  mxUtils.extend(r, mxActor);
  r.prototype.redrawPath = function (a, b, c, d, e) {
    a.moveTo(0, 0);
    a.quadTo(d / 2, 0.5 * e, d, 0);
    a.quadTo(0.5 * d, e / 2, d, e);
    a.quadTo(d / 2, 0.5 * e, 0, e);
    a.quadTo(0.5 * d, e / 2, 0, 0);
    a.end();
  };
  mxCellRenderer.registerShape('switch', r);
  mxUtils.extend(t, mxCylinder);
  t.prototype.tabWidth = 60;
  t.prototype.tabHeight = 20;
  t.prototype.tabPosition = 'right';
  t.prototype.arcSize = 0.1;
  t.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.translate(b, c);
    b = Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'tabWidth', this.tabWidth))));
    c = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'tabHeight', this.tabHeight))));
    var f = mxUtils.getValue(this.style, 'tabPosition', this.tabPosition),
      g = mxUtils.getValue(this.style, 'rounded', !1),
      q = mxUtils.getValue(this.style, 'absoluteArcSize', !1),
      k = parseFloat(mxUtils.getValue(this.style, 'arcSize', this.arcSize));
    q || (k *= Math.min(d, e));
    k = Math.min(k, 0.5 * d, 0.5 * (e - c));
    b = Math.max(b, k);
    b = Math.min(d - k, b);
    g || (k = 0);
    a.begin();
    'left' == f
      ? (a.moveTo(Math.max(k, 0), c), a.lineTo(Math.max(k, 0), 0), a.lineTo(b, 0), a.lineTo(b, c))
      : (a.moveTo(d - b, c), a.lineTo(d - b, 0), a.lineTo(d - Math.max(k, 0), 0), a.lineTo(d - Math.max(k, 0), c));
    g
      ? (a.moveTo(0, k + c),
        a.arcTo(k, k, 0, 0, 1, k, c),
        a.lineTo(d - k, c),
        a.arcTo(k, k, 0, 0, 1, d, k + c),
        a.lineTo(d, e - k),
        a.arcTo(k, k, 0, 0, 1, d - k, e),
        a.lineTo(k, e),
        a.arcTo(k, k, 0, 0, 1, 0, e - k))
      : (a.moveTo(0, c), a.lineTo(d, c), a.lineTo(d, e), a.lineTo(0, e));
    a.close();
    a.fillAndStroke();
    a.setShadow(!1);
    'triangle' == mxUtils.getValue(this.style, 'folderSymbol', null) &&
      (a.begin(), a.moveTo(d - 30, c + 20), a.lineTo(d - 20, c + 10), a.lineTo(d - 10, c + 20), a.close(), a.stroke());
  };
  mxCellRenderer.registerShape('folder', t);
  t.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'tabHeight', 15) * this.scale;
      if (mxUtils.getValue(this.style, 'labelInHeader', !1)) {
        var c = mxUtils.getValue(this.style, 'tabWidth', 15) * this.scale,
          b = mxUtils.getValue(this.style, 'tabHeight', 15) * this.scale,
          d = mxUtils.getValue(this.style, 'rounded', !1),
          e = mxUtils.getValue(this.style, 'absoluteArcSize', !1),
          f = parseFloat(mxUtils.getValue(this.style, 'arcSize', this.arcSize));
        e || (f *= Math.min(a.width, a.height));
        f = Math.min(f, 0.5 * a.width, 0.5 * (a.height - b));
        d || (f = 0);
        return 'left' == mxUtils.getValue(this.style, 'tabPosition', this.tabPosition)
          ? new mxRectangle(f, 0, Math.min(a.width, a.width - c), Math.min(a.height, a.height - b))
          : new mxRectangle(Math.min(a.width, a.width - c), 0, f, Math.min(a.height, a.height - b));
      }
      return new mxRectangle(0, Math.min(a.height, b), 0, 0);
    }
    return null;
  };
  mxUtils.extend(u, mxCylinder);
  u.prototype.arcSize = 0.1;
  u.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.translate(b, c);
    var f = mxUtils.getValue(this.style, 'rounded', !1),
      g = mxUtils.getValue(this.style, 'absoluteArcSize', !1);
    b = parseFloat(mxUtils.getValue(this.style, 'arcSize', this.arcSize));
    c = mxUtils.getValue(this.style, 'umlStateConnection', null);
    g || (b *= Math.min(d, e));
    b = Math.min(b, 0.5 * d, 0.5 * e);
    f || (b = 0);
    f = 0;
    null != c && (f = 10);
    a.begin();
    a.moveTo(f, b);
    a.arcTo(b, b, 0, 0, 1, f + b, 0);
    a.lineTo(d - b, 0);
    a.arcTo(b, b, 0, 0, 1, d, b);
    a.lineTo(d, e - b);
    a.arcTo(b, b, 0, 0, 1, d - b, e);
    a.lineTo(f + b, e);
    a.arcTo(b, b, 0, 0, 1, f, e - b);
    a.close();
    a.fillAndStroke();
    a.setShadow(!1);
    'collapseState' == mxUtils.getValue(this.style, 'umlStateSymbol', null) &&
      (a.roundrect(d - 40, e - 20, 10, 10, 3, 3),
      a.stroke(),
      a.roundrect(d - 20, e - 20, 10, 10, 3, 3),
      a.stroke(),
      a.begin(),
      a.moveTo(d - 30, e - 15),
      a.lineTo(d - 20, e - 15),
      a.stroke());
    'connPointRefEntry' == c
      ? (a.ellipse(0, 0.5 * e - 10, 20, 20), a.fillAndStroke())
      : 'connPointRefExit' == c &&
        (a.ellipse(0, 0.5 * e - 10, 20, 20),
        a.fillAndStroke(),
        a.begin(),
        a.moveTo(5, 0.5 * e - 5),
        a.lineTo(15, 0.5 * e + 5),
        a.moveTo(15, 0.5 * e - 5),
        a.lineTo(5, 0.5 * e + 5),
        a.stroke());
  };
  u.prototype.getLabelMargins = function (a) {
    return mxUtils.getValue(this.style, 'boundedLbl', !1) &&
      null != mxUtils.getValue(this.style, 'umlStateConnection', null)
      ? new mxRectangle(10 * this.scale, 0, 0, 0)
      : null;
  };
  mxCellRenderer.registerShape('umlState', u);
  mxUtils.extend(x, mxActor);
  x.prototype.size = 30;
  x.prototype.isRoundable = function () {
    return !0;
  };
  x.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.max(0, Math.min(d, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [new mxPoint(b, 0), new mxPoint(d, 0), new mxPoint(d, e), new mxPoint(0, e), new mxPoint(0, b)],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('card', x);
  mxUtils.extend(z, mxActor);
  z.prototype.size = 0.4;
  z.prototype.redrawPath = function (a, b, c, d, e) {
    b = e * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    a.moveTo(0, b / 2);
    a.quadTo(d / 4, 1.4 * b, d / 2, b / 2);
    a.quadTo((3 * d) / 4, b * (1 - 1.4), d, b / 2);
    a.lineTo(d, e - b / 2);
    a.quadTo((3 * d) / 4, e - 1.4 * b, d / 2, e - b / 2);
    a.quadTo(d / 4, e - b * (1 - 1.4), 0, e - b / 2);
    a.lineTo(0, b / 2);
    a.close();
    a.end();
  };
  z.prototype.getLabelBounds = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'size', this.size),
        c = a.width,
        d = a.height;
      if (
        null == this.direction ||
        this.direction == mxConstants.DIRECTION_EAST ||
        this.direction == mxConstants.DIRECTION_WEST
      )
        return (b *= d), new mxRectangle(a.x, a.y + b, c, d - 2 * b);
      b *= c;
      return new mxRectangle(a.x + b, a.y, c - 2 * b, d);
    }
    return a;
  };
  mxCellRenderer.registerShape('tape', z);
  mxUtils.extend(D, mxActor);
  D.prototype.size = 0.3;
  D.prototype.getLabelMargins = function (a) {
    return mxUtils.getValue(this.style, 'boundedLbl', !1)
      ? new mxRectangle(0, 0, 0, parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * a.height)
      : null;
  };
  D.prototype.redrawPath = function (a, b, c, d, e) {
    b = e * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    a.moveTo(0, 0);
    a.lineTo(d, 0);
    a.lineTo(d, e - b / 2);
    a.quadTo((3 * d) / 4, e - 1.4 * b, d / 2, e - b / 2);
    a.quadTo(d / 4, e - b * (1 - 1.4), 0, e - b / 2);
    a.lineTo(0, b / 2);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('document', D);
  var tb = mxCylinder.prototype.getCylinderSize;
  mxCylinder.prototype.getCylinderSize = function (a, b, c, d) {
    var e = mxUtils.getValue(this.style, 'size');
    return null != e ? d * Math.max(0, Math.min(1, e)) : tb.apply(this, arguments);
  };
  mxCylinder.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = 2 * mxUtils.getValue(this.style, 'size', 0.15);
      return new mxRectangle(0, Math.min(this.maxHeight * this.scale, a.height * b), 0, 0);
    }
    return null;
  };
  p.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'size', 15);
      mxUtils.getValue(this.style, 'lid', !0) || (b /= 2);
      return new mxRectangle(
        0,
        Math.min(a.height * this.scale, 2 * b * this.scale),
        0,
        Math.max(0, 0.3 * b * this.scale)
      );
    }
    return null;
  };
  t.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'tabHeight', 15) * this.scale;
      if (mxUtils.getValue(this.style, 'labelInHeader', !1)) {
        var c = mxUtils.getValue(this.style, 'tabWidth', 15) * this.scale,
          b = mxUtils.getValue(this.style, 'tabHeight', 15) * this.scale,
          d = mxUtils.getValue(this.style, 'rounded', !1),
          e = mxUtils.getValue(this.style, 'absoluteArcSize', !1),
          f = parseFloat(mxUtils.getValue(this.style, 'arcSize', this.arcSize));
        e || (f *= Math.min(a.width, a.height));
        f = Math.min(f, 0.5 * a.width, 0.5 * (a.height - b));
        d || (f = 0);
        return 'left' == mxUtils.getValue(this.style, 'tabPosition', this.tabPosition)
          ? new mxRectangle(f, 0, Math.min(a.width, a.width - c), Math.min(a.height, a.height - b))
          : new mxRectangle(Math.min(a.width, a.width - c), 0, f, Math.min(a.height, a.height - b));
      }
      return new mxRectangle(0, Math.min(a.height, b), 0, 0);
    }
    return null;
  };
  u.prototype.getLabelMargins = function (a) {
    return mxUtils.getValue(this.style, 'boundedLbl', !1) &&
      null != mxUtils.getValue(this.style, 'umlStateConnection', null)
      ? new mxRectangle(10 * this.scale, 0, 0, 0)
      : null;
  };
  l.prototype.getLabelMargins = function (a) {
    if (mxUtils.getValue(this.style, 'boundedLbl', !1)) {
      var b = mxUtils.getValue(this.style, 'size', 15);
      return new mxRectangle(0, Math.min(a.height * this.scale, b * this.scale), 0, Math.max(0, b * this.scale));
    }
    return null;
  };
  mxUtils.extend(B, mxActor);
  B.prototype.size = 0.2;
  B.prototype.fixedSize = 20;
  B.prototype.isRoundable = function () {
    return !0;
  };
  B.prototype.redrawPath = function (a, b, c, d, e) {
    b =
      '0' != mxUtils.getValue(this.style, 'fixedSize', '0')
        ? Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'size', this.fixedSize))))
        : d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [new mxPoint(0, e), new mxPoint(b, 0), new mxPoint(d, 0), new mxPoint(d - b, e)],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('parallelogram', B);
  mxUtils.extend(C, mxActor);
  C.prototype.size = 0.2;
  C.prototype.fixedSize = 20;
  C.prototype.isRoundable = function () {
    return !0;
  };
  C.prototype.redrawPath = function (a, b, c, d, e) {
    b =
      '0' != mxUtils.getValue(this.style, 'fixedSize', '0')
        ? Math.max(0, Math.min(0.5 * d, parseFloat(mxUtils.getValue(this.style, 'size', this.fixedSize))))
        : d * Math.max(0, Math.min(0.5, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [new mxPoint(0, e), new mxPoint(b, 0), new mxPoint(d - b, 0), new mxPoint(d, e)],
      this.isRounded,
      c,
      !0
    );
  };
  mxCellRenderer.registerShape('trapezoid', C);
  mxUtils.extend(J, mxActor);
  J.prototype.size = 0.5;
  J.prototype.redrawPath = function (a, b, c, d, e) {
    a.setFillColor(null);
    b = d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(d, 0),
        new mxPoint(b, 0),
        new mxPoint(b, e / 2),
        new mxPoint(0, e / 2),
        new mxPoint(b, e / 2),
        new mxPoint(b, e),
        new mxPoint(d, e),
      ],
      this.isRounded,
      c,
      !1
    );
    a.end();
  };
  mxCellRenderer.registerShape('curlyBracket', J);
  mxUtils.extend(v, mxActor);
  v.prototype.redrawPath = function (a, b, c, d, e) {
    a.setStrokeWidth(1);
    a.setFillColor(this.stroke);
    b = d / 5;
    a.rect(0, 0, b, e);
    a.fillAndStroke();
    a.rect(2 * b, 0, b, e);
    a.fillAndStroke();
    a.rect(4 * b, 0, b, e);
    a.fillAndStroke();
  };
  mxCellRenderer.registerShape('parallelMarker', v);
  K.prototype.moveTo = function (a, b) {
    this.originalMoveTo.apply(this.canvas, arguments);
    this.lastX = a;
    this.lastY = b;
    this.firstX = a;
    this.firstY = b;
  };
  K.prototype.close = function () {
    null != this.firstX &&
      null != this.firstY &&
      (this.lineTo(this.firstX, this.firstY), this.originalClose.apply(this.canvas, arguments));
    this.originalClose.apply(this.canvas, arguments);
  };
  K.prototype.quadTo = function (a, b, c, d) {
    this.originalQuadTo.apply(this.canvas, arguments);
    this.lastX = c;
    this.lastY = d;
  };
  K.prototype.curveTo = function (a, b, c, d, e, f) {
    this.originalCurveTo.apply(this.canvas, arguments);
    this.lastX = e;
    this.lastY = f;
  };
  K.prototype.arcTo = function (a, b, c, d, e, f, g) {
    this.originalArcTo.apply(this.canvas, arguments);
    this.lastX = f;
    this.lastY = g;
  };
  K.prototype.lineTo = function (a, b) {
    if (null != this.lastX && null != this.lastY) {
      var c = function (a) {
          return 'number' === typeof a ? (a ? (0 > a ? -1 : 1) : a === a ? 0 : NaN) : NaN;
        },
        d = Math.abs(a - this.lastX),
        e = Math.abs(b - this.lastY),
        f = Math.sqrt(d * d + e * e);
      if (2 > f) {
        this.originalLineTo.apply(this.canvas, arguments);
        this.lastX = a;
        this.lastY = b;
        return;
      }
      var g = Math.round(f / 10),
        q = this.defaultVariation;
      5 > g && ((g = 5), (q /= 3));
      for (
        var k = (c(a - this.lastX) * d) / g, c = (c(b - this.lastY) * e) / g, d = d / f, e = e / f, f = 0;
        f < g;
        f++
      ) {
        var h = (Math.random() - 0.5) * q;
        this.originalLineTo.call(this.canvas, k * f + this.lastX - h * e, c * f + this.lastY - h * d);
      }
      this.originalLineTo.call(this.canvas, a, b);
    } else this.originalLineTo.apply(this.canvas, arguments);
    this.lastX = a;
    this.lastY = b;
  };
  K.prototype.destroy = function () {
    this.canvas.lineTo = this.originalLineTo;
    this.canvas.moveTo = this.originalMoveTo;
    this.canvas.close = this.originalClose;
    this.canvas.quadTo = this.originalQuadTo;
    this.canvas.curveTo = this.originalCurveTo;
    this.canvas.arcTo = this.originalArcTo;
  };
  mxShape.prototype.defaultJiggle = 1.5;
  var Aa = mxShape.prototype.beforePaint;
  mxShape.prototype.beforePaint = function (a) {
    Aa.apply(this, arguments);
    null == a.handJiggle && (a.handJiggle = this.createHandJiggle(a));
  };
  var ab = mxShape.prototype.afterPaint;
  mxShape.prototype.afterPaint = function (a) {
    ab.apply(this, arguments);
    null != a.handJiggle && (a.handJiggle.destroy(), delete a.handJiggle);
  };
  mxShape.prototype.createComicCanvas = function (a) {
    return new K(a, mxUtils.getValue(this.style, 'jiggle', this.defaultJiggle));
  };
  mxShape.prototype.createHandJiggle = function (a) {
    return this.outline || null == this.style || '0' == mxUtils.getValue(this.style, 'comic', '0')
      ? null
      : this.createComicCanvas(a);
  };
  mxRhombus.prototype.defaultJiggle = 2;
  var Ba = mxRectangleShape.prototype.isHtmlAllowed;
  mxRectangleShape.prototype.isHtmlAllowed = function () {
    return (
      !this.outline &&
      (null == this.style ||
        ('0' == mxUtils.getValue(this.style, 'comic', '0') &&
          '0' == mxUtils.getValue(this.style, 'sketch', '1' == urlParams.rough ? '1' : '0'))) &&
      Ba.apply(this, arguments)
    );
  };
  var jb = mxRectangleShape.prototype.paintBackground;
  mxRectangleShape.prototype.paintBackground = function (a, b, c, d, e) {
    if (null == a.handJiggle || a.handJiggle.constructor != K) jb.apply(this, arguments);
    else {
      var f = !0;
      null != this.style && (f = '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1'));
      if (
        f ||
        (null != this.fill && this.fill != mxConstants.NONE) ||
        (null != this.stroke && this.stroke != mxConstants.NONE)
      )
        f || (null != this.fill && this.fill != mxConstants.NONE) || (a.pointerEvents = !1),
          a.begin(),
          this.isRounded
            ? ('1' == mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)
                ? (f = Math.min(
                    d / 2,
                    Math.min(
                      e / 2,
                      mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2
                    )
                  ))
                : ((f =
                    mxUtils.getValue(
                      this.style,
                      mxConstants.STYLE_ARCSIZE,
                      100 * mxConstants.RECTANGLE_ROUNDING_FACTOR
                    ) / 100),
                  (f = Math.min(d * f, e * f))),
              a.moveTo(b + f, c),
              a.lineTo(b + d - f, c),
              a.quadTo(b + d, c, b + d, c + f),
              a.lineTo(b + d, c + e - f),
              a.quadTo(b + d, c + e, b + d - f, c + e),
              a.lineTo(b + f, c + e),
              a.quadTo(b, c + e, b, c + e - f),
              a.lineTo(b, c + f),
              a.quadTo(b, c, b + f, c))
            : (a.moveTo(b, c), a.lineTo(b + d, c), a.lineTo(b + d, c + e), a.lineTo(b, c + e), a.lineTo(b, c)),
          a.close(),
          a.end(),
          a.fillAndStroke();
    }
  };
  mxUtils.extend(O, mxRectangleShape);
  O.prototype.size = 0.1;
  O.prototype.fixedSize = !1;
  O.prototype.isHtmlAllowed = function () {
    return !1;
  };
  O.prototype.getLabelBounds = function (a) {
    if (
      mxUtils.getValue(this.state.style, mxConstants.STYLE_HORIZONTAL, !0) ==
      (null == this.direction ||
        this.direction == mxConstants.DIRECTION_EAST ||
        this.direction == mxConstants.DIRECTION_WEST)
    ) {
      var b = a.width,
        c = a.height;
      a = new mxRectangle(a.x, a.y, b, c);
      var d = b * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
      if (this.isRounded)
        var e =
            mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100,
          d = Math.max(d, Math.min(b * e, c * e));
      a.x += Math.round(d);
      a.width -= Math.round(2 * d);
    }
    return a;
  };
  O.prototype.paintForeground = function (a, b, c, d, e) {
    var f = mxUtils.getValue(this.style, 'fixedSize', this.fixedSize),
      g = parseFloat(mxUtils.getValue(this.style, 'size', this.size)),
      g = f ? Math.max(0, Math.min(d, g)) : d * Math.max(0, Math.min(1, g));
    this.isRounded &&
      ((f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100),
      (g = Math.max(g, Math.min(d * f, e * f))));
    g = Math.round(g);
    a.begin();
    a.moveTo(b + g, c);
    a.lineTo(b + g, c + e);
    a.moveTo(b + d - g, c);
    a.lineTo(b + d - g, c + e);
    a.end();
    a.stroke();
    mxRectangleShape.prototype.paintForeground.apply(this, arguments);
  };
  mxCellRenderer.registerShape('process', O);
  mxCellRenderer.registerShape('process2', O);
  mxUtils.extend(T, mxRectangleShape);
  T.prototype.paintBackground = function (a, b, c, d, e) {
    a.setFillColor(mxConstants.NONE);
    a.rect(b, c, d, e);
    a.fill();
  };
  T.prototype.paintForeground = function (a, b, c, d, e) {};
  mxCellRenderer.registerShape('transparent', T);
  mxUtils.extend(M, mxHexagon);
  M.prototype.size = 30;
  M.prototype.position = 0.5;
  M.prototype.position2 = 0.5;
  M.prototype.base = 20;
  M.prototype.getLabelMargins = function () {
    return new mxRectangle(0, 0, 0, parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * this.scale);
  };
  M.prototype.isRoundable = function () {
    return !0;
  };
  M.prototype.redrawPath = function (a, b, c, d, e) {
    b = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    c = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    var f = d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'position', this.position)))),
      g = d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'position2', this.position2)))),
      q = Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'base', this.base))));
    this.addPoints(
      a,
      [
        new mxPoint(0, 0),
        new mxPoint(d, 0),
        new mxPoint(d, e - c),
        new mxPoint(Math.min(d, f + q), e - c),
        new mxPoint(g, e),
        new mxPoint(Math.max(0, f), e - c),
        new mxPoint(0, e - c),
      ],
      this.isRounded,
      b,
      !0,
      [4]
    );
  };
  mxCellRenderer.registerShape('callout', M);
  mxUtils.extend(U, mxActor);
  U.prototype.size = 0.2;
  U.prototype.fixedSize = 20;
  U.prototype.isRoundable = function () {
    return !0;
  };
  U.prototype.redrawPath = function (a, b, c, d, e) {
    b =
      '0' != mxUtils.getValue(this.style, 'fixedSize', '0')
        ? Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'size', this.fixedSize))))
        : d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(0, 0),
        new mxPoint(d - b, 0),
        new mxPoint(d, e / 2),
        new mxPoint(d - b, e),
        new mxPoint(0, e),
        new mxPoint(b, e / 2),
      ],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('step', U);
  mxUtils.extend(da, mxHexagon);
  da.prototype.size = 0.25;
  da.prototype.fixedSize = 20;
  da.prototype.isRoundable = function () {
    return !0;
  };
  da.prototype.redrawPath = function (a, b, c, d, e) {
    b =
      '0' != mxUtils.getValue(this.style, 'fixedSize', '0')
        ? Math.max(0, Math.min(0.5 * d, parseFloat(mxUtils.getValue(this.style, 'size', this.fixedSize))))
        : d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(b, 0),
        new mxPoint(d - b, 0),
        new mxPoint(d, 0.5 * e),
        new mxPoint(d - b, e),
        new mxPoint(b, e),
        new mxPoint(0, 0.5 * e),
      ],
      this.isRounded,
      c,
      !0
    );
  };
  mxCellRenderer.registerShape('hexagon', da);
  mxUtils.extend(ha, mxRectangleShape);
  ha.prototype.isHtmlAllowed = function () {
    return !1;
  };
  ha.prototype.paintForeground = function (a, b, c, d, e) {
    var f = Math.min(d / 5, e / 5) + 1;
    a.begin();
    a.moveTo(b + d / 2, c + f);
    a.lineTo(b + d / 2, c + e - f);
    a.moveTo(b + f, c + e / 2);
    a.lineTo(b + d - f, c + e / 2);
    a.end();
    a.stroke();
    mxRectangleShape.prototype.paintForeground.apply(this, arguments);
  };
  mxCellRenderer.registerShape('plus', ha);
  var ga = mxRhombus.prototype.paintVertexShape;
  mxRhombus.prototype.getLabelBounds = function (a) {
    if (1 == this.style['double']) {
      var b =
        (2 * Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants.STYLE_MARGIN] || 0)) * this.scale;
      return new mxRectangle(a.x + b, a.y + b, a.width - 2 * b, a.height - 2 * b);
    }
    return a;
  };
  mxRhombus.prototype.paintVertexShape = function (a, b, c, d, e) {
    ga.apply(this, arguments);
    if (!this.outline && 1 == this.style['double']) {
      var f = 2 * Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants.STYLE_MARGIN] || 0);
      b += f;
      c += f;
      d -= 2 * f;
      e -= 2 * f;
      0 < d && 0 < e && (a.setShadow(!1), ga.apply(this, [a, b, c, d, e]));
    }
  };
  mxUtils.extend(Y, mxRectangleShape);
  Y.prototype.isHtmlAllowed = function () {
    return !1;
  };
  Y.prototype.getLabelBounds = function (a) {
    if (1 == this.style['double']) {
      var b = (Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants.STYLE_MARGIN] || 0)) * this.scale;
      return new mxRectangle(a.x + b, a.y + b, a.width - 2 * b, a.height - 2 * b);
    }
    return a;
  };
  Y.prototype.paintForeground = function (a, b, c, d, e) {
    if (null != this.style) {
      if (!this.outline && 1 == this.style['double']) {
        var f = Math.max(2, this.strokewidth + 1) + parseFloat(this.style[mxConstants.STYLE_MARGIN] || 0);
        b += f;
        c += f;
        d -= 2 * f;
        e -= 2 * f;
        0 < d && 0 < e && mxRectangleShape.prototype.paintBackground.apply(this, arguments);
      }
      a.setDashed(!1);
      var f = 0,
        g;
      do {
        g = mxCellRenderer.defaultShapes[this.style['symbol' + f]];
        if (null != g) {
          var q = this.style['symbol' + f + 'Align'],
            k = this.style['symbol' + f + 'VerticalAlign'],
            h = this.style['symbol' + f + 'Width'],
            l = this.style['symbol' + f + 'Height'],
            w = this.style['symbol' + f + 'Spacing'] || 0,
            A = this.style['symbol' + f + 'VSpacing'] || w,
            m = this.style['symbol' + f + 'ArcSpacing'];
          null != m && ((m *= this.getArcSize(d + this.strokewidth, e + this.strokewidth)), (w += m), (A += m));
          var m = b,
            y = c,
            m =
              q == mxConstants.ALIGN_CENTER ? m + (d - h) / 2 : q == mxConstants.ALIGN_RIGHT ? m + (d - h - w) : m + w,
            y =
              k == mxConstants.ALIGN_MIDDLE ? y + (e - l) / 2 : k == mxConstants.ALIGN_BOTTOM ? y + (e - l - A) : y + A;
          a.save();
          q = new g();
          q.style = this.style;
          g.prototype.paintVertexShape.call(q, a, m, y, h, l);
          a.restore();
        }
        f++;
      } while (null != g);
    }
    mxRectangleShape.prototype.paintForeground.apply(this, arguments);
  };
  mxCellRenderer.registerShape('ext', Y);
  mxUtils.extend(P, mxCylinder);
  P.prototype.redrawPath = function (a, b, c, d, e, f) {
    f
      ? (a.moveTo(0, 0), a.lineTo(d / 2, e / 2), a.lineTo(d, 0), a.end())
      : (a.moveTo(0, 0), a.lineTo(d, 0), a.lineTo(d, e), a.lineTo(0, e), a.close());
  };
  mxCellRenderer.registerShape('message', P);
  mxUtils.extend(Oa, mxShape);
  Oa.prototype.paintBackground = function (a, b, c, d, e) {
    a.translate(b, c);
    a.ellipse(d / 4, 0, d / 2, e / 4);
    a.fillAndStroke();
    a.begin();
    a.moveTo(d / 2, e / 4);
    a.lineTo(d / 2, (2 * e) / 3);
    a.moveTo(d / 2, e / 3);
    a.lineTo(0, e / 3);
    a.moveTo(d / 2, e / 3);
    a.lineTo(d, e / 3);
    a.moveTo(d / 2, (2 * e) / 3);
    a.lineTo(0, e);
    a.moveTo(d / 2, (2 * e) / 3);
    a.lineTo(d, e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('umlActor', Oa);
  mxUtils.extend(Da, mxShape);
  Da.prototype.getLabelMargins = function (a) {
    return new mxRectangle(a.width / 6, 0, 0, 0);
  };
  Da.prototype.paintBackground = function (a, b, c, d, e) {
    a.translate(b, c);
    a.begin();
    a.moveTo(0, e / 4);
    a.lineTo(0, (3 * e) / 4);
    a.end();
    a.stroke();
    a.begin();
    a.moveTo(0, e / 2);
    a.lineTo(d / 6, e / 2);
    a.end();
    a.stroke();
    a.ellipse(d / 6, 0, (5 * d) / 6, e);
    a.fillAndStroke();
  };
  mxCellRenderer.registerShape('umlBoundary', Da);
  mxUtils.extend(Pa, mxEllipse);
  Pa.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxEllipse.prototype.paintVertexShape.apply(this, arguments);
    a.begin();
    a.moveTo(b + d / 8, c + e);
    a.lineTo(b + (7 * d) / 8, c + e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('umlEntity', Pa);
  mxUtils.extend(Wa, mxShape);
  Wa.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.translate(b, c);
    a.begin();
    a.moveTo(d, 0);
    a.lineTo(0, e);
    a.moveTo(0, 0);
    a.lineTo(d, e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('umlDestroy', Wa);
  mxUtils.extend(Ea, mxShape);
  Ea.prototype.getLabelBounds = function (a) {
    return new mxRectangle(a.x, a.y + a.height / 8, a.width, (7 * a.height) / 8);
  };
  Ea.prototype.paintBackground = function (a, b, c, d, e) {
    a.translate(b, c);
    a.begin();
    a.moveTo((3 * d) / 8, (e / 8) * 1.1);
    a.lineTo((5 * d) / 8, 0);
    a.end();
    a.stroke();
    a.ellipse(0, e / 8, d, (7 * e) / 8);
    a.fillAndStroke();
  };
  Ea.prototype.paintForeground = function (a, b, c, d, e) {
    a.begin();
    a.moveTo((3 * d) / 8, (e / 8) * 1.1);
    a.lineTo((5 * d) / 8, e / 4);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('umlControl', Ea);
  mxUtils.extend(qa, mxRectangleShape);
  qa.prototype.size = 40;
  qa.prototype.isHtmlAllowed = function () {
    return !1;
  };
  qa.prototype.getLabelBounds = function (a) {
    var b = Math.max(0, Math.min(a.height, parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * this.scale));
    return new mxRectangle(a.x, a.y, a.width, b);
  };
  qa.prototype.paintBackground = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))),
      g = mxUtils.getValue(this.style, 'participant');
    null == g || null == this.state
      ? mxRectangleShape.prototype.paintBackground.call(this, a, b, c, d, f)
      : ((g = this.state.view.graph.cellRenderer.getShape(g)),
        null != g &&
          g != qa &&
          ((g = new g()), g.apply(this.state), a.save(), g.paintVertexShape(a, b, c, d, f), a.restore()));
    f < e &&
      (a.setDashed('1' == mxUtils.getValue(this.style, 'lifelineDashed', '1')),
      a.begin(),
      a.moveTo(b + d / 2, c + f),
      a.lineTo(b + d / 2, c + e),
      a.end(),
      a.stroke());
  };
  qa.prototype.paintForeground = function (a, b, c, d, e) {
    var f = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    mxRectangleShape.prototype.paintForeground.call(this, a, b, c, d, Math.min(e, f));
  };
  mxCellRenderer.registerShape('umlLifeline', qa);
  mxUtils.extend(ia, mxShape);
  ia.prototype.width = 60;
  ia.prototype.height = 30;
  ia.prototype.corner = 10;
  ia.prototype.getLabelMargins = function (a) {
    return new mxRectangle(
      0,
      0,
      a.width - parseFloat(mxUtils.getValue(this.style, 'width', this.width) * this.scale),
      a.height - parseFloat(mxUtils.getValue(this.style, 'height', this.height) * this.scale)
    );
  };
  ia.prototype.paintBackground = function (a, b, c, d, e) {
    var f = this.corner,
      g = Math.min(d, Math.max(f, parseFloat(mxUtils.getValue(this.style, 'width', this.width)))),
      q = Math.min(e, Math.max(1.5 * f, parseFloat(mxUtils.getValue(this.style, 'height', this.height)))),
      k = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);
    k != mxConstants.NONE && (a.setFillColor(k), a.rect(b, c, d, e), a.fill());
    null != this.fill && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE
      ? (this.getGradientBounds(a, b, c, d, e),
        a.setGradient(this.fill, this.gradient, b, c, d, e, this.gradientDirection))
      : a.setFillColor(this.fill);
    a.begin();
    a.moveTo(b, c);
    a.lineTo(b + g, c);
    a.lineTo(b + g, c + Math.max(0, q - 1.5 * f));
    a.lineTo(b + Math.max(0, g - f), c + q);
    a.lineTo(b, c + q);
    a.close();
    a.fillAndStroke();
    a.begin();
    a.moveTo(b + g, c);
    a.lineTo(b + d, c);
    a.lineTo(b + d, c + e);
    a.lineTo(b, c + e);
    a.lineTo(b, c + q);
    a.stroke();
  };
  mxCellRenderer.registerShape('umlFrame', ia);
  mxPerimeter.CenterPerimeter = function (a, b, c, d) {
    return new mxPoint(a.getCenterX(), a.getCenterY());
  };
  mxStyleRegistry.putValue('centerPerimeter', mxPerimeter.CenterPerimeter);
  mxPerimeter.LifelinePerimeter = function (a, b, c, d) {
    d = qa.prototype.size;
    null != b && (d = mxUtils.getValue(b.style, 'size', d) * b.view.scale);
    b = (parseFloat(b.style[mxConstants.STYLE_STROKEWIDTH] || 1) * b.view.scale) / 2 - 1;
    c.x < a.getCenterX() && (b = -1 * (b + 1));
    return new mxPoint(a.getCenterX() + b, Math.min(a.y + a.height, Math.max(a.y + d, c.y)));
  };
  mxStyleRegistry.putValue('lifelinePerimeter', mxPerimeter.LifelinePerimeter);
  mxPerimeter.OrthogonalPerimeter = function (a, b, c, d) {
    d = !0;
    return mxPerimeter.RectanglePerimeter.apply(this, arguments);
  };
  mxStyleRegistry.putValue('orthogonalPerimeter', mxPerimeter.OrthogonalPerimeter);
  mxPerimeter.BackbonePerimeter = function (a, b, c, d) {
    d = (parseFloat(b.style[mxConstants.STYLE_STROKEWIDTH] || 1) * b.view.scale) / 2 - 1;
    null != b.style.backboneSize && (d += (parseFloat(b.style.backboneSize) * b.view.scale) / 2 - 1);
    if ('south' == b.style[mxConstants.STYLE_DIRECTION] || 'north' == b.style[mxConstants.STYLE_DIRECTION])
      return (
        c.x < a.getCenterX() && (d = -1 * (d + 1)),
        new mxPoint(a.getCenterX() + d, Math.min(a.y + a.height, Math.max(a.y, c.y)))
      );
    c.y < a.getCenterY() && (d = -1 * (d + 1));
    return new mxPoint(Math.min(a.x + a.width, Math.max(a.x, c.x)), a.getCenterY() + d);
  };
  mxStyleRegistry.putValue('backbonePerimeter', mxPerimeter.BackbonePerimeter);
  mxPerimeter.CalloutPerimeter = function (a, b, c, d) {
    return mxPerimeter.RectanglePerimeter(
      mxUtils.getDirectedBounds(
        a,
        new mxRectangle(
          0,
          0,
          0,
          Math.max(
            0,
            Math.min(a.height, parseFloat(mxUtils.getValue(b.style, 'size', M.prototype.size)) * b.view.scale)
          )
        ),
        b.style
      ),
      b,
      c,
      d
    );
  };
  mxStyleRegistry.putValue('calloutPerimeter', mxPerimeter.CalloutPerimeter);
  mxPerimeter.ParallelogramPerimeter = function (a, b, c, d) {
    var e = '0' != mxUtils.getValue(b.style, 'fixedSize', '0'),
      f = e ? B.prototype.fixedSize : B.prototype.size;
    null != b && (f = mxUtils.getValue(b.style, 'size', f));
    e && (f *= b.view.scale);
    var g = a.x,
      q = a.y,
      k = a.width,
      h = a.height;
    b =
      null != b
        ? mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST)
        : mxConstants.DIRECTION_EAST;
    b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_SOUTH
      ? ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q),
          new mxPoint(g + k, q + e),
          new mxPoint(g + k, q + h),
          new mxPoint(g, q + h - e),
          new mxPoint(g, q),
        ]))
      : ((e = e ? Math.max(0, Math.min(0.5 * k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g + e, q),
          new mxPoint(g + k, q),
          new mxPoint(g + k - e, q + h),
          new mxPoint(g, q + h),
          new mxPoint(g + e, q),
        ]));
    h = a.getCenterX();
    a = a.getCenterY();
    a = new mxPoint(h, a);
    d && (c.x < g || c.x > g + k ? (a.y = c.y) : (a.x = c.x));
    return mxUtils.getPerimeterPoint(q, a, c);
  };
  mxStyleRegistry.putValue('parallelogramPerimeter', mxPerimeter.ParallelogramPerimeter);
  mxPerimeter.TrapezoidPerimeter = function (a, b, c, d) {
    var e = '0' != mxUtils.getValue(b.style, 'fixedSize', '0'),
      f = e ? C.prototype.fixedSize : C.prototype.size;
    null != b && (f = mxUtils.getValue(b.style, 'size', f));
    e && (f *= b.view.scale);
    var g = a.x,
      q = a.y,
      k = a.width,
      h = a.height;
    b =
      null != b
        ? mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST)
        : mxConstants.DIRECTION_EAST;
    b == mxConstants.DIRECTION_EAST
      ? ((e = e ? Math.max(0, Math.min(0.5 * k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g + e, q),
          new mxPoint(g + k - e, q),
          new mxPoint(g + k, q + h),
          new mxPoint(g, q + h),
          new mxPoint(g + e, q),
        ]))
      : b == mxConstants.DIRECTION_WEST
      ? ((e = e ? Math.max(0, Math.min(k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q),
          new mxPoint(g + k, q),
          new mxPoint(g + k - e, q + h),
          new mxPoint(g + e, q + h),
          new mxPoint(g, q),
        ]))
      : b == mxConstants.DIRECTION_NORTH
      ? ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q + e),
          new mxPoint(g + k, q),
          new mxPoint(g + k, q + h),
          new mxPoint(g, q + h - e),
          new mxPoint(g, q + e),
        ]))
      : ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q),
          new mxPoint(g + k, q + e),
          new mxPoint(g + k, q + h - e),
          new mxPoint(g, q + h),
          new mxPoint(g, q),
        ]));
    h = a.getCenterX();
    a = a.getCenterY();
    a = new mxPoint(h, a);
    d && (c.x < g || c.x > g + k ? (a.y = c.y) : (a.x = c.x));
    return mxUtils.getPerimeterPoint(q, a, c);
  };
  mxStyleRegistry.putValue('trapezoidPerimeter', mxPerimeter.TrapezoidPerimeter);
  mxPerimeter.StepPerimeter = function (a, b, c, d) {
    var e = '0' != mxUtils.getValue(b.style, 'fixedSize', '0'),
      f = e ? U.prototype.fixedSize : U.prototype.size;
    null != b && (f = mxUtils.getValue(b.style, 'size', f));
    e && (f *= b.view.scale);
    var g = a.x,
      q = a.y,
      k = a.width,
      h = a.height,
      l = a.getCenterX();
    a = a.getCenterY();
    b =
      null != b
        ? mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST)
        : mxConstants.DIRECTION_EAST;
    b == mxConstants.DIRECTION_EAST
      ? ((e = e ? Math.max(0, Math.min(k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q),
          new mxPoint(g + k - e, q),
          new mxPoint(g + k, a),
          new mxPoint(g + k - e, q + h),
          new mxPoint(g, q + h),
          new mxPoint(g + e, a),
          new mxPoint(g, q),
        ]))
      : b == mxConstants.DIRECTION_WEST
      ? ((e = e ? Math.max(0, Math.min(k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g + e, q),
          new mxPoint(g + k, q),
          new mxPoint(g + k - e, a),
          new mxPoint(g + k, q + h),
          new mxPoint(g + e, q + h),
          new mxPoint(g, a),
          new mxPoint(g + e, q),
        ]))
      : b == mxConstants.DIRECTION_NORTH
      ? ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q + e),
          new mxPoint(l, q),
          new mxPoint(g + k, q + e),
          new mxPoint(g + k, q + h),
          new mxPoint(l, q + h - e),
          new mxPoint(g, q + h),
          new mxPoint(g, q + e),
        ]))
      : ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g, q),
          new mxPoint(l, q + e),
          new mxPoint(g + k, q),
          new mxPoint(g + k, q + h - e),
          new mxPoint(l, q + h),
          new mxPoint(g, q + h - e),
          new mxPoint(g, q),
        ]));
    l = new mxPoint(l, a);
    d && (c.x < g || c.x > g + k ? (l.y = c.y) : (l.x = c.x));
    return mxUtils.getPerimeterPoint(q, l, c);
  };
  mxStyleRegistry.putValue('stepPerimeter', mxPerimeter.StepPerimeter);
  mxPerimeter.HexagonPerimeter2 = function (a, b, c, d) {
    var e = '0' != mxUtils.getValue(b.style, 'fixedSize', '0'),
      f = e ? da.prototype.fixedSize : da.prototype.size;
    null != b && (f = mxUtils.getValue(b.style, 'size', f));
    e && (f *= b.view.scale);
    var g = a.x,
      q = a.y,
      k = a.width,
      h = a.height,
      l = a.getCenterX();
    a = a.getCenterY();
    b =
      null != b
        ? mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST)
        : mxConstants.DIRECTION_EAST;
    b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_SOUTH
      ? ((e = e ? Math.max(0, Math.min(h, f)) : h * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(l, q),
          new mxPoint(g + k, q + e),
          new mxPoint(g + k, q + h - e),
          new mxPoint(l, q + h),
          new mxPoint(g, q + h - e),
          new mxPoint(g, q + e),
          new mxPoint(l, q),
        ]))
      : ((e = e ? Math.max(0, Math.min(k, f)) : k * Math.max(0, Math.min(1, f))),
        (q = [
          new mxPoint(g + e, q),
          new mxPoint(g + k - e, q),
          new mxPoint(g + k, a),
          new mxPoint(g + k - e, q + h),
          new mxPoint(g + e, q + h),
          new mxPoint(g, a),
          new mxPoint(g + e, q),
        ]));
    l = new mxPoint(l, a);
    d && (c.x < g || c.x > g + k ? (l.y = c.y) : (l.x = c.x));
    return mxUtils.getPerimeterPoint(q, l, c);
  };
  mxStyleRegistry.putValue('hexagonPerimeter2', mxPerimeter.HexagonPerimeter2);
  mxUtils.extend(Ka, mxShape);
  Ka.prototype.size = 10;
  Ka.prototype.paintBackground = function (a, b, c, d, e) {
    var f = parseFloat(mxUtils.getValue(this.style, 'size', this.size));
    a.translate(b, c);
    a.ellipse((d - f) / 2, 0, f, f);
    a.fillAndStroke();
    a.begin();
    a.moveTo(d / 2, f);
    a.lineTo(d / 2, e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('lollipop', Ka);
  mxUtils.extend(ua, mxShape);
  ua.prototype.size = 10;
  ua.prototype.inset = 2;
  ua.prototype.paintBackground = function (a, b, c, d, e) {
    var f = parseFloat(mxUtils.getValue(this.style, 'size', this.size)),
      g = parseFloat(mxUtils.getValue(this.style, 'inset', this.inset)) + this.strokewidth;
    a.translate(b, c);
    a.begin();
    a.moveTo(d / 2, f + g);
    a.lineTo(d / 2, e);
    a.end();
    a.stroke();
    a.begin();
    a.moveTo((d - f) / 2 - g, f / 2);
    a.quadTo((d - f) / 2 - g, f + g, d / 2, f + g);
    a.quadTo((d + f) / 2 + g, f + g, (d + f) / 2 + g, f / 2);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('requires', ua);
  mxUtils.extend(Xa, mxShape);
  Xa.prototype.paintBackground = function (a, b, c, d, e) {
    a.translate(b, c);
    a.begin();
    a.moveTo(0, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, 0, e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('requiredInterface', Xa);
  mxUtils.extend(Z, mxShape);
  Z.prototype.inset = 2;
  Z.prototype.paintBackground = function (a, b, c, d, e) {
    var f = parseFloat(mxUtils.getValue(this.style, 'inset', this.inset)) + this.strokewidth;
    a.translate(b, c);
    a.ellipse(0, f, d - 2 * f, e - 2 * f);
    a.fillAndStroke();
    a.begin();
    a.moveTo(d / 2, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, d / 2, e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('providedRequiredInterface', Z);
  mxUtils.extend(ea, mxCylinder);
  ea.prototype.jettyWidth = 20;
  ea.prototype.jettyHeight = 10;
  ea.prototype.redrawPath = function (a, b, c, d, e, f) {
    var g = parseFloat(mxUtils.getValue(this.style, 'jettyWidth', this.jettyWidth));
    b = parseFloat(mxUtils.getValue(this.style, 'jettyHeight', this.jettyHeight));
    c = g / 2;
    var g = c + g / 2,
      k = Math.min(b, e - b),
      q = Math.min(k + 2 * b, e - b);
    f
      ? (a.moveTo(c, k),
        a.lineTo(g, k),
        a.lineTo(g, k + b),
        a.lineTo(c, k + b),
        a.moveTo(c, q),
        a.lineTo(g, q),
        a.lineTo(g, q + b),
        a.lineTo(c, q + b))
      : (a.moveTo(c, 0),
        a.lineTo(d, 0),
        a.lineTo(d, e),
        a.lineTo(c, e),
        a.lineTo(c, q + b),
        a.lineTo(0, q + b),
        a.lineTo(0, q),
        a.lineTo(c, q),
        a.lineTo(c, k + b),
        a.lineTo(0, k + b),
        a.lineTo(0, k),
        a.lineTo(c, k),
        a.close());
    a.end();
  };
  mxCellRenderer.registerShape('module', ea);
  mxUtils.extend(L, mxCylinder);
  L.prototype.jettyWidth = 32;
  L.prototype.jettyHeight = 12;
  L.prototype.redrawPath = function (a, b, c, d, e, f) {
    var g = parseFloat(mxUtils.getValue(this.style, 'jettyWidth', this.jettyWidth));
    b = parseFloat(mxUtils.getValue(this.style, 'jettyHeight', this.jettyHeight));
    c = g / 2;
    var g = c + g / 2,
      k = 0.3 * e - b / 2,
      q = 0.7 * e - b / 2;
    f
      ? (a.moveTo(c, k),
        a.lineTo(g, k),
        a.lineTo(g, k + b),
        a.lineTo(c, k + b),
        a.moveTo(c, q),
        a.lineTo(g, q),
        a.lineTo(g, q + b),
        a.lineTo(c, q + b))
      : (a.moveTo(c, 0),
        a.lineTo(d, 0),
        a.lineTo(d, e),
        a.lineTo(c, e),
        a.lineTo(c, q + b),
        a.lineTo(0, q + b),
        a.lineTo(0, q),
        a.lineTo(c, q),
        a.lineTo(c, k + b),
        a.lineTo(0, k + b),
        a.lineTo(0, k),
        a.lineTo(c, k),
        a.close());
    a.end();
  };
  mxCellRenderer.registerShape('component', L);
  mxUtils.extend(db, mxRectangleShape);
  db.prototype.paintForeground = function (a, b, c, d, e) {
    var f = d / 2,
      g = e / 2,
      k = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    a.begin();
    this.addPoints(
      a,
      [new mxPoint(b + f, c), new mxPoint(b + d, c + g), new mxPoint(b + f, c + e), new mxPoint(b, c + g)],
      this.isRounded,
      k,
      !0
    );
    a.stroke();
    mxRectangleShape.prototype.paintForeground.apply(this, arguments);
  };
  mxCellRenderer.registerShape('associativeEntity', db);
  mxUtils.extend(sa, mxDoubleEllipse);
  sa.prototype.outerStroke = !0;
  sa.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = Math.min(4, Math.min(d / 5, e / 5));
    0 < d && 0 < e && (a.ellipse(b + f, c + f, d - 2 * f, e - 2 * f), a.fillAndStroke());
    a.setShadow(!1);
    this.outerStroke && (a.ellipse(b, c, d, e), a.stroke());
  };
  mxCellRenderer.registerShape('endState', sa);
  mxUtils.extend(eb, sa);
  eb.prototype.outerStroke = !1;
  mxCellRenderer.registerShape('startState', eb);
  mxUtils.extend(ta, mxArrowConnector);
  ta.prototype.defaultWidth = 4;
  ta.prototype.isOpenEnded = function () {
    return !0;
  };
  ta.prototype.getEdgeWidth = function () {
    return mxUtils.getNumber(this.style, 'width', this.defaultWidth) + Math.max(0, this.strokewidth - 1);
  };
  ta.prototype.isArrowRounded = function () {
    return this.isRounded;
  };
  mxCellRenderer.registerShape('link', ta);
  mxUtils.extend(Fa, mxArrowConnector);
  Fa.prototype.defaultWidth = 10;
  Fa.prototype.defaultArrowWidth = 20;
  Fa.prototype.getStartArrowWidth = function () {
    return this.getEdgeWidth() + mxUtils.getNumber(this.style, 'startWidth', this.defaultArrowWidth);
  };
  Fa.prototype.getEndArrowWidth = function () {
    return this.getEdgeWidth() + mxUtils.getNumber(this.style, 'endWidth', this.defaultArrowWidth);
  };
  Fa.prototype.getEdgeWidth = function () {
    return mxUtils.getNumber(this.style, 'width', this.defaultWidth) + Math.max(0, this.strokewidth - 1);
  };
  mxCellRenderer.registerShape('flexArrow', Fa);
  mxUtils.extend(La, mxActor);
  La.prototype.size = 30;
  La.prototype.isRoundable = function () {
    return !0;
  };
  La.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size)));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [new mxPoint(0, e), new mxPoint(0, b), new mxPoint(d, 0), new mxPoint(d, e)],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('manualInput', La);
  mxUtils.extend(la, mxRectangleShape);
  la.prototype.dx = 20;
  la.prototype.dy = 20;
  la.prototype.isHtmlAllowed = function () {
    return !1;
  };
  la.prototype.paintForeground = function (a, b, c, d, e) {
    mxRectangleShape.prototype.paintForeground.apply(this, arguments);
    var f = 0;
    if (this.isRounded)
      var g =
          mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100,
        f = Math.max(f, Math.min(d * g, e * g));
    g = Math.max(f, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
    f = Math.max(f, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
    a.begin();
    a.moveTo(b, c + f);
    a.lineTo(b + d, c + f);
    a.end();
    a.stroke();
    a.begin();
    a.moveTo(b + g, c);
    a.lineTo(b + g, c + e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('internalStorage', la);
  mxUtils.extend(Ca, mxActor);
  Ca.prototype.dx = 20;
  Ca.prototype.dy = 20;
  Ca.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
    c = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
    parseFloat(mxUtils.getValue(this.style, 'size', this.size));
    var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(0, 0),
        new mxPoint(d, 0),
        new mxPoint(d, c),
        new mxPoint(b, c),
        new mxPoint(b, e),
        new mxPoint(0, e),
      ],
      this.isRounded,
      f,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('corner', Ca);
  mxUtils.extend(pa, mxActor);
  pa.prototype.redrawPath = function (a, b, c, d, e) {
    a.moveTo(0, 0);
    a.lineTo(0, e);
    a.end();
    a.moveTo(d, 0);
    a.lineTo(d, e);
    a.end();
    a.moveTo(0, e / 2);
    a.lineTo(d, e / 2);
    a.end();
  };
  mxCellRenderer.registerShape('crossbar', pa);
  mxUtils.extend(Ja, mxActor);
  Ja.prototype.dx = 20;
  Ja.prototype.dy = 20;
  Ja.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx))));
    c = Math.max(0, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
    parseFloat(mxUtils.getValue(this.style, 'size', this.size));
    var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(0, 0),
        new mxPoint(d, 0),
        new mxPoint(d, c),
        new mxPoint((d + b) / 2, c),
        new mxPoint((d + b) / 2, e),
        new mxPoint((d - b) / 2, e),
        new mxPoint((d - b) / 2, c),
        new mxPoint(0, c),
      ],
      this.isRounded,
      f,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('tee', Ja);
  mxUtils.extend(ba, mxActor);
  ba.prototype.arrowWidth = 0.3;
  ba.prototype.arrowSize = 0.2;
  ba.prototype.redrawPath = function (a, b, c, d, e) {
    var f = e * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', this.arrowWidth))));
    b = d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', this.arrowSize))));
    c = (e - f) / 2;
    var f = c + f,
      g = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(0, c),
        new mxPoint(d - b, c),
        new mxPoint(d - b, 0),
        new mxPoint(d, e / 2),
        new mxPoint(d - b, e),
        new mxPoint(d - b, f),
        new mxPoint(0, f),
      ],
      this.isRounded,
      g,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('singleArrow', ba);
  mxUtils.extend(E, mxActor);
  E.prototype.redrawPath = function (a, b, c, d, e) {
    var f =
      e * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', ba.prototype.arrowWidth))));
    b = d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', ba.prototype.arrowSize))));
    c = (e - f) / 2;
    var f = c + f,
      g = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(0, e / 2),
        new mxPoint(b, 0),
        new mxPoint(b, c),
        new mxPoint(d - b, c),
        new mxPoint(d - b, 0),
        new mxPoint(d, e / 2),
        new mxPoint(d - b, e),
        new mxPoint(d - b, f),
        new mxPoint(b, f),
        new mxPoint(b, e),
      ],
      this.isRounded,
      g,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('doubleArrow', E);
  mxUtils.extend(I, mxActor);
  I.prototype.size = 0.1;
  I.prototype.fixedSize = 20;
  I.prototype.redrawPath = function (a, b, c, d, e) {
    b =
      '0' != mxUtils.getValue(this.style, 'fixedSize', '0')
        ? Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'size', this.fixedSize))))
        : d * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    a.moveTo(b, 0);
    a.lineTo(d, 0);
    a.quadTo(d - 2 * b, e / 2, d, e);
    a.lineTo(b, e);
    a.quadTo(b - 2 * b, e / 2, b, 0);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('dataStorage', I);
  mxUtils.extend(F, mxActor);
  F.prototype.redrawPath = function (a, b, c, d, e) {
    a.moveTo(0, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, 0, e);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('or', F);
  mxUtils.extend(N, mxActor);
  N.prototype.redrawPath = function (a, b, c, d, e) {
    a.moveTo(0, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, 0, e);
    a.quadTo(d / 2, e / 2, 0, 0);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('xor', N);
  mxUtils.extend(V, mxActor);
  V.prototype.size = 20;
  V.prototype.isRoundable = function () {
    return !0;
  };
  V.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(d / 2, Math.min(e, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [
        new mxPoint(b, 0),
        new mxPoint(d - b, 0),
        new mxPoint(d, 0.8 * b),
        new mxPoint(d, e),
        new mxPoint(0, e),
        new mxPoint(0, 0.8 * b),
      ],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('loopLimit', V);
  mxUtils.extend(Q, mxActor);
  Q.prototype.size = 0.375;
  Q.prototype.isRoundable = function () {
    return !0;
  };
  Q.prototype.redrawPath = function (a, b, c, d, e) {
    b = e * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
    this.addPoints(
      a,
      [new mxPoint(0, 0), new mxPoint(d, 0), new mxPoint(d, e - b), new mxPoint(d / 2, e), new mxPoint(0, e - b)],
      this.isRounded,
      c,
      !0
    );
    a.end();
  };
  mxCellRenderer.registerShape('offPageConnector', Q);
  mxUtils.extend(X, mxEllipse);
  X.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxEllipse.prototype.paintVertexShape.apply(this, arguments);
    a.begin();
    a.moveTo(b + d / 2, c + e);
    a.lineTo(b + d, c + e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('tapeData', X);
  mxUtils.extend(ja, mxEllipse);
  ja.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxEllipse.prototype.paintVertexShape.apply(this, arguments);
    a.setShadow(!1);
    a.begin();
    a.moveTo(b, c + e / 2);
    a.lineTo(b + d, c + e / 2);
    a.end();
    a.stroke();
    a.begin();
    a.moveTo(b + d / 2, c);
    a.lineTo(b + d / 2, c + e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('orEllipse', ja);
  mxUtils.extend(Qa, mxEllipse);
  Qa.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxEllipse.prototype.paintVertexShape.apply(this, arguments);
    a.setShadow(!1);
    a.begin();
    a.moveTo(b + 0.145 * d, c + 0.145 * e);
    a.lineTo(b + 0.855 * d, c + 0.855 * e);
    a.end();
    a.stroke();
    a.begin();
    a.moveTo(b + 0.855 * d, c + 0.145 * e);
    a.lineTo(b + 0.145 * d, c + 0.855 * e);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('sumEllipse', Qa);
  mxUtils.extend(Ga, mxRhombus);
  Ga.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxRhombus.prototype.paintVertexShape.apply(this, arguments);
    a.setShadow(!1);
    a.begin();
    a.moveTo(b, c + e / 2);
    a.lineTo(b + d, c + e / 2);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('sortShape', Ga);
  mxUtils.extend(Ra, mxEllipse);
  Ra.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.begin();
    a.moveTo(b, c);
    a.lineTo(b + d, c);
    a.lineTo(b + d / 2, c + e / 2);
    a.close();
    a.fillAndStroke();
    a.begin();
    a.moveTo(b, c + e);
    a.lineTo(b + d, c + e);
    a.lineTo(b + d / 2, c + e / 2);
    a.close();
    a.fillAndStroke();
  };
  mxCellRenderer.registerShape('collate', Ra);
  mxUtils.extend(Sa, mxEllipse);
  Sa.prototype.paintVertexShape = function (a, b, c, d, e) {
    var f = a.state.strokeWidth / 2,
      g = 10 + 2 * f,
      k = c + e - g / 2;
    a.begin();
    a.moveTo(b, c);
    a.lineTo(b, c + e);
    a.moveTo(b + f, k);
    a.lineTo(b + f + g, k - g / 2);
    a.moveTo(b + f, k);
    a.lineTo(b + f + g, k + g / 2);
    a.moveTo(b + f, k);
    a.lineTo(b + d - f, k);
    a.moveTo(b + d, c);
    a.lineTo(b + d, c + e);
    a.moveTo(b + d - f, k);
    a.lineTo(b + d - g - f, k - g / 2);
    a.moveTo(b + d - f, k);
    a.lineTo(b + d - g - f, k + g / 2);
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('dimension', Sa);
  mxUtils.extend(ya, mxEllipse);
  ya.prototype.drawHidden = !0;
  ya.prototype.paintVertexShape = function (a, b, c, d, e) {
    this.outline || a.setStrokeColor(null);
    if (null != this.style) {
      var f = a.pointerEvents,
        g = null != this.fill && this.fill != mxConstants.NONE;
      '1' == mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') || g || (a.pointerEvents = !1);
      var k = '1' == mxUtils.getValue(this.style, 'top', '1'),
        h = '1' == mxUtils.getValue(this.style, 'left', '1'),
        q = '1' == mxUtils.getValue(this.style, 'right', '1'),
        l = '1' == mxUtils.getValue(this.style, 'bottom', '1');
      this.drawHidden || g || this.outline || k || q || l || h
        ? (a.rect(b, c, d, e),
          a.fill(),
          (a.pointerEvents = f),
          a.setStrokeColor(this.stroke),
          a.setLineCap('square'),
          a.begin(),
          a.moveTo(b, c),
          this.outline || k ? a.lineTo(b + d, c) : a.moveTo(b + d, c),
          this.outline || q ? a.lineTo(b + d, c + e) : a.moveTo(b + d, c + e),
          this.outline || l ? a.lineTo(b, c + e) : a.moveTo(b, c + e),
          (this.outline || h) && a.lineTo(b, c),
          a.end(),
          a.stroke(),
          a.setLineCap('flat'))
        : a.setStrokeColor(this.stroke);
    }
  };
  mxCellRenderer.registerShape('partialRectangle', ya);
  mxUtils.extend(Ma, mxEllipse);
  Ma.prototype.paintVertexShape = function (a, b, c, d, e) {
    mxEllipse.prototype.paintVertexShape.apply(this, arguments);
    a.setShadow(!1);
    a.begin();
    'vertical' == mxUtils.getValue(this.style, 'line')
      ? (a.moveTo(b + d / 2, c), a.lineTo(b + d / 2, c + e))
      : (a.moveTo(b, c + e / 2), a.lineTo(b + d, c + e / 2));
    a.end();
    a.stroke();
  };
  mxCellRenderer.registerShape('lineEllipse', Ma);
  mxUtils.extend(fa, mxActor);
  fa.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(d, e / 2);
    a.moveTo(0, 0);
    a.lineTo(d - b, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, d - b, e);
    a.lineTo(0, e);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('delay', fa);
  mxUtils.extend(S, mxActor);
  S.prototype.size = 0.2;
  S.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(e, d);
    var f = Math.max(0, Math.min(b, b * parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    b = (e - f) / 2;
    c = b + f;
    var g = (d - f) / 2,
      f = g + f;
    a.moveTo(0, b);
    a.lineTo(g, b);
    a.lineTo(g, 0);
    a.lineTo(f, 0);
    a.lineTo(f, b);
    a.lineTo(d, b);
    a.lineTo(d, c);
    a.lineTo(f, c);
    a.lineTo(f, e);
    a.lineTo(g, e);
    a.lineTo(g, c);
    a.lineTo(0, c);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('cross', S);
  mxUtils.extend(ma, mxActor);
  ma.prototype.size = 0.25;
  ma.prototype.redrawPath = function (a, b, c, d, e) {
    b = Math.min(d, e / 2);
    c = Math.min(d - b, Math.max(0, parseFloat(mxUtils.getValue(this.style, 'size', this.size))) * d);
    a.moveTo(0, e / 2);
    a.lineTo(c, 0);
    a.lineTo(d - b, 0);
    a.quadTo(d, 0, d, e / 2);
    a.quadTo(d, e, d - b, e);
    a.lineTo(c, e);
    a.close();
    a.end();
  };
  mxCellRenderer.registerShape('display', ma);
  mxUtils.extend(R, mxActor);
  R.prototype.cst = { RECT2: 'mxgraph.basic.rect' };
  R.prototype.customProperties = [
    {
      name: 'rectStyle',
      dispName: 'Style',
      type: 'enum',
      defVal: 'square',
      enumList: [
        { val: 'square', dispName: 'Square' },
        { val: 'rounded', dispName: 'Round' },
        { val: 'snip', dispName: 'Snip' },
        { val: 'invRound', dispName: 'Inv. Round' },
        { val: 'fold', dispName: 'Fold' },
      ],
    },
    { name: 'size', dispName: 'Corner Size', type: 'float', defVal: 10 },
    { name: 'absoluteCornerSize', dispName: 'Abs. Corner Size', type: 'bool', defVal: !0 },
    { name: 'indent', dispName: 'Indent', type: 'float', defVal: 2 },
    {
      name: 'rectOutline',
      dispName: 'Outline',
      type: 'enum',
      defVal: 'single',
      enumList: [
        { val: 'single', dispName: 'Single' },
        { val: 'double', dispName: 'Double' },
        { val: 'frame', dispName: 'Frame' },
      ],
    },
    { name: 'fillColor2', dispName: 'Inside Fill Color', type: 'color', defVal: 'none' },
    { name: 'gradientColor2', dispName: 'Inside Gradient Color', type: 'color', defVal: 'none' },
    {
      name: 'gradientDirection2',
      dispName: 'Inside Gradient Direction',
      type: 'enum',
      defVal: 'south',
      enumList: [
        { val: 'south', dispName: 'South' },
        { val: 'west', dispName: 'West' },
        { val: 'north', dispName: 'North' },
        { val: 'east', dispName: 'East' },
      ],
    },
    { name: 'top', dispName: 'Top Line', type: 'bool', defVal: !0 },
    { name: 'right', dispName: 'Right', type: 'bool', defVal: !0 },
    { name: 'bottom', dispName: 'Bottom Line', type: 'bool', defVal: !0 },
    { name: 'left', dispName: 'Left ', type: 'bool', defVal: !0 },
    {
      name: 'topLeftStyle',
      dispName: 'Top Left Style',
      type: 'enum',
      defVal: 'default',
      enumList: [
        { val: 'default', dispName: 'Default' },
        { val: 'square', dispName: 'Square' },
        { val: 'rounded', dispName: 'Round' },
        { val: 'snip', dispName: 'Snip' },
        { val: 'invRound', dispName: 'Inv. Round' },
        { val: 'fold', dispName: 'Fold' },
      ],
    },
    {
      name: 'topRightStyle',
      dispName: 'Top Right Style',
      type: 'enum',
      defVal: 'default',
      enumList: [
        { val: 'default', dispName: 'Default' },
        { val: 'square', dispName: 'Square' },
        { val: 'rounded', dispName: 'Round' },
        { val: 'snip', dispName: 'Snip' },
        { val: 'invRound', dispName: 'Inv. Round' },
        { val: 'fold', dispName: 'Fold' },
      ],
    },
    {
      name: 'bottomRightStyle',
      dispName: 'Bottom Right Style',
      type: 'enum',
      defVal: 'default',
      enumList: [
        { val: 'default', dispName: 'Default' },
        { val: 'square', dispName: 'Square' },
        { val: 'rounded', dispName: 'Round' },
        { val: 'snip', dispName: 'Snip' },
        { val: 'invRound', dispName: 'Inv. Round' },
        { val: 'fold', dispName: 'Fold' },
      ],
    },
    {
      name: 'bottomLeftStyle',
      dispName: 'Bottom Left Style',
      type: 'enum',
      defVal: 'default',
      enumList: [
        { val: 'default', dispName: 'Default' },
        { val: 'square', dispName: 'Square' },
        { val: 'rounded', dispName: 'Round' },
        { val: 'snip', dispName: 'Snip' },
        { val: 'invRound', dispName: 'Inv. Round' },
        { val: 'fold', dispName: 'Fold' },
      ],
    },
  ];
  R.prototype.paintVertexShape = function (a, b, c, d, e) {
    a.translate(b, c);
    this.strictDrawShape(a, 0, 0, d, e);
  };
  R.prototype.strictDrawShape = function (a, b, c, d, e, f) {
    var g = f && f.rectStyle ? f.rectStyle : mxUtils.getValue(this.style, 'rectStyle', this.rectStyle),
      k =
        f && f.absoluteCornerSize
          ? f.absoluteCornerSize
          : mxUtils.getValue(this.style, 'absoluteCornerSize', this.absoluteCornerSize),
      h = f && f.size ? f.size : Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))),
      l = f && f.rectOutline ? f.rectOutline : mxUtils.getValue(this.style, 'rectOutline', this.rectOutline),
      q =
        f && f.indent
          ? f.indent
          : Math.max(0, Math.min(d, parseFloat(mxUtils.getValue(this.style, 'indent', this.indent)))),
      m = f && f.dashed ? f.dashed : mxUtils.getValue(this.style, 'dashed', !1),
      n = f && f.dashPattern ? f.dashPattern : mxUtils.getValue(this.style, 'dashPattern', null),
      w = f && f.relIndent ? f.relIndent : Math.max(0, Math.min(50, q)),
      p = f && f.top ? f.top : mxUtils.getValue(this.style, 'top', !0),
      A = f && f.right ? f.right : mxUtils.getValue(this.style, 'right', !0),
      y = f && f.bottom ? f.bottom : mxUtils.getValue(this.style, 'bottom', !0),
      r = f && f.left ? f.left : mxUtils.getValue(this.style, 'left', !0),
      t = f && f.topLeftStyle ? f.topLeftStyle : mxUtils.getValue(this.style, 'topLeftStyle', 'default'),
      G = f && f.topRightStyle ? f.topRightStyle : mxUtils.getValue(this.style, 'topRightStyle', 'default'),
      u = f && f.bottomRightStyle ? f.bottomRightStyle : mxUtils.getValue(this.style, 'bottomRightStyle', 'default'),
      H = f && f.bottomLeftStyle ? f.bottomLeftStyle : mxUtils.getValue(this.style, 'bottomLeftStyle', 'default'),
      v = f && f.fillColor ? f.fillColor : mxUtils.getValue(this.style, 'fillColor', '#ffffff');
    (f && f.strokeColor) || mxUtils.getValue(this.style, 'strokeColor', '#000000');
    var x = f && f.strokeWidth ? f.strokeWidth : mxUtils.getValue(this.style, 'strokeWidth', '1'),
      z = f && f.fillColor2 ? f.fillColor2 : mxUtils.getValue(this.style, 'fillColor2', 'none'),
      B = f && f.gradientColor2 ? f.gradientColor2 : mxUtils.getValue(this.style, 'gradientColor2', 'none'),
      C =
        f && f.gradientDirection2 ? f.gradientDirection2 : mxUtils.getValue(this.style, 'gradientDirection2', 'south'),
      D = f && f.opacity ? f.opacity : mxUtils.getValue(this.style, 'opacity', '100'),
      E = Math.max(0, Math.min(50, h));
    f = R.prototype;
    a.setDashed(m);
    n && '' != n && a.setDashPattern(n);
    a.setStrokeWidth(x);
    h = Math.min(0.5 * e, 0.5 * d, h);
    k || (h = (E * Math.min(d, e)) / 100);
    h = Math.min(h, 0.5 * Math.min(d, e));
    k || (q = Math.min((w * Math.min(d, e)) / 100));
    q = Math.min(q, 0.5 * Math.min(d, e) - h);
    (p || A || y || r) &&
      'frame' != l &&
      (a.begin(),
      p ? f.moveNW(a, b, c, d, e, g, t, h, r) : a.moveTo(0, 0),
      p && f.paintNW(a, b, c, d, e, g, t, h, r),
      f.paintTop(a, b, c, d, e, g, G, h, A),
      A && f.paintNE(a, b, c, d, e, g, G, h, p),
      f.paintRight(a, b, c, d, e, g, u, h, y),
      y && f.paintSE(a, b, c, d, e, g, u, h, A),
      f.paintBottom(a, b, c, d, e, g, H, h, r),
      r && f.paintSW(a, b, c, d, e, g, H, h, y),
      f.paintLeft(a, b, c, d, e, g, t, h, p),
      a.close(),
      a.fill(),
      a.setShadow(!1),
      a.setFillColor(z),
      (m = k = D),
      'none' == z && (k = 0),
      'none' == B && (m = 0),
      a.setGradient(z, B, 0, 0, d, e, C, k, m),
      a.begin(),
      p ? f.moveNWInner(a, b, c, d, e, g, t, h, q, p, r) : a.moveTo(q, 0),
      f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
      r && y && f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
      f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
      y && A && f.paintSEInner(a, b, c, d, e, g, u, h, q),
      f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
      A && p && f.paintNEInner(a, b, c, d, e, g, G, h, q),
      f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
      p && r && f.paintNWInner(a, b, c, d, e, g, t, h, q),
      a.fill(),
      'none' == v && (a.begin(), f.paintFolds(a, b, c, d, e, g, t, G, u, H, h, p, A, y, r), a.stroke()));
    p || A || y || !r
      ? p || A || !y || r
        ? !p && !A && y && r
          ? 'frame' != l
            ? (a.begin(),
              f.moveSE(a, b, c, d, e, g, u, h, A),
              f.paintBottom(a, b, c, d, e, g, H, h, r),
              f.paintSW(a, b, c, d, e, g, H, h, y),
              f.paintLeft(a, b, c, d, e, g, t, h, p),
              'double' == l &&
                (f.moveNWInner(a, b, c, d, e, g, t, h, q, p, r),
                f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y)),
              a.stroke())
            : (a.begin(),
              f.moveSE(a, b, c, d, e, g, u, h, A),
              f.paintBottom(a, b, c, d, e, g, H, h, r),
              f.paintSW(a, b, c, d, e, g, H, h, y),
              f.paintLeft(a, b, c, d, e, g, t, h, p),
              f.lineNWInner(a, b, c, d, e, g, t, h, q, p, r),
              f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
              f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
              f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
              a.close(),
              a.fillAndStroke())
          : p || !A || y || r
          ? !p && A && !y && r
            ? 'frame' != l
              ? (a.begin(),
                f.moveSW(a, b, c, d, e, g, t, h, y),
                f.paintLeft(a, b, c, d, e, g, t, h, p),
                'double' == l &&
                  (f.moveNWInner(a, b, c, d, e, g, t, h, q, p, r), f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r)),
                a.stroke(),
                a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                'double' == l &&
                  (f.moveSEInner(a, b, c, d, e, g, u, h, q, y), f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A)),
                a.stroke())
              : (a.begin(),
                f.moveSW(a, b, c, d, e, g, t, h, y),
                f.paintLeft(a, b, c, d, e, g, t, h, p),
                f.lineNWInner(a, b, c, d, e, g, t, h, q, p, r),
                f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                a.close(),
                a.fillAndStroke(),
                a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                f.lineSEInner(a, b, c, d, e, g, u, h, q, y),
                f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                a.close(),
                a.fillAndStroke())
            : !p && A && y && !r
            ? 'frame' != l
              ? (a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                f.paintSE(a, b, c, d, e, g, u, h, A),
                f.paintBottom(a, b, c, d, e, g, H, h, r),
                'double' == l &&
                  (f.moveSWInner(a, b, c, d, e, g, H, h, q, r),
                  f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                  f.paintSEInner(a, b, c, d, e, g, u, h, q),
                  f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A)),
                a.stroke())
              : (a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                f.paintSE(a, b, c, d, e, g, u, h, A),
                f.paintBottom(a, b, c, d, e, g, H, h, r),
                f.lineSWInner(a, b, c, d, e, g, H, h, q, r),
                f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                f.paintSEInner(a, b, c, d, e, g, u, h, q),
                f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                a.close(),
                a.fillAndStroke())
            : !p && A && y && r
            ? 'frame' != l
              ? (a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                f.paintSE(a, b, c, d, e, g, u, h, A),
                f.paintBottom(a, b, c, d, e, g, H, h, r),
                f.paintSW(a, b, c, d, e, g, H, h, y),
                f.paintLeft(a, b, c, d, e, g, t, h, p),
                'double' == l &&
                  (f.moveNWInner(a, b, c, d, e, g, t, h, q, p, r),
                  f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                  f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                  f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                  f.paintSEInner(a, b, c, d, e, g, u, h, q),
                  f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A)),
                a.stroke())
              : (a.begin(),
                f.moveNE(a, b, c, d, e, g, G, h, p),
                f.paintRight(a, b, c, d, e, g, u, h, y),
                f.paintSE(a, b, c, d, e, g, u, h, A),
                f.paintBottom(a, b, c, d, e, g, H, h, r),
                f.paintSW(a, b, c, d, e, g, H, h, y),
                f.paintLeft(a, b, c, d, e, g, t, h, p),
                f.lineNWInner(a, b, c, d, e, g, t, h, q, p, r),
                f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                f.paintSEInner(a, b, c, d, e, g, u, h, q),
                f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                a.close(),
                a.fillAndStroke())
            : !p || A || y || r
            ? p && !A && !y && r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  'double' == l &&
                    (f.moveNEInner(a, b, c, d, e, g, G, h, q, A),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                    f.paintNWInner(a, b, c, d, e, g, t, h, q),
                    f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r)),
                  a.stroke())
                : (a.begin(),
                  f.moveSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.lineNEInner(a, b, c, d, e, g, G, h, q, A),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  f.paintNWInner(a, b, c, d, e, g, t, h, q),
                  f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                  a.close(),
                  a.fillAndStroke())
              : p && !A && y && !r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  'double' == l &&
                    (f.moveNEInner(a, b, c, d, e, g, G, h, q, A), f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p)),
                  a.stroke(),
                  a.begin(),
                  f.moveSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  'double' == l &&
                    (f.moveSWInner(a, b, c, d, e, g, H, h, q, r), f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y)),
                  a.stroke())
                : (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.lineNEInner(a, b, c, d, e, g, G, h, q, A),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  a.close(),
                  a.fillAndStroke(),
                  a.begin(),
                  f.moveSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  f.lineSWInner(a, b, c, d, e, g, H, h, q, r),
                  f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                  a.close(),
                  a.fillAndStroke())
              : p && !A && y && r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  f.paintSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  'double' == l &&
                    (f.moveNEInner(a, b, c, d, e, g, G, h, q, A),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                    f.paintNWInner(a, b, c, d, e, g, t, h, q),
                    f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                    f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                    f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y)),
                  a.stroke())
                : (a.begin(),
                  f.moveSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  f.paintSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.lineNEInner(a, b, c, d, e, g, G, h, q, A),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  f.paintNWInner(a, b, c, d, e, g, t, h, q),
                  f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                  f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                  f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                  a.close(),
                  a.fillAndStroke())
              : p && A && !y && !r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  'double' == l &&
                    (f.moveSEInner(a, b, c, d, e, g, u, h, q, y),
                    f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                    f.paintNEInner(a, b, c, d, e, g, G, h, q),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p)),
                  a.stroke())
                : (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  f.lineSEInner(a, b, c, d, e, g, u, h, q, y),
                  f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                  f.paintNEInner(a, b, c, d, e, g, G, h, q),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  a.close(),
                  a.fillAndStroke())
              : p && A && !y && r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  'double' == l &&
                    (f.moveSEInner(a, b, c, d, e, g, u, h, q, y),
                    f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                    f.paintNEInner(a, b, c, d, e, g, G, h, q),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                    f.paintNWInner(a, b, c, d, e, g, t, h, q),
                    f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r)),
                  a.stroke())
                : (a.begin(),
                  f.moveSW(a, b, c, d, e, g, H, h, y),
                  f.paintLeft(a, b, c, d, e, g, t, h, p),
                  f.paintNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  f.lineSEInner(a, b, c, d, e, g, u, h, q, y),
                  f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                  f.paintNEInner(a, b, c, d, e, g, G, h, q),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  f.paintNWInner(a, b, c, d, e, g, t, h, q),
                  f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                  a.close(),
                  a.fillAndStroke())
              : p && A && y && !r
              ? 'frame' != l
                ? (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  f.paintSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  'double' == l &&
                    (f.moveSWInner(a, b, c, d, e, g, H, h, q, r),
                    f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                    f.paintSEInner(a, b, c, d, e, g, u, h, q),
                    f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                    f.paintNEInner(a, b, c, d, e, g, G, h, q),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p)),
                  a.stroke())
                : (a.begin(),
                  f.moveNW(a, b, c, d, e, g, t, h, r),
                  f.paintTop(a, b, c, d, e, g, G, h, A),
                  f.paintNE(a, b, c, d, e, g, G, h, p),
                  f.paintRight(a, b, c, d, e, g, u, h, y),
                  f.paintSE(a, b, c, d, e, g, u, h, A),
                  f.paintBottom(a, b, c, d, e, g, H, h, r),
                  f.lineSWInner(a, b, c, d, e, g, H, h, q, r),
                  f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                  f.paintSEInner(a, b, c, d, e, g, u, h, q),
                  f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                  f.paintNEInner(a, b, c, d, e, g, G, h, q),
                  f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                  a.close(),
                  a.fillAndStroke())
              : p &&
                A &&
                y &&
                r &&
                ('frame' != l
                  ? (a.begin(),
                    f.moveNW(a, b, c, d, e, g, t, h, r),
                    f.paintNW(a, b, c, d, e, g, t, h, r),
                    f.paintTop(a, b, c, d, e, g, G, h, A),
                    f.paintNE(a, b, c, d, e, g, G, h, p),
                    f.paintRight(a, b, c, d, e, g, u, h, y),
                    f.paintSE(a, b, c, d, e, g, u, h, A),
                    f.paintBottom(a, b, c, d, e, g, H, h, r),
                    f.paintSW(a, b, c, d, e, g, H, h, y),
                    f.paintLeft(a, b, c, d, e, g, t, h, p),
                    a.close(),
                    'double' == l &&
                      (f.moveSWInner(a, b, c, d, e, g, H, h, q, r),
                      f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                      f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                      f.paintSEInner(a, b, c, d, e, g, u, h, q),
                      f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                      f.paintNEInner(a, b, c, d, e, g, G, h, q),
                      f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                      f.paintNWInner(a, b, c, d, e, g, t, h, q),
                      f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                      a.close()),
                    a.stroke())
                  : (a.begin(),
                    f.moveNW(a, b, c, d, e, g, t, h, r),
                    f.paintNW(a, b, c, d, e, g, t, h, r),
                    f.paintTop(a, b, c, d, e, g, G, h, A),
                    f.paintNE(a, b, c, d, e, g, G, h, p),
                    f.paintRight(a, b, c, d, e, g, u, h, y),
                    f.paintSE(a, b, c, d, e, g, u, h, A),
                    f.paintBottom(a, b, c, d, e, g, H, h, r),
                    f.paintSW(a, b, c, d, e, g, H, h, y),
                    f.paintLeft(a, b, c, d, e, g, t, h, p),
                    a.close(),
                    f.moveSWInner(a, b, c, d, e, g, H, h, q, r),
                    f.paintSWInner(a, b, c, d, e, g, H, h, q, y),
                    f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
                    f.paintSEInner(a, b, c, d, e, g, u, h, q),
                    f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
                    f.paintNEInner(a, b, c, d, e, g, G, h, q),
                    f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
                    f.paintNWInner(a, b, c, d, e, g, t, h, q),
                    f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
                    a.close(),
                    a.fillAndStroke()))
            : 'frame' != l
            ? (a.begin(),
              f.moveNW(a, b, c, d, e, g, t, h, r),
              f.paintTop(a, b, c, d, e, g, G, h, A),
              'double' == l &&
                (f.moveNEInner(a, b, c, d, e, g, G, h, q, A), f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p)),
              a.stroke())
            : (a.begin(),
              f.moveNW(a, b, c, d, e, g, t, h, r),
              f.paintTop(a, b, c, d, e, g, G, h, A),
              f.lineNEInner(a, b, c, d, e, g, G, h, q, A),
              f.paintTopInner(a, b, c, d, e, g, t, h, q, r, p),
              a.close(),
              a.fillAndStroke())
          : 'frame' != l
          ? (a.begin(),
            f.moveNE(a, b, c, d, e, g, G, h, p),
            f.paintRight(a, b, c, d, e, g, u, h, y),
            'double' == l &&
              (f.moveSEInner(a, b, c, d, e, g, u, h, q, y), f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A)),
            a.stroke())
          : (a.begin(),
            f.moveNE(a, b, c, d, e, g, G, h, p),
            f.paintRight(a, b, c, d, e, g, u, h, y),
            f.lineSEInner(a, b, c, d, e, g, u, h, q, y),
            f.paintRightInner(a, b, c, d, e, g, G, h, q, p, A),
            a.close(),
            a.fillAndStroke())
        : 'frame' != l
        ? (a.begin(),
          f.moveSE(a, b, c, d, e, g, u, h, A),
          f.paintBottom(a, b, c, d, e, g, H, h, r),
          'double' == l &&
            (f.moveSWInner(a, b, c, d, e, g, H, h, q, r), f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y)),
          a.stroke())
        : (a.begin(),
          f.moveSE(a, b, c, d, e, g, u, h, A),
          f.paintBottom(a, b, c, d, e, g, H, h, r),
          f.lineSWInner(a, b, c, d, e, g, H, h, q, r),
          f.paintBottomInner(a, b, c, d, e, g, u, h, q, A, y),
          a.close(),
          a.fillAndStroke())
      : 'frame' != l
      ? (a.begin(),
        f.moveSW(a, b, c, d, e, g, t, h, y),
        f.paintLeft(a, b, c, d, e, g, t, h, p),
        'double' == l &&
          (f.moveNWInner(a, b, c, d, e, g, t, h, q, p, r), f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r)),
        a.stroke())
      : (a.begin(),
        f.moveSW(a, b, c, d, e, g, t, h, y),
        f.paintLeft(a, b, c, d, e, g, t, h, p),
        f.lineNWInner(a, b, c, d, e, g, t, h, q, p, r),
        f.paintLeftInner(a, b, c, d, e, g, H, h, q, y, r),
        a.close(),
        a.fillAndStroke());
    a.begin();
    f.paintFolds(a, b, c, d, e, g, t, G, u, H, h, p, A, y, r);
    a.stroke();
  };
  R.prototype.moveNW = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.moveTo(0, 0) : a.moveTo(0, h);
  };
  R.prototype.moveNE = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.moveTo(d, 0) : a.moveTo(d - h, 0);
  };
  R.prototype.moveSE = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.moveTo(d, e) : a.moveTo(d, e - h);
  };
  R.prototype.moveSW = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.moveTo(0, e) : a.moveTo(h, e);
  };
  R.prototype.paintNW = function (a, b, c, d, e, f, g, h, k) {
    if (k)
      if (
        'rounded' == g ||
        ('default' == g && 'rounded' == f) ||
        'invRound' == g ||
        ('default' == g && 'invRound' == f)
      ) {
        b = 0;
        if ('rounded' == g || ('default' == g && 'rounded' == f)) b = 1;
        a.arcTo(h, h, 0, 0, b, h, 0);
      } else
        ('snip' == g || ('default' == g && 'snip' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(h, 0);
    else a.lineTo(0, 0);
  };
  R.prototype.paintTop = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.lineTo(d, 0) : a.lineTo(d - h, 0);
  };
  R.prototype.paintNE = function (a, b, c, d, e, f, g, h, k) {
    if (k)
      if (
        'rounded' == g ||
        ('default' == g && 'rounded' == f) ||
        'invRound' == g ||
        ('default' == g && 'invRound' == f)
      ) {
        b = 0;
        if ('rounded' == g || ('default' == g && 'rounded' == f)) b = 1;
        a.arcTo(h, h, 0, 0, b, d, h);
      } else
        ('snip' == g || ('default' == g && 'snip' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(d, h);
    else a.lineTo(d, 0);
  };
  R.prototype.paintRight = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.lineTo(d, e) : a.lineTo(d, e - h);
  };
  R.prototype.paintLeft = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.lineTo(0, 0) : a.lineTo(0, h);
  };
  R.prototype.paintSE = function (a, b, c, d, e, f, g, h, k) {
    if (k)
      if (
        'rounded' == g ||
        ('default' == g && 'rounded' == f) ||
        'invRound' == g ||
        ('default' == g && 'invRound' == f)
      ) {
        b = 0;
        if ('rounded' == g || ('default' == g && 'rounded' == f)) b = 1;
        a.arcTo(h, h, 0, 0, b, d - h, e);
      } else
        ('snip' == g || ('default' == g && 'snip' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(d - h, e);
    else a.lineTo(d, e);
  };
  R.prototype.paintBottom = function (a, b, c, d, e, f, g, h, k) {
    'square' == g || ('default' == g && 'square' == f) || !k ? a.lineTo(0, e) : a.lineTo(h, e);
  };
  R.prototype.paintSW = function (a, b, c, d, e, f, g, h, k) {
    if (k)
      if (
        'rounded' == g ||
        ('default' == g && 'rounded' == f) ||
        'invRound' == g ||
        ('default' == g && 'invRound' == f)
      ) {
        b = 0;
        if ('rounded' == g || ('default' == g && 'rounded' == f)) b = 1;
        a.arcTo(h, h, 0, 0, b, 0, e - h);
      } else
        ('snip' == g || ('default' == g && 'snip' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(0, e - h);
    else a.lineTo(0, e);
  };
  R.prototype.paintNWInner = function (a, b, c, d, e, f, g, h, k) {
    if ('rounded' == g || ('default' == g && 'rounded' == f))
      a.arcTo(h - 0.5 * k, h - 0.5 * k, 0, 0, 0, k, 0.5 * k + h);
    else if ('invRound' == g || ('default' == g && 'invRound' == f)) a.arcTo(h + k, h + k, 0, 0, 1, k, k + h);
    else if ('snip' == g || ('default' == g && 'snip' == f)) a.lineTo(k, 0.5 * k + h);
    else if ('fold' == g || ('default' == g && 'fold' == f)) a.lineTo(k + h, k + h), a.lineTo(k, k + h);
  };
  R.prototype.paintTopInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.lineTo(0, k)
        : l && !m
        ? a.lineTo(k, 0)
        : l
        ? 'square' == g || ('default' == g && 'square' == f)
          ? a.lineTo(k, k)
          : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
          ? a.lineTo(h + 0.5 * k, k)
          : a.lineTo(h + k, k)
        : a.lineTo(0, k)
      : a.lineTo(0, 0);
  };
  R.prototype.paintNEInner = function (a, b, c, d, e, f, g, h, k) {
    if ('rounded' == g || ('default' == g && 'rounded' == f))
      a.arcTo(h - 0.5 * k, h - 0.5 * k, 0, 0, 0, d - h - 0.5 * k, k);
    else if ('invRound' == g || ('default' == g && 'invRound' == f)) a.arcTo(h + k, h + k, 0, 0, 1, d - h - k, k);
    else if ('snip' == g || ('default' == g && 'snip' == f)) a.lineTo(d - h - 0.5 * k, k);
    else if ('fold' == g || ('default' == g && 'fold' == f)) a.lineTo(d - h - k, h + k), a.lineTo(d - h - k, k);
  };
  R.prototype.paintRightInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.lineTo(d - k, 0)
        : l && !m
        ? a.lineTo(d, k)
        : l
        ? 'square' == g || ('default' == g && 'square' == f)
          ? a.lineTo(d - k, k)
          : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
          ? a.lineTo(d - k, h + 0.5 * k)
          : a.lineTo(d - k, h + k)
        : a.lineTo(d - k, 0)
      : a.lineTo(d, 0);
  };
  R.prototype.paintLeftInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.lineTo(k, e)
        : l && !m
        ? a.lineTo(0, e - k)
        : l
        ? 'square' == g || ('default' == g && 'square' == f)
          ? a.lineTo(k, e - k)
          : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
          ? a.lineTo(k, e - h - 0.5 * k)
          : a.lineTo(k, e - h - k)
        : a.lineTo(k, e)
      : a.lineTo(0, e);
  };
  R.prototype.paintSEInner = function (a, b, c, d, e, f, g, h, k) {
    if ('rounded' == g || ('default' == g && 'rounded' == f))
      a.arcTo(h - 0.5 * k, h - 0.5 * k, 0, 0, 0, d - k, e - h - 0.5 * k);
    else if ('invRound' == g || ('default' == g && 'invRound' == f)) a.arcTo(h + k, h + k, 0, 0, 1, d - k, e - h - k);
    else if ('snip' == g || ('default' == g && 'snip' == f)) a.lineTo(d - k, e - h - 0.5 * k);
    else if ('fold' == g || ('default' == g && 'fold' == f)) a.lineTo(d - h - k, e - h - k), a.lineTo(d - k, e - h - k);
  };
  R.prototype.paintBottomInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.lineTo(d, e - k)
        : l && !m
        ? a.lineTo(d - k, e)
        : 'square' == g || ('default' == g && 'square' == f) || !l
        ? a.lineTo(d - k, e - k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.lineTo(d - h - 0.5 * k, e - k)
        : a.lineTo(d - h - k, e - k)
      : a.lineTo(d, e);
  };
  R.prototype.paintSWInner = function (a, b, c, d, e, f, g, h, k, l) {
    if (!l) a.lineTo(k, e);
    else if ('square' == g || ('default' == g && 'square' == f)) a.lineTo(k, e - k);
    else if ('rounded' == g || ('default' == g && 'rounded' == f))
      a.arcTo(h - 0.5 * k, h - 0.5 * k, 0, 0, 0, h + 0.5 * k, e - k);
    else if ('invRound' == g || ('default' == g && 'invRound' == f)) a.arcTo(h + k, h + k, 0, 0, 1, h + k, e - k);
    else if ('snip' == g || ('default' == g && 'snip' == f)) a.lineTo(h + 0.5 * k, e - k);
    else if ('fold' == g || ('default' == g && 'fold' == f)) a.lineTo(k + h, e - h - k), a.lineTo(k + h, e - k);
  };
  R.prototype.moveSWInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f)
        ? a.moveTo(k, e - k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.moveTo(k, e - h - 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.moveTo(k, e - h - k)
      : a.moveTo(0, e - k);
  };
  R.prototype.lineSWInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f)
        ? a.lineTo(k, e - k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.lineTo(k, e - h - 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(k, e - h - k)
      : a.lineTo(0, e - k);
  };
  R.prototype.moveSEInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f)
        ? a.moveTo(d - k, e - k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.moveTo(d - k, e - h - 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.moveTo(d - k, e - h - k)
      : a.moveTo(d - k, e);
  };
  R.prototype.lineSEInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f)
        ? a.lineTo(d - k, e - k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.lineTo(d - k, e - h - 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(d - k, e - h - k)
      : a.lineTo(d - k, e);
  };
  R.prototype.moveNEInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f) || l
        ? a.moveTo(d - k, k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.moveTo(d - k, h + 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.moveTo(d - k, h + k)
      : a.moveTo(d, k);
  };
  R.prototype.lineNEInner = function (a, b, c, d, e, f, g, h, k, l) {
    l
      ? 'square' == g || ('default' == g && 'square' == f) || l
        ? a.lineTo(d - k, k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.lineTo(d - k, h + 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(d - k, h + k)
      : a.lineTo(d, k);
  };
  R.prototype.moveNWInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.moveTo(k, 0)
        : l && !m
        ? a.moveTo(0, k)
        : 'square' == g || ('default' == g && 'square' == f)
        ? a.moveTo(k, k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.moveTo(k, h + 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.moveTo(k, h + k)
      : a.moveTo(0, 0);
  };
  R.prototype.lineNWInner = function (a, b, c, d, e, f, g, h, k, l, m) {
    l || m
      ? !l && m
        ? a.lineTo(k, 0)
        : l && !m
        ? a.lineTo(0, k)
        : 'square' == g || ('default' == g && 'square' == f)
        ? a.lineTo(k, k)
        : 'rounded' == g || ('default' == g && 'rounded' == f) || 'snip' == g || ('default' == g && 'snip' == f)
        ? a.lineTo(k, h + 0.5 * k)
        : ('invRound' == g || ('default' == g && 'invRound' == f) || 'fold' == g || ('default' == g && 'fold' == f)) &&
          a.lineTo(k, h + k)
      : a.lineTo(0, 0);
  };
  R.prototype.paintFolds = function (a, b, c, d, e, f, g, h, k, l, m, n, p, r, t) {
    if ('fold' == f || 'fold' == g || 'fold' == h || 'fold' == k || 'fold' == l)
      ('fold' == g || ('default' == g && 'fold' == f)) && n && t && (a.moveTo(0, m), a.lineTo(m, m), a.lineTo(m, 0)),
        ('fold' == h || ('default' == h && 'fold' == f)) &&
          n &&
          p &&
          (a.moveTo(d - m, 0), a.lineTo(d - m, m), a.lineTo(d, m)),
        ('fold' == k || ('default' == k && 'fold' == f)) &&
          r &&
          p &&
          (a.moveTo(d - m, e), a.lineTo(d - m, e - m), a.lineTo(d, e - m)),
        ('fold' == l || ('default' == l && 'fold' == f)) &&
          r &&
          t &&
          (a.moveTo(0, e - m), a.lineTo(m, e - m), a.lineTo(m, e));
  };
  mxCellRenderer.registerShape(R.prototype.cst.RECT2, R);
  R.prototype.constraints = null;
  mxUtils.extend(ra, mxConnector);
  ra.prototype.origPaintEdgeShape = ra.prototype.paintEdgeShape;
  ra.prototype.paintEdgeShape = function (a, b, c) {
    for (var d = [], e = 0; e < b.length; e++) d.push(mxUtils.clone(b[e]));
    var e = a.state.dashed,
      f = a.state.fixDash;
    ra.prototype.origPaintEdgeShape.apply(this, [a, d, c]);
    3 <= a.state.strokeWidth &&
      ((d = mxUtils.getValue(this.style, 'fillColor', null)),
      null != d &&
        (a.setStrokeColor(d),
        a.setStrokeWidth(a.state.strokeWidth - 2),
        a.setDashed(e, f),
        ra.prototype.origPaintEdgeShape.apply(this, [a, b, c])));
  };
  mxCellRenderer.registerShape('filledEdge', ra);
  'undefined' !== typeof StyleFormatPanel &&
    (function () {
      var a = StyleFormatPanel.prototype.getCustomColors;
      StyleFormatPanel.prototype.getCustomColors = function () {
        var b = this.editorUi.getSelectionState(),
          c = a.apply(this, arguments);
        'umlFrame' == b.style.shape &&
          c.push({ title: mxResources.get('laneColor'), key: 'swimlaneFillColor', defaultValue: 'default' });
        return c;
      };
    })();
  mxMarker.addMarker('dash', function (a, b, c, d, e, f, g, h, k, l) {
    var q = e * (g + k + 1),
      m = f * (g + k + 1);
    return function () {
      a.begin();
      a.moveTo(d.x - q / 2 - m / 2, d.y - m / 2 + q / 2);
      a.lineTo(d.x + m / 2 - (3 * q) / 2, d.y - (3 * m) / 2 - q / 2);
      a.stroke();
    };
  });
  mxMarker.addMarker('box', function (a, b, c, d, e, f, g, h, k, l) {
    var q = e * (g + k + 1),
      m = f * (g + k + 1),
      n = d.x + q / 2,
      p = d.y + m / 2;
    d.x -= q;
    d.y -= m;
    return function () {
      a.begin();
      a.moveTo(n - q / 2 - m / 2, p - m / 2 + q / 2);
      a.lineTo(n - q / 2 + m / 2, p - m / 2 - q / 2);
      a.lineTo(n + m / 2 - (3 * q) / 2, p - (3 * m) / 2 - q / 2);
      a.lineTo(n - m / 2 - (3 * q) / 2, p - (3 * m) / 2 + q / 2);
      a.close();
      l ? a.fillAndStroke() : a.stroke();
    };
  });
  mxMarker.addMarker('cross', function (a, b, c, d, e, f, g, h, k, l) {
    var q = e * (g + k + 1),
      m = f * (g + k + 1);
    return function () {
      a.begin();
      a.moveTo(d.x - q / 2 - m / 2, d.y - m / 2 + q / 2);
      a.lineTo(d.x + m / 2 - (3 * q) / 2, d.y - (3 * m) / 2 - q / 2);
      a.moveTo(d.x - q / 2 + m / 2, d.y - m / 2 - q / 2);
      a.lineTo(d.x - m / 2 - (3 * q) / 2, d.y - (3 * m) / 2 + q / 2);
      a.stroke();
    };
  });
  mxMarker.addMarker('circle', ib);
  mxMarker.addMarker('circlePlus', function (a, b, c, d, e, f, g, h, k, l) {
    var m = d.clone(),
      q = ib.apply(this, arguments),
      n = e * (g + 2 * k),
      p = f * (g + 2 * k);
    return function () {
      q.apply(this, arguments);
      a.begin();
      a.moveTo(m.x - e * k, m.y - f * k);
      a.lineTo(m.x - 2 * n + e * k, m.y - 2 * p + f * k);
      a.moveTo(m.x - n - p + f * k, m.y - p + n - e * k);
      a.lineTo(m.x + p - n - f * k, m.y - p - n + e * k);
      a.stroke();
    };
  });
  mxMarker.addMarker('halfCircle', function (a, b, c, d, e, f, g, h, k, l) {
    var m = e * (g + k + 1),
      q = f * (g + k + 1),
      n = d.clone();
    d.x -= m;
    d.y -= q;
    return function () {
      a.begin();
      a.moveTo(n.x - q, n.y + m);
      a.quadTo(d.x - q, d.y + m, d.x, d.y);
      a.quadTo(d.x + q, d.y - m, n.x + q, n.y - m);
      a.stroke();
    };
  });
  mxMarker.addMarker('async', function (a, b, c, d, e, f, g, h, k, l) {
    b = e * k * 1.118;
    c = f * k * 1.118;
    e *= g + k;
    f *= g + k;
    var m = d.clone();
    m.x -= b;
    m.y -= c;
    d.x += 1 * -e - b;
    d.y += 1 * -f - c;
    return function () {
      a.begin();
      a.moveTo(m.x, m.y);
      h ? a.lineTo(m.x - e - f / 2, m.y - f + e / 2) : a.lineTo(m.x + f / 2 - e, m.y - f - e / 2);
      a.lineTo(m.x - e, m.y - f);
      a.close();
      l ? a.fillAndStroke() : a.stroke();
    };
  });
  mxMarker.addMarker(
    'openAsync',
    (function (a) {
      a = null != a ? a : 2;
      return function (b, c, d, e, f, g, h, k, l, m) {
        f *= h + l;
        g *= h + l;
        var q = e.clone();
        return function () {
          b.begin();
          b.moveTo(q.x, q.y);
          k ? b.lineTo(q.x - f - g / a, q.y - g + f / a) : b.lineTo(q.x + g / a - f, q.y - g - f / a);
          b.stroke();
        };
      };
    })(2)
  );
  if ('undefined' !== typeof mxVertexHandler) {
    var kb = function (a, b, c) {
        return aa(
          a,
          ['width'],
          b,
          function (b, d, e, f, g) {
            g = a.shape.getEdgeWidth() * a.view.scale + c;
            return new mxPoint(f.x + (d * b) / 4 + (e * g) / 2, f.y + (e * b) / 4 - (d * g) / 2);
          },
          function (b, d, e, f, g, h) {
            b = Math.sqrt(mxUtils.ptSegDistSq(f.x, f.y, g.x, g.y, h.x, h.y));
            a.style.width = Math.round(2 * b) / a.view.scale - c;
          }
        );
      },
      aa = function (a, b, c, d, e) {
        return W(
          a,
          b,
          function (b) {
            var e = a.absolutePoints,
              f = e.length - 1;
            b = a.view.translate;
            var g = a.view.scale,
              h = c ? e[0] : e[f],
              e = c ? e[1] : e[f - 1],
              f = e.x - h.x,
              k = e.y - h.y,
              l = Math.sqrt(f * f + k * k),
              h = d.call(this, l, f / l, k / l, h, e);
            return new mxPoint(h.x / g - b.x, h.y / g - b.y);
          },
          function (b, d, f) {
            var g = a.absolutePoints,
              h = g.length - 1;
            b = a.view.translate;
            var k = a.view.scale,
              l = c ? g[0] : g[h],
              g = c ? g[1] : g[h - 1],
              h = g.x - l.x,
              m = g.y - l.y,
              q = Math.sqrt(h * h + m * m);
            d.x = (d.x + b.x) * k;
            d.y = (d.y + b.y) * k;
            e.call(this, q, h / q, m / q, l, g, d, f);
          }
        );
      },
      Ha = function (a) {
        return function (b) {
          return [
            W(
              b,
              ['arrowWidth', 'arrowSize'],
              function (b) {
                var c = Math.max(
                    0,
                    Math.min(1, mxUtils.getValue(this.state.style, 'arrowWidth', ba.prototype.arrowWidth))
                  ),
                  d = Math.max(0, Math.min(a, mxUtils.getValue(this.state.style, 'arrowSize', ba.prototype.arrowSize)));
                return new mxPoint(b.x + (1 - d) * b.width, b.y + ((1 - c) * b.height) / 2);
              },
              function (b, c) {
                this.state.style.arrowWidth = Math.max(
                  0,
                  Math.min(1, (Math.abs(b.y + b.height / 2 - c.y) / b.height) * 2)
                );
                this.state.style.arrowSize = Math.max(0, Math.min(a, (b.x + b.width - c.x) / b.width));
              }
            ),
          ];
        };
      },
      ca = function (a) {
        return function (b) {
          return [
            W(
              b,
              ['size'],
              function (b) {
                var c = Math.max(
                  0,
                  Math.min(0.5 * b.height, parseFloat(mxUtils.getValue(this.state.style, 'size', a)))
                );
                return new mxPoint(b.x, b.y + c);
              },
              function (a, b) {
                this.state.style.size = Math.max(0, b.y - a.y);
              },
              !0
            ),
          ];
        };
      },
      Ua = function (a, b, c) {
        return function (d) {
          var e = [
            W(
              d,
              ['size'],
              function (c) {
                var d =
                  Math.max(
                    0,
                    Math.min(c.width, Math.min(c.height, parseFloat(mxUtils.getValue(this.state.style, 'size', b))))
                  ) * a;
                return new mxPoint(c.x + d, c.y + d);
              },
              function (b, c) {
                this.state.style.size = Math.round(
                  Math.max(0, Math.min(Math.min(b.width, c.x - b.x), Math.min(b.height, c.y - b.y))) / a
                );
              },
              !1
            ),
          ];
          c && mxUtils.getValue(d.style, mxConstants.STYLE_ROUNDED, !1) && e.push(Ia(d));
          return e;
        };
      },
      Ya = function (a, b, c, d, e) {
        c = null != c ? c : 0.5;
        return function (f) {
          var g = [
            W(
              f,
              ['size'],
              function (b) {
                var c = null != e ? '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0') : null,
                  d = parseFloat(mxUtils.getValue(this.state.style, 'size', c ? e : a));
                return new mxPoint(b.x + Math.max(0, Math.min(0.5 * b.width, d * (c ? 1 : b.width))), b.getCenterY());
              },
              function (a, b, d) {
                a =
                  null != e && '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0')
                    ? b.x - a.x
                    : Math.max(0, Math.min(c, (b.x - a.x) / a.width));
                this.state.style.size = a;
              },
              !1,
              d
            ),
          ];
          b && mxUtils.getValue(f.style, mxConstants.STYLE_ROUNDED, !1) && g.push(Ia(f));
          return g;
        };
      },
      pb = function (a, b, c) {
        a = null != a ? a : 0.5;
        return function (d) {
          var e = [
            W(
              d,
              ['size'],
              function (d) {
                var e = null != c ? '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0') : null,
                  f = Math.max(0, parseFloat(mxUtils.getValue(this.state.style, 'size', e ? c : b)));
                return new mxPoint(
                  d.x + Math.min(0.75 * d.width * a, f * (e ? 0.75 : 0.75 * d.width)),
                  d.y + d.height / 4
                );
              },
              function (b, d) {
                var e =
                  null != c && '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0')
                    ? d.x - b.x
                    : Math.max(0, Math.min(a, ((d.x - b.x) / b.width) * 0.75));
                this.state.style.size = e;
              },
              !1,
              !0
            ),
          ];
          mxUtils.getValue(d.style, mxConstants.STYLE_ROUNDED, !1) && e.push(Ia(d));
          return e;
        };
      },
      Za = function () {
        return function (a) {
          var b = [];
          mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED, !1) && b.push(Ia(a));
          return b;
        };
      },
      Ia = function (a, b) {
        return W(
          a,
          [mxConstants.STYLE_ARCSIZE],
          function (c) {
            var d = null != b ? b : c.height / 8;
            if ('1' == mxUtils.getValue(a.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)) {
              var e = mxUtils.getValue(a.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
              return new mxPoint(c.x + c.width - Math.min(c.width / 2, e), c.y + d);
            }
            e =
              Math.max(
                0,
                parseFloat(
                  mxUtils.getValue(a.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR)
                )
              ) / 100;
            return new mxPoint(
              c.x + c.width - Math.min(Math.max(c.width / 2, c.height / 2), Math.min(c.width, c.height) * e),
              c.y + d
            );
          },
          function (b, c, d) {
            '1' == mxUtils.getValue(a.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0)
              ? (this.state.style[mxConstants.STYLE_ARCSIZE] = Math.round(
                  Math.max(0, Math.min(b.width, 2 * (b.x + b.width - c.x)))
                ))
              : (this.state.style[mxConstants.STYLE_ARCSIZE] = Math.round(
                  Math.min(50, Math.max(0, (100 * (b.width - c.x + b.x)) / Math.min(b.width, b.height)))
                ));
          }
        );
      },
      W = function (a, b, c, d, e, f, g) {
        var h = new mxHandle(a, null, mxVertexHandler.prototype.secondaryHandleImage);
        h.execute = function (a) {
          for (var c = 0; c < b.length; c++) this.copyStyle(b[c]);
          g && g(a);
        };
        h.getPosition = c;
        h.setPosition = d;
        h.ignoreGrid = null != e ? e : !0;
        if (f) {
          var k = h.positionChanged;
          h.positionChanged = function () {
            k.apply(this, arguments);
            a.view.invalidate(this.state.cell);
            a.view.validate();
          };
        }
        return h;
      },
      va = {
        'link': function (a) {
          return [kb(a, !0, 10), kb(a, !1, 10)];
        },
        'flexArrow': function (a) {
          var b = a.view.graph.gridSize / a.view.scale,
            c = [];
          mxUtils.getValue(a.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE &&
            (c.push(
              aa(
                a,
                ['width', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE],
                !0,
                function (b, c, d, e, f) {
                  b = (a.shape.getEdgeWidth() - a.shape.strokewidth) * a.view.scale;
                  f =
                    3 *
                    mxUtils.getNumber(a.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) *
                    a.view.scale;
                  return new mxPoint(
                    e.x + c * (f + a.shape.strokewidth * a.view.scale) + (d * b) / 2,
                    e.y + d * (f + a.shape.strokewidth * a.view.scale) - (c * b) / 2
                  );
                },
                function (c, d, e, f, g, h, k) {
                  c = Math.sqrt(mxUtils.ptSegDistSq(f.x, f.y, g.x, g.y, h.x, h.y));
                  d = mxUtils.ptLineDist(f.x, f.y, f.x + e, f.y - d, h.x, h.y);
                  a.style[mxConstants.STYLE_STARTSIZE] =
                    Math.round((100 * (d - a.shape.strokewidth)) / 3) / 100 / a.view.scale;
                  a.style.width = Math.round(2 * c) / a.view.scale;
                  if (mxEvent.isShiftDown(k.getEvent()) || mxEvent.isControlDown(k.getEvent()))
                    a.style[mxConstants.STYLE_ENDSIZE] = a.style[mxConstants.STYLE_STARTSIZE];
                  mxEvent.isAltDown(k.getEvent()) ||
                    (Math.abs(
                      parseFloat(a.style[mxConstants.STYLE_STARTSIZE]) - parseFloat(a.style[mxConstants.STYLE_ENDSIZE])
                    ) <
                      b / 6 &&
                      (a.style[mxConstants.STYLE_STARTSIZE] = a.style[mxConstants.STYLE_ENDSIZE]));
                }
              )
            ),
            c.push(
              aa(
                a,
                ['startWidth', 'endWidth', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE],
                !0,
                function (b, c, d, e, f) {
                  b = (a.shape.getStartArrowWidth() - a.shape.strokewidth) * a.view.scale;
                  f =
                    3 *
                    mxUtils.getNumber(a.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) *
                    a.view.scale;
                  return new mxPoint(
                    e.x + c * (f + a.shape.strokewidth * a.view.scale) + (d * b) / 2,
                    e.y + d * (f + a.shape.strokewidth * a.view.scale) - (c * b) / 2
                  );
                },
                function (c, d, e, f, g, h, k) {
                  c = Math.sqrt(mxUtils.ptSegDistSq(f.x, f.y, g.x, g.y, h.x, h.y));
                  d = mxUtils.ptLineDist(f.x, f.y, f.x + e, f.y - d, h.x, h.y);
                  a.style[mxConstants.STYLE_STARTSIZE] =
                    Math.round((100 * (d - a.shape.strokewidth)) / 3) / 100 / a.view.scale;
                  a.style.startWidth = Math.max(0, Math.round(2 * c) - a.shape.getEdgeWidth()) / a.view.scale;
                  if (mxEvent.isShiftDown(k.getEvent()) || mxEvent.isControlDown(k.getEvent()))
                    (a.style[mxConstants.STYLE_ENDSIZE] = a.style[mxConstants.STYLE_STARTSIZE]),
                      (a.style.endWidth = a.style.startWidth);
                  mxEvent.isAltDown(k.getEvent()) ||
                    (Math.abs(
                      parseFloat(a.style[mxConstants.STYLE_STARTSIZE]) - parseFloat(a.style[mxConstants.STYLE_ENDSIZE])
                    ) <
                      b / 6 && (a.style[mxConstants.STYLE_STARTSIZE] = a.style[mxConstants.STYLE_ENDSIZE]),
                    Math.abs(parseFloat(a.style.startWidth) - parseFloat(a.style.endWidth)) < b &&
                      (a.style.startWidth = a.style.endWidth));
                }
              )
            ));
          mxUtils.getValue(a.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE &&
            (c.push(
              aa(
                a,
                ['width', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE],
                !1,
                function (b, c, d, e, f) {
                  b = (a.shape.getEdgeWidth() - a.shape.strokewidth) * a.view.scale;
                  f =
                    3 *
                    mxUtils.getNumber(a.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) *
                    a.view.scale;
                  return new mxPoint(
                    e.x + c * (f + a.shape.strokewidth * a.view.scale) - (d * b) / 2,
                    e.y + d * (f + a.shape.strokewidth * a.view.scale) + (c * b) / 2
                  );
                },
                function (c, d, e, f, g, h, k) {
                  c = Math.sqrt(mxUtils.ptSegDistSq(f.x, f.y, g.x, g.y, h.x, h.y));
                  d = mxUtils.ptLineDist(f.x, f.y, f.x + e, f.y - d, h.x, h.y);
                  a.style[mxConstants.STYLE_ENDSIZE] =
                    Math.round((100 * (d - a.shape.strokewidth)) / 3) / 100 / a.view.scale;
                  a.style.width = Math.round(2 * c) / a.view.scale;
                  if (mxEvent.isShiftDown(k.getEvent()) || mxEvent.isControlDown(k.getEvent()))
                    a.style[mxConstants.STYLE_STARTSIZE] = a.style[mxConstants.STYLE_ENDSIZE];
                  mxEvent.isAltDown(k.getEvent()) ||
                    (Math.abs(
                      parseFloat(a.style[mxConstants.STYLE_ENDSIZE]) - parseFloat(a.style[mxConstants.STYLE_STARTSIZE])
                    ) <
                      b / 6 &&
                      (a.style[mxConstants.STYLE_ENDSIZE] = a.style[mxConstants.STYLE_STARTSIZE]));
                }
              )
            ),
            c.push(
              aa(
                a,
                ['startWidth', 'endWidth', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE],
                !1,
                function (b, c, d, e, f) {
                  b = (a.shape.getEndArrowWidth() - a.shape.strokewidth) * a.view.scale;
                  f =
                    3 *
                    mxUtils.getNumber(a.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) *
                    a.view.scale;
                  return new mxPoint(
                    e.x + c * (f + a.shape.strokewidth * a.view.scale) - (d * b) / 2,
                    e.y + d * (f + a.shape.strokewidth * a.view.scale) + (c * b) / 2
                  );
                },
                function (c, d, e, f, g, h, k) {
                  c = Math.sqrt(mxUtils.ptSegDistSq(f.x, f.y, g.x, g.y, h.x, h.y));
                  d = mxUtils.ptLineDist(f.x, f.y, f.x + e, f.y - d, h.x, h.y);
                  a.style[mxConstants.STYLE_ENDSIZE] =
                    Math.round((100 * (d - a.shape.strokewidth)) / 3) / 100 / a.view.scale;
                  a.style.endWidth = Math.max(0, Math.round(2 * c) - a.shape.getEdgeWidth()) / a.view.scale;
                  if (mxEvent.isShiftDown(k.getEvent()) || mxEvent.isControlDown(k.getEvent()))
                    (a.style[mxConstants.STYLE_STARTSIZE] = a.style[mxConstants.STYLE_ENDSIZE]),
                      (a.style.startWidth = a.style.endWidth);
                  mxEvent.isAltDown(k.getEvent()) ||
                    (Math.abs(
                      parseFloat(a.style[mxConstants.STYLE_ENDSIZE]) - parseFloat(a.style[mxConstants.STYLE_STARTSIZE])
                    ) <
                      b / 6 && (a.style[mxConstants.STYLE_ENDSIZE] = a.style[mxConstants.STYLE_STARTSIZE]),
                    Math.abs(parseFloat(a.style.endWidth) - parseFloat(a.style.startWidth)) < b &&
                      (a.style.endWidth = a.style.startWidth));
                }
              )
            ));
          return c;
        },
        'swimlane': function (a) {
          var b = [];
          if (mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED)) {
            var c = parseFloat(mxUtils.getValue(a.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
            b.push(Ia(a, c / 2));
          }
          b.push(
            W(
              a,
              [mxConstants.STYLE_STARTSIZE],
              function (b) {
                var c = parseFloat(
                  mxUtils.getValue(a.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE)
                );
                return 1 == mxUtils.getValue(a.style, mxConstants.STYLE_HORIZONTAL, 1)
                  ? new mxPoint(b.getCenterX(), b.y + Math.max(0, Math.min(b.height, c)))
                  : new mxPoint(b.x + Math.max(0, Math.min(b.width, c)), b.getCenterY());
              },
              function (b, c) {
                a.style[mxConstants.STYLE_STARTSIZE] =
                  1 == mxUtils.getValue(this.state.style, mxConstants.STYLE_HORIZONTAL, 1)
                    ? Math.round(Math.max(0, Math.min(b.height, c.y - b.y)))
                    : Math.round(Math.max(0, Math.min(b.width, c.x - b.x)));
              },
              !1,
              null,
              function (b) {
                var c = a.view.graph;
                if (
                  !mxEvent.isShiftDown(b.getEvent()) &&
                  !mxEvent.isControlDown(b.getEvent()) &&
                  (c.isTableRow(a.cell) || c.isTableCell(a.cell))
                ) {
                  b = c.getSwimlaneDirection(a.style);
                  for (
                    var d = c.model.getParent(a.cell), d = c.model.getChildCells(d, !0), e = [], f = 0;
                    f < d.length;
                    f++
                  )
                    d[f] != a.cell &&
                      c.isSwimlane(d[f]) &&
                      c.getSwimlaneDirection(c.getCurrentCellStyle(d[f])) == b &&
                      e.push(d[f]);
                  c.setCellStyles(mxConstants.STYLE_STARTSIZE, a.style[mxConstants.STYLE_STARTSIZE], e);
                }
              }
            )
          );
          return b;
        },
        'label': Za(),
        'ext': Za(),
        'rectangle': Za(),
        'triangle': Za(),
        'rhombus': Za(),
        'umlLifeline': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(a.height, parseFloat(mxUtils.getValue(this.state.style, 'size', qa.prototype.size)))
                );
                return new mxPoint(a.getCenterX(), a.y + b);
              },
              function (a, b) {
                this.state.style.size = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)));
              },
              !1
            ),
          ];
        },
        'umlFrame': function (a) {
          return [
            W(
              a,
              ['width', 'height'],
              function (a) {
                var b = Math.max(
                    ia.prototype.corner,
                    Math.min(a.width, mxUtils.getValue(this.state.style, 'width', ia.prototype.width))
                  ),
                  c = Math.max(
                    1.5 * ia.prototype.corner,
                    Math.min(a.height, mxUtils.getValue(this.state.style, 'height', ia.prototype.height))
                  );
                return new mxPoint(a.x + b, a.y + c);
              },
              function (a, b) {
                this.state.style.width = Math.round(Math.max(ia.prototype.corner, Math.min(a.width, b.x - a.x)));
                this.state.style.height = Math.round(
                  Math.max(1.5 * ia.prototype.corner, Math.min(a.height, b.y - a.y))
                );
              },
              !1
            ),
          ];
        },
        'process': function (a) {
          var b = [
            W(
              a,
              ['size'],
              function (a) {
                var b = '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0'),
                  c = parseFloat(mxUtils.getValue(this.state.style, 'size', O.prototype.size));
                return b
                  ? new mxPoint(a.x + c, a.y + a.height / 4)
                  : new mxPoint(a.x + a.width * c, a.y + a.height / 4);
              },
              function (a, b) {
                var c =
                  '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0')
                    ? Math.max(0, Math.min(0.5 * a.width, b.x - a.x))
                    : Math.max(0, Math.min(0.5, (b.x - a.x) / a.width));
                this.state.style.size = c;
              },
              !1
            ),
          ];
          mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED, !1) && b.push(Ia(a));
          return b;
        },
        'cross': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.min(a.width, a.height),
                  b = (Math.max(0, Math.min(1, mxUtils.getValue(this.state.style, 'size', S.prototype.size))) * b) / 2;
                return new mxPoint(a.getCenterX() - b, a.getCenterY() - b);
              },
              function (a, b) {
                var c = Math.min(a.width, a.height);
                this.state.style.size = Math.max(
                  0,
                  Math.min(
                    1,
                    Math.min((Math.max(0, a.getCenterY() - b.y) / c) * 2, (Math.max(0, a.getCenterX() - b.x) / c) * 2)
                  )
                );
              }
            ),
          ];
        },
        'note': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(
                    a.width,
                    Math.min(a.height, parseFloat(mxUtils.getValue(this.state.style, 'size', h.prototype.size)))
                  )
                );
                return new mxPoint(a.x + a.width - b, a.y + b);
              },
              function (a, b) {
                this.state.style.size = Math.round(
                  Math.max(0, Math.min(Math.min(a.width, a.x + a.width - b.x), Math.min(a.height, b.y - a.y)))
                );
              }
            ),
          ];
        },
        'note2': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(
                    a.width,
                    Math.min(a.height, parseFloat(mxUtils.getValue(this.state.style, 'size', l.prototype.size)))
                  )
                );
                return new mxPoint(a.x + a.width - b, a.y + b);
              },
              function (a, b) {
                this.state.style.size = Math.round(
                  Math.max(0, Math.min(Math.min(a.width, a.x + a.width - b.x), Math.min(a.height, b.y - a.y)))
                );
              }
            ),
          ];
        },
        'manualInput': function (a) {
          var b = [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'size', La.prototype.size)));
                return new mxPoint(a.x + a.width / 4, a.y + (3 * b) / 4);
              },
              function (a, b) {
                this.state.style.size = Math.round(Math.max(0, Math.min(a.height, (4 * (b.y - a.y)) / 3)));
              },
              !1
            ),
          ];
          mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED, !1) && b.push(Ia(a));
          return b;
        },
        'dataStorage': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0'),
                  c = parseFloat(
                    mxUtils.getValue(this.state.style, 'size', b ? I.prototype.fixedSize : I.prototype.size)
                  );
                return new mxPoint(a.x + a.width - c * (b ? 1 : a.width), a.getCenterY());
              },
              function (a, b) {
                var c =
                  '0' != mxUtils.getValue(this.state.style, 'fixedSize', '0')
                    ? Math.max(0, Math.min(a.width, a.x + a.width - b.x))
                    : Math.max(0, Math.min(1, (a.x + a.width - b.x) / a.width));
                this.state.style.size = c;
              },
              !1
            ),
          ];
        },
        'callout': function (a) {
          var b = [
            W(
              a,
              ['size', 'position'],
              function (a) {
                var b = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'size', M.prototype.size))),
                  c = Math.max(0, Math.min(1, mxUtils.getValue(this.state.style, 'position', M.prototype.position)));
                mxUtils.getValue(this.state.style, 'base', M.prototype.base);
                return new mxPoint(a.x + c * a.width, a.y + a.height - b);
              },
              function (a, b) {
                mxUtils.getValue(this.state.style, 'base', M.prototype.base);
                this.state.style.size = Math.round(Math.max(0, Math.min(a.height, a.y + a.height - b.y)));
                this.state.style.position = Math.round(100 * Math.max(0, Math.min(1, (b.x - a.x) / a.width))) / 100;
              },
              !1
            ),
            W(
              a,
              ['position2'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(1, mxUtils.getValue(this.state.style, 'position2', M.prototype.position2))
                );
                return new mxPoint(a.x + b * a.width, a.y + a.height);
              },
              function (a, b) {
                this.state.style.position2 = Math.round(100 * Math.max(0, Math.min(1, (b.x - a.x) / a.width))) / 100;
              },
              !1
            ),
            W(
              a,
              ['base'],
              function (a) {
                var b = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'size', M.prototype.size))),
                  c = Math.max(0, Math.min(1, mxUtils.getValue(this.state.style, 'position', M.prototype.position))),
                  d = Math.max(0, Math.min(a.width, mxUtils.getValue(this.state.style, 'base', M.prototype.base)));
                return new mxPoint(a.x + Math.min(a.width, c * a.width + d), a.y + a.height - b);
              },
              function (a, b) {
                var c = Math.max(0, Math.min(1, mxUtils.getValue(this.state.style, 'position', M.prototype.position)));
                this.state.style.base = Math.round(Math.max(0, Math.min(a.width, b.x - a.x - c * a.width)));
              },
              !1
            ),
          ];
          mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED, !1) && b.push(Ia(a));
          return b;
        },
        'internalStorage': function (a) {
          var b = [
            W(
              a,
              ['dx', 'dy'],
              function (a) {
                var b = Math.max(0, Math.min(a.width, mxUtils.getValue(this.state.style, 'dx', la.prototype.dx))),
                  c = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'dy', la.prototype.dy)));
                return new mxPoint(a.x + b, a.y + c);
              },
              function (a, b) {
                this.state.style.dx = Math.round(Math.max(0, Math.min(a.width, b.x - a.x)));
                this.state.style.dy = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)));
              },
              !1
            ),
          ];
          mxUtils.getValue(a.style, mxConstants.STYLE_ROUNDED, !1) && b.push(Ia(a));
          return b;
        },
        'module': function (a) {
          return [
            W(
              a,
              ['jettyWidth', 'jettyHeight'],
              function (a) {
                var b = Math.max(
                    0,
                    Math.min(a.width, mxUtils.getValue(this.state.style, 'jettyWidth', ea.prototype.jettyWidth))
                  ),
                  c = Math.max(
                    0,
                    Math.min(a.height, mxUtils.getValue(this.state.style, 'jettyHeight', ea.prototype.jettyHeight))
                  );
                return new mxPoint(a.x + b / 2, a.y + 2 * c);
              },
              function (a, b) {
                this.state.style.jettyWidth = Math.round(2 * Math.max(0, Math.min(a.width, b.x - a.x)));
                this.state.style.jettyHeight = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)) / 2);
              }
            ),
          ];
        },
        'corner': function (a) {
          return [
            W(
              a,
              ['dx', 'dy'],
              function (a) {
                var b = Math.max(0, Math.min(a.width, mxUtils.getValue(this.state.style, 'dx', Ca.prototype.dx))),
                  c = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'dy', Ca.prototype.dy)));
                return new mxPoint(a.x + b, a.y + c);
              },
              function (a, b) {
                this.state.style.dx = Math.round(Math.max(0, Math.min(a.width, b.x - a.x)));
                this.state.style.dy = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)));
              },
              !1
            ),
          ];
        },
        'tee': function (a) {
          return [
            W(
              a,
              ['dx', 'dy'],
              function (a) {
                var b = Math.max(0, Math.min(a.width, mxUtils.getValue(this.state.style, 'dx', Ja.prototype.dx))),
                  c = Math.max(0, Math.min(a.height, mxUtils.getValue(this.state.style, 'dy', Ja.prototype.dy)));
                return new mxPoint(a.x + (a.width + b) / 2, a.y + c);
              },
              function (a, b) {
                this.state.style.dx = Math.round(Math.max(0, 2 * Math.min(a.width / 2, b.x - a.x - a.width / 2)));
                this.state.style.dy = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)));
              },
              !1
            ),
          ];
        },
        'singleArrow': Ha(1),
        'doubleArrow': Ha(0.5),
        'folder': function (a) {
          return [
            W(
              a,
              ['tabWidth', 'tabHeight'],
              function (a) {
                var b = Math.max(
                    0,
                    Math.min(a.width, mxUtils.getValue(this.state.style, 'tabWidth', t.prototype.tabWidth))
                  ),
                  c = Math.max(
                    0,
                    Math.min(a.height, mxUtils.getValue(this.state.style, 'tabHeight', t.prototype.tabHeight))
                  );
                mxUtils.getValue(this.state.style, 'tabPosition', t.prototype.tabPosition) == mxConstants.ALIGN_RIGHT &&
                  (b = a.width - b);
                return new mxPoint(a.x + b, a.y + c);
              },
              function (a, b) {
                var c = Math.max(0, Math.min(a.width, b.x - a.x));
                mxUtils.getValue(this.state.style, 'tabPosition', t.prototype.tabPosition) == mxConstants.ALIGN_RIGHT &&
                  (c = a.width - c);
                this.state.style.tabWidth = Math.round(c);
                this.state.style.tabHeight = Math.round(Math.max(0, Math.min(a.height, b.y - a.y)));
              },
              !1
            ),
          ];
        },
        'document': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'size', D.prototype.size)))
                );
                return new mxPoint(a.x + (3 * a.width) / 4, a.y + (1 - b) * a.height);
              },
              function (a, b) {
                this.state.style.size = Math.max(0, Math.min(1, (a.y + a.height - b.y) / a.height));
              },
              !1
            ),
          ];
        },
        'tape': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'size', z.prototype.size)))
                );
                return new mxPoint(a.getCenterX(), a.y + (b * a.height) / 2);
              },
              function (a, b) {
                this.state.style.size = Math.max(0, Math.min(1, ((b.y - a.y) / a.height) * 2));
              },
              !1
            ),
          ];
        },
        'isoCube2': function (a) {
          return [
            W(
              a,
              ['isoAngle'],
              function (a) {
                var b =
                  (Math.max(
                    0.01,
                    Math.min(94, parseFloat(mxUtils.getValue(this.state.style, 'isoAngle', m.isoAngle)))
                  ) *
                    Math.PI) /
                  200;
                return new mxPoint(a.x, a.y + Math.min(a.width * Math.tan(b), 0.5 * a.height));
              },
              function (a, b) {
                this.state.style.isoAngle = Math.max(0, (50 * (b.y - a.y)) / a.height);
              },
              !0
            ),
          ];
        },
        'cylinder2': ca(n.prototype.size),
        'cylinder3': ca(p.prototype.size),
        'offPageConnector': function (a) {
          return [
            W(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(1, parseFloat(mxUtils.getValue(this.state.style, 'size', Q.prototype.size)))
                );
                return new mxPoint(a.getCenterX(), a.y + (1 - b) * a.height);
              },
              function (a, b) {
                this.state.style.size = Math.max(0, Math.min(1, (a.y + a.height - b.y) / a.height));
              },
              !1
            ),
          ];
        },
        'mxgraph.basic.rect': function (a) {
          var b = [
            Graph.createHandle(
              a,
              ['size'],
              function (a) {
                var b = Math.max(
                  0,
                  Math.min(a.width / 2, a.height / 2, parseFloat(mxUtils.getValue(this.state.style, 'size', this.size)))
                );
                return new mxPoint(a.x + b, a.y + b);
              },
              function (a, b) {
                this.state.style.size =
                  Math.round(100 * Math.max(0, Math.min(a.height / 2, a.width / 2, b.x - a.x))) / 100;
              }
            ),
          ];
          a = Graph.createHandle(
            a,
            ['indent'],
            function (a) {
              var b = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, 'indent', this.dx2))));
              return new mxPoint(a.x + 0.75 * a.width, a.y + (b * a.height) / 200);
            },
            function (a, b) {
              this.state.style.indent =
                Math.round(100 * Math.max(0, Math.min(100, (200 * (b.y - a.y)) / a.height))) / 100;
            }
          );
          b.push(a);
          return b;
        },
        'step': Ya(U.prototype.size, !0, null, !0, U.prototype.fixedSize),
        'hexagon': Ya(da.prototype.size, !0, 0.5, !0, da.prototype.fixedSize),
        'curlyBracket': Ya(J.prototype.size, !1),
        'display': Ya(ma.prototype.size, !1),
        'cube': Ua(1, d.prototype.size, !1),
        'card': Ua(0.5, x.prototype.size, !0),
        'loopLimit': Ua(0.5, V.prototype.size, !0),
        'trapezoid': pb(0.5, C.prototype.size, C.prototype.fixedSize),
        'parallelogram': pb(1, B.prototype.size, B.prototype.fixedSize),
      };
    Graph.createHandle = W;
    Graph.handleFactory = va;
    var qb = mxVertexHandler.prototype.createCustomHandles;
    mxVertexHandler.prototype.createCustomHandles = function () {
      var a = qb.apply(this, arguments);
      if (this.graph.isCellRotatable(this.state.cell)) {
        var b = this.state.style.shape;
        null == mxCellRenderer.defaultShapes[b] && null == mxStencilRegistry.getStencil(b)
          ? (b = mxConstants.SHAPE_RECTANGLE)
          : this.state.view.graph.isSwimlane(this.state.cell) && (b = mxConstants.SHAPE_SWIMLANE);
        b = va[b];
        null == b &&
          null != this.state.shape &&
          this.state.shape.isRoundable() &&
          (b = va[mxConstants.SHAPE_RECTANGLE]);
        null != b && ((b = b(this.state)), null != b && (a = null == a ? b : a.concat(b)));
      }
      return a;
    };
    mxEdgeHandler.prototype.createCustomHandles = function () {
      var a = this.state.style.shape;
      null == mxCellRenderer.defaultShapes[a] &&
        null == mxStencilRegistry.getStencil(a) &&
        (a = mxConstants.SHAPE_CONNECTOR);
      a = va[a];
      return null != a ? a(this.state) : null;
    };
  } else (Graph.createHandle = function () {}), (Graph.handleFactory = {});
  var bb = new mxPoint(1, 0),
    Na = new mxPoint(1, 0),
    fb = mxUtils.toRadians(-30),
    bb = mxUtils.getRotatedPoint(bb, Math.cos(fb), Math.sin(fb)),
    gb = mxUtils.toRadians(-150),
    Na = mxUtils.getRotatedPoint(Na, Math.cos(gb), Math.sin(gb));
  mxEdgeStyle.IsometricConnector = function (a, b, c, d, e) {
    var f = a.view;
    d = null != d && 0 < d.length ? d[0] : null;
    var g = a.absolutePoints,
      h = g[0],
      g = g[g.length - 1];
    null != d && (d = f.transformControlPoint(a, d));
    null == h && null != b && (h = new mxPoint(b.getCenterX(), b.getCenterY()));
    null == g && null != c && (g = new mxPoint(c.getCenterX(), c.getCenterY()));
    var k = bb.x,
      l = bb.y,
      m = Na.x,
      q = Na.y,
      n = 'horizontal' == mxUtils.getValue(a.style, 'elbow', 'horizontal');
    if (null != g && null != h) {
      a = function (a, b, c) {
        a -= p.x;
        var d = b - p.y;
        b = (q * a - m * d) / (k * q - l * m);
        a = (l * a - k * d) / (l * m - k * q);
        n
          ? (c && ((p = new mxPoint(p.x + k * b, p.y + l * b)), e.push(p)), (p = new mxPoint(p.x + m * a, p.y + q * a)))
          : (c && ((p = new mxPoint(p.x + m * a, p.y + q * a)), e.push(p)),
            (p = new mxPoint(p.x + k * b, p.y + l * b)));
        e.push(p);
      };
      var p = h;
      null == d && (d = new mxPoint(h.x + (g.x - h.x) / 2, h.y + (g.y - h.y) / 2));
      a(d.x, d.y, !0);
      a(g.x, g.y, !1);
    }
  };
  mxStyleRegistry.putValue('isometricEdgeStyle', mxEdgeStyle.IsometricConnector);
  var ub = Graph.prototype.createEdgeHandler;
  Graph.prototype.createEdgeHandler = function (a, b) {
    if (b == mxEdgeStyle.IsometricConnector) {
      var c = new mxElbowEdgeHandler(a);
      c.snapToTerminals = !1;
      return c;
    }
    return ub.apply(this, arguments);
  };
  f.prototype.constraints = [];
  g.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.tan(mxUtils.toRadians(30)),
      e = (0.5 - d) / 2,
      d = Math.min(b, c / (0.5 + d));
    b = (b - d) / 2;
    c = (c - d) / 2;
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, c + 0.25 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b + 0.5 * d, c + d * e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b + d, c + 0.25 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b + d, c + 0.75 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b + 0.5 * d, c + (1 - e) * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, c + 0.75 * d));
    return a;
  };
  m.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d =
        (Math.max(0.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, 'isoAngle', this.isoAngle)))) * Math.PI) /
        200,
      d = Math.min(b * Math.tan(d), 0.5 * c);
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, d));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, d));
    return a;
  };
  M.prototype.getConstraints = function (a, b, c) {
    a = [];
    mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE);
    var d = Math.max(0, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    parseFloat(mxUtils.getValue(this.style, 'position', this.position));
    var e = b * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'position2', this.position2))));
    parseFloat(mxUtils.getValue(this.style, 'base', this.base));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.25, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.75, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * (c - d)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.5 * (c - d)));
    b >= 2 * d && a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    return a;
  };
  mxRectangleShape.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 0), !0),
    new mxConnectionConstraint(new mxPoint(1, 0), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 1), !0),
    new mxConnectionConstraint(new mxPoint(1, 1), !0),
  ];
  mxEllipse.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0), !0),
    new mxConnectionConstraint(new mxPoint(1, 0), !0),
    new mxConnectionConstraint(new mxPoint(0, 1), !0),
    new mxConnectionConstraint(new mxPoint(1, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5)),
  ];
  ya.prototype.constraints = mxRectangleShape.prototype.constraints;
  mxImageShape.prototype.constraints = mxRectangleShape.prototype.constraints;
  mxSwimlane.prototype.constraints = mxRectangleShape.prototype.constraints;
  ha.prototype.constraints = mxRectangleShape.prototype.constraints;
  mxLabel.prototype.constraints = mxRectangleShape.prototype.constraints;
  h.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - 0.5 * d, 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * (c + d)));
    a.push(new mxConnectionConstraint(new mxPoint(1, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    b >= 2 * d && a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    return a;
  };
  x.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * d, 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.5 * (c + d)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    b >= 2 * d && a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    return a;
  };
  d.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - 0.5 * d, 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * (c + d)));
    a.push(new mxConnectionConstraint(new mxPoint(1, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * d, c - 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.5 * (c - d)));
    return a;
  };
  p.prototype.getConstraints = function (a, b, c) {
    a = [];
    b = Math.max(0, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, b));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1, null, 0, b));
    a.push(new mxConnectionConstraint(new mxPoint(1, 1), !1, null, 0, -b));
    a.push(new mxConnectionConstraint(new mxPoint(0, 1), !1, null, 0, -b));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, b + 0.5 * (0.5 * c - b)));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1, null, 0, b + 0.5 * (0.5 * c - b)));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1, null, 0, c - b - 0.5 * (0.5 * c - b)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c - b - 0.5 * (0.5 * c - b)));
    a.push(new mxConnectionConstraint(new mxPoint(0.145, 0), !1, null, 0, 0.29 * b));
    a.push(new mxConnectionConstraint(new mxPoint(0.855, 0), !1, null, 0, 0.29 * b));
    a.push(new mxConnectionConstraint(new mxPoint(0.855, 1), !1, null, 0, 0.29 * -b));
    a.push(new mxConnectionConstraint(new mxPoint(0.145, 1), !1, null, 0, 0.29 * -b));
    return a;
  };
  t.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, parseFloat(mxUtils.getValue(this.style, 'tabWidth', this.tabWidth)))),
      e = Math.max(0, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'tabHeight', this.tabHeight))));
    'left' == mxUtils.getValue(this.style, 'tabPosition', this.tabPosition)
      ? (a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * d, 0)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, 0)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, e)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), e)))
      : (a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - 0.5 * d, 0)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, 0)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, e)),
        a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), e)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.25 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.75 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.25 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.5 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.75 * (c - e) + e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c));
    a.push(new mxConnectionConstraint(new mxPoint(0.25, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.75, 1), !1));
    return a;
  };
  la.prototype.constraints = mxRectangleShape.prototype.constraints;
  I.prototype.constraints = mxRectangleShape.prototype.constraints;
  X.prototype.constraints = mxEllipse.prototype.constraints;
  ja.prototype.constraints = mxEllipse.prototype.constraints;
  Qa.prototype.constraints = mxEllipse.prototype.constraints;
  Ma.prototype.constraints = mxEllipse.prototype.constraints;
  La.prototype.constraints = mxRectangleShape.prototype.constraints;
  fa.prototype.constraints = mxRectangleShape.prototype.constraints;
  ma.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.min(b, c / 2),
      e = Math.min(b - d, Math.max(0, parseFloat(mxUtils.getValue(this.style, 'size', this.size))) * b);
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1, null));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (e + b - d), 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, 0));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1, null));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - d, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (e + b - d), c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, c));
    return a;
  };
  ea.prototype.getConstraints = function (a, b, c) {
    b = parseFloat(mxUtils.getValue(a, 'jettyWidth', ea.prototype.jettyWidth)) / 2;
    a = parseFloat(mxUtils.getValue(a, 'jettyHeight', ea.prototype.jettyHeight));
    var d = [
      new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b),
      new mxConnectionConstraint(new mxPoint(0.25, 0), !0),
      new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
      new mxConnectionConstraint(new mxPoint(0.75, 0), !0),
      new mxConnectionConstraint(new mxPoint(1, 0), !0),
      new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
      new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
      new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
      new mxConnectionConstraint(new mxPoint(0, 1), !1, null, b),
      new mxConnectionConstraint(new mxPoint(0.25, 1), !0),
      new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
      new mxConnectionConstraint(new mxPoint(0.75, 1), !0),
      new mxConnectionConstraint(new mxPoint(1, 1), !0),
      new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, Math.min(c - 0.5 * a, 1.5 * a)),
      new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, Math.min(c - 0.5 * a, 3.5 * a)),
    ];
    c > 5 * a && d.push(new mxConnectionConstraint(new mxPoint(0, 0.75), !1, null, b));
    c > 8 * a && d.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1, null, b));
    c > 15 * a && d.push(new mxConnectionConstraint(new mxPoint(0, 0.25), !1, null, b));
    return d;
  };
  V.prototype.constraints = mxRectangleShape.prototype.constraints;
  Q.prototype.constraints = mxRectangleShape.prototype.constraints;
  mxCylinder.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.15, 0.05), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.85, 0.05), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.3), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.7), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.3), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.7), !0),
    new mxConnectionConstraint(new mxPoint(0.15, 0.95), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.85, 0.95), !1),
  ];
  Oa.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.25, 0.1), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !1),
    new mxConnectionConstraint(new mxPoint(0.75, 0.1), !1),
    new mxConnectionConstraint(new mxPoint(0, 1 / 3), !1),
    new mxConnectionConstraint(new mxPoint(0, 1), !1),
    new mxConnectionConstraint(new mxPoint(1, 1 / 3), !1),
    new mxConnectionConstraint(new mxPoint(1, 1), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0.5), !1),
  ];
  L.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.25, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 0), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.3), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.7), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 1), !0),
  ];
  mxActor.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 0.2), !1),
    new mxConnectionConstraint(new mxPoint(0.1, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 0.25), !1),
    new mxConnectionConstraint(new mxPoint(0.9, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 1), !0),
  ];
  r.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0.25), !1),
    new mxConnectionConstraint(new mxPoint(1, 0), !1),
    new mxConnectionConstraint(new mxPoint(0.25, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.75, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0, 1), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0.75), !1),
    new mxConnectionConstraint(new mxPoint(1, 1), !1),
  ];
  z.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.35), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.65), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.35), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.65), !1),
    new mxConnectionConstraint(new mxPoint(0.25, 1), !1),
    new mxConnectionConstraint(new mxPoint(0.75, 0), !1),
  ];
  U.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.25, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.25, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 1), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
  ];
  mxLine.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.25, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.75, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
  ];
  Ka.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.5, 0), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !1),
  ];
  mxDoubleEllipse.prototype.constraints = mxEllipse.prototype.constraints;
  mxRhombus.prototype.constraints = mxEllipse.prototype.constraints;
  mxTriangle.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
  ];
  mxHexagon.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.375, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.625, 0), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(0.375, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 1), !0),
    new mxConnectionConstraint(new mxPoint(0.625, 1), !0),
  ];
  mxCloud.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.25, 0.25), !1),
    new mxConnectionConstraint(new mxPoint(0.4, 0.1), !1),
    new mxConnectionConstraint(new mxPoint(0.16, 0.55), !1),
    new mxConnectionConstraint(new mxPoint(0.07, 0.4), !1),
    new mxConnectionConstraint(new mxPoint(0.31, 0.8), !1),
    new mxConnectionConstraint(new mxPoint(0.13, 0.77), !1),
    new mxConnectionConstraint(new mxPoint(0.8, 0.8), !1),
    new mxConnectionConstraint(new mxPoint(0.55, 0.95), !1),
    new mxConnectionConstraint(new mxPoint(0.875, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.96, 0.7), !1),
    new mxConnectionConstraint(new mxPoint(0.625, 0.2), !1),
    new mxConnectionConstraint(new mxPoint(0.88, 0.25), !1),
  ];
  B.prototype.constraints = mxRectangleShape.prototype.constraints;
  C.prototype.constraints = mxRectangleShape.prototype.constraints;
  D.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.25, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.5, 0), !0),
    new mxConnectionConstraint(new mxPoint(0.75, 0), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.25), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !0),
    new mxConnectionConstraint(new mxPoint(1, 0.75), !0),
  ];
  mxArrow.prototype.constraints = null;
  Ja.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))),
      e = Math.max(0, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.75 * b + 0.25 * d, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), 0.5 * (c + e)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), c));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), 0.5 * (c + e)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - d), e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.25 * b - 0.25 * d, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, 0.5 * e));
    return a;
  };
  Ca.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.max(0, Math.min(b, parseFloat(mxUtils.getValue(this.style, 'dx', this.dx)))),
      e = Math.max(0, Math.min(c, parseFloat(mxUtils.getValue(this.style, 'dy', this.dy))));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, 0.5 * e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + d), e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, e));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, 0.5 * (c + e)));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, d, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * d, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 1), !1));
    return a;
  };
  pa.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0, 1), !1),
    new mxConnectionConstraint(new mxPoint(0.25, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.5, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.75, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 1), !1),
  ];
  ba.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = c * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', this.arrowWidth)))),
      e = b * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', this.arrowSize)))),
      d = (c - d) / 2;
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - e), d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - e, 0));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - e, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b - e), c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, c - d));
    return a;
  };
  E.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d =
        c * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', ba.prototype.arrowWidth)))),
      e = b * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', ba.prototype.arrowSize)))),
      d = (c - d) / 2;
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * b, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - e, 0));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b - e, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * b, c - d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, c));
    return a;
  };
  S.prototype.getConstraints = function (a, b, c) {
    a = [];
    var d = Math.min(c, b),
      e = Math.max(0, Math.min(d, d * parseFloat(mxUtils.getValue(this.style, 'size', this.size)))),
      d = (c - e) / 2,
      f = d + e,
      g = (b - e) / 2,
      e = g + e;
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 0), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, 0));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, c - 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, c));
    a.push(new mxConnectionConstraint(new mxPoint(0.5, 1), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, c));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, c - 0.5 * d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, e, f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + e), d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, d));
    a.push(new mxConnectionConstraint(new mxPoint(1, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, b, f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * (b + e), f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * g, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, d));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0.5), !1));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0, f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, 0.5 * g, f));
    a.push(new mxConnectionConstraint(new mxPoint(0, 0), !1, null, g, d));
    return a;
  };
  qa.prototype.constraints = null;
  F.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.25), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0, 0.75), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.7, 0.1), !1),
    new mxConnectionConstraint(new mxPoint(0.7, 0.9), !1),
  ];
  N.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0.175, 0.25), !1),
    new mxConnectionConstraint(new mxPoint(0.25, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.175, 0.75), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(0.7, 0.1), !1),
    new mxConnectionConstraint(new mxPoint(0.7, 0.9), !1),
  ];
  Xa.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
  ];
  Z.prototype.constraints = [
    new mxConnectionConstraint(new mxPoint(0, 0.5), !1),
    new mxConnectionConstraint(new mxPoint(1, 0.5), !1),
  ];
})();

(function (w, r) {
  function M() {
    if (!t) {
      t = !0;
      window.MathJax = {
        skipStartupTypeset: !0,
        showMathMenu: !1,
        messageStyle: 'none',
        AuthorInit: function () {
          MathJax.Hub.Config({
            jax: ['input/TeX', 'input/MathML', 'input/AsciiMath', 'output/SVG'],
            extensions: ['tex2jax.js', 'mml2jax.js', 'asciimath2jax.js'],
            TeX: { extensions: ['AMSmath.js', 'AMSsymbols.js', 'noErrors.js', 'noUndefined.js'] },
          });
          MathJax.Hub.Register.StartupHook('Begin', function () {
            for (var a = 0; a < p.length; a++) MathJax.Hub.Queue(['Typeset', MathJax.Hub, p[a]]);
          });
        },
      };
      var a = document.createElement('script');
      a.type = 'text/javascript';
      a.src = 'https://app.diagrams.net/math/MathJax.js';
      document.getElementsByTagName('head')[0].appendChild(a);
    }
  }
  function N(a) {
    'undefined' !== typeof MathJax && 'undefined' !== typeof MathJax.Hub
      ? MathJax.Hub.Queue(['Typeset', MathJax.Hub, a.container])
      : p.push(a.container);
    a.addListener(mxEvent.SIZE, function (e, m) {
      'undefined' !== typeof MathJax &&
        'undefined' !== typeof MathJax.Hub &&
        MathJax.Hub.Queue(['Typeset', MathJax.Hub, a.container]);
    });
  }
  mxStencilRegistry.dynamicLoading = !1;
  try {
    var e = document.createElement('style');
    e.type = 'text/css';
    e.innerHTML =
      'div.mxTooltip {\n-webkit-box-shadow: 3px 3px 12px #C0C0C0;\n-moz-box-shadow: 3px 3px 12px #C0C0C0;\nbox-shadow: 3px 3px 12px #C0C0C0;\nbackground: #FFFFCC;\nborder-style: solid;\nborder-width: 1px;\nborder-color: black;\nfont-family: Arial;\nfont-size: 8pt;\nposition: absolute;\ncursor: default;\npadding: 4px;\ncolor: black;}';
    document.getElementsByTagName('head')[0].appendChild(e);
  } catch (a) {}
  var E = mxClient.NO_FO,
    t = 'undefined' !== typeof MathJax && 'undefined' !== typeof MathJax.Hub,
    p = [];
  mxGraph.prototype.getImageFromBundles = function (a) {
    return null != a
      ? ('http://' != a.substring(0, 7) &&
          'https://' != a.substring(0, 8) &&
          'data:image' != a.substring(0, 10) &&
          ('/' == a.charAt(0) && (a = a.substring(1, a.length)), (a = 'https://app.diagrams.net/' + a)),
        a)
      : null;
  };
  if (null != r)
    for (e = 0; e < r.length; e++) {
      var x = mxUtils.parseXml(r[e]);
      mxStencilRegistry.parseStencilSet(x.documentElement);
    }
  mxClient.IS_TOUCH &&
    (mxPanningHandler.prototype.isPanningTrigger = function (a) {
      return !0;
    });
  (function () {
    function a(a) {
      try {
        for (var e = a.firstChild; null != e && e.nodeType != mxConstants.NODETYPE_ELEMENT; ) e = e.nextSibling;
        var l = mxUtils.trim(e.innerHTML);
        a.innerHTML = '';
        var b = new Graph(a),
          l =
            '&lt;' == l.substring(0, 4)
              ? l
                  .replace(/&lt;/g, '<')
                  .replace(/&gt;/g, '>')
                  .replace(/&amp;gt;/g, '&gt;')
                  .replace(/&amp;lt;/g, '&lt;')
                  .replace(/&amp;quot;/g, '&quot;')
                  .replace(/&#xa;/g, '\n')
              : '%3C' == l.substring(0, 3)
              ? decodeURIComponent(l)
              : Graph.decompress(l),
          h = mxUtils.parseXml(l),
          d = null,
          f = null;
        null != h.documentElement &&
          'mxfile' == h.documentElement.nodeName &&
          ((f = h.documentElement.getElementsByTagName('diagram')),
          (d = h.documentElement),
          0 < f.length && ((l = mxUtils.getTextContent(f[0])), (l = Graph.decompress(l)), (h = mxUtils.parseXml(l))));
        if (null != h.documentElement && 'mxGraphModel' == h.documentElement.nodeName) {
          var e = function () {
              k.style.top = a.offsetTop + F.y + 'px';
              k.style.left = a.offsetLeft + F.x + 'px';
              k.style.visibility = 'visible';
            },
            m = function (a, c) {
              var b = document.createElement('div');
              b.style.position = 'absolute';
              b.style.border = '1px solid gray';
              b.style.textAlign = 'center';
              b.style.cursor = 'hand';
              b.style.width = y + 'px';
              b.style.height = G + 'px';
              b.style.left = H + 'px';
              b.style.top = '0px';
              b.style.backgroundColor = 'white';
              mxUtils.setOpacity(b, 50);
              var g = document.createElement('table');
              g.style.borderWidth = '0px';
              g.style.width = '100%';
              g.style.height = '100%';
              var e = document.createElement('tbody'),
                d = document.createElement('tr'),
                f = document.createElement('td');
              f.style.verticalAlign = 'middle';
              f.style.textAlign = 'center';
              f.style.fontSize = I + 'px';
              f.style.padding = '0px';
              mxUtils.write(f, a);
              d.appendChild(f);
              e.appendChild(d);
              g.appendChild(e);
              b.appendChild(g);
              mxEvent.addListener(b, mxClient.IS_POINTER ? 'pointerdown' : 'mousedown', function (b) {
                mxEvent.consume(b);
              });
              mxEvent.addListener(b, mxClient.IS_POINTER ? 'pointerup' : 'mouseup', function (b) {
                c();
                mxEvent.consume(b);
              });
              !mxClient.IS_POINTER &&
                mxClient.IS_TOUCH &&
                (mxEvent.addListener(b, 'touchstart', function (b) {
                  mxEvent.consume(b);
                }),
                mxEvent.addListener(b, 'touchend', function (b) {
                  c();
                  mxEvent.consume(b);
                }));
              H += y;
              k.appendChild(b);
              return b;
            },
            r = function (a) {
              a = a.getAttribute('backgroundImage');
              null != a &&
                ((a = JSON.parse(a)),
                b.setBackgroundImage(new mxImage(a.src, a.width, a.height)),
                b.view.validateBackgroundImage());
              '0' != z && b.fit(u);
              '1' == A && N(b);
              a = b.container.getElementsByTagName('a');
              if (null != a)
                for (var c = 0; c < a.length; c++) {
                  var g = a[c].getAttribute('href');
                  null != g &&
                    '#' == g.charAt(0) &&
                    '_blank' == a[c].getAttribute('target') &&
                    a[c].removeAttribute('target');
                }
            },
            p = new mxCodec(h),
            B = h.documentElement;
          null == d && (d = B);
          b.resetViewOnRootChange = !1;
          b.setEnabled(!1);
          if (null != f && 0 < f.length) {
            var t = b.getGlobalVariable;
            b.getGlobalVariable = function (b) {
              return 'page' == b
                ? f[0].getAttribute('name') || 'Page-1'
                : 'pagenumber' == b
                ? 1
                : 'pagecount' == b
                ? f.length
                : t.apply(this, arguments);
            };
          }
          b.foldingEnabled = '1' == d.getAttribute('nav');
          b.cellRenderer.forceControlClickHandler = b.foldingEnabled;
          var J = d.getAttribute('tooltips');
          '0' != J ? b.setTooltips(!0) : b.setTooltips(!1);
          if (null != w) {
            var K = mxUtils.parseXml(w);
            new mxCodec(K).decode(K.documentElement, b.getStylesheet());
          }
          var A = d.getAttribute('math');
          '1' == A && ((mxClient.NO_FO = !0), M());
          '0' != d.getAttribute('pan')
            ? ((b.panningHandler.useLeftButtonForPanning = !0),
              (b.panningHandler.ignoreCell = !0),
              (a.style.cursor = 'move'),
              b.setPanning(!0))
            : (a.style.cursor = 'default');
          var C = d.getAttribute('resize'),
            u = Number(d.getAttribute('border') || 0);
          b.border = u;
          var z = d.getAttribute('fit');
          ('100%' != a.style.width && '1' != z && '0' != C) || ('' == a.style.width && '' == a.style.height)
            ? ((b.resizeContainer = !0), (b.centerZoom = !1))
            : '0' != C && '100%' == a.style.width && '' == a.style.height
            ? ((b.resizeContainer = !0),
              (b.centerZoom = !1),
              (b.doResizeContainer = function (b, a) {
                a = mxClient.IS_IE ? (9 <= document.documentMode ? a + 5 : a + 1) : a + 1;
                null != this.maximumContainerSize && (a = Math.min(this.maximumContainerSize.height, a));
                this.container.style.height = Math.ceil(a + 18) + 'px';
              }))
            : (b.centerZoom = !0);
          var x = d.getAttribute('links'),
            v = d.getAttribute('highlight');
          if ('0' != x || '0' != J) {
            var O = a.style.cursor,
              L = b.getTolerance();
            b.addMouseListener({
              currentState: null,
              currentLink: null,
              highlight: null != v && '' != v && v != mxConstants.NONE ? new mxCellHighlight(b, v, 2) : null,
              startX: 0,
              startY: 0,
              mouseDown: function (b, a) {
                this.startX = a.getGraphX();
                this.startY = a.getGraphY();
              },
              mouseMove: function (a, c) {
                if (b.isMouseDown) {
                  if (null != this.currentLink) {
                    var g = Math.abs(this.startX - c.getGraphX()),
                      e = Math.abs(this.startY - c.getGraphY());
                    (g > L || e > L) && this.clear();
                  }
                } else if (
                  null == this.currentState ||
                  (c.getState() != this.currentState && null != c.getState()) ||
                  !b.intersects(this.currentState, c.getGraphX(), c.getGraphY())
                )
                  (g = b.view.getState(c.getCell())),
                    g != this.currentState &&
                      (null != this.currentState && this.clear(),
                      (this.currentState = g),
                      null != this.currentState && this.activate(this.currentState));
              },
              mouseUp: function (a, b) {
                var c = this.currentLink;
                this.clear();
                null != c && ('#' == c.charAt(0) ? (window.location.hash = c) : window.open(c));
              },
              activate: function (g) {
                this.currentLink = b.getLinkForCell(g.cell);
                null != this.currentLink &&
                  ((a.style.cursor = 'pointer'), null != this.highlight && this.highlight.highlight(g));
              },
              clear: function () {
                a.style.cursor = O;
                this.currentLink = this.currentState = null;
                null != this.highlight && this.highlight.hide();
              },
            });
          }
          var P = Number(d.getAttribute('x0') || 0),
            Q = Number(d.getAttribute('y0') || 0);
          b.view.translate.x = -P + u;
          b.view.translate.y = -Q + u;
          var n = d.getAttribute('url');
          if (null != n)
            try {
              var q =
                null != navigator.userAgent && 0 < navigator.userAgent.indexOf('MSIE 9')
                  ? new XDomainRequest()
                  : new XMLHttpRequest();
              q.open('GET', n);
              q.onload = mxUtils.bind(this, function () {
                try {
                  '1' == A && (mxClient.NO_FO = mxClient.IS_SF);
                  var a = null != q.getText ? q.getText() : q.responseText;
                  if (null != a) {
                    var c = mxUtils.parseXml(a);
                    if (null != c && 'html' == c.documentElement.nodeName) {
                      var e = c.documentElement.getElementsByTagName('div');
                      if (0 < e.length && 'mxgraph' == e[0].getAttribute('class')) {
                        var f = e[0].getElementsByTagName('div');
                        0 < f.length &&
                          ((a = mxUtils.getTextContent(f[0])),
                          (a = Graph.decompress(a)),
                          0 < a.length && (c = mxUtils.parseXml(a)));
                      }
                    }
                    if (null != c && 'svg' == c.documentElement.nodeName) {
                      var d = c.documentElement.getAttribute('content');
                      null != d &&
                        '<' != d.charAt(0) &&
                        '%' != d.charAt(0) &&
                        (d = unescape(window.atob ? atob(d) : Base64.decode(cont, d)));
                      null != d && '%' == d.charAt(0) && (d = decodeURIComponent(d));
                      null != d && 0 < d.length && (c = mxUtils.parseXml(d));
                    }
                    if ('mxfile' == c.documentElement.nodeName) {
                      var h = c.documentElement.getElementsByTagName('diagram');
                      if (0 < h.length) {
                        var k = mxUtils.trim(mxUtils.getTextContent(h[0]));
                        if (0 < k.length)
                          (d = Graph.decompress(k)), null != d && 0 < d.length && (c = mxUtils.parseXml(d));
                        else {
                          var l = mxUtils.getChildNodes(h[0]);
                          0 < l.length && ((c = mxUtils.createXmlDocument()), c.appendChild(c.importNode(l[0], !0)));
                        }
                      }
                    }
                    p = new mxCodec(c);
                    p.decode(c.documentElement, b.getModel());
                    r(c.documentElement);
                  } else b.container.innerHTML = 'Cannot load ' + mxUtils.htmlEntities(n);
                  mxClient.NO_FO = E;
                } catch (R) {
                  b.container.innerHTML =
                    'Cannot load ' + mxUtils.htmlEntities(n) + ': ' + mxUtils.htmlEntities(R.message);
                }
              });
              q.onerror = function () {
                b.container.innerHTML = 'Cannot load ' + mxUtils.htmlEntities(n);
              };
              q.send();
            } catch (g) {
              b.container.innerHTML = 'Cannot load ' + mxUtils.htmlEntities(n) + ': ' + mxUtils.htmlEntities(g.message);
            }
          else p.decode(B, b.getModel()), r(B);
          '100%' != a.style.width && '0' != z && '1' == C && ((b.resizeContainer = !0), (b.centerZoom = !1));
          var k = document.createElement('div');
          k.style.position = 'absolute';
          k.style.overflow = 'visible';
          k.style.cursor = 'pointer';
          var F = b.getBorderSizes(),
            H = 0,
            I = 10,
            y = 16,
            G = 16;
          mxClient.IS_TOUCH && ((G = y = 24), (I = 14));
          '0' != d.getAttribute('zoom') &&
            (m('+', function () {
              b.zoomIn();
            }),
            m('-', function () {
              b.zoomOut();
            }));
          var D = d.getAttribute('edit');
          null != D &&
            (m('', function () {
              if ('_blank' == D)
                if (null != n) window.open('https://app.diagrams.net/#U' + encodeURIComponent(n));
                else {
                  var a = null,
                    b = function (c) {
                      'ready' == c.data &&
                        c.source == a &&
                        (a.postMessage(l, '*'), window.removeEventListener('message', b));
                    };
                  window.addEventListener('message', b);
                  a = window.open('https://app.diagrams.net/?client=1');
                }
              else window.open(D);
            }).innerHTML = '...');
          mxClient.IS_POINTER || mxClient.IS_TOUCH
            ? e()
            : ((h = function () {
                k.style.visibility = 'hidden';
              }),
              mxEvent.addListener(a, 'mouseover', e),
              mxEvent.addListener(k, 'mouseover', e),
              mxEvent.addListener(a, 'mouseout', h),
              mxEvent.addListener(k, 'mouseout', h),
              h());
          null != k.firstChild &&
            (null != a.nextSibling ? a.parentNode.insertBefore(k, a.nextSibling) : a.parentNode.appendChild(k));
          'function' == typeof window.mxClientOnCreate && window.mxClientOnCreate(b);
        }
      } catch (g) {
        null != window.console && console.log('Error:', g);
      }
      mxClient.NO_FO = E;
      return b;
    }
    if ('function' == typeof mxClientOnLoad) mxClientOnLoad(w, a);
    else if (mxClient.isBrowserSupported()) {
      for (var e = document.getElementsByTagName('*'), m = [], f = 0; f < e.length; f++) m.push(e[f]);
      for (f = 0; f < m.length; f++) 0 <= m[f].className.toString().indexOf('mxgraph') && a(m[f]);
    }
  })();
})(
  '<mxStylesheet><add as="defaultVertex"><add as="shape" value="label"/><add as="perimeter" value="rectanglePerimeter"/><add as="fontSize" value="12"/><add as="fontFamily" value="Helvetica"/><add as="align" value="center"/><add as="verticalAlign" value="middle"/><add as="fillColor" value="default"/><add as="strokeColor" value="default"/><add as="fontColor" value="default"/></add><add as="defaultEdge"><add as="shape" value="connector"/><add as="labelBackgroundColor" value="default"/><add as="endArrow" value="classic"/><add as="fontSize" value="11"/><add as="fontFamily" value="Helvetica"/><add as="align" value="center"/><add as="verticalAlign" value="middle"/><add as="rounded" value="1"/><add as="strokeColor" value="default"/><add as="fontColor" value="default"/></add><add as="text"><add as="fillColor" value="none"/><add as="gradientColor" value="none"/><add as="strokeColor" value="none"/><add as="align" value="left"/><add as="verticalAlign" value="top"/></add><add as="edgeLabel" extend="text"><add as="labelBackgroundColor" value="default"/><add as="fontSize" value="11"/></add><add as="label"><add as="fontStyle" value="1"/><add as="align" value="left"/><add as="verticalAlign" value="middle"/><add as="spacing" value="2"/><add as="spacingLeft" value="52"/><add as="imageWidth" value="42"/><add as="imageHeight" value="42"/><add as="rounded" value="1"/></add><add as="icon" extend="label"><add as="align" value="center"/><add as="imageAlign" value="center"/><add as="verticalLabelPosition" value="bottom"/><add as="verticalAlign" value="top"/><add as="spacingTop" value="4"/><add as="labelBackgroundColor" value="default"/><add as="spacing" value="0"/><add as="spacingLeft" value="0"/><add as="spacingTop" value="6"/><add as="fontStyle" value="0"/><add as="imageWidth" value="48"/><add as="imageHeight" value="48"/></add><add as="swimlane"><add as="shape" value="swimlane"/><add as="fontSize" value="12"/><add as="fontStyle" value="1"/><add as="startSize" value="23"/></add><add as="group"><add as="verticalAlign" value="top"/><add as="fillColor" value="none"/><add as="strokeColor" value="none"/><add as="gradientColor" value="none"/><add as="pointerEvents" value="0"/></add><add as="ellipse"><add as="shape" value="ellipse"/><add as="perimeter" value="ellipsePerimeter"/></add><add as="rhombus"><add as="shape" value="rhombus"/><add as="perimeter" value="rhombusPerimeter"/></add><add as="triangle"><add as="shape" value="triangle"/><add as="perimeter" value="trianglePerimeter"/></add><add as="line"><add as="shape" value="line"/><add as="strokeWidth" value="4"/><add as="labelBackgroundColor" value="default"/><add as="verticalAlign" value="top"/><add as="spacingTop" value="8"/></add><add as="image"><add as="shape" value="image"/><add as="labelBackgroundColor" value="default"/><add as="verticalAlign" value="top"/><add as="verticalLabelPosition" value="bottom"/></add><add as="roundImage" extend="image"><add as="perimeter" value="ellipsePerimeter"/></add><add as="rhombusImage" extend="image"><add as="perimeter" value="rhombusPerimeter"/></add><add as="arrow"><add as="shape" value="arrow"/><add as="edgeStyle" value="none"/><add as="fillColor" value="default"/></add><add as="fancy"><add as="shadow" value="1"/><add as="glass" value="1"/></add><add as="gray" extend="fancy"><add as="gradientColor" value="#B3B3B3"/><add as="fillColor" value="#F5F5F5"/><add as="strokeColor" value="#666666"/></add><add as="blue" extend="fancy"><add as="gradientColor" value="#7EA6E0"/><add as="fillColor" value="#DAE8FC"/><add as="strokeColor" value="#6C8EBF"/></add><add as="green" extend="fancy"><add as="gradientColor" value="#97D077"/><add as="fillColor" value="#D5E8D4"/><add as="strokeColor" value="#82B366"/></add><add as="turquoise" extend="fancy"><add as="gradientColor" value="#67AB9F"/><add as="fillColor" value="#D5E8D4"/><add as="strokeColor" value="#6A9153"/></add><add as="yellow" extend="fancy"><add as="gradientColor" value="#FFD966"/><add as="fillColor" value="#FFF2CC"/><add as="strokeColor" value="#D6B656"/></add><add as="orange" extend="fancy"><add as="gradientColor" value="#FFA500"/><add as="fillColor" value="#FFCD28"/><add as="strokeColor" value="#D79B00"/></add><add as="red" extend="fancy"><add as="gradientColor" value="#EA6B66"/><add as="fillColor" value="#F8CECC"/><add as="strokeColor" value="#B85450"/></add><add as="pink" extend="fancy"><add as="gradientColor" value="#B5739D"/><add as="fillColor" value="#E6D0DE"/><add as="strokeColor" value="#996185"/></add><add as="purple" extend="fancy"><add as="gradientColor" value="#8C6C9C"/><add as="fillColor" value="#E1D5E7"/><add as="strokeColor" value="#9673A6"/></add><add as="plain-gray"><add as="gradientColor" value="#B3B3B3"/><add as="fillColor" value="#F5F5F5"/><add as="strokeColor" value="#666666"/></add><add as="plain-blue"><add as="gradientColor" value="#7EA6E0"/><add as="fillColor" value="#DAE8FC"/><add as="strokeColor" value="#6C8EBF"/></add><add as="plain-green"><add as="gradientColor" value="#97D077"/><add as="fillColor" value="#D5E8D4"/><add as="strokeColor" value="#82B366"/></add><add as="plain-turquoise"><add as="gradientColor" value="#67AB9F"/><add as="fillColor" value="#D5E8D4"/><add as="strokeColor" value="#6A9153"/></add><add as="plain-yellow"><add as="gradientColor" value="#FFD966"/><add as="fillColor" value="#FFF2CC"/><add as="strokeColor" value="#D6B656"/></add><add as="plain-orange"><add as="gradientColor" value="#FFA500"/><add as="fillColor" value="#FFCD28"/><add as="strokeColor" value="#D79B00"/></add><add as="plain-red"><add as="gradientColor" value="#EA6B66"/><add as="fillColor" value="#F8CECC"/><add as="strokeColor" value="#B85450"/></add><add as="plain-pink"><add as="gradientColor" value="#B5739D"/><add as="fillColor" value="#E6D0DE"/><add as="strokeColor" value="#996185"/></add><add as="plain-purple"><add as="gradientColor" value="#8C6C9C"/><add as="fillColor" value="#E1D5E7"/><add as="strokeColor" value="#9673A6"/></add></mxStylesheet>',
  []
);
